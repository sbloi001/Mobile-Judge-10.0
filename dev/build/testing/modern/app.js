/*
 jQuery JavaScript Library v1.11.1
 http://jquery.com/

 Includes Sizzle.js
 http://sizzlejs.com/

 Copyright 2005, 2014 jQuery Foundation, Inc. and other contributors
 Released under the MIT license
 http://jquery.org/license

 Date: 2014-05-01T17:42Z
 Sizzle CSS Selector Engine v1.10.19
 http://sizzlejs.com/

 Copyright 2013 jQuery Foundation, Inc. and other contributors
 Released under the MIT license
 http://jquery.org/license

 Date: 2014-04-18
*/
var $jscomp = $jscomp || {};
$jscomp.scope = {};
$jscomp.defineProperty = typeof Object.defineProperties == 'function' ? Object.defineProperty : function(target, property, descriptor) {
  descriptor = (descriptor);
  if (target == Array.prototype || target == Object.prototype) {
    return;
  }
  target[property] = descriptor.value;
};
$jscomp.getGlobal = function(maybeGlobal) {
  return typeof window != 'undefined' && window === maybeGlobal ? maybeGlobal : typeof global != 'undefined' && global != null ? global : maybeGlobal;
};
$jscomp.global = $jscomp.getGlobal(this);
$jscomp.polyfill = function(target, polyfill, fromLang, toLang) {
  if (!polyfill) {
    return;
  }
  var obj = $jscomp.global;
  var split = target.split('.');
  for (var i = 0; i < split.length - 1; i++) {
    var key = split[i];
    if (!(key in obj)) {
      obj[key] = {};
    }
    obj = obj[key];
  }
  var property = split[split.length - 1];
  var orig = obj[property];
  var impl = polyfill(orig);
  if (impl == orig || impl == null) {
    return;
  }
  $jscomp.defineProperty(obj, property, {configurable:true, writable:true, value:impl});
};
$jscomp.polyfill('Array.prototype.copyWithin', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, start, opt_end) {
    var len = this.length;
    target = Number(target);
    start = Number(start);
    opt_end = Number(opt_end != null ? opt_end : len);
    if (target < start) {
      opt_end = Math.min(opt_end, len);
      while (start < opt_end) {
        if (start in this) {
          this[target++] = this[start++];
        } else {
          delete this[target++];
          start++;
        }
      }
    } else {
      opt_end = Math.min(opt_end, len + start - target);
      target += opt_end - start;
      while (opt_end > start) {
        if (--opt_end in this) {
          this[--target] = this[opt_end];
        } else {
          delete this[target];
        }
      }
    }
    return this;
  };
  return polyfill;
}, 'es6-impl', 'es3');
$jscomp.SYMBOL_PREFIX = 'jscomp_symbol_';
$jscomp.initSymbol = function() {
  $jscomp.initSymbol = function() {
  };
  if (!$jscomp.global['Symbol']) {
    $jscomp.global['Symbol'] = $jscomp.Symbol;
  }
};
$jscomp.symbolCounter_ = 0;
$jscomp.Symbol = function(opt_description) {
  return ($jscomp.SYMBOL_PREFIX + (opt_description || '') + $jscomp.symbolCounter_++);
};
$jscomp.initSymbolIterator = function() {
  $jscomp.initSymbol();
  var symbolIterator = $jscomp.global['Symbol'].iterator;
  if (!symbolIterator) {
    symbolIterator = $jscomp.global['Symbol'].iterator = $jscomp.global['Symbol']('iterator');
  }
  if (typeof Array.prototype[symbolIterator] != 'function') {
    $jscomp.defineProperty(Array.prototype, symbolIterator, {configurable:true, writable:true, value:function() {
      return $jscomp.arrayIterator(this);
    }});
  }
  $jscomp.initSymbolIterator = function() {
  };
};
$jscomp.arrayIterator = function(array) {
  var index = 0;
  return $jscomp.iteratorPrototype(function() {
    if (index < array.length) {
      return {done:false, value:array[index++]};
    } else {
      return {done:true};
    }
  });
};
$jscomp.iteratorPrototype = function(next) {
  $jscomp.initSymbolIterator();
  var iterator = {next:next};
  iterator[$jscomp.global['Symbol'].iterator] = function() {
    return this;
  };
  return (iterator);
};
$jscomp.iteratorFromArray = function(array, transform) {
  $jscomp.initSymbolIterator();
  if (array instanceof String) {
    array = array + '';
  }
  var i = 0;
  var iter = {next:function() {
    if (i < array.length) {
      var index = i++;
      return {value:transform(index, array[index]), done:false};
    }
    iter.next = function() {
      return {done:true, value:void 0};
    };
    return iter.next();
  }};
  iter[Symbol.iterator] = function() {
    return iter;
  };
  return iter;
};
$jscomp.polyfill('Array.prototype.entries', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function() {
    return $jscomp.iteratorFromArray(this, function(i, v) {
      return [i, v];
    });
  };
  return polyfill;
}, 'es6-impl', 'es3');
$jscomp.polyfill('Array.prototype.fill', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(value, opt_start, opt_end) {
    var length = this.length || 0;
    if (opt_start < 0) {
      opt_start = Math.max(0, length + (opt_start));
    }
    if (opt_end == null || opt_end > length) {
      opt_end = length;
    }
    opt_end = Number(opt_end);
    if (opt_end < 0) {
      opt_end = Math.max(0, length + opt_end);
    }
    for (var i = Number(opt_start || 0); i < opt_end; i++) {
      this[i] = value;
    }
    return this;
  };
  return polyfill;
}, 'es6-impl', 'es3');
$jscomp.findInternal = function(array, callback, thisArg) {
  if (array instanceof String) {
    array = (String(array));
  }
  var len = array.length;
  for (var i = 0; i < len; i++) {
    var value = array[i];
    if (callback.call(thisArg, value, i, array)) {
      return {i:i, v:value};
    }
  }
  return {i:-1, v:void 0};
};
$jscomp.polyfill('Array.prototype.find', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(callback, opt_thisArg) {
    return $jscomp.findInternal(this, callback, opt_thisArg).v;
  };
  return polyfill;
}, 'es6-impl', 'es3');
$jscomp.polyfill('Array.prototype.findIndex', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(callback, opt_thisArg) {
    return $jscomp.findInternal(this, callback, opt_thisArg).i;
  };
  return polyfill;
}, 'es6-impl', 'es3');
$jscomp.polyfill('Array.from', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(arrayLike, opt_mapFn, opt_thisArg) {
    $jscomp.initSymbolIterator();
    opt_mapFn = opt_mapFn != null ? opt_mapFn : function(x) {
      return x;
    };
    var result = [];
    var iteratorFunction = (arrayLike)[Symbol.iterator];
    if (typeof iteratorFunction == 'function') {
      arrayLike = iteratorFunction.call(arrayLike);
      var next;
      while (!(next = arrayLike.next()).done) {
        result.push(opt_mapFn.call((opt_thisArg), next.value));
      }
    } else {
      var len = arrayLike.length;
      for (var i = 0; i < len; i++) {
        result.push(opt_mapFn.call((opt_thisArg), arrayLike[i]));
      }
    }
    return result;
  };
  return polyfill;
}, 'es6-impl', 'es3');
$jscomp.polyfill('Object.is', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(left, right) {
    if (left === right) {
      return left !== 0 || 1 / left === 1 / (right);
    } else {
      return left !== left && right !== right;
    }
  };
  return polyfill;
}, 'es6-impl', 'es3');
$jscomp.polyfill('Array.prototype.includes', function(orig) {
  if (orig) {
    return orig;
  }
  var includes = function(searchElement, opt_fromIndex) {
    var array = this;
    if (array instanceof String) {
      array = (String(array));
    }
    var len = array.length;
    for (var i = opt_fromIndex || 0; i < len; i++) {
      if (array[i] == searchElement || Object.is(array[i], searchElement)) {
        return true;
      }
    }
    return false;
  };
  return includes;
}, 'es7', 'es3');
$jscomp.polyfill('Array.prototype.keys', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function() {
    return $jscomp.iteratorFromArray(this, function(i) {
      return i;
    });
  };
  return polyfill;
}, 'es6-impl', 'es3');
$jscomp.polyfill('Array.of', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(var_args) {
    return Array.from(arguments);
  };
  return polyfill;
}, 'es6-impl', 'es3');
$jscomp.polyfill('Array.prototype.values', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function() {
    return $jscomp.iteratorFromArray(this, function(k, v) {
      return v;
    });
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.makeIterator = function(iterable) {
  $jscomp.initSymbolIterator();
  var iteratorFunction = (iterable)[Symbol.iterator];
  return iteratorFunction ? iteratorFunction.call(iterable) : $jscomp.arrayIterator((iterable));
};
$jscomp.EXPOSE_ASYNC_EXECUTOR = true;
$jscomp.FORCE_POLYFILL_PROMISE = false;
$jscomp.polyfill('Promise', function(NativePromise) {
  if (NativePromise && !$jscomp.FORCE_POLYFILL_PROMISE) {
    return NativePromise;
  }
  function AsyncExecutor() {
    this.batch_ = null;
  }
  AsyncExecutor.prototype.asyncExecute = function(f) {
    if (this.batch_ == null) {
      this.batch_ = [];
      this.asyncExecuteBatch_();
    }
    this.batch_.push(f);
    return this;
  };
  AsyncExecutor.prototype.asyncExecuteBatch_ = function() {
    var self = this;
    this.asyncExecuteFunction(function() {
      self.executeBatch_();
    });
  };
  var nativeSetTimeout = $jscomp.global['setTimeout'];
  AsyncExecutor.prototype.asyncExecuteFunction = function(f) {
    nativeSetTimeout(f, 0);
  };
  AsyncExecutor.prototype.executeBatch_ = function() {
    while (this.batch_ && this.batch_.length) {
      var executingBatch = this.batch_;
      this.batch_ = [];
      for (var i = 0; i < executingBatch.length; ++i) {
        var f = executingBatch[i];
        delete executingBatch[i];
        try {
          f();
        } catch (error) {
          this.asyncThrow_(error);
        }
      }
    }
    this.batch_ = null;
  };
  AsyncExecutor.prototype.asyncThrow_ = function(exception) {
    this.asyncExecuteFunction(function() {
      throw exception;
    });
  };
  var PromiseState = {PENDING:0, FULFILLED:1, REJECTED:2};
  var PolyfillPromise = function(executor) {
    this.state_ = PromiseState.PENDING;
    this.result_ = undefined;
    this.onSettledCallbacks_ = [];
    var resolveAndReject = this.createResolveAndReject_();
    try {
      executor(resolveAndReject.resolve, resolveAndReject.reject);
    } catch (e) {
      resolveAndReject.reject(e);
    }
  };
  PolyfillPromise.prototype.createResolveAndReject_ = function() {
    var thisPromise = this;
    var alreadyCalled = false;
    function firstCallWins(method) {
      return function(x) {
        if (!alreadyCalled) {
          alreadyCalled = true;
          method.call(thisPromise, x);
        }
      };
    }
    return {resolve:firstCallWins(this.resolveTo_), reject:firstCallWins(this.reject_)};
  };
  PolyfillPromise.prototype.resolveTo_ = function(value) {
    if (value === this) {
      this.reject_(new TypeError('A Promise cannot resolve to itself'));
    } else {
      if (value instanceof PolyfillPromise) {
        this.settleSameAsPromise_((value));
      } else {
        if (isObject(value)) {
          this.resolveToNonPromiseObj_((value));
        } else {
          this.fulfill_(value);
        }
      }
    }
  };
  PolyfillPromise.prototype.resolveToNonPromiseObj_ = function(obj) {
    var thenMethod = undefined;
    try {
      thenMethod = obj.then;
    } catch (error) {
      this.reject_(error);
      return;
    }
    if (typeof thenMethod == 'function') {
      this.settleSameAsThenable_(thenMethod, (obj));
    } else {
      this.fulfill_(obj);
    }
  };
  function isObject(value) {
    switch(typeof value) {
      case 'object':
        return value != null;
      case 'function':
        return true;
      default:
        return false;
    }
  }
  PolyfillPromise.prototype.reject_ = function(reason) {
    this.settle_(PromiseState.REJECTED, reason);
  };
  PolyfillPromise.prototype.fulfill_ = function(value) {
    this.settle_(PromiseState.FULFILLED, value);
  };
  PolyfillPromise.prototype.settle_ = function(settledState, valueOrReason) {
    if (this.state_ != PromiseState.PENDING) {
      throw new Error('Cannot settle(' + settledState + ', ' + valueOrReason | '): Promise already settled in state' + this.state_);
    }
    this.state_ = settledState;
    this.result_ = valueOrReason;
    this.executeOnSettledCallbacks_();
  };
  PolyfillPromise.prototype.executeOnSettledCallbacks_ = function() {
    if (this.onSettledCallbacks_ != null) {
      var callbacks = this.onSettledCallbacks_;
      for (var i = 0; i < callbacks.length; ++i) {
        (callbacks[i]).call();
        callbacks[i] = null;
      }
      this.onSettledCallbacks_ = null;
    }
  };
  var asyncExecutor = new AsyncExecutor;
  PolyfillPromise.prototype.settleSameAsPromise_ = function(promise) {
    var methods = this.createResolveAndReject_();
    promise.callWhenSettled_(methods.resolve, methods.reject);
  };
  PolyfillPromise.prototype.settleSameAsThenable_ = function(thenMethod, thenable) {
    var methods = this.createResolveAndReject_();
    try {
      thenMethod.call(thenable, methods.resolve, methods.reject);
    } catch (error) {
      methods.reject(error);
    }
  };
  PolyfillPromise.prototype.then = function(onFulfilled, onRejected) {
    var resolveChild;
    var rejectChild;
    var childPromise = new PolyfillPromise(function(resolve, reject) {
      resolveChild = resolve;
      rejectChild = reject;
    });
    function createCallback(paramF, defaultF) {
      if (typeof paramF == 'function') {
        return function(x) {
          try {
            resolveChild(paramF(x));
          } catch (error) {
            rejectChild(error);
          }
        };
      } else {
        return defaultF;
      }
    }
    this.callWhenSettled_(createCallback(onFulfilled, resolveChild), createCallback(onRejected, rejectChild));
    return childPromise;
  };
  PolyfillPromise.prototype['catch'] = function(onRejected) {
    return this.then(undefined, onRejected);
  };
  PolyfillPromise.prototype.callWhenSettled_ = function(onFulfilled, onRejected) {
    var thisPromise = this;
    function callback() {
      switch(thisPromise.state_) {
        case PromiseState.FULFILLED:
          onFulfilled(thisPromise.result_);
          break;
        case PromiseState.REJECTED:
          onRejected(thisPromise.result_);
          break;
        default:
          throw new Error('Unexpected state: ' + thisPromise.state_);
      }
    }
    if (this.onSettledCallbacks_ == null) {
      asyncExecutor.asyncExecute(callback);
    } else {
      this.onSettledCallbacks_.push(function() {
        asyncExecutor.asyncExecute(callback);
      });
    }
  };
  PolyfillPromise.resolve = function(opt_value) {
    if (opt_value instanceof PolyfillPromise) {
      return opt_value;
    } else {
      return new PolyfillPromise(function(resolve, reject) {
        resolve(opt_value);
      });
    }
  };
  PolyfillPromise.reject = function(opt_reason) {
    return new PolyfillPromise(function(resolve, reject) {
      reject(opt_reason);
    });
  };
  PolyfillPromise.race = function(thenablesOrValues) {
    return new PolyfillPromise(function(resolve, reject) {
      var iterator = $jscomp.makeIterator(thenablesOrValues);
      for (var iterRec = iterator.next(); !iterRec.done; iterRec = iterator.next()) {
        PolyfillPromise.resolve(iterRec.value).callWhenSettled_(resolve, reject);
      }
    });
  };
  PolyfillPromise.all = function(thenablesOrValues) {
    var iterator = $jscomp.makeIterator(thenablesOrValues);
    var iterRec = iterator.next();
    if (iterRec.done) {
      return PolyfillPromise.resolve([]);
    } else {
      return new PolyfillPromise(function(resolveAll, rejectAll) {
        var resultsArray = [];
        var unresolvedCount = 0;
        function onFulfilled(i) {
          return function(ithResult) {
            resultsArray[i] = ithResult;
            unresolvedCount--;
            if (unresolvedCount == 0) {
              resolveAll(resultsArray);
            }
          };
        }
        do {
          resultsArray.push(undefined);
          unresolvedCount++;
          PolyfillPromise.resolve(iterRec.value).callWhenSettled_(onFulfilled(resultsArray.length - 1), rejectAll);
          iterRec = iterator.next();
        } while (!iterRec.done);
      });
    }
  };
  if ($jscomp.EXPOSE_ASYNC_EXECUTOR) {
    PolyfillPromise['$jscomp$new$AsyncExecutor'] = function() {
      return new AsyncExecutor;
    };
  }
  return PolyfillPromise;
}, 'es6-impl', 'es3');
$jscomp.executeAsyncGenerator = function(generator) {
  function passValueToGenerator(value) {
    return generator.next(value);
  }
  function passErrorToGenerator(error) {
    return generator['throw'](error);
  }
  return new Promise(function(resolve, reject) {
    function handleGeneratorRecord(genRec) {
      if (genRec.done) {
        resolve(genRec.value);
      } else {
        Promise.resolve(genRec.value).then(passValueToGenerator, passErrorToGenerator).then(handleGeneratorRecord, reject);
      }
    }
    handleGeneratorRecord(generator.next());
  });
};
$jscomp.owns = function(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
};
$jscomp.polyfill('WeakMap', function(NativeWeakMap) {
  function isConformant() {
    if (!NativeWeakMap || !Object.seal) {
      return false;
    }
    try {
      var x = Object.seal({});
      var y = Object.seal({});
      var map = new (NativeWeakMap)([[x, 2], [y, 3]]);
      if (map.get(x) != 2 || map.get(y) != 3) {
        return false;
      }
      map['delete'](x);
      map.set(y, 4);
      return !map.has(x) && map.get(y) == 4;
    } catch (err) {
      return false;
    }
  }
  if (isConformant()) {
    return NativeWeakMap;
  }
  var prop = '$jscomp_hidden_' + Math.random().toString().substring(2);
  function insert(target) {
    if (!$jscomp.owns(target, prop)) {
      var obj = {};
      $jscomp.defineProperty(target, prop, {value:obj});
    }
  }
  function patch(name) {
    var prev = Object[name];
    if (prev) {
      Object[name] = function(target) {
        insert(target);
        return prev(target);
      };
    }
  }
  patch('freeze');
  patch('preventExtensions');
  patch('seal');
  var index = 0;
  var PolyfillWeakMap = function(opt_iterable) {
    this.id_ = (index += Math.random() + 1).toString();
    if (opt_iterable) {
      $jscomp.initSymbol();
      $jscomp.initSymbolIterator();
      var iter = $jscomp.makeIterator(opt_iterable);
      var entry;
      while (!(entry = iter.next()).done) {
        var item = entry.value;
        this.set((item[0]), (item[1]));
      }
    }
  };
  PolyfillWeakMap.prototype.set = function(key, value) {
    insert(key);
    if (!$jscomp.owns(key, prop)) {
      throw new Error('WeakMap key fail: ' + key);
    }
    key[prop][this.id_] = value;
    return this;
  };
  PolyfillWeakMap.prototype.get = function(key) {
    return $jscomp.owns(key, prop) ? key[prop][this.id_] : undefined;
  };
  PolyfillWeakMap.prototype.has = function(key) {
    return $jscomp.owns(key, prop) && $jscomp.owns(key[prop], this.id_);
  };
  PolyfillWeakMap.prototype['delete'] = function(key) {
    if (!$jscomp.owns(key, prop) || !$jscomp.owns(key[prop], this.id_)) {
      return false;
    }
    return delete key[prop][this.id_];
  };
  return PolyfillWeakMap;
}, 'es6-impl', 'es3');
$jscomp.MapEntry = function() {
  this.previous;
  this.next;
  this.head;
  this.key;
  this.value;
};
$jscomp.ASSUME_NO_NATIVE_MAP = false;
$jscomp.polyfill('Map', function(NativeMap) {
  var isConformant = !$jscomp.ASSUME_NO_NATIVE_MAP && function() {
    if (!NativeMap || !NativeMap.prototype.entries || typeof Object.seal != 'function') {
      return false;
    }
    try {
      NativeMap = (NativeMap);
      var key = Object.seal({x:4});
      var map = new NativeMap($jscomp.makeIterator([[key, 's']]));
      if (map.get(key) != 's' || map.size != 1 || map.get({x:4}) || map.set({x:4}, 't') != map || map.size != 2) {
        return false;
      }
      var iter = map.entries();
      var item = iter.next();
      if (item.done || item.value[0] != key || item.value[1] != 's') {
        return false;
      }
      item = iter.next();
      if (item.done || item.value[0].x != 4 || item.value[1] != 't' || !iter.next().done) {
        return false;
      }
      return true;
    } catch (err) {
      return false;
    }
  }();
  if (isConformant) {
    return NativeMap;
  }
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  var idMap = new WeakMap;
  var PolyfillMap = function(opt_iterable) {
    this.data_ = {};
    this.head_ = createHead();
    this.size = 0;
    if (opt_iterable) {
      var iter = $jscomp.makeIterator(opt_iterable);
      var entry;
      while (!(entry = iter.next()).done) {
        var item = (entry).value;
        this.set((item[0]), (item[1]));
      }
    }
  };
  PolyfillMap.prototype.set = function(key, value) {
    var r = maybeGetEntry(this, key);
    if (!r.list) {
      r.list = this.data_[r.id] = [];
    }
    if (!r.entry) {
      r.entry = {next:this.head_, previous:this.head_.previous, head:this.head_, key:key, value:value};
      r.list.push(r.entry);
      this.head_.previous.next = r.entry;
      this.head_.previous = r.entry;
      this.size++;
    } else {
      r.entry.value = value;
    }
    return this;
  };
  PolyfillMap.prototype['delete'] = function(key) {
    var r = maybeGetEntry(this, key);
    if (r.entry && r.list) {
      r.list.splice(r.index, 1);
      if (!r.list.length) {
        delete this.data_[r.id];
      }
      r.entry.previous.next = r.entry.next;
      r.entry.next.previous = r.entry.previous;
      r.entry.head = null;
      this.size--;
      return true;
    }
    return false;
  };
  PolyfillMap.prototype.clear = function() {
    this.data_ = {};
    this.head_ = this.head_.previous = createHead();
    this.size = 0;
  };
  PolyfillMap.prototype.has = function(key) {
    return !!maybeGetEntry(this, key).entry;
  };
  PolyfillMap.prototype.get = function(key) {
    var entry = maybeGetEntry(this, key).entry;
    return (entry && (entry.value));
  };
  PolyfillMap.prototype.entries = function() {
    return makeIterator(this, function(entry) {
      return [entry.key, entry.value];
    });
  };
  PolyfillMap.prototype.keys = function() {
    return makeIterator(this, function(entry) {
      return entry.key;
    });
  };
  PolyfillMap.prototype.values = function() {
    return makeIterator(this, function(entry) {
      return entry.value;
    });
  };
  PolyfillMap.prototype.forEach = function(callback, opt_thisArg) {
    var iter = this.entries();
    var item;
    while (!(item = iter.next()).done) {
      var entry = item.value;
      callback.call((opt_thisArg), (entry[1]), (entry[0]), this);
    }
  };
  (PolyfillMap.prototype)[Symbol.iterator] = PolyfillMap.prototype.entries;
  var maybeGetEntry = function(map, key) {
    var id = getId(key);
    var list = map.data_[id];
    if (list && $jscomp.owns(map.data_, id)) {
      for (var index = 0; index < list.length; index++) {
        var entry = list[index];
        if (key !== key && entry.key !== entry.key || key === entry.key) {
          return {id:id, list:list, index:index, entry:entry};
        }
      }
    }
    return {id:id, list:list, index:-1, entry:undefined};
  };
  var makeIterator = function(map, func) {
    var entry = map.head_;
    return $jscomp.iteratorPrototype(function() {
      if (entry) {
        while (entry.head != map.head_) {
          entry = entry.previous;
        }
        while (entry.next != entry.head) {
          entry = entry.next;
          return {done:false, value:func(entry)};
        }
        entry = null;
      }
      return {done:true, value:void 0};
    });
  };
  var createHead = function() {
    var head = {};
    head.previous = head.next = head.head = head;
    return head;
  };
  var mapIndex = 0;
  var getId = function(obj) {
    var type = obj && typeof obj;
    if (type == 'object' || type == 'function') {
      obj = (obj);
      if (!idMap.has(obj)) {
        var id = '' + ++mapIndex;
        idMap.set(obj, id);
        return id;
      }
      return idMap.get(obj);
    }
    return 'p_' + obj;
  };
  return PolyfillMap;
}, 'es6-impl', 'es3');
$jscomp.polyfill('Math.acosh', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    return Math.log(x + Math.sqrt(x * x - 1));
  };
  return polyfill;
}, 'es6-impl', 'es3');
$jscomp.polyfill('Math.asinh', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    if (x === 0) {
      return x;
    }
    var y = Math.log(Math.abs(x) + Math.sqrt(x * x + 1));
    return x < 0 ? -y : y;
  };
  return polyfill;
}, 'es6-impl', 'es3');
$jscomp.polyfill('Math.log1p', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    if (x < 0.25 && x > -0.25) {
      var y = x;
      var d = 1;
      var z = x;
      var zPrev = 0;
      var s = 1;
      while (zPrev != z) {
        y *= x;
        s *= -1;
        z = (zPrev = z) + s * y / ++d;
      }
      return z;
    }
    return Math.log(1 + x);
  };
  return polyfill;
}, 'es6-impl', 'es3');
$jscomp.polyfill('Math.atanh', function(orig) {
  if (orig) {
    return orig;
  }
  var log1p = Math.log1p;
  var polyfill = function(x) {
    x = Number(x);
    return (log1p(x) - log1p(-x)) / 2;
  };
  return polyfill;
}, 'es6-impl', 'es3');
$jscomp.polyfill('Math.cbrt', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    if (x === 0) {
      return x;
    }
    x = Number(x);
    var y = Math.pow(Math.abs(x), 1 / 3);
    return x < 0 ? -y : y;
  };
  return polyfill;
}, 'es6-impl', 'es3');
$jscomp.polyfill('Math.clz32', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x) >>> 0;
    if (x === 0) {
      return 32;
    }
    var result = 0;
    if ((x & 4294901760) === 0) {
      x <<= 16;
      result += 16;
    }
    if ((x & 4278190080) === 0) {
      x <<= 8;
      result += 8;
    }
    if ((x & 4026531840) === 0) {
      x <<= 4;
      result += 4;
    }
    if ((x & 3221225472) === 0) {
      x <<= 2;
      result += 2;
    }
    if ((x & 2147483648) === 0) {
      result++;
    }
    return result;
  };
  return polyfill;
}, 'es6-impl', 'es3');
$jscomp.polyfill('Math.cosh', function(orig) {
  if (orig) {
    return orig;
  }
  var exp = Math.exp;
  var polyfill = function(x) {
    x = Number(x);
    return (exp(x) + exp(-x)) / 2;
  };
  return polyfill;
}, 'es6-impl', 'es3');
$jscomp.polyfill('Math.expm1', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    if (x < .25 && x > -.25) {
      var y = x;
      var d = 1;
      var z = x;
      var zPrev = 0;
      while (zPrev != z) {
        y *= x / ++d;
        z = (zPrev = z) + y;
      }
      return z;
    }
    return Math.exp(x) - 1;
  };
  return polyfill;
}, 'es6-impl', 'es3');
$jscomp.polyfill('Math.hypot', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x, y, var_args) {
    x = Number(x);
    y = Number(y);
    var i, z, sum;
    var max = Math.max(Math.abs(x), Math.abs(y));
    for (i = 2; i < arguments.length; i++) {
      max = Math.max(max, Math.abs(arguments[i]));
    }
    if (max > 1e100 || max < 1e-100) {
      x = x / max;
      y = y / max;
      sum = x * x + y * y;
      for (i = 2; i < arguments.length; i++) {
        z = Number(arguments[i]) / max;
        sum += z * z;
      }
      return Math.sqrt(sum) * max;
    } else {
      sum = x * x + y * y;
      for (i = 2; i < arguments.length; i++) {
        z = Number(arguments[i]);
        sum += z * z;
      }
      return Math.sqrt(sum);
    }
  };
  return polyfill;
}, 'es6-impl', 'es3');
$jscomp.polyfill('Math.imul', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(a, b) {
    a = Number(a);
    b = Number(b);
    var ah = a >>> 16 & 65535;
    var al = a & 65535;
    var bh = b >>> 16 & 65535;
    var bl = b & 65535;
    var lh = ah * bl + al * bh << 16 >>> 0;
    return al * bl + lh | 0;
  };
  return polyfill;
}, 'es6-impl', 'es3');
$jscomp.polyfill('Math.log10', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    return Math.log(x) / Math.LN10;
  };
  return polyfill;
}, 'es6-impl', 'es3');
$jscomp.polyfill('Math.log2', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    return Math.log(x) / Math.LN2;
  };
  return polyfill;
}, 'es6-impl', 'es3');
$jscomp.polyfill('Math.sign', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    return x === 0 || isNaN(x) ? x : x > 0 ? 1 : -1;
  };
  return polyfill;
}, 'es6-impl', 'es3');
$jscomp.polyfill('Math.sinh', function(orig) {
  if (orig) {
    return orig;
  }
  var exp = Math.exp;
  var polyfill = function(x) {
    x = Number(x);
    if (x === 0) {
      return x;
    }
    return (exp(x) - exp(-x)) / 2;
  };
  return polyfill;
}, 'es6-impl', 'es3');
$jscomp.polyfill('Math.tanh', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    if (x === 0) {
      return x;
    }
    var y = Math.exp(-2 * Math.abs(x));
    var z = (1 - y) / (1 + y);
    return x < 0 ? -z : z;
  };
  return polyfill;
}, 'es6-impl', 'es3');
$jscomp.polyfill('Math.trunc', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    if (isNaN(x) || x === Infinity || x === -Infinity || x === 0) {
      return x;
    }
    var y = Math.floor(Math.abs(x));
    return x < 0 ? -y : y;
  };
  return polyfill;
}, 'es6-impl', 'es3');
$jscomp.polyfill('Number.EPSILON', function(orig) {
  return Math.pow(2, -52);
}, 'es6-impl', 'es3');
$jscomp.polyfill('Number.MAX_SAFE_INTEGER', function() {
  return 9007199254740991;
}, 'es6-impl', 'es3');
$jscomp.polyfill('Number.MIN_SAFE_INTEGER', function() {
  return -9007199254740991;
}, 'es6-impl', 'es3');
$jscomp.polyfill('Number.isFinite', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    if (typeof x !== 'number') {
      return false;
    }
    return !isNaN(x) && x !== Infinity && x !== -Infinity;
  };
  return polyfill;
}, 'es6-impl', 'es3');
$jscomp.polyfill('Number.isInteger', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    if (!Number.isFinite(x)) {
      return false;
    }
    return x === Math.floor(x);
  };
  return polyfill;
}, 'es6-impl', 'es3');
$jscomp.polyfill('Number.isNaN', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    return typeof x === 'number' && isNaN(x);
  };
  return polyfill;
}, 'es6-impl', 'es3');
$jscomp.polyfill('Number.isSafeInteger', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    return Number.isInteger(x) && Math.abs(x) <= Number.MAX_SAFE_INTEGER;
  };
  return polyfill;
}, 'es6-impl', 'es3');
$jscomp.polyfill('Object.assign', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, var_args) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];
      if (!source) {
        continue;
      }
      for (var key in source) {
        if ($jscomp.owns(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return polyfill;
}, 'es6-impl', 'es3');
$jscomp.polyfill('Object.entries', function(orig) {
  if (orig) {
    return orig;
  }
  var entries = function(obj) {
    var result = [];
    for (var key in obj) {
      if ($jscomp.owns(obj, key)) {
        result.push([key, obj[key]]);
      }
    }
    return result;
  };
  return entries;
}, 'es8', 'es3');
$jscomp.polyfill('Object.getOwnPropertySymbols', function(orig) {
  if (orig) {
    return orig;
  }
  return function() {
    return [];
  };
}, 'es6-impl', 'es5');
$jscomp.polyfill('Reflect.ownKeys', function(orig) {
  if (orig) {
    return orig;
  }
  var symbolPrefix = 'jscomp_symbol_';
  function isSymbol(key) {
    return key.substring(0, symbolPrefix.length) == symbolPrefix;
  }
  var polyfill = function(target) {
    var keys = [];
    var names = Object.getOwnPropertyNames(target);
    var symbols = Object.getOwnPropertySymbols(target);
    for (var i = 0; i < names.length; i++) {
      (isSymbol(names[i]) ? symbols : keys).push(names[i]);
    }
    return keys.concat(symbols);
  };
  return polyfill;
}, 'es6', 'es5');
$jscomp.polyfill('Object.getOwnPropertyDescriptors', function(orig) {
  if (orig) {
    return orig;
  }
  var getOwnPropertyDescriptors = function(obj) {
    var result = {};
    var keys = Reflect.ownKeys(obj);
    for (var i = 0; i < keys.length; i++) {
      result[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return result;
  };
  return getOwnPropertyDescriptors;
}, 'es8', 'es5');
$jscomp.polyfill('Object.setPrototypeOf', function(orig) {
  if (orig) {
    return orig;
  }
  if (typeof ''.__proto__ != 'object') {
    return null;
  }
  var polyfill = function(target, proto) {
    target.__proto__ = proto;
    if (target.__proto__ !== proto) {
      throw new TypeError(target + ' is not extensible');
    }
    return target;
  };
  return polyfill;
}, 'es6', 'es5');
$jscomp.polyfill('Object.values', function(orig) {
  if (orig) {
    return orig;
  }
  var values = function(obj) {
    var result = [];
    for (var key in obj) {
      if ($jscomp.owns(obj, key)) {
        result.push(obj[key]);
      }
    }
    return result;
  };
  return values;
}, 'es8', 'es3');
$jscomp.polyfill('Reflect.apply', function(orig) {
  if (orig) {
    return orig;
  }
  var apply = Function.prototype.apply;
  var polyfill = function(target, thisArg, argList) {
    return apply.call(target, thisArg, argList);
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Reflect.construct', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, argList, opt_newTarget) {
    if (opt_newTarget === undefined) {
      opt_newTarget = target;
    }
    var proto = opt_newTarget.prototype || Object.prototype;
    var obj = Object.create(proto);
    var out = Reflect.apply(target, obj, argList);
    return out || obj;
  };
  return polyfill;
}, 'es6', 'es5');
$jscomp.polyfill('Reflect.defineProperty', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, propertyKey, attributes) {
    try {
      Object.defineProperty(target, propertyKey, attributes);
      var desc = Object.getOwnPropertyDescriptor(target, propertyKey);
      if (!desc) {
        return false;
      }
      return desc.configurable === (attributes.configurable || false) && desc.enumerable === (attributes.enumerable || false) && ('value' in desc ? desc.value === attributes.value && desc.writable === (attributes.writable || false) : desc.get === attributes.get && desc.set === attributes.set);
    } catch (err) {
      return false;
    }
  };
  return polyfill;
}, 'es6', 'es5');
$jscomp.polyfill('Reflect.deleteProperty', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, propertyKey) {
    if (!$jscomp.owns(target, propertyKey)) {
      return true;
    }
    try {
      return delete target[propertyKey];
    } catch (err) {
      return false;
    }
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Reflect.getOwnPropertyDescriptor', function(orig) {
  return orig || Object.getOwnPropertyDescriptor;
}, 'es6', 'es5');
$jscomp.polyfill('Reflect.getPrototypeOf', function(orig) {
  return orig || Object.getPrototypeOf;
}, 'es6', 'es5');
$jscomp.findDescriptor = function(target, propertyKey) {
  var obj = target;
  while (obj) {
    var property = Reflect.getOwnPropertyDescriptor(obj, propertyKey);
    if (property) {
      return property;
    }
    obj = Reflect.getPrototypeOf(obj);
  }
  return undefined;
};
$jscomp.polyfill('Reflect.get', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, propertyKey, opt_receiver) {
    if (arguments.length <= 2) {
      return target[propertyKey];
    }
    var property = $jscomp.findDescriptor(target, propertyKey);
    if (property) {
      return property.get ? property.get.call(opt_receiver) : property.value;
    }
    return undefined;
  };
  return polyfill;
}, 'es6', 'es5');
$jscomp.polyfill('Reflect.has', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, propertyKey) {
    return propertyKey in target;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Reflect.isExtensible', function(orig) {
  if (orig) {
    return orig;
  }
  if (typeof Object.isExtensible == 'function') {
    return Object.isExtensible;
  }
  return function() {
    return true;
  };
}, 'es6', 'es3');
$jscomp.polyfill('Reflect.preventExtensions', function(orig) {
  if (orig) {
    return orig;
  }
  if (typeof Object.preventExtensions != 'function') {
    return function() {
      return false;
    };
  }
  var polyfill = function(target) {
    Object.preventExtensions(target);
    return !Object.isExtensible(target);
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Reflect.set', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, propertyKey, value, opt_receiver) {
    var property = $jscomp.findDescriptor(target, propertyKey);
    if (!property) {
      if (Reflect.isExtensible(target)) {
        target[propertyKey] = value;
        return true;
      }
      return false;
    }
    if (property.set) {
      property.set.call(arguments.length > 3 ? opt_receiver : target, value);
      return true;
    } else {
      if (property.writable && !Object.isFrozen(target)) {
        target[propertyKey] = value;
        return true;
      }
    }
    return false;
  };
  return polyfill;
}, 'es6', 'es5');
$jscomp.polyfill('Reflect.setPrototypeOf', function(orig) {
  if (orig) {
    return orig;
  }
  if (typeof ''.__proto__ != 'object') {
    return null;
  }
  var polyfill = function(target, proto) {
    try {
      target.__proto__ = proto;
      return target.__proto__ === proto;
    } catch (err) {
      return false;
    }
  };
  return polyfill;
}, 'es6', 'es5');
$jscomp.ASSUME_NO_NATIVE_SET = false;
$jscomp.polyfill('Set', function(NativeSet) {
  var isConformant = !$jscomp.ASSUME_NO_NATIVE_SET && function() {
    if (!NativeSet || !NativeSet.prototype.entries || typeof Object.seal != 'function') {
      return false;
    }
    try {
      NativeSet = (NativeSet);
      var value = Object.seal({x:4});
      var set = new NativeSet($jscomp.makeIterator([value]));
      if (!set.has(value) || set.size != 1 || set.add(value) != set || set.size != 1 || set.add({x:4}) != set || set.size != 2) {
        return false;
      }
      var iter = set.entries();
      var item = iter.next();
      if (item.done || item.value[0] != value || item.value[1] != value) {
        return false;
      }
      item = iter.next();
      if (item.done || item.value[0] == value || item.value[0].x != 4 || item.value[1] != item.value[0]) {
        return false;
      }
      return iter.next().done;
    } catch (err) {
      return false;
    }
  }();
  if (isConformant) {
    return NativeSet;
  }
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  var PolyfillSet = function(opt_iterable) {
    this.map_ = new Map;
    if (opt_iterable) {
      var iter = $jscomp.makeIterator(opt_iterable);
      var entry;
      while (!(entry = iter.next()).done) {
        var item = (entry).value;
        this.add(item);
      }
    }
    this.size = this.map_.size;
  };
  PolyfillSet.prototype.add = function(value) {
    this.map_.set(value, value);
    this.size = this.map_.size;
    return this;
  };
  PolyfillSet.prototype['delete'] = function(value) {
    var result = this.map_['delete'](value);
    this.size = this.map_.size;
    return result;
  };
  PolyfillSet.prototype.clear = function() {
    this.map_.clear();
    this.size = 0;
  };
  PolyfillSet.prototype.has = function(value) {
    return this.map_.has(value);
  };
  PolyfillSet.prototype.entries = function() {
    return this.map_.entries();
  };
  PolyfillSet.prototype.values = function() {
    return this.map_.values();
  };
  PolyfillSet.prototype.keys = PolyfillSet.prototype.values;
  (PolyfillSet.prototype)[Symbol.iterator] = PolyfillSet.prototype.values;
  PolyfillSet.prototype.forEach = function(callback, opt_thisArg) {
    var set = this;
    this.map_.forEach(function(value) {
      return callback.call((opt_thisArg), value, value, set);
    });
  };
  return PolyfillSet;
}, 'es6-impl', 'es3');
$jscomp.checkStringArgs = function(thisArg, arg, func) {
  if (thisArg == null) {
    throw new TypeError("The 'this' value for String.prototype." + func + ' must not be null or undefined');
  }
  if (arg instanceof RegExp) {
    throw new TypeError('First argument to String.prototype.' + func + ' must not be a regular expression');
  }
  return thisArg + '';
};
$jscomp.polyfill('String.prototype.codePointAt', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(position) {
    var string = $jscomp.checkStringArgs(this, null, 'codePointAt');
    var size = string.length;
    position = Number(position) || 0;
    if (!(position >= 0 && position < size)) {
      return void 0;
    }
    position = position | 0;
    var first = string.charCodeAt(position);
    if (first < 55296 || first > 56319 || position + 1 === size) {
      return first;
    }
    var second = string.charCodeAt(position + 1);
    if (second < 56320 || second > 57343) {
      return first;
    }
    return (first - 55296) * 1024 + second + 9216;
  };
  return polyfill;
}, 'es6-impl', 'es3');
$jscomp.polyfill('String.prototype.endsWith', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(searchString, opt_position) {
    var string = $jscomp.checkStringArgs(this, searchString, 'endsWith');
    searchString = searchString + '';
    if (opt_position === void 0) {
      opt_position = string.length;
    }
    var i = Math.max(0, Math.min(opt_position | 0, string.length));
    var j = searchString.length;
    while (j > 0 && i > 0) {
      if (string[--i] != searchString[--j]) {
        return false;
      }
    }
    return j <= 0;
  };
  return polyfill;
}, 'es6-impl', 'es3');
$jscomp.polyfill('String.fromCodePoint', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(var_args) {
    var result = '';
    for (var i = 0; i < arguments.length; i++) {
      var code = Number(arguments[i]);
      if (code < 0 || code > 1114111 || code !== Math.floor(code)) {
        throw new RangeError('invalid_code_point ' + code);
      }
      if (code <= 65535) {
        result += String.fromCharCode(code);
      } else {
        code -= 65536;
        result += String.fromCharCode(code >>> 10 & 1023 | 55296);
        result += String.fromCharCode(code & 1023 | 56320);
      }
    }
    return result;
  };
  return polyfill;
}, 'es6-impl', 'es3');
$jscomp.polyfill('String.prototype.includes', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(searchString, opt_position) {
    var string = $jscomp.checkStringArgs(this, searchString, 'includes');
    return string.indexOf(searchString, opt_position || 0) !== -1;
  };
  return polyfill;
}, 'es6-impl', 'es3');
$jscomp.polyfill('String.prototype.repeat', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(copies) {
    var string = $jscomp.checkStringArgs(this, null, 'repeat');
    if (copies < 0 || copies > 1342177279) {
      throw new RangeError('Invalid count value');
    }
    copies = copies | 0;
    var result = '';
    while (copies) {
      if (copies & 1) {
        result += string;
      }
      if (copies >>>= 1) {
        string += string;
      }
    }
    return result;
  };
  return polyfill;
}, 'es6-impl', 'es3');
$jscomp.stringPadding = function(padString, padLength) {
  var padding = padString !== undefined ? String(padString) : ' ';
  if (!(padLength > 0) || !padding) {
    return '';
  }
  var repeats = Math.ceil(padLength / padding.length);
  return padding.repeat(repeats).substring(0, padLength);
};
$jscomp.polyfill('String.prototype.padEnd', function(orig) {
  if (orig) {
    return orig;
  }
  var padEnd = function(targetLength, opt_padString) {
    var string = $jscomp.checkStringArgs(this, null, 'padStart');
    var padLength = targetLength - string.length;
    return string + $jscomp.stringPadding(opt_padString, padLength);
  };
  return padEnd;
}, 'es8', 'es3');
$jscomp.polyfill('String.prototype.padStart', function(orig) {
  if (orig) {
    return orig;
  }
  var padStart = function(targetLength, opt_padString) {
    var string = $jscomp.checkStringArgs(this, null, 'padStart');
    var padLength = targetLength - string.length;
    return $jscomp.stringPadding(opt_padString, padLength) + string;
  };
  return padStart;
}, 'es8', 'es3');
$jscomp.polyfill('String.prototype.startsWith', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(searchString, opt_position) {
    var string = $jscomp.checkStringArgs(this, searchString, 'startsWith');
    searchString = searchString + '';
    var strLen = string.length;
    var searchLen = searchString.length;
    var i = Math.max(0, Math.min((opt_position) | 0, string.length));
    var j = 0;
    while (j < searchLen && i < strLen) {
      if (string[i++] != searchString[j++]) {
        return false;
      }
    }
    return j >= searchLen;
  };
  return polyfill;
}, 'es6-impl', 'es3');
$jscomp.arrayFromIterator = function(iterator) {
  var i;
  var arr = [];
  while (!(i = iterator.next()).done) {
    arr.push(i.value);
  }
  return arr;
};
$jscomp.arrayFromIterable = function(iterable) {
  if (iterable instanceof Array) {
    return iterable;
  } else {
    return $jscomp.arrayFromIterator($jscomp.makeIterator(iterable));
  }
};
$jscomp.inherits = function(childCtor, parentCtor) {
  function tempCtor() {
  }
  tempCtor.prototype = parentCtor.prototype;
  childCtor.superClass_ = parentCtor.prototype;
  childCtor.prototype = new tempCtor;
  childCtor.prototype.constructor = childCtor;
  for (var p in parentCtor) {
    if (Object.defineProperties) {
      var descriptor = Object.getOwnPropertyDescriptor(parentCtor, p);
      if (descriptor) {
        Object.defineProperty(childCtor, p, descriptor);
      }
    } else {
      childCtor[p] = parentCtor[p];
    }
  }
};
$jscomp.polyfill('WeakSet', function(NativeWeakSet) {
  function isConformant() {
    if (!NativeWeakSet || !Object.seal) {
      return false;
    }
    try {
      var x = Object.seal({});
      var y = Object.seal({});
      var set = new (NativeWeakSet)([x]);
      if (!set.has(x) || set.has(y)) {
        return false;
      }
      set['delete'](x);
      set.add(y);
      return !set.has(x) && set.has(y);
    } catch (err) {
      return false;
    }
  }
  if (isConformant()) {
    return NativeWeakSet;
  }
  var PolyfillWeakSet = function(opt_iterable) {
    this.map_ = new WeakMap;
    if (opt_iterable) {
      $jscomp.initSymbol();
      $jscomp.initSymbolIterator();
      var iter = $jscomp.makeIterator(opt_iterable);
      var entry;
      while (!(entry = iter.next()).done) {
        var item = entry.value;
        this.add(item);
      }
    }
  };
  PolyfillWeakSet.prototype.add = function(elem) {
    this.map_.set(elem, true);
    return this;
  };
  PolyfillWeakSet.prototype.has = function(elem) {
    return this.map_.has(elem);
  };
  PolyfillWeakSet.prototype['delete'] = function(elem) {
    return this.map_['delete'](elem);
  };
  return PolyfillWeakSet;
}, 'es6-impl', 'es3');
try {
  if (Array.prototype.values.toString().indexOf('[native code]') == -1) {
    delete Array.prototype.values;
  }
} catch (e) {
}
var Ext = Ext || {};
(function() {
  var global = this, objectPrototype = Object.prototype, toString = objectPrototype.toString, enumerables = ['valueOf', 'toLocaleString', 'toString', 'constructor'], emptyFn = function() {
  }, privateFn = function() {
  }, identityFn = function(o) {
    return o;
  }, callOverrideParent = function() {
    var method = callOverrideParent.caller.caller;
    return method.$owner.prototype[method.$name].apply(this, arguments);
  }, manifest = Ext.manifest || {}, i, iterableRe = /\[object\s*(?:Array|Arguments|\w*Collection|\w*List|HTML\s+document\.all\s+class)\]/, MSDateRe = /^\\?\/Date\(([-+])?(\d+)(?:[+-]\d{4})?\)\\?\/$/;
  Ext.global = global;
  Ext.now = Date.now || (Date.now = function() {
    return +new Date;
  });
  Ext.ticks = global.performance && global.performance.now ? function() {
    return performance.now();
  } : Ext.now;
  Ext._startTime = Ext.ticks();
  emptyFn.$nullFn = identityFn.$nullFn = emptyFn.$emptyFn = identityFn.$identityFn = privateFn.$nullFn = true;
  privateFn.$privacy = 'framework';
  Ext['suspendLayouts'] = Ext['resumeLayouts'] = emptyFn;
  for (i in{toString:1}) {
    enumerables = null;
  }
  Ext.enumerables = enumerables;
  Ext.apply = function(object, config, defaults) {
    if (defaults) {
      Ext.apply(object, defaults);
    }
    if (object && config && typeof config === 'object') {
      var i, j, k;
      for (i in config) {
        object[i] = config[i];
      }
      if (enumerables) {
        for (j = enumerables.length; j--;) {
          k = enumerables[j];
          if (config.hasOwnProperty(k)) {
            object[k] = config[k];
          }
        }
      }
    }
    return object;
  };
  function addInstanceOverrides(target, owner, overrides) {
    var name, value;
    for (name in overrides) {
      if (overrides.hasOwnProperty(name)) {
        value = overrides[name];
        if (typeof value === 'function') {
          if (owner.$className) {
            value.name = owner.$className + '#' + name;
          }
          value.$name = name;
          value.$owner = owner;
          value.$previous = target.hasOwnProperty(name) ? target[name] : callOverrideParent;
        }
        target[name] = value;
      }
    }
  }
  Ext.buildSettings = Ext.apply({baseCSSPrefix:'x-'}, Ext.buildSettings || {});
  Ext.apply(Ext, {idSeed:0, idPrefix:'ext-', isSecure:/^https/i.test(window.location.protocol), enableGarbageCollector:false, enableListenerCollection:true, name:Ext.sandboxName || 'Ext', privateFn:privateFn, emptyFn:emptyFn, identityFn:identityFn, frameStartTime:Ext.now(), manifest:manifest, debugConfig:Ext.debugConfig || manifest.debug || {hooks:{'*':true}}, enableAria:true, enableAriaButtons:true, enableAriaPanels:true, startsWithHashRe:/^#/, validIdRe:/^[a-z_][a-z0-9\-_]*$/i, BLANK_IMAGE_URL:'data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw\x3d\x3d', 
  makeIdSelector:function(id) {
    if (!Ext.validIdRe.test(id)) {
      Ext.raise('Invalid id selector: "' + id + '"');
    }
    return '#' + id;
  }, id:function(o, prefix) {
    if (o && o.id) {
      return o.id;
    }
    var id = (prefix || Ext.idPrefix) + ++Ext.idSeed;
    if (o) {
      o.id = id;
    }
    return id;
  }, returnId:function(o) {
    return o.getId();
  }, returnTrue:function() {
    return true;
  }, emptyString:new String, baseCSSPrefix:Ext.buildSettings.baseCSSPrefix, $eventNameMap:{}, $vendorEventRe:/^(Moz.+|MS.+|webkit.+)/, canonicalEventName:function(name) {
    return Ext.$eventNameMap[name] || (Ext.$eventNameMap[name] = Ext.$vendorEventRe.test(name) ? name : name.toLowerCase());
  }, applyIf:function(object, config) {
    var property;
    if (object) {
      for (property in config) {
        if (object[property] === undefined) {
          object[property] = config[property];
        }
      }
    }
    return object;
  }, destroy:function() {
    var ln = arguments.length, i, arg;
    for (i = 0; i < ln; i++) {
      arg = arguments[i];
      if (arg) {
        if (Ext.isArray(arg)) {
          this.destroy.apply(this, arg);
        } else {
          if (Ext.isFunction(arg.destroy)) {
            arg.destroy();
          }
        }
      }
    }
    return null;
  }, destroyMembers:function(object) {
    for (var ref, name, i = 1, a = arguments, len = a.length; i < len; i++) {
      ref = object[name = a[i]];
      if (ref != null) {
        object[name] = Ext.destroy(ref);
      }
    }
  }, override:function(target, overrides) {
    if (target.$isClass) {
      target.override(overrides);
    } else {
      if (typeof target === 'function') {
        Ext.apply(target.prototype, overrides);
      } else {
        var owner = target.self, privates;
        if (owner && owner.$isClass) {
          privates = overrides.privates;
          if (privates) {
            overrides = Ext.apply({}, overrides);
            delete overrides.privates;
            addInstanceOverrides(target, owner, privates);
          }
          addInstanceOverrides(target, owner, overrides);
        } else {
          Ext.apply(target, overrides);
        }
      }
    }
    return target;
  }, valueFrom:function(value, defaultValue, allowBlank) {
    return Ext.isEmpty(value, allowBlank) ? defaultValue : value;
  }, isEmpty:function(value, allowEmptyString) {
    return value == null || (!allowEmptyString ? value === '' : false) || Ext.isArray(value) && value.length === 0;
  }, isArray:'isArray' in Array ? Array.isArray : function(value) {
    return toString.call(value) === '[object Array]';
  }, isDate:function(value) {
    return toString.call(value) === '[object Date]';
  }, isMSDate:function(value) {
    if (!Ext.isString(value)) {
      return false;
    }
    return MSDateRe.test(value);
  }, isObject:toString.call(null) === '[object Object]' ? function(value) {
    return value !== null && value !== undefined && toString.call(value) === '[object Object]' && value.ownerDocument === undefined;
  } : function(value) {
    return toString.call(value) === '[object Object]';
  }, isSimpleObject:function(value) {
    return value instanceof Object && value.constructor === Object;
  }, isPrimitive:function(value) {
    var type = typeof value;
    return type === 'string' || type === 'number' || type === 'boolean';
  }, isFunction:typeof document !== 'undefined' && typeof document.getElementsByTagName('body') === 'function' ? function(value) {
    return !!value && toString.call(value) === '[object Function]';
  } : function(value) {
    return !!value && typeof value === 'function';
  }, isNumber:function(value) {
    return typeof value === 'number' && isFinite(value);
  }, isNumeric:function(value) {
    return !isNaN(parseFloat(value)) && isFinite(value);
  }, isString:function(value) {
    return typeof value === 'string';
  }, isBoolean:function(value) {
    return typeof value === 'boolean';
  }, isElement:function(value) {
    return value ? value.nodeType === 1 : false;
  }, isTextNode:function(value) {
    return value ? value.nodeName === '#text' : false;
  }, isDefined:function(value) {
    return typeof value !== 'undefined';
  }, isIterable:function(value) {
    if (!value || typeof value.length !== 'number' || typeof value === 'string' || Ext.isFunction(value)) {
      return false;
    }
    if (!value.propertyIsEnumerable) {
      return !!value.item;
    }
    if (value.hasOwnProperty('length') && !value.propertyIsEnumerable('length')) {
      return true;
    }
    return iterableRe.test(toString.call(value));
  }, isDebugEnabled:function(className, defaultEnabled) {
    var debugConfig = Ext.debugConfig.hooks;
    if (debugConfig.hasOwnProperty(className)) {
      return debugConfig[className];
    }
    var enabled = debugConfig['*'], prefixLength = 0;
    if (defaultEnabled !== undefined) {
      enabled = defaultEnabled;
    }
    if (!className) {
      return enabled;
    }
    for (var prefix in debugConfig) {
      var value = debugConfig[prefix];
      if (className.charAt(prefix.length) === '.') {
        if (className.substring(0, prefix.length) === prefix) {
          if (prefixLength < prefix.length) {
            prefixLength = prefix.length;
            enabled = value;
          }
        }
      }
    }
    return enabled;
  } || emptyFn, clone:function(item) {
    if (item === null || item === undefined) {
      return item;
    }
    if (item.nodeType && item.cloneNode) {
      return item.cloneNode(true);
    }
    var type = toString.call(item), i, j, k, clone, key;
    if (type === '[object Date]') {
      return new Date(item.getTime());
    }
    if (type === '[object Array]') {
      i = item.length;
      clone = [];
      while (i--) {
        clone[i] = Ext.clone(item[i]);
      }
    } else {
      if (type === '[object Object]' && item.constructor === Object) {
        clone = {};
        for (key in item) {
          clone[key] = Ext.clone(item[key]);
        }
        if (enumerables) {
          for (j = enumerables.length; j--;) {
            k = enumerables[j];
            if (item.hasOwnProperty(k)) {
              clone[k] = item[k];
            }
          }
        }
      }
    }
    return clone || item;
  }, getUniqueGlobalNamespace:function() {
    var uniqueGlobalNamespace = this.uniqueGlobalNamespace, i;
    if (uniqueGlobalNamespace === undefined) {
      i = 0;
      do {
        uniqueGlobalNamespace = 'ExtBox' + ++i;
      } while (global[uniqueGlobalNamespace] !== undefined);
      global[uniqueGlobalNamespace] = Ext;
      this.uniqueGlobalNamespace = uniqueGlobalNamespace;
    }
    return uniqueGlobalNamespace;
  }, functionFactoryCache:{}, cacheableFunctionFactory:function() {
    var me = this, args = Array.prototype.slice.call(arguments), cache = me.functionFactoryCache, idx, fn, ln;
    if (Ext.isSandboxed) {
      ln = args.length;
      if (ln > 0) {
        ln--;
        args[ln] = 'var Ext\x3dwindow.' + Ext.name + ';' + args[ln];
      }
    }
    idx = args.join('');
    fn = cache[idx];
    if (!fn) {
      fn = Function.prototype.constructor.apply(Function.prototype, args);
      cache[idx] = fn;
    }
    return fn;
  }, functionFactory:function() {
    var args = Array.prototype.slice.call(arguments), ln;
    if (Ext.isSandboxed) {
      ln = args.length;
      if (ln > 0) {
        ln--;
        args[ln] = 'var Ext\x3dwindow.' + Ext.name + ';' + args[ln];
      }
    }
    return Function.prototype.constructor.apply(Function.prototype, args);
  }, Logger:{log:function(message, priority) {
    if (message && global.console) {
      if (!priority || !(priority in global.console)) {
        priority = 'log';
      }
      message = '[' + priority.toUpperCase() + '] ' + message;
      global.console[priority](message);
    }
  }, verbose:function(message) {
    this.log(message, 'verbose');
  }, info:function(message) {
    this.log(message, 'info');
  }, warn:function(message) {
    this.log(message, 'warn');
  }, error:function(message) {
    throw new Error(message);
  }, deprecate:function(message) {
    this.log(message, 'warn');
  }} || {verbose:emptyFn, log:emptyFn, info:emptyFn, warn:emptyFn, error:function(message) {
    throw new Error(message);
  }, deprecate:emptyFn}, getElementById:function(id) {
    return document.getElementById(id);
  }, splitAndUnescape:function() {
    var cache = {};
    return function(origin, delimiter) {
      if (!origin) {
        return [];
      } else {
        if (!delimiter) {
          return [origin];
        }
      }
      var replaceRe = cache[delimiter] || (cache[delimiter] = new RegExp('\\\\' + delimiter, 'g')), result = [], parts, part;
      parts = origin.split(delimiter);
      while ((part = parts.shift()) !== undefined) {
        while (part.charAt(part.length - 1) === '\\' && parts.length > 0) {
          part = part + delimiter + parts.shift();
        }
        part = part.replace(replaceRe, delimiter);
        result.push(part);
      }
      return result;
    };
  }()});
  Ext.returnTrue.$nullFn = Ext.returnId.$nullFn = true;
})();
Ext.platformTags.classic = !(Ext.platformTags.modern = Ext.isModern = true);
(function() {
  function toString() {
    var me = this, cls = me.sourceClass, method = me.sourceMethod, msg = me.msg;
    if (method) {
      if (msg) {
        method += '(): ';
        method += msg;
      } else {
        method += '()';
      }
    }
    if (cls) {
      method = method ? cls + '.' + method : cls;
    }
    return method || msg || '';
  }
  Ext.Error = function(config) {
    if (Ext.isString(config)) {
      config = {msg:config};
    }
    var error = new Error;
    Ext.apply(error, config);
    error.message = error.message || error.msg;
    error.toString = toString;
    return error;
  };
  Ext.apply(Ext.Error, {ignore:false, raise:function(err) {
    err = err || {};
    if (Ext.isString(err)) {
      err = {msg:err};
    }
    var me = this, method = me.raise.caller, msg, name;
    if (method === Ext.raise) {
      method = method.caller;
    }
    if (method) {
      if (!err.sourceMethod && (name = method.$name)) {
        err.sourceMethod = name;
      }
      if (!err.sourceClass && (name = method.$owner) && (name = name.$className)) {
        err.sourceClass = name;
      }
    }
    if (me.handle(err) !== true) {
      msg = toString.call(err);
      Ext.log({msg:msg, level:'error', dump:err, stack:true});
      throw new Ext.Error(err);
    }
  }, handle:function() {
    return this.ignore;
  }});
})();
Ext.deprecated = function(suggestion) {
  if (!suggestion) {
    suggestion = '';
  }
  function fail() {
    Ext.raise('The method "' + fail.$owner.$className + '.' + fail.$name + '" has been removed. ' + suggestion);
  }
  return fail;
  return Ext.emptyFn;
};
Ext.raise = function() {
  Ext.Error.raise.apply(Ext.Error, arguments);
};
(function() {
  if (typeof window === 'undefined') {
    return;
  }
  var last = 0, notify = function() {
    var cnt = Ext.log && Ext.log.counters, n = cnt && cnt.error + cnt.warn + cnt.info + cnt.log, msg;
    if (n && last !== n) {
      msg = [];
      if (cnt.error) {
        msg.push('Errors: ' + cnt.error);
      }
      if (cnt.warn) {
        msg.push('Warnings: ' + cnt.warn);
      }
      if (cnt.info) {
        msg.push('Info: ' + cnt.info);
      }
      if (cnt.log) {
        msg.push('Log: ' + cnt.log);
      }
      window.status = '*** ' + msg.join(' -- ');
      last = n;
    }
  };
  setInterval(notify, 1000);
})();
Ext.Array = function() {
  var arrayPrototype = Array.prototype, slice = arrayPrototype.slice, supportsSplice = function() {
    var array = [], lengthBefore, j = 20;
    if (!array.splice) {
      return false;
    }
    while (j--) {
      array.push('A');
    }
    array.splice(15, 0, 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F');
    lengthBefore = array.length;
    array.splice(13, 0, 'XXX');
    if (lengthBefore + 1 !== array.length) {
      return false;
    }
    return true;
  }(), supportsIndexOf = 'indexOf' in arrayPrototype, supportsSliceOnNodeList = true;
  function stableSort(array, userComparator) {
    var len = array.length, indices = new Array(len), i;
    for (i = 0; i < len; i++) {
      indices[i] = i;
    }
    indices.sort(function(index1, index2) {
      return userComparator(array[index1], array[index2]) || index1 - index2;
    });
    for (i = 0; i < len; i++) {
      indices[i] = array[indices[i]];
    }
    for (i = 0; i < len; i++) {
      array[i] = indices[i];
    }
    return array;
  }
  try {
    if (typeof document !== 'undefined') {
      slice.call(document.getElementsByTagName('body'));
    }
  } catch (e$0) {
    supportsSliceOnNodeList = false;
  }
  var fixArrayIndex = function(array, index) {
    return index < 0 ? Math.max(0, array.length + index) : Math.min(array.length, index);
  }, replaceSim = function(array, index, removeCount, insert) {
    var add = insert ? insert.length : 0, length = array.length, pos = fixArrayIndex(array, index);
    if (pos === length) {
      if (add) {
        array.push.apply(array, insert);
      }
    } else {
      var remove = Math.min(removeCount, length - pos), tailOldPos = pos + remove, tailNewPos = tailOldPos + add - remove, tailCount = length - tailOldPos, lengthAfterRemove = length - remove, i;
      if (tailNewPos < tailOldPos) {
        for (i = 0; i < tailCount; ++i) {
          array[tailNewPos + i] = array[tailOldPos + i];
        }
      } else {
        if (tailNewPos > tailOldPos) {
          for (i = tailCount; i--;) {
            array[tailNewPos + i] = array[tailOldPos + i];
          }
        }
      }
      if (add && pos === lengthAfterRemove) {
        array.length = lengthAfterRemove;
        array.push.apply(array, insert);
      } else {
        array.length = lengthAfterRemove + add;
        for (i = 0; i < add; ++i) {
          array[pos + i] = insert[i];
        }
      }
    }
    return array;
  }, replaceNative = function(array, index, removeCount, insert) {
    if (insert && insert.length) {
      if (index === 0 && !removeCount) {
        array.unshift.apply(array, insert);
      } else {
        if (index < array.length) {
          array.splice.apply(array, [index, removeCount].concat(insert));
        } else {
          array.push.apply(array, insert);
        }
      }
    } else {
      array.splice(index, removeCount);
    }
    return array;
  }, eraseSim = function(array, index, removeCount) {
    return replaceSim(array, index, removeCount);
  }, eraseNative = function(array, index, removeCount) {
    array.splice(index, removeCount);
    return array;
  }, spliceSim = function(array, index, removeCount) {
    var pos = fixArrayIndex(array, index), removed = array.slice(index, fixArrayIndex(array, pos + removeCount));
    if (arguments.length < 4) {
      replaceSim(array, pos, removeCount);
    } else {
      replaceSim(array, pos, removeCount, slice.call(arguments, 3));
    }
    return removed;
  }, spliceNative = function(array) {
    return array.splice.apply(array, slice.call(arguments, 1));
  }, erase = supportsSplice ? eraseNative : eraseSim, replace = supportsSplice ? replaceNative : replaceSim, splice = supportsSplice ? spliceNative : spliceSim, ExtArray = {binarySearch:function(array, item, begin, end, compareFn) {
    var length = array.length, middle, comparison;
    if (begin instanceof Function) {
      compareFn = begin;
      begin = 0;
      end = length;
    } else {
      if (end instanceof Function) {
        compareFn = end;
        end = length;
      } else {
        if (begin === undefined) {
          begin = 0;
        }
        if (end === undefined) {
          end = length;
        }
        compareFn = compareFn || ExtArray.lexicalCompare;
      }
    }
    --end;
    while (begin <= end) {
      middle = begin + end >> 1;
      comparison = compareFn(item, array[middle]);
      if (comparison >= 0) {
        begin = middle + 1;
      } else {
        if (comparison < 0) {
          end = middle - 1;
        }
      }
    }
    return begin;
  }, defaultCompare:function(lhs, rhs) {
    return lhs < rhs ? -1 : lhs > rhs ? 1 : 0;
  }, lexicalCompare:function(lhs, rhs) {
    lhs = String(lhs);
    rhs = String(rhs);
    return lhs < rhs ? -1 : lhs > rhs ? 1 : 0;
  }, each:function(array, fn, scope, reverse) {
    array = ExtArray.from(array);
    var i, ln = array.length;
    if (reverse !== true) {
      for (i = 0; i < ln; i++) {
        if (fn.call(scope || array[i], array[i], i, array) === false) {
          return i;
        }
      }
    } else {
      for (i = ln - 1; i > -1; i--) {
        if (fn.call(scope || array[i], array[i], i, array) === false) {
          return i;
        }
      }
    }
    return true;
  }, forEach:'forEach' in arrayPrototype ? function(array, fn, scope) {
    return array.forEach(fn, scope);
  } : function(array, fn, scope) {
    for (var i = 0, ln = array.length; i < ln; i++) {
      fn.call(scope, array[i], i, array);
    }
  }, indexOf:supportsIndexOf ? function(array, item, from) {
    return arrayPrototype.indexOf.call(array, item, from);
  } : function(array, item, from) {
    var i, length = array.length;
    for (i = from < 0 ? Math.max(0, length + from) : from || 0; i < length; i++) {
      if (array[i] === item) {
        return i;
      }
    }
    return -1;
  }, contains:supportsIndexOf ? function(array, item) {
    return arrayPrototype.indexOf.call(array, item) !== -1;
  } : function(array, item) {
    var i, ln;
    for (i = 0, ln = array.length; i < ln; i++) {
      if (array[i] === item) {
        return true;
      }
    }
    return false;
  }, toArray:function(iterable, start, end) {
    if (!iterable || !iterable.length) {
      return [];
    }
    if (typeof iterable === 'string') {
      iterable = iterable.split('');
    }
    if (supportsSliceOnNodeList) {
      return slice.call(iterable, start || 0, end || iterable.length);
    }
    var array = [], i;
    start = start || 0;
    end = end ? end < 0 ? iterable.length + end : end : iterable.length;
    for (i = start; i < end; i++) {
      array.push(iterable[i]);
    }
    return array;
  }, pluck:function(array, propertyName) {
    var ret = [], i, ln, item;
    for (i = 0, ln = array.length; i < ln; i++) {
      item = array[i];
      ret.push(item[propertyName]);
    }
    return ret;
  }, map:'map' in arrayPrototype ? function(array, fn, scope) {
    Ext.Assert.isFunction(fn, 'Ext.Array.map must have a callback function passed as second argument.');
    return array.map(fn, scope);
  } : function(array, fn, scope) {
    Ext.Assert.isFunction(fn, 'Ext.Array.map must have a callback function passed as second argument.');
    var results = [], len = array.length, i;
    for (i = 0; i < len; i++) {
      results[i] = fn.call(scope, array[i], i, array);
    }
    return results;
  }, every:'every' in arrayPrototype ? function(array, fn, scope) {
    Ext.Assert.isFunction(fn, 'Ext.Array.every must have a callback function passed as second argument.');
    return array.every(fn, scope);
  } : function(array, fn, scope) {
    Ext.Assert.isFunction(fn, 'Ext.Array.every must have a callback function passed as second argument.');
    var i = 0, ln = array.length;
    for (; i < ln; ++i) {
      if (!fn.call(scope, array[i], i, array)) {
        return false;
      }
    }
    return true;
  }, some:'some' in arrayPrototype ? function(array, fn, scope) {
    Ext.Assert.isFunction(fn, 'Ext.Array.some must have a callback function passed as second argument.');
    return array.some(fn, scope);
  } : function(array, fn, scope) {
    Ext.Assert.isFunction(fn, 'Ext.Array.some must have a callback function passed as second argument.');
    var i = 0, ln = array.length;
    for (; i < ln; ++i) {
      if (fn.call(scope, array[i], i, array)) {
        return true;
      }
    }
    return false;
  }, equals:function(array1, array2) {
    var len1 = array1.length, len2 = array2.length, i;
    if (array1 === array2) {
      return true;
    }
    if (len1 !== len2) {
      return false;
    }
    for (i = 0; i < len1; ++i) {
      if (array1[i] !== array2[i]) {
        return false;
      }
    }
    return true;
  }, clean:function(array) {
    var results = [], i = 0, ln = array.length, item;
    for (; i < ln; i++) {
      item = array[i];
      if (!Ext.isEmpty(item)) {
        results.push(item);
      }
    }
    return results;
  }, unique:function(array) {
    var clone = [], i = 0, ln = array.length, item;
    for (; i < ln; i++) {
      item = array[i];
      if (ExtArray.indexOf(clone, item) === -1) {
        clone.push(item);
      }
    }
    return clone;
  }, filter:'filter' in arrayPrototype ? function(array, fn, scope) {
    Ext.Assert.isFunction(fn, 'Ext.Array.filter must have a filter function passed as second argument.');
    return array.filter(fn, scope);
  } : function(array, fn, scope) {
    Ext.Assert.isFunction(fn, 'Ext.Array.filter must have a filter function passed as second argument.');
    var results = [], i = 0, ln = array.length;
    for (; i < ln; i++) {
      if (fn.call(scope, array[i], i, array)) {
        results.push(array[i]);
      }
    }
    return results;
  }, findBy:function(array, fn, scope) {
    var i = 0, len = array.length;
    for (; i < len; i++) {
      if (fn.call(scope || array, array[i], i)) {
        return array[i];
      }
    }
    return null;
  }, from:function(value, newReference) {
    if (value === undefined || value === null) {
      return [];
    }
    if (Ext.isArray(value)) {
      return newReference ? slice.call(value) : value;
    }
    var type = typeof value;
    if (value && value.length !== undefined && type !== 'string' && (type !== 'function' || !value.apply)) {
      return ExtArray.toArray(value);
    }
    return [value];
  }, remove:function(array, item) {
    var index = ExtArray.indexOf(array, item);
    if (index !== -1) {
      erase(array, index, 1);
    }
    return array;
  }, removeAt:function(array, index, count) {
    var len = array.length;
    if (index >= 0 && index < len) {
      count = count || 1;
      count = Math.min(count, len - index);
      erase(array, index, count);
    }
    return array;
  }, include:function(array, item) {
    if (!ExtArray.contains(array, item)) {
      array.push(item);
    }
  }, clone:function(array) {
    return slice.call(array);
  }, merge:function() {
    var args = slice.call(arguments), array = [], i, ln;
    for (i = 0, ln = args.length; i < ln; i++) {
      array = array.concat(args[i]);
    }
    return ExtArray.unique(array);
  }, intersect:function() {
    var intersection = [], arrays = slice.call(arguments), arraysLength, array, arrayLength, minArray, minArrayIndex, minArrayCandidate, minArrayLength, element, elementCandidate, elementCount, i, j, k;
    if (!arrays.length) {
      return intersection;
    }
    arraysLength = arrays.length;
    for (i = minArrayIndex = 0; i < arraysLength; i++) {
      minArrayCandidate = arrays[i];
      if (!minArray || minArrayCandidate.length < minArray.length) {
        minArray = minArrayCandidate;
        minArrayIndex = i;
      }
    }
    minArray = ExtArray.unique(minArray);
    erase(arrays, minArrayIndex, 1);
    minArrayLength = minArray.length;
    arraysLength = arrays.length;
    for (i = 0; i < minArrayLength; i++) {
      element = minArray[i];
      elementCount = 0;
      for (j = 0; j < arraysLength; j++) {
        array = arrays[j];
        arrayLength = array.length;
        for (k = 0; k < arrayLength; k++) {
          elementCandidate = array[k];
          if (element === elementCandidate) {
            elementCount++;
            break;
          }
        }
      }
      if (elementCount === arraysLength) {
        intersection.push(element);
      }
    }
    return intersection;
  }, difference:function(arrayA, arrayB) {
    var clone = slice.call(arrayA), ln = clone.length, i, j, lnB;
    for (i = 0, lnB = arrayB.length; i < lnB; i++) {
      for (j = 0; j < ln; j++) {
        if (clone[j] === arrayB[i]) {
          erase(clone, j, 1);
          j--;
          ln--;
        }
      }
    }
    return clone;
  }, reduce:Array.prototype.reduce ? function(array, reduceFn, initialValue) {
    if (arguments.length === 3) {
      return Array.prototype.reduce.call(array, reduceFn, initialValue);
    }
    return Array.prototype.reduce.call(array, reduceFn);
  } : function(array, reduceFn, initialValue) {
    array = Object(array);
    if (!Ext.isFunction(reduceFn)) {
      Ext.raise('Invalid parameter: expected a function.');
    }
    var index = 0, length = array.length >>> 0, reduced = initialValue;
    if (arguments.length < 3) {
      while (true) {
        if (index in array) {
          reduced = array[index++];
          break;
        }
        if (++index >= length) {
          throw new TypeError('Reduce of empty array with no initial value');
        }
      }
    }
    for (; index < length; ++index) {
      if (index in array) {
        reduced = reduceFn(reduced, array[index], index, array);
      }
    }
    return reduced;
  }, slice:[1, 2].slice(1, undefined).length ? function(array, begin, end) {
    return slice.call(array, begin, end);
  } : function(array, begin, end) {
    if (typeof begin === 'undefined') {
      return slice.call(array);
    }
    if (typeof end === 'undefined') {
      return slice.call(array, begin);
    }
    return slice.call(array, begin, end);
  }, sort:function(array, sortFn) {
    return stableSort(array, sortFn || ExtArray.lexicalCompare);
  }, flatten:function(array) {
    var worker = [];
    function rFlatten(a) {
      var i, ln, v;
      for (i = 0, ln = a.length; i < ln; i++) {
        v = a[i];
        if (Ext.isArray(v)) {
          rFlatten(v);
        } else {
          worker.push(v);
        }
      }
      return worker;
    }
    return rFlatten(array);
  }, min:function(array, comparisonFn) {
    var min = array[0], i, ln, item;
    for (i = 0, ln = array.length; i < ln; i++) {
      item = array[i];
      if (comparisonFn) {
        if (comparisonFn(min, item) === 1) {
          min = item;
        }
      } else {
        if (item < min) {
          min = item;
        }
      }
    }
    return min;
  }, max:function(array, comparisonFn) {
    var max = array[0], i, ln, item;
    for (i = 0, ln = array.length; i < ln; i++) {
      item = array[i];
      if (comparisonFn) {
        if (comparisonFn(max, item) === -1) {
          max = item;
        }
      } else {
        if (item > max) {
          max = item;
        }
      }
    }
    return max;
  }, mean:function(array) {
    return array.length > 0 ? ExtArray.sum(array) / array.length : undefined;
  }, sum:function(array) {
    var sum = 0, i, ln, item;
    for (i = 0, ln = array.length; i < ln; i++) {
      item = array[i];
      sum += item;
    }
    return sum;
  }, toMap:function(array, getKey, scope) {
    var map = {}, i = array.length;
    if (!getKey) {
      while (i--) {
        map[array[i]] = i + 1;
      }
    } else {
      if (typeof getKey === 'string') {
        while (i--) {
          map[array[i][getKey]] = i + 1;
        }
      } else {
        while (i--) {
          map[getKey.call(scope, array[i])] = i + 1;
        }
      }
    }
    return map;
  }, toValueMap:function(array, getKey, scope, arrayify) {
    var map = {}, i = array.length, autoArray, alwaysArray, entry, fn, key, value;
    if (!getKey) {
      while (i--) {
        value = array[i];
        map[value] = value;
      }
    } else {
      if (!(fn = typeof getKey !== 'string')) {
        arrayify = scope;
      }
      alwaysArray = arrayify === 1;
      autoArray = arrayify === 2;
      while (i--) {
        value = array[i];
        key = fn ? getKey.call(scope, value) : value[getKey];
        if (alwaysArray) {
          if (key in map) {
            map[key].push(value);
          } else {
            map[key] = [value];
          }
        } else {
          if (autoArray && key in map) {
            if ((entry = map[key]) instanceof Array) {
              entry.push(value);
            } else {
              map[key] = [entry, value];
            }
          } else {
            map[key] = value;
          }
        }
      }
    }
    return map;
  }, _replaceSim:replaceSim, _spliceSim:spliceSim, erase:erase, insert:function(array, index, items) {
    return replace(array, index, 0, items);
  }, move:function(array, fromIdx, toIdx) {
    if (toIdx === fromIdx) {
      return;
    }
    var item = array[fromIdx], incr = toIdx > fromIdx ? 1 : -1, i;
    for (i = fromIdx; i != toIdx; i += incr) {
      array[i] = array[i + incr];
    }
    array[toIdx] = item;
  }, replace:replace, splice:splice, push:function(target) {
    var len = arguments.length, i = 1, newItem;
    if (target === undefined) {
      target = [];
    } else {
      if (!Ext.isArray(target)) {
        target = [target];
      }
    }
    for (; i < len; i++) {
      newItem = arguments[i];
      Array.prototype.push[Ext.isIterable(newItem) ? 'apply' : 'call'](target, newItem);
    }
    return target;
  }, numericSortFn:function(a, b) {
    return a - b;
  }};
  Ext.each = ExtArray.each;
  ExtArray.union = ExtArray.merge;
  Ext.min = ExtArray.min;
  Ext.max = ExtArray.max;
  Ext.sum = ExtArray.sum;
  Ext.mean = ExtArray.mean;
  Ext.flatten = ExtArray.flatten;
  Ext.clean = ExtArray.clean;
  Ext.unique = ExtArray.unique;
  Ext.pluck = ExtArray.pluck;
  Ext.toArray = function() {
    return ExtArray.toArray.apply(ExtArray, arguments);
  };
  return ExtArray;
}();
Ext.Assert = {falsey:function(b, msg) {
  if (b) {
    Ext.raise(msg || 'Expected a falsey value but was ' + b);
  }
}, falseyProp:function(object, property) {
  Ext.Assert.truthy(object);
  var b = object[property];
  if (b) {
    if (object.$className) {
      property = object.$className + '#' + property;
    }
    Ext.raise('Expected a falsey value for ' + property + ' but was ' + b);
  }
}, truthy:function(b, msg) {
  if (!b) {
    Ext.raise(msg || 'Expected a truthy value but was ' + typeof b);
  }
}, truthyProp:function(object, property) {
  Ext.Assert.truthy(object);
  var b = object[property];
  if (!b) {
    if (object.$className) {
      property = object.$className + '#' + property;
    }
    Ext.raise('Expected a truthy value for ' + property + ' but was ' + typeof b);
  }
}};
(function() {
  function makeAssert(name, kind) {
    var testFn = Ext[name], def;
    return function(value, msg) {
      if (!testFn(value)) {
        Ext.raise(msg || def || (def = 'Expected value to be ' + kind));
      }
    };
  }
  function makeAssertProp(name, kind) {
    var testFn = Ext[name], def;
    return function(object, prop) {
      Ext.Assert.truthy(object);
      if (!testFn(object[prop])) {
        Ext.raise(def || (def = 'Expected ' + (object.$className ? object.$className + '#' : '') + prop + ' to be ' + kind));
      }
    };
  }
  function makeNotAssert(name, kind) {
    var testFn = Ext[name], def;
    return function(value, msg) {
      if (testFn(value)) {
        Ext.raise(msg || def || (def = 'Expected value to NOT be ' + kind));
      }
    };
  }
  function makeNotAssertProp(name, kind) {
    var testFn = Ext[name], def;
    return function(object, prop) {
      Ext.Assert.truthy(object);
      if (testFn(object[prop])) {
        Ext.raise(def || (def = 'Expected ' + (object.$className ? object.$className + '#' : '') + prop + ' to NOT be ' + kind));
      }
    };
  }
  for (var name in Ext) {
    if (name.substring(0, 2) == 'is' && Ext.isFunction(Ext[name])) {
      var kind = name.substring(2);
      Ext.Assert[name] = makeAssert(name, kind);
      Ext.Assert[name + 'Prop'] = makeAssertProp(name, kind);
      Ext.Assert['isNot' + kind] = makeNotAssert(name, kind);
      Ext.Assert['isNot' + kind + 'Prop'] = makeNotAssertProp(name, kind);
    }
  }
})();
Ext.String = function() {
  var trimRegex = /^[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000]+|[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000]+$/g, escapeRe = /('|\\)/g, escapeRegexRe = /([-.*+?\^${}()|\[\]\/\\])/g, basicTrimRe = /^\s+|\s+$/g, whitespaceRe = /\s+/, varReplace = /(^[^a-z]*|[^\w])/gi, charToEntity, entityToChar, charToEntityRegex, 
  entityToCharRegex, htmlEncodeReplaceFn = function(match, capture) {
    return charToEntity[capture];
  }, htmlDecodeReplaceFn = function(match, capture) {
    return capture in entityToChar ? entityToChar[capture] : String.fromCharCode(parseInt(capture.substr(2), 10));
  }, boundsCheck = function(s, other) {
    if (s === null || s === undefined || other === null || other === undefined) {
      return false;
    }
    return other.length <= s.length;
  }, ExtString;
  return ExtString = {insert:function(s, value, index) {
    if (!s) {
      return value;
    }
    if (!value) {
      return s;
    }
    var len = s.length;
    if (!index && index !== 0) {
      index = len;
    }
    if (index < 0) {
      index *= -1;
      if (index >= len) {
        index = 0;
      } else {
        index = len - index;
      }
    }
    if (index === 0) {
      s = value + s;
    } else {
      if (index >= s.length) {
        s += value;
      } else {
        s = s.substr(0, index) + value + s.substr(index);
      }
    }
    return s;
  }, startsWith:function(s, start, ignoreCase) {
    var result = boundsCheck(s, start);
    if (result) {
      if (ignoreCase) {
        s = s.toLowerCase();
        start = start.toLowerCase();
      }
      result = s.lastIndexOf(start, 0) === 0;
    }
    return result;
  }, endsWith:function(s, end, ignoreCase) {
    var result = boundsCheck(s, end);
    if (result) {
      if (ignoreCase) {
        s = s.toLowerCase();
        end = end.toLowerCase();
      }
      result = s.indexOf(end, s.length - end.length) !== -1;
    }
    return result;
  }, createVarName:function(s) {
    return s.replace(varReplace, '');
  }, htmlEncode:function(value) {
    return !value ? value : String(value).replace(charToEntityRegex, htmlEncodeReplaceFn);
  }, htmlDecode:function(value) {
    return !value ? value : String(value).replace(entityToCharRegex, htmlDecodeReplaceFn);
  }, hasHtmlCharacters:function(s) {
    return charToEntityRegex.test(s);
  }, addCharacterEntities:function(newEntities) {
    var charKeys = [], entityKeys = [], key, echar;
    for (key in newEntities) {
      echar = newEntities[key];
      entityToChar[key] = echar;
      charToEntity[echar] = key;
      charKeys.push(echar);
      entityKeys.push(key);
    }
    charToEntityRegex = new RegExp('(' + charKeys.join('|') + ')', 'g');
    entityToCharRegex = new RegExp('(' + entityKeys.join('|') + '|\x26#[0-9]{1,5};' + ')', 'g');
  }, resetCharacterEntities:function() {
    charToEntity = {};
    entityToChar = {};
    this.addCharacterEntities({'\x26amp;':'\x26', '\x26gt;':'\x3e', '\x26lt;':'\x3c', '\x26quot;':'"', '\x26#39;':"'"});
  }, urlAppend:function(url, string) {
    if (!Ext.isEmpty(string)) {
      return url + (url.indexOf('?') === -1 ? '?' : '\x26') + string;
    }
    return url;
  }, trim:function(string) {
    if (string) {
      string = string.replace(trimRegex, '');
    }
    return string || '';
  }, capitalize:function(string) {
    if (string) {
      string = string.charAt(0).toUpperCase() + string.substr(1);
    }
    return string || '';
  }, uncapitalize:function(string) {
    if (string) {
      string = string.charAt(0).toLowerCase() + string.substr(1);
    }
    return string || '';
  }, ellipsis:function(value, length, word) {
    if (value && value.length > length) {
      if (word) {
        var vs = value.substr(0, length - 2), index = Math.max(vs.lastIndexOf(' '), vs.lastIndexOf('.'), vs.lastIndexOf('!'), vs.lastIndexOf('?'));
        if (index !== -1 && index >= length - 15) {
          return vs.substr(0, index) + '...';
        }
      }
      return value.substr(0, length - 3) + '...';
    }
    return value;
  }, escapeRegex:function(string) {
    return string.replace(escapeRegexRe, '\\$1');
  }, createRegex:function(value, startsWith, endsWith, ignoreCase) {
    var ret = value;
    if (value != null && !value.exec) {
      ret = ExtString.escapeRegex(String(value));
      if (startsWith !== false) {
        ret = '^' + ret;
      }
      if (endsWith !== false) {
        ret += '$';
      }
      ret = new RegExp(ret, ignoreCase !== false ? 'i' : '');
    }
    return ret;
  }, escape:function(string) {
    return string.replace(escapeRe, '\\$1');
  }, toggle:function(string, value, other) {
    return string === value ? other : value;
  }, leftPad:function(string, size, character) {
    var result = String(string);
    character = character || ' ';
    while (result.length < size) {
      result = character + result;
    }
    return result;
  }, repeat:function(pattern, count, sep) {
    if (count < 1) {
      count = 0;
    }
    for (var buf = [], i = count; i--;) {
      buf.push(pattern);
    }
    return buf.join(sep || '');
  }, splitWords:function(words) {
    if (words && typeof words == 'string') {
      return words.replace(basicTrimRe, '').split(whitespaceRe);
    }
    return words || [];
  }};
}();
Ext.String.resetCharacterEntities();
Ext.htmlEncode = Ext.String.htmlEncode;
Ext.htmlDecode = Ext.String.htmlDecode;
Ext.urlAppend = Ext.String.urlAppend;
Ext.Date = function() {
  var utilDate, nativeDate = Date, stripEscapeRe = /(\\.)/g, hourInfoRe = /([gGhHisucUOPZ]|MS)/, dateInfoRe = /([djzmnYycU]|MS)/, slashRe = /\\/gi, numberTokenRe = /\{(\d+)\}/g, MSFormatRe = new RegExp('\\/Date\\(([-+])?(\\d+)(?:[+-]\\d{4})?\\)\\/'), pad = Ext.String.leftPad, code = ['var me \x3d this, dt, y, m, d, h, i, s, ms, o, O, z, zz, u, v, W, year, jan4, week1monday, daysInMonth, dayMatched,', 'def \x3d me.defaults,', 'from \x3d Ext.Number.from,', 'results \x3d String(input).match(me.parseRegexes[{0}]);', 
  'if(results){', '{1}', 'if(u !\x3d null){', 'v \x3d new Date(u * 1000);', '}else{', 'dt \x3d me.clearTime(new Date);', 'y \x3d from(y, from(def.y, dt.getFullYear()));', 'm \x3d from(m, from(def.m - 1, dt.getMonth()));', 'dayMatched \x3d d !\x3d\x3d undefined;', 'd \x3d from(d, from(def.d, dt.getDate()));', 'if (!dayMatched) {', 'dt.setDate(1);', 'dt.setMonth(m);', 'dt.setFullYear(y);', 'daysInMonth \x3d me.getDaysInMonth(dt);', 'if (d \x3e daysInMonth) {', 'd \x3d daysInMonth;', '}', '}', 'h  \x3d from(h, from(def.h, dt.getHours()));', 
  'i  \x3d from(i, from(def.i, dt.getMinutes()));', 's  \x3d from(s, from(def.s, dt.getSeconds()));', 'ms \x3d from(ms, from(def.ms, dt.getMilliseconds()));', 'if(z \x3e\x3d 0 \x26\x26 y \x3e\x3d 0){', 'v \x3d me.add(new Date(y \x3c 100 ? 100 : y, 0, 1, h, i, s, ms), me.YEAR, y \x3c 100 ? y - 100 : 0);', 'v \x3d !strict? v : (strict \x3d\x3d\x3d true \x26\x26 (z \x3c\x3d 364 || (me.isLeapYear(v) \x26\x26 z \x3c\x3d 365))? me.add(v, me.DAY, z) : null);', '}else if(strict \x3d\x3d\x3d true \x26\x26 !me.isValid(y, m + 1, d, h, i, s, ms)){', 
  'v \x3d null;', '}else{', 'if (W) {', 'year \x3d y || (new Date()).getFullYear();', 'jan4 \x3d new Date(year, 0, 4, 0, 0, 0);', 'd \x3d jan4.getDay();', 'week1monday \x3d new Date(jan4.getTime() - ((d \x3d\x3d\x3d 0 ? 6 : d - 1) * 86400000));', 'v \x3d Ext.Date.clearTime(new Date(week1monday.getTime() + ((W - 1) * 604800000 + 43200000)));', '} else {', 'v \x3d me.add(new Date(y \x3c 100 ? 100 : y, m, d, h, i, s, ms), me.YEAR, y \x3c 100 ? y - 100 : 0);', '}', '}', '}', '}', 'if(v){', 'if(zz !\x3d null){', 
  'v \x3d me.add(v, me.SECOND, -v.getTimezoneOffset() * 60 - zz);', '}else if(o){', "v \x3d me.add(v, me.MINUTE, -v.getTimezoneOffset() + (sn \x3d\x3d '+'? -1 : 1) * (hr * 60 + mn));", '}', '}', 'return (v !\x3d null) ? v : null;'].join('\n');
  if (!Date.prototype.toISOString) {
    Date.prototype.toISOString = function() {
      var me = this;
      return pad(me.getUTCFullYear(), 4, '0') + '-' + pad(me.getUTCMonth() + 1, 2, '0') + '-' + pad(me.getUTCDate(), 2, '0') + 'T' + pad(me.getUTCHours(), 2, '0') + ':' + pad(me.getUTCMinutes(), 2, '0') + ':' + pad(me.getUTCSeconds(), 2, '0') + '.' + pad(me.getUTCMilliseconds(), 3, '0') + 'Z';
    };
  }
  function xf(format) {
    var args = Array.prototype.slice.call(arguments, 1);
    return format.replace(numberTokenRe, function(m, i) {
      return args[i];
    });
  }
  return utilDate = {now:nativeDate.now, toString:function(date) {
    if (!date) {
      date = new nativeDate;
    }
    return date.getFullYear() + '-' + pad(date.getMonth() + 1, 2, '0') + '-' + pad(date.getDate(), 2, '0') + 'T' + pad(date.getHours(), 2, '0') + ':' + pad(date.getMinutes(), 2, '0') + ':' + pad(date.getSeconds(), 2, '0');
  }, getElapsed:function(dateA, dateB) {
    return Math.abs(dateA - (dateB || utilDate.now()));
  }, useStrict:false, formatCodeToRegex:function(character, currentGroup) {
    var p = utilDate.parseCodes[character];
    if (p) {
      p = typeof p === 'function' ? p() : p;
      utilDate.parseCodes[character] = p;
    }
    return p ? Ext.applyIf({c:p.c ? xf(p.c, currentGroup || '{0}') : p.c}, p) : {g:0, c:null, s:Ext.String.escapeRegex(character)};
  }, parseFunctions:{'MS':function(input, strict) {
    var r = (input || '').match(MSFormatRe);
    return r ? new nativeDate(((r[1] || '') + r[2]) * 1) : null;
  }, 'time':function(input, strict) {
    var num = parseInt(input, 10);
    if (num || num === 0) {
      return new nativeDate(num);
    }
    return null;
  }, 'timestamp':function(input, strict) {
    var num = parseInt(input, 10);
    if (num || num === 0) {
      return new nativeDate(num * 1000);
    }
    return null;
  }}, parseRegexes:[], formatFunctions:{'MS':function() {
    return '\\/Date(' + this.getTime() + ')\\/';
  }, 'time':function() {
    return this.getTime().toString();
  }, 'timestamp':function() {
    return utilDate.format(this, 'U');
  }}, y2kYear:50, MILLI:'ms', SECOND:'s', MINUTE:'mi', HOUR:'h', DAY:'d', MONTH:'mo', YEAR:'y', defaults:{}, dayNames:['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'], monthNames:['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'], monthNumbers:{January:0, Jan:0, February:1, Feb:1, March:2, Mar:2, April:3, Apr:3, May:4, June:5, Jun:5, July:6, Jul:6, August:7, Aug:7, September:8, Sep:8, October:9, 
  Oct:9, November:10, Nov:10, December:11, Dec:11}, defaultFormat:'m/d/Y', getShortMonthName:function(month) {
    return utilDate.monthNames[month].substring(0, 3);
  }, getShortDayName:function(day) {
    return utilDate.dayNames[day].substring(0, 3);
  }, getMonthNumber:function(name) {
    return utilDate.monthNumbers[name.substring(0, 1).toUpperCase() + name.substring(1, 3).toLowerCase()];
  }, formatContainsHourInfo:function(format) {
    return hourInfoRe.test(format.replace(stripEscapeRe, ''));
  }, formatContainsDateInfo:function(format) {
    return dateInfoRe.test(format.replace(stripEscapeRe, ''));
  }, unescapeFormat:function(format) {
    return format.replace(slashRe, '');
  }, formatCodes:{d:"Ext.String.leftPad(m.getDate(), 2, '0')", D:'Ext.Date.getShortDayName(m.getDay())', j:'m.getDate()', l:'Ext.Date.dayNames[m.getDay()]', N:'(m.getDay() ? m.getDay() : 7)', S:'Ext.Date.getSuffix(m)', w:'m.getDay()', z:'Ext.Date.getDayOfYear(m)', W:"Ext.String.leftPad(Ext.Date.getWeekOfYear(m), 2, '0')", F:'Ext.Date.monthNames[m.getMonth()]', m:"Ext.String.leftPad(m.getMonth() + 1, 2, '0')", M:'Ext.Date.getShortMonthName(m.getMonth())', n:'(m.getMonth() + 1)', t:'Ext.Date.getDaysInMonth(m)', 
  L:'(Ext.Date.isLeapYear(m) ? 1 : 0)', o:'(m.getFullYear() + (Ext.Date.getWeekOfYear(m) \x3d\x3d 1 \x26\x26 m.getMonth() \x3e 0 ? +1 : (Ext.Date.getWeekOfYear(m) \x3e\x3d 52 \x26\x26 m.getMonth() \x3c 11 ? -1 : 0)))', Y:"Ext.String.leftPad(m.getFullYear(), 4, '0')", y:"('' + m.getFullYear()).substring(2, 4)", a:"(m.getHours() \x3c 12 ? 'am' : 'pm')", A:"(m.getHours() \x3c 12 ? 'AM' : 'PM')", g:'((m.getHours() % 12) ? m.getHours() % 12 : 12)', G:'m.getHours()', h:"Ext.String.leftPad((m.getHours() % 12) ? m.getHours() % 12 : 12, 2, '0')", 
  H:"Ext.String.leftPad(m.getHours(), 2, '0')", i:"Ext.String.leftPad(m.getMinutes(), 2, '0')", s:"Ext.String.leftPad(m.getSeconds(), 2, '0')", u:"Ext.String.leftPad(m.getMilliseconds(), 3, '0')", O:'Ext.Date.getGMTOffset(m)', P:'Ext.Date.getGMTOffset(m, true)', T:'Ext.Date.getTimezone(m)', Z:'(m.getTimezoneOffset() * -60)', c:function() {
    var c = 'Y-m-dTH:i:sP', code = [], i, l = c.length, e;
    for (i = 0; i < l; ++i) {
      e = c.charAt(i);
      code.push(e === 'T' ? "'T'" : utilDate.getFormatCode(e));
    }
    return code.join(' + ');
  }, C:function() {
    return 'm.toISOString()';
  }, U:'Math.round(m.getTime() / 1000)'}, isValid:function(y, m, d, h, i, s, ms) {
    h = h || 0;
    i = i || 0;
    s = s || 0;
    ms = ms || 0;
    var dt = utilDate.add(new nativeDate(y < 100 ? 100 : y, m - 1, d, h, i, s, ms), utilDate.YEAR, y < 100 ? y - 100 : 0);
    return y === dt.getFullYear() && m === dt.getMonth() + 1 && d === dt.getDate() && h === dt.getHours() && i === dt.getMinutes() && s === dt.getSeconds() && ms === dt.getMilliseconds();
  }, parse:function(input, format, strict) {
    var p = utilDate.parseFunctions;
    if (p[format] == null) {
      utilDate.createParser(format);
    }
    return p[format].call(utilDate, input, Ext.isDefined(strict) ? strict : utilDate.useStrict);
  }, parseDate:function(input, format, strict) {
    return utilDate.parse(input, format, strict);
  }, getFormatCode:function(character) {
    var f = utilDate.formatCodes[character];
    if (f) {
      f = typeof f === 'function' ? f() : f;
      utilDate.formatCodes[character] = f;
    }
    return f || "'" + Ext.String.escape(character) + "'";
  }, createFormat:function(format) {
    var code = [], special = false, ch = '', i;
    for (i = 0; i < format.length; ++i) {
      ch = format.charAt(i);
      if (!special && ch === '\\') {
        special = true;
      } else {
        if (special) {
          special = false;
          code.push("'" + Ext.String.escape(ch) + "'");
        } else {
          if (ch === '\n') {
            code.push("'\\n'");
          } else {
            code.push(utilDate.getFormatCode(ch));
          }
        }
      }
    }
    utilDate.formatFunctions[format] = Ext.functionFactory('var m\x3dthis;return ' + code.join('+'));
  }, createParser:function(format) {
    var regexNum = utilDate.parseRegexes.length, currentGroup = 1, calc = [], regex = [], special = false, ch = '', i = 0, len = format.length, atEnd = [], obj;
    for (; i < len; ++i) {
      ch = format.charAt(i);
      if (!special && ch === '\\') {
        special = true;
      } else {
        if (special) {
          special = false;
          regex.push(Ext.String.escape(ch));
        } else {
          obj = utilDate.formatCodeToRegex(ch, currentGroup);
          currentGroup += obj.g;
          regex.push(obj.s);
          if (obj.g && obj.c) {
            if (obj.calcAtEnd) {
              atEnd.push(obj.c);
            } else {
              calc.push(obj.c);
            }
          }
        }
      }
    }
    calc = calc.concat(atEnd);
    utilDate.parseRegexes[regexNum] = new RegExp('^' + regex.join('') + '$', 'i');
    utilDate.parseFunctions[format] = Ext.functionFactory('input', 'strict', xf(code, regexNum, calc.join('')));
  }, parseCodes:{d:{g:1, c:'d \x3d parseInt(results[{0}], 10);\n', s:'(3[0-1]|[1-2][0-9]|0[1-9])'}, j:{g:1, c:'d \x3d parseInt(results[{0}], 10);\n', s:'(3[0-1]|[1-2][0-9]|[1-9])'}, D:function() {
    for (var a = [], i = 0; i < 7; a.push(utilDate.getShortDayName(i)), ++i) {
    }
    return {g:0, c:null, s:'(?:' + a.join('|') + ')'};
  }, l:function() {
    return {g:0, c:null, s:'(?:' + utilDate.dayNames.join('|') + ')'};
  }, N:{g:0, c:null, s:'[1-7]'}, S:{g:0, c:null, s:'(?:st|nd|rd|th)'}, w:{g:0, c:null, s:'[0-6]'}, z:{g:1, c:'z \x3d parseInt(results[{0}], 10);\n', s:'(\\d{1,3})'}, W:{g:1, c:'W \x3d parseInt(results[{0}], 10);\n', s:'(\\d{2})'}, F:function() {
    return {g:1, c:'m \x3d parseInt(me.getMonthNumber(results[{0}]), 10);\n', s:'(' + utilDate.monthNames.join('|') + ')'};
  }, M:function() {
    for (var a = [], i = 0; i < 12; a.push(utilDate.getShortMonthName(i)), ++i) {
    }
    return Ext.applyIf({s:'(' + a.join('|') + ')'}, utilDate.formatCodeToRegex('F'));
  }, m:{g:1, c:'m \x3d parseInt(results[{0}], 10) - 1;\n', s:'(1[0-2]|0[1-9])'}, n:{g:1, c:'m \x3d parseInt(results[{0}], 10) - 1;\n', s:'(1[0-2]|[1-9])'}, t:{g:0, c:null, s:'(?:\\d{2})'}, L:{g:0, c:null, s:'(?:1|0)'}, o:{g:1, c:'y \x3d parseInt(results[{0}], 10);\n', s:'(\\d{4})'}, Y:{g:1, c:'y \x3d parseInt(results[{0}], 10);\n', s:'(\\d{4})'}, y:{g:1, c:'var ty \x3d parseInt(results[{0}], 10);\n' + 'y \x3d ty \x3e me.y2kYear ? 1900 + ty : 2000 + ty;\n', s:'(\\d{2})'}, a:{g:1, c:'if (/(am)/i.test(results[{0}])) {\n' + 
  'if (!h || h \x3d\x3d 12) { h \x3d 0; }\n' + '} else { if (!h || h \x3c 12) { h \x3d (h || 0) + 12; }}', s:'(am|pm|AM|PM)', calcAtEnd:true}, A:{g:1, c:'if (/(am)/i.test(results[{0}])) {\n' + 'if (!h || h \x3d\x3d 12) { h \x3d 0; }\n' + '} else { if (!h || h \x3c 12) { h \x3d (h || 0) + 12; }}', s:'(AM|PM|am|pm)', calcAtEnd:true}, g:{g:1, c:'h \x3d parseInt(results[{0}], 10);\n', s:'(1[0-2]|[0-9])'}, G:{g:1, c:'h \x3d parseInt(results[{0}], 10);\n', s:'(2[0-3]|1[0-9]|[0-9])'}, h:{g:1, c:'h \x3d parseInt(results[{0}], 10);\n', 
  s:'(1[0-2]|0[1-9])'}, H:{g:1, c:'h \x3d parseInt(results[{0}], 10);\n', s:'(2[0-3]|[0-1][0-9])'}, i:{g:1, c:'i \x3d parseInt(results[{0}], 10);\n', s:'([0-5][0-9])'}, s:{g:1, c:'s \x3d parseInt(results[{0}], 10);\n', s:'([0-5][0-9])'}, u:{g:1, c:'ms \x3d results[{0}]; ms \x3d parseInt(ms, 10)/Math.pow(10, ms.length - 3);\n', s:'(\\d+)'}, O:{g:1, c:['o \x3d results[{0}];', 'var sn \x3d o.substring(0,1),', 'hr \x3d o.substring(1,3)*1 + Math.floor(o.substring(3,5) / 60),', 'mn \x3d o.substring(3,5) % 60;', 
  "o \x3d ((-12 \x3c\x3d (hr*60 + mn)/60) \x26\x26 ((hr*60 + mn)/60 \x3c\x3d 14))? (sn + Ext.String.leftPad(hr, 2, '0') + Ext.String.leftPad(mn, 2, '0')) : null;\n"].join('\n'), s:'([+-]\\d{4})'}, P:{g:1, c:['o \x3d results[{0}];', 'var sn \x3d o.substring(0,1),', 'hr \x3d o.substring(1,3)*1 + Math.floor(o.substring(4,6) / 60),', 'mn \x3d o.substring(4,6) % 60;', "o \x3d ((-12 \x3c\x3d (hr*60 + mn)/60) \x26\x26 ((hr*60 + mn)/60 \x3c\x3d 14))? (sn + Ext.String.leftPad(hr, 2, '0') + Ext.String.leftPad(mn, 2, '0')) : null;\n"].join('\n'), 
  s:'([+-]\\d{2}:\\d{2})'}, T:{g:0, c:null, s:'[A-Z]{1,5}'}, Z:{g:1, c:'zz \x3d results[{0}] * 1;\n' + 'zz \x3d (-43200 \x3c\x3d zz \x26\x26 zz \x3c\x3d 50400)? zz : null;\n', s:'([+-]?\\d{1,5})'}, c:function() {
    var calc = [], arr = [utilDate.formatCodeToRegex('Y', 1), utilDate.formatCodeToRegex('m', 2), utilDate.formatCodeToRegex('d', 3), utilDate.formatCodeToRegex('H', 4), utilDate.formatCodeToRegex('i', 5), utilDate.formatCodeToRegex('s', 6), {c:"ms \x3d results[7] || '0'; ms \x3d parseInt(ms, 10)/Math.pow(10, ms.length - 3);\n"}, {c:['if(results[8]) {', "if(results[8] \x3d\x3d 'Z'){", 'zz \x3d 0;', "}else if (results[8].indexOf(':') \x3e -1){", utilDate.formatCodeToRegex('P', 8).c, '}else{', utilDate.formatCodeToRegex('O', 
    8).c, '}', '}'].join('\n')}], i, l;
    for (i = 0, l = arr.length; i < l; ++i) {
      calc.push(arr[i].c);
    }
    return {g:1, c:calc.join(''), s:[arr[0].s, '(?:', '-', arr[1].s, '(?:', '-', arr[2].s, '(?:', '(?:T| )?', arr[3].s, ':', arr[4].s, '(?::', arr[5].s, ')?', '(?:(?:\\.|,)(\\d+))?', '(Z|(?:[-+]\\d{2}(?::)?\\d{2}))?', ')?', ')?', ')?'].join('')};
  }, U:{g:1, c:'u \x3d parseInt(results[{0}], 10);\n', s:'(-?\\d+)'}}, dateFormat:function(date, format) {
    return utilDate.format(date, format);
  }, isEqual:function(date1, date2) {
    if (date1 && date2) {
      return date1.getTime() === date2.getTime();
    }
    return !(date1 || date2);
  }, format:function(date, format) {
    var formatFunctions = utilDate.formatFunctions;
    if (!Ext.isDate(date)) {
      return '';
    }
    if (formatFunctions[format] == null) {
      utilDate.createFormat(format);
    }
    return formatFunctions[format].call(date) + '';
  }, getTimezone:function(date) {
    return date.toString().replace(/^.* (?:\((.*)\)|([A-Z]{1,5})(?:[\-+][0-9]{4})?(?: -?\d+)?)$/, '$1$2').replace(/[^A-Z]/g, '');
  }, getGMTOffset:function(date, colon) {
    var offset = date.getTimezoneOffset();
    return (offset > 0 ? '-' : '+') + Ext.String.leftPad(Math.floor(Math.abs(offset) / 60), 2, '0') + (colon ? ':' : '') + Ext.String.leftPad(Math.abs(offset % 60), 2, '0');
  }, getDayOfYear:function(date) {
    var num = 0, d = utilDate.clone(date), m = date.getMonth(), i;
    for (i = 0, d.setDate(1), d.setMonth(0); i < m; d.setMonth(++i)) {
      num += utilDate.getDaysInMonth(d);
    }
    return num + date.getDate() - 1;
  }, getWeekOfYear:function() {
    var ms1d = 86400000, ms7d = 7 * ms1d;
    return function(date) {
      var DC3 = nativeDate.UTC(date.getFullYear(), date.getMonth(), date.getDate() + 3) / ms1d, AWN = Math.floor(DC3 / 7), Wyr = (new nativeDate(AWN * ms7d)).getUTCFullYear();
      return AWN - Math.floor(nativeDate.UTC(Wyr, 0, 7) / ms7d) + 1;
    };
  }(), isLeapYear:function(date) {
    var year = date.getFullYear();
    return !!((year & 3) === 0 && (year % 100 || year % 400 === 0 && year));
  }, getFirstDayOfMonth:function(date) {
    var day = (date.getDay() - (date.getDate() - 1)) % 7;
    return day < 0 ? day + 7 : day;
  }, getLastDayOfMonth:function(date) {
    return utilDate.getLastDateOfMonth(date).getDay();
  }, getFirstDateOfMonth:function(date) {
    return new nativeDate(date.getFullYear(), date.getMonth(), 1);
  }, getLastDateOfMonth:function(date) {
    return new nativeDate(date.getFullYear(), date.getMonth(), utilDate.getDaysInMonth(date));
  }, getDaysInMonth:function() {
    var daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    return function(date) {
      var m = date.getMonth();
      return m === 1 && utilDate.isLeapYear(date) ? 29 : daysInMonth[m];
    };
  }(), getSuffix:function(date) {
    switch(date.getDate()) {
      case 1:
      case 21:
      case 31:
        return 'st';
      case 2:
      case 22:
        return 'nd';
      case 3:
      case 23:
        return 'rd';
      default:
        return 'th';
    }
  }, clone:function(date) {
    return new nativeDate(date.getTime());
  }, isDST:function(date) {
    return (new nativeDate(date.getFullYear(), 0, 1)).getTimezoneOffset() !== date.getTimezoneOffset();
  }, clearTime:function(date, clone) {
    if (isNaN(date.getTime())) {
      return date;
    }
    if (clone) {
      return utilDate.clearTime(utilDate.clone(date));
    }
    var d = date.getDate(), hr, c;
    date.setHours(0);
    date.setMinutes(0);
    date.setSeconds(0);
    date.setMilliseconds(0);
    if (date.getDate() !== d) {
      for (hr = 1, c = utilDate.add(date, utilDate.HOUR, hr); c.getDate() !== d; hr++, c = utilDate.add(date, utilDate.HOUR, hr)) {
      }
      date.setDate(d);
      date.setHours(c.getHours());
    }
    return date;
  }, add:function(date, interval, value) {
    var d = utilDate.clone(date), day, decimalValue, base = 0;
    if (!interval || value === 0) {
      return d;
    }
    decimalValue = value - parseInt(value, 10);
    value = parseInt(value, 10);
    if (value) {
      switch(interval.toLowerCase()) {
        case utilDate.MILLI:
          d.setTime(d.getTime() + value);
          break;
        case utilDate.SECOND:
          d.setTime(d.getTime() + value * 1000);
          break;
        case utilDate.MINUTE:
          d.setTime(d.getTime() + value * 60 * 1000);
          break;
        case utilDate.HOUR:
          d.setTime(d.getTime() + value * 60 * 60 * 1000);
          break;
        case utilDate.DAY:
          d.setDate(d.getDate() + value);
          break;
        case utilDate.MONTH:
          day = date.getDate();
          if (day > 28) {
            day = Math.min(day, utilDate.getLastDateOfMonth(utilDate.add(utilDate.getFirstDateOfMonth(date), utilDate.MONTH, value)).getDate());
          }
          d.setDate(day);
          d.setMonth(date.getMonth() + value);
          break;
        case utilDate.YEAR:
          day = date.getDate();
          if (day > 28) {
            day = Math.min(day, utilDate.getLastDateOfMonth(utilDate.add(utilDate.getFirstDateOfMonth(date), utilDate.YEAR, value)).getDate());
          }
          d.setDate(day);
          d.setFullYear(date.getFullYear() + value);
          break;
      }
    }
    if (decimalValue) {
      switch(interval.toLowerCase()) {
        case utilDate.MILLI:
          base = 1;
          break;
        case utilDate.SECOND:
          base = 1000;
          break;
        case utilDate.MINUTE:
          base = 1000 * 60;
          break;
        case utilDate.HOUR:
          base = 1000 * 60 * 60;
          break;
        case utilDate.DAY:
          base = 1000 * 60 * 60 * 24;
          break;
        case utilDate.MONTH:
          day = utilDate.getDaysInMonth(d);
          base = 1000 * 60 * 60 * 24 * day;
          break;
        case utilDate.YEAR:
          day = utilDate.isLeapYear(d) ? 366 : 365;
          base = 1000 * 60 * 60 * 24 * day;
          break;
      }
      if (base) {
        d.setTime(d.getTime() + base * decimalValue);
      }
    }
    return d;
  }, subtract:function(date, interval, value) {
    return utilDate.add(date, interval, -value);
  }, between:function(date, start, end) {
    var t = date.getTime();
    return start.getTime() <= t && t <= end.getTime();
  }, compat:function() {
    var p, statics = ['useStrict', 'formatCodeToRegex', 'parseFunctions', 'parseRegexes', 'formatFunctions', 'y2kYear', 'MILLI', 'SECOND', 'MINUTE', 'HOUR', 'DAY', 'MONTH', 'YEAR', 'defaults', 'dayNames', 'monthNames', 'monthNumbers', 'getShortMonthName', 'getShortDayName', 'getMonthNumber', 'formatCodes', 'isValid', 'parseDate', 'getFormatCode', 'createFormat', 'createParser', 'parseCodes'], proto = ['dateFormat', 'format', 'getTimezone', 'getGMTOffset', 'getDayOfYear', 'getWeekOfYear', 'isLeapYear', 
    'getFirstDayOfMonth', 'getLastDayOfMonth', 'getDaysInMonth', 'getSuffix', 'clone', 'isDST', 'clearTime', 'add', 'between'], sLen = statics.length, pLen = proto.length, stat, prot, s;
    for (s = 0; s < sLen; s++) {
      stat = statics[s];
      nativeDate[stat] = utilDate[stat];
    }
    for (p = 0; p < pLen; p++) {
      prot = proto[p];
      nativeDate.prototype[prot] = function() {
        var args = Array.prototype.slice.call(arguments);
        args.unshift(this);
        return utilDate[prot].apply(utilDate, args);
      };
    }
  }, diff:function(min, max, unit) {
    var est, diff = +max - min;
    switch(unit) {
      case utilDate.MILLI:
        return diff;
      case utilDate.SECOND:
        return Math.floor(diff / 1000);
      case utilDate.MINUTE:
        return Math.floor(diff / 60000);
      case utilDate.HOUR:
        return Math.floor(diff / 3600000);
      case utilDate.DAY:
        return Math.floor(diff / 86400000);
      case 'w':
        return Math.floor(diff / 604800000);
      case utilDate.MONTH:
        est = max.getFullYear() * 12 + max.getMonth() - (min.getFullYear() * 12 + min.getMonth());
        if (utilDate.add(min, unit, est) > max) {
          return est - 1;
        }
        return est;
      case utilDate.YEAR:
        est = max.getFullYear() - min.getFullYear();
        if (utilDate.add(min, unit, est) > max) {
          return est - 1;
        } else {
          return est;
        }
    }
  }, align:function(date, unit, step) {
    var num = new nativeDate(+date);
    switch(unit.toLowerCase()) {
      case utilDate.MILLI:
        return num;
      case utilDate.SECOND:
        num.setUTCSeconds(num.getUTCSeconds() - num.getUTCSeconds() % step);
        num.setUTCMilliseconds(0);
        return num;
      case utilDate.MINUTE:
        num.setUTCMinutes(num.getUTCMinutes() - num.getUTCMinutes() % step);
        num.setUTCSeconds(0);
        num.setUTCMilliseconds(0);
        return num;
      case utilDate.HOUR:
        num.setUTCHours(num.getUTCHours() - num.getUTCHours() % step);
        num.setUTCMinutes(0);
        num.setUTCSeconds(0);
        num.setUTCMilliseconds(0);
        return num;
      case utilDate.DAY:
        if (step === 7 || step === 14) {
          num.setUTCDate(num.getUTCDate() - num.getUTCDay() + 1);
        }
        num.setUTCHours(0);
        num.setUTCMinutes(0);
        num.setUTCSeconds(0);
        num.setUTCMilliseconds(0);
        return num;
      case utilDate.MONTH:
        num.setUTCMonth(num.getUTCMonth() - (num.getUTCMonth() - 1) % step, 1);
        num.setUTCHours(0);
        num.setUTCMinutes(0);
        num.setUTCSeconds(0);
        num.setUTCMilliseconds(0);
        return num;
      case utilDate.YEAR:
        num.setUTCFullYear(num.getUTCFullYear() - num.getUTCFullYear() % step, 1, 1);
        num.setUTCHours(0);
        num.setUTCMinutes(0);
        num.setUTCSeconds(0);
        num.setUTCMilliseconds(0);
        return date;
    }
  }};
}();
Ext.Function = function() {
  var lastTime = 0, animFrameId, animFrameHandlers = [], animFrameNoArgs = [], idSource = 0, animFrameMap = {}, win = window, global = Ext.global, hasImmediate = !!(global.setImmediate && global.clearImmediate), requestAnimFrame = win.requestAnimationFrame || win.webkitRequestAnimationFrame || win.mozRequestAnimationFrame || win.oRequestAnimationFrame || function(callback) {
    var currTime = Ext.now(), timeToCall = Math.max(0, 16 - (currTime - lastTime)), id = win.setTimeout(function() {
      callback(currTime + timeToCall);
    }, timeToCall);
    lastTime = currTime + timeToCall;
    return id;
  }, fireHandlers = function() {
    var len = animFrameHandlers.length, id, i, handler;
    animFrameId = null;
    for (i = 0; i < len; i++) {
      handler = animFrameHandlers[i];
      id = handler[3];
      if (animFrameMap[id]) {
        handler[0].apply(handler[1] || global, handler[2] || animFrameNoArgs);
        delete animFrameMap[id];
      }
    }
    animFrameHandlers = animFrameHandlers.slice(len);
  }, fireElevatedHandlers = function() {
    Ext.elevateFunction(fireHandlers);
  }, ExtFunction = {flexSetter:function(setter) {
    return function(name, value) {
      var k, i;
      if (name !== null) {
        if (typeof name !== 'string') {
          for (k in name) {
            if (name.hasOwnProperty(k)) {
              setter.call(this, k, name[k]);
            }
          }
          if (Ext.enumerables) {
            for (i = Ext.enumerables.length; i--;) {
              k = Ext.enumerables[i];
              if (name.hasOwnProperty(k)) {
                setter.call(this, k, name[k]);
              }
            }
          }
        } else {
          setter.call(this, name, value);
        }
      }
      return this;
    };
  }, bind:function(fn, scope, args, appendArgs) {
    if (arguments.length === 2) {
      return function() {
        return fn.apply(scope, arguments);
      };
    }
    var method = fn, slice = Array.prototype.slice;
    return function() {
      var callArgs = args || arguments;
      if (appendArgs === true) {
        callArgs = slice.call(arguments, 0);
        callArgs = callArgs.concat(args);
      } else {
        if (typeof appendArgs === 'number') {
          callArgs = slice.call(arguments, 0);
          Ext.Array.insert(callArgs, appendArgs, args);
        }
      }
      return method.apply(scope || global, callArgs);
    };
  }, bindCallback:function(callback, scope, args, delay, caller) {
    return function() {
      var a = Ext.Array.slice(arguments);
      return Ext.callback(callback, scope, args ? args.concat(a) : a, delay, caller);
    };
  }, pass:function(fn, args, scope) {
    if (!Ext.isArray(args)) {
      if (Ext.isIterable(args)) {
        args = Ext.Array.clone(args);
      } else {
        args = args !== undefined ? [args] : [];
      }
    }
    return function() {
      var fnArgs = args.slice();
      fnArgs.push.apply(fnArgs, arguments);
      return fn.apply(scope || this, fnArgs);
    };
  }, alias:function(object, methodName) {
    return function() {
      return object[methodName].apply(object, arguments);
    };
  }, clone:function(method) {
    return function() {
      return method.apply(this, arguments);
    };
  }, createInterceptor:function(origFn, newFn, scope, returnValue) {
    if (!Ext.isFunction(newFn)) {
      return origFn;
    } else {
      returnValue = Ext.isDefined(returnValue) ? returnValue : null;
      return function() {
        var me = this, args = arguments;
        return newFn.apply(scope || me || global, args) !== false ? origFn.apply(me || global, args) : returnValue;
      };
    }
  }, createDelayed:function(fn, delay, scope, args, appendArgs) {
    if (scope || args) {
      fn = Ext.Function.bind(fn, scope, args, appendArgs);
    }
    return function() {
      var me = this, args = Array.prototype.slice.call(arguments);
      setTimeout(function() {
        if (Ext.elevateFunction) {
          Ext.elevateFunction(fn, me, args);
        } else {
          fn.apply(me, args);
        }
      }, delay);
    };
  }, defer:function(fn, millis, scope, args, appendArgs) {
    fn = Ext.Function.bind(fn, scope, args, appendArgs);
    if (millis > 0) {
      return setTimeout(function() {
        if (Ext.elevateFunction) {
          Ext.elevateFunction(fn);
        } else {
          fn();
        }
      }, millis);
    }
    fn();
    return 0;
  }, interval:function(fn, millis, scope, args, appendArgs) {
    fn = Ext.Function.bind(fn, scope, args, appendArgs);
    return setInterval(function() {
      if (Ext.elevateFunction) {
        Ext.elevateFunction(fn);
      } else {
        fn();
      }
    }, millis);
  }, createSequence:function(originalFn, newFn, scope) {
    if (!newFn) {
      return originalFn;
    } else {
      return function() {
        var result = originalFn.apply(this, arguments);
        newFn.apply(scope || this, arguments);
        return result;
      };
    }
  }, createBuffered:function(fn, buffer, scope, args) {
    var timerId;
    return function() {
      var callArgs = args || Array.prototype.slice.call(arguments, 0), me = scope || this;
      if (timerId) {
        clearTimeout(timerId);
      }
      timerId = setTimeout(function() {
        if (Ext.elevateFunction) {
          Ext.elevateFunction(fn, me, callArgs);
        } else {
          fn.apply(me, callArgs);
        }
      }, buffer);
    };
  }, createAnimationFrame:function(fn, scope, args, queueStrategy) {
    var timerId;
    queueStrategy = queueStrategy || 3;
    return function() {
      var callArgs = args || Array.prototype.slice.call(arguments, 0);
      scope = scope || this;
      if (queueStrategy === 3 && timerId) {
        ExtFunction.cancelAnimationFrame(timerId);
      }
      if (queueStrategy & 1 || !timerId) {
        timerId = ExtFunction.requestAnimationFrame(function() {
          timerId = null;
          fn.apply(scope, callArgs);
        });
      }
    };
  }, requestAnimationFrame:function(fn, scope, args) {
    var id = ++idSource, handler = Array.prototype.slice.call(arguments, 0);
    handler[3] = id;
    animFrameMap[id] = 1;
    animFrameHandlers.push(handler);
    if (!animFrameId) {
      animFrameId = requestAnimFrame(Ext.elevateFunction ? fireElevatedHandlers : fireHandlers);
    }
    return id;
  }, cancelAnimationFrame:function(id) {
    delete animFrameMap[id];
  }, createThrottled:function(fn, interval, scope) {
    var lastCallTime = 0, elapsed, lastArgs, timer, execute = function() {
      if (Ext.elevateFunction) {
        Ext.elevateFunction(fn, scope, lastArgs);
      } else {
        fn.apply(scope, lastArgs);
      }
      lastCallTime = Ext.now();
      timer = null;
    };
    return function() {
      if (!scope) {
        scope = this;
      }
      elapsed = Ext.now() - lastCallTime;
      lastArgs = arguments;
      if (elapsed >= interval) {
        clearTimeout(timer);
        execute();
      } else {
        if (!timer) {
          timer = Ext.defer(execute, interval - elapsed);
        }
      }
    };
  }, createBarrier:function(count, fn, scope) {
    return function() {
      if (!--count) {
        fn.apply(scope, arguments);
      }
    };
  }, interceptBefore:function(object, methodName, fn, scope) {
    var method = object[methodName] || Ext.emptyFn;
    return object[methodName] = function() {
      var ret = fn.apply(scope || this, arguments);
      method.apply(this, arguments);
      return ret;
    };
  }, interceptAfter:function(object, methodName, fn, scope) {
    var method = object[methodName] || Ext.emptyFn;
    return object[methodName] = function() {
      method.apply(this, arguments);
      return fn.apply(scope || this, arguments);
    };
  }, makeCallback:function(callback, scope) {
    if (!scope[callback]) {
      if (scope.$className) {
        Ext.raise('No method "' + callback + '" on ' + scope.$className);
      }
      Ext.raise('No method "' + callback + '"');
    }
    return function() {
      return scope[callback].apply(scope, arguments);
    };
  }, memoize:function(fn, scope, hashFn) {
    var memo = {}, isFunc = hashFn && Ext.isFunction(hashFn);
    return function(value) {
      var key = isFunc ? hashFn.apply(scope, arguments) : value;
      if (!(key in memo)) {
        memo[key] = fn.apply(scope, arguments);
      }
      return memo[key];
    };
  }};
  Ext.asap = hasImmediate ? function(fn, scope, parameters) {
    if (scope != null || parameters != null) {
      fn = ExtFunction.bind(fn, scope, parameters);
    }
    return setImmediate(function() {
      if (Ext.elevateFunction) {
        Ext.elevateFunction(fn);
      } else {
        fn();
      }
    });
  } : function(fn, scope, parameters) {
    if (scope != null || parameters != null) {
      fn = ExtFunction.bind(fn, scope, parameters);
    }
    return setTimeout(function() {
      if (Ext.elevateFunction) {
        Ext.elevateFunction(fn);
      } else {
        fn();
      }
    }, 0, true);
  }, Ext.asapCancel = hasImmediate ? function(id) {
    clearImmediate(id);
  } : function(id) {
    clearTimeout(id);
  };
  Ext.defer = ExtFunction.defer;
  Ext.interval = ExtFunction.interval;
  Ext.pass = ExtFunction.pass;
  Ext.bind = ExtFunction.bind;
  Ext.deferCallback = ExtFunction.requestAnimationFrame;
  return ExtFunction;
}();
Ext.Number = new function() {
  var ExtNumber = this, isToFixedBroken = (0.9).toFixed() !== '1', math = Math, ClipDefault = {count:false, inclusive:false, wrap:true};
  Ext.apply(ExtNumber, {Clip:{DEFAULT:ClipDefault, COUNT:Ext.applyIf({count:true}, ClipDefault), INCLUSIVE:Ext.applyIf({inclusive:true}, ClipDefault), NOWRAP:Ext.applyIf({wrap:false}, ClipDefault)}, clipIndices:function(length, indices, options) {
    options = options || ClipDefault;
    var defaultValue = 0, wrap = options.wrap, begin, end, i;
    indices = indices || [];
    for (i = 0; i < 2; ++i) {
      begin = end;
      end = indices[i];
      if (end == null) {
        end = defaultValue;
      } else {
        if (i && options.count) {
          end += begin;
          end = end > length ? length : end;
        } else {
          if (wrap) {
            end = end < 0 ? length + end : end;
          }
          if (i && options.inclusive) {
            ++end;
          }
          end = end < 0 ? 0 : end > length ? length : end;
        }
      }
      defaultValue = length;
    }
    indices[0] = begin;
    indices[1] = end < begin ? begin : end;
    return indices;
  }, constrain:function(number, min, max) {
    var x = parseFloat(number);
    if (min === null) {
      min = number;
    }
    if (max === null) {
      max = number;
    }
    return x < min ? min : x > max ? max : x;
  }, snap:function(value, increment, minValue, maxValue) {
    var m;
    if (value === undefined || value < minValue) {
      return minValue || 0;
    }
    if (increment) {
      m = value % increment;
      if (m !== 0) {
        value -= m;
        if (m * 2 >= increment) {
          value += increment;
        } else {
          if (m * 2 < -increment) {
            value -= increment;
          }
        }
      }
    }
    return ExtNumber.constrain(value, minValue, maxValue);
  }, snapInRange:function(value, increment, minValue, maxValue) {
    var tween;
    minValue = minValue || 0;
    if (value === undefined || value < minValue) {
      return minValue;
    }
    if (increment && (tween = (value - minValue) % increment)) {
      value -= tween;
      tween *= 2;
      if (tween >= increment) {
        value += increment;
      }
    }
    if (maxValue !== undefined) {
      if (value > (maxValue = ExtNumber.snapInRange(maxValue, increment, minValue))) {
        value = maxValue;
      }
    }
    return value;
  }, sign:function(x) {
    x = +x;
    if (x === 0 || isNaN(x)) {
      return x;
    }
    return x > 0 ? 1 : -1;
  }, toFixed:isToFixedBroken ? function(value, precision) {
    precision = precision || 0;
    var pow = math.pow(10, precision);
    return (math.round(value * pow) / pow).toFixed(precision);
  } : function(value, precision) {
    return value.toFixed(precision);
  }, from:function(value, defaultValue) {
    if (isFinite(value)) {
      value = parseFloat(value);
    }
    return !isNaN(value) ? value : defaultValue;
  }, randomInt:function(from, to) {
    return math.floor(math.random() * (to - from + 1) + from);
  }, correctFloat:function(n) {
    return parseFloat(n.toPrecision(14));
  }});
  Ext.num = function() {
    return ExtNumber.from.apply(this, arguments);
  };
};
(function() {
  var TemplateClass = function() {
  }, queryRe = /^\?/, keyRe = /(\[):?([^\]]*)\]/g, nameRe = /^([^\[]+)/, plusRe = /\+/g, ExtObject = Ext.Object = {chain:Object.create || function(object) {
    TemplateClass.prototype = object;
    var result = new TemplateClass;
    TemplateClass.prototype = null;
    return result;
  }, clear:function(object) {
    for (var key in object) {
      delete object[key];
    }
    return object;
  }, freeze:Object.freeze ? function(obj, deep) {
    if (obj && typeof obj === 'object' && !Object.isFrozen(obj)) {
      Object.freeze(obj);
      if (deep) {
        for (var name in obj) {
          ExtObject.freeze(obj[name], deep);
        }
      }
    }
    return obj;
  } : Ext.identityFn, toQueryObjects:function(name, value, recursive) {
    var self = ExtObject.toQueryObjects, objects = [], i, ln;
    if (Ext.isArray(value)) {
      for (i = 0, ln = value.length; i < ln; i++) {
        if (recursive) {
          objects = objects.concat(self(name + '[' + i + ']', value[i], true));
        } else {
          objects.push({name:name, value:value[i]});
        }
      }
    } else {
      if (Ext.isObject(value)) {
        for (i in value) {
          if (value.hasOwnProperty(i)) {
            if (recursive) {
              objects = objects.concat(self(name + '[' + i + ']', value[i], true));
            } else {
              objects.push({name:name, value:value[i]});
            }
          }
        }
      } else {
        objects.push({name:name, value:value});
      }
    }
    return objects;
  }, toQueryString:function(object, recursive) {
    var paramObjects = [], params = [], i, j, ln, paramObject, value;
    for (i in object) {
      if (object.hasOwnProperty(i)) {
        paramObjects = paramObjects.concat(ExtObject.toQueryObjects(i, object[i], recursive));
      }
    }
    for (j = 0, ln = paramObjects.length; j < ln; j++) {
      paramObject = paramObjects[j];
      value = paramObject.value;
      if (Ext.isEmpty(value)) {
        value = '';
      } else {
        if (Ext.isDate(value)) {
          value = Ext.Date.toString(value);
        }
      }
      params.push(encodeURIComponent(paramObject.name) + '\x3d' + encodeURIComponent(String(value)));
    }
    return params.join('\x26');
  }, fromQueryString:function(queryString, recursive) {
    var parts = queryString.replace(queryRe, '').split('\x26'), object = {}, temp, components, name, value, i, ln, part, j, subLn, matchedKeys, matchedName, keys, key, nextKey;
    for (i = 0, ln = parts.length; i < ln; i++) {
      part = parts[i];
      if (part.length > 0) {
        components = part.split('\x3d');
        name = components[0];
        name = name.replace(plusRe, '%20');
        name = decodeURIComponent(name);
        value = components[1];
        if (value !== undefined) {
          value = value.replace(plusRe, '%20');
          value = decodeURIComponent(value);
        } else {
          value = '';
        }
        if (!recursive) {
          if (object.hasOwnProperty(name)) {
            if (!Ext.isArray(object[name])) {
              object[name] = [object[name]];
            }
            object[name].push(value);
          } else {
            object[name] = value;
          }
        } else {
          matchedKeys = name.match(keyRe);
          matchedName = name.match(nameRe);
          if (!matchedName) {
            throw new Error('[Ext.Object.fromQueryString] Malformed query string given, failed parsing name from "' + part + '"');
          }
          name = matchedName[0];
          keys = [];
          if (matchedKeys === null) {
            object[name] = value;
            continue;
          }
          for (j = 0, subLn = matchedKeys.length; j < subLn; j++) {
            key = matchedKeys[j];
            key = key.length === 2 ? '' : key.substring(1, key.length - 1);
            keys.push(key);
          }
          keys.unshift(name);
          temp = object;
          for (j = 0, subLn = keys.length; j < subLn; j++) {
            key = keys[j];
            if (j === subLn - 1) {
              if (Ext.isArray(temp) && key === '') {
                temp.push(value);
              } else {
                temp[key] = value;
              }
            } else {
              if (temp[key] === undefined || typeof temp[key] === 'string') {
                nextKey = keys[j + 1];
                temp[key] = Ext.isNumeric(nextKey) || nextKey === '' ? [] : {};
              }
              temp = temp[key];
            }
          }
        }
      }
    }
    return object;
  }, each:function(object, fn, scope) {
    var enumerables = Ext.enumerables, i, property;
    if (object) {
      scope = scope || object;
      for (property in object) {
        if (object.hasOwnProperty(property)) {
          if (fn.call(scope, property, object[property], object) === false) {
            return;
          }
        }
      }
      if (enumerables) {
        for (i = enumerables.length; i--;) {
          if (object.hasOwnProperty(property = enumerables[i])) {
            if (fn.call(scope, property, object[property], object) === false) {
              return;
            }
          }
        }
      }
    }
  }, eachValue:function(object, fn, scope) {
    var enumerables = Ext.enumerables, i, property;
    scope = scope || object;
    for (property in object) {
      if (object.hasOwnProperty(property)) {
        if (fn.call(scope, object[property]) === false) {
          return;
        }
      }
    }
    if (enumerables) {
      for (i = enumerables.length; i--;) {
        if (object.hasOwnProperty(property = enumerables[i])) {
          if (fn.call(scope, object[property]) === false) {
            return;
          }
        }
      }
    }
  }, merge:function(destination) {
    var i = 1, ln = arguments.length, mergeFn = ExtObject.merge, cloneFn = Ext.clone, object, key, value, sourceKey;
    for (; i < ln; i++) {
      object = arguments[i];
      for (key in object) {
        value = object[key];
        if (value && value.constructor === Object) {
          sourceKey = destination[key];
          if (sourceKey && sourceKey.constructor === Object) {
            mergeFn(sourceKey, value);
          } else {
            destination[key] = cloneFn(value);
          }
        } else {
          destination[key] = value;
        }
      }
    }
    return destination;
  }, mergeIf:function(destination) {
    var i = 1, ln = arguments.length, cloneFn = Ext.clone, object, key, value;
    for (; i < ln; i++) {
      object = arguments[i];
      for (key in object) {
        if (!(key in destination)) {
          value = object[key];
          if (value && value.constructor === Object) {
            destination[key] = cloneFn(value);
          } else {
            destination[key] = value;
          }
        }
      }
    }
    return destination;
  }, getAllKeys:function(object) {
    var keys = [], property;
    for (property in object) {
      keys.push(property);
    }
    return keys;
  }, getKey:function(object, value) {
    for (var property in object) {
      if (object.hasOwnProperty(property) && object[property] === value) {
        return property;
      }
    }
    return null;
  }, getValues:function(object) {
    var values = [], property;
    for (property in object) {
      if (object.hasOwnProperty(property)) {
        values.push(object[property]);
      }
    }
    return values;
  }, getKeys:typeof Object.keys == 'function' ? function(object) {
    if (!object) {
      return [];
    }
    return Object.keys(object);
  } : function(object) {
    var keys = [], property;
    for (property in object) {
      if (object.hasOwnProperty(property)) {
        keys.push(property);
      }
    }
    return keys;
  }, getSize:function(object) {
    var size = 0, property;
    for (property in object) {
      if (object.hasOwnProperty(property)) {
        size++;
      }
    }
    return size;
  }, isEmpty:function(object) {
    for (var key in object) {
      if (object.hasOwnProperty(key)) {
        return false;
      }
    }
    return true;
  }, equals:function() {
    var check = function(o1, o2) {
      var key;
      for (key in o1) {
        if (o1.hasOwnProperty(key)) {
          if (o1[key] !== o2[key]) {
            return false;
          }
        }
      }
      return true;
    };
    return function(object1, object2) {
      if (object1 === object2) {
        return true;
      }
      if (object1 && object2) {
        return check(object1, object2) && check(object2, object1);
      } else {
        if (!object1 && !object2) {
          return object1 === object2;
        } else {
          return false;
        }
      }
    };
  }(), fork:function(obj) {
    var ret, key, value;
    if (obj && obj.constructor === Object) {
      ret = ExtObject.chain(obj);
      for (key in obj) {
        value = obj[key];
        if (value) {
          if (value.constructor === Object) {
            ret[key] = ExtObject.fork(value);
          } else {
            if (value instanceof Array) {
              ret[key] = Ext.Array.clone(value);
            }
          }
        }
      }
    } else {
      ret = obj;
    }
    return ret;
  }, defineProperty:'defineProperty' in Object ? Object.defineProperty : function(object, name, descriptor) {
    if (!Object.prototype.__defineGetter__) {
      return;
    }
    if (descriptor.get) {
      object.__defineGetter__(name, descriptor.get);
    }
    if (descriptor.set) {
      object.__defineSetter__(name, descriptor.set);
    }
  }, classify:function(object) {
    var prototype = object, objectProperties = [], propertyClassesMap = {}, objectClass = function() {
      var i = 0, ln = objectProperties.length, property;
      for (; i < ln; i++) {
        property = objectProperties[i];
        this[property] = new propertyClassesMap[property];
      }
    }, key, value;
    for (key in object) {
      if (object.hasOwnProperty(key)) {
        value = object[key];
        if (value && value.constructor === Object) {
          objectProperties.push(key);
          propertyClassesMap[key] = ExtObject.classify(value);
        }
      }
    }
    objectClass.prototype = prototype;
    return objectClass;
  }};
  Ext.merge = Ext.Object.merge;
  Ext.mergeIf = Ext.Object.mergeIf;
})();
Ext.apply(Ext, {_namedScopes:{'this':{isThis:1}, controller:{isController:1}, self:{isSelf:1}, 'self.controller':{isSelf:1, isController:1}}, escapeId:function() {
  var validIdRe = /^[a-zA-Z_][a-zA-Z0-9_\-]*$/i, escapeRx = /([\W]{1})/g, leadingNumRx = /^(\d)/g, escapeFn = function(match, capture) {
    return '\\' + capture;
  }, numEscapeFn = function(match, capture) {
    return '\\00' + capture.charCodeAt(0).toString(16) + ' ';
  };
  return function(id) {
    return validIdRe.test(id) ? id : id.replace(escapeRx, escapeFn).replace(leadingNumRx, numEscapeFn);
  };
}(), callback:function(callback, scope, args, delay, caller, defaultScope) {
  if (!callback) {
    return;
  }
  var namedScope = scope in Ext._namedScopes;
  if (callback.charAt) {
    if ((!scope || namedScope) && caller) {
      scope = caller.resolveListenerScope(namedScope ? scope : defaultScope);
    }
    if (!scope || !Ext.isObject(scope)) {
      Ext.raise('Named method "' + callback + '" requires a scope object');
    }
    if (!Ext.isFunction(scope[callback])) {
      Ext.raise('No method named "' + callback + '" on ' + (scope.$className || 'scope object'));
    }
    callback = scope[callback];
  } else {
    if (namedScope) {
      scope = defaultScope || caller;
    } else {
      if (!scope) {
        scope = caller;
      }
    }
  }
  var ret;
  if (callback && Ext.isFunction(callback)) {
    scope = scope || Ext.global;
    if (delay) {
      Ext.defer(callback, delay, scope, args);
    } else {
      if (Ext.elevateFunction) {
        ret = Ext.elevateFunction(callback, scope, args);
      } else {
        if (args) {
          ret = callback.apply(scope, args);
        } else {
          ret = callback.call(scope);
        }
      }
    }
  }
  return ret;
}, coerce:function(from, to) {
  var fromType = Ext.typeOf(from), toType = Ext.typeOf(to), isString = typeof from === 'string';
  if (fromType !== toType) {
    switch(toType) {
      case 'string':
        return String(from);
      case 'number':
        return Number(from);
      case 'boolean':
        return isString && (!from || from === 'false') ? false : Boolean(from);
      case 'null':
        return isString && (!from || from === 'null') ? null : from;
      case 'undefined':
        return isString && (!from || from === 'undefined') ? undefined : from;
      case 'date':
        return isString && isNaN(from) ? Ext.Date.parse(from, Ext.Date.defaultFormat) : Date(Number(from));
    }
  }
  return from;
}, copyTo:function(dest, source, names, usePrototypeKeys) {
  if (typeof names === 'string') {
    names = names.split(Ext.propertyNameSplitRe);
  }
  for (var name, i = 0, n = names ? names.length : 0; i < n; i++) {
    name = names[i];
    if (usePrototypeKeys || source.hasOwnProperty(name)) {
      dest[name] = source[name];
    }
  }
  return dest;
}, copy:function(dest, source, names, usePrototypeKeys) {
  if (typeof names === 'string') {
    names = names.split(Ext.propertyNameSplitRe);
  }
  for (var name, i = 0, n = names ? names.length : 0; i < n; i++) {
    name = names[i];
    if (source.hasOwnProperty(name) || usePrototypeKeys && name in source) {
      dest[name] = source[name];
    }
  }
  return dest;
}, propertyNameSplitRe:/[,;\s]+/, copyToIf:function(destination, source, names) {
  if (typeof names === 'string') {
    names = names.split(Ext.propertyNameSplitRe);
  }
  for (var name, i = 0, n = names ? names.length : 0; i < n; i++) {
    name = names[i];
    if (destination[name] === undefined) {
      destination[name] = source[name];
    }
  }
  return destination;
}, copyIf:function(destination, source, names) {
  if (typeof names === 'string') {
    names = names.split(Ext.propertyNameSplitRe);
  }
  for (var name, i = 0, n = names ? names.length : 0; i < n; i++) {
    name = names[i];
    if (!(name in destination) && name in source) {
      destination[name] = source[name];
    }
  }
  return destination;
}, extend:function() {
  var objectConstructor = Object.prototype.constructor, inlineOverrides = function(o) {
    for (var m in o) {
      if (!o.hasOwnProperty(m)) {
        continue;
      }
      this[m] = o[m];
    }
  };
  return function(subclass, superclass, overrides) {
    if (Ext.isObject(superclass)) {
      overrides = superclass;
      superclass = subclass;
      subclass = overrides.constructor !== objectConstructor ? overrides.constructor : function() {
        superclass.apply(this, arguments);
      };
    }
    if (!superclass) {
      Ext.raise({sourceClass:'Ext', sourceMethod:'extend', msg:'Attempting to extend from a class which has not been loaded on the page.'});
    }
    var F = function() {
    }, subclassProto, superclassProto = superclass.prototype;
    F.prototype = superclassProto;
    subclassProto = subclass.prototype = new F;
    subclassProto.constructor = subclass;
    subclass.superclass = superclassProto;
    if (superclassProto.constructor === objectConstructor) {
      superclassProto.constructor = superclass;
    }
    subclass.override = function(overrides) {
      Ext.override(subclass, overrides);
    };
    subclassProto.override = inlineOverrides;
    subclassProto.proto = subclassProto;
    subclass.override(overrides);
    subclass.extend = function(o) {
      return Ext.extend(subclass, o);
    };
    return subclass;
  };
}(), iterate:function(object, fn, scope) {
  if (Ext.isEmpty(object)) {
    return;
  }
  if (scope === undefined) {
    scope = object;
  }
  if (Ext.isIterable(object)) {
    Ext.Array.each.call(Ext.Array, object, fn, scope);
  } else {
    Ext.Object.each.call(Ext.Object, object, fn, scope);
  }
}, _resourcePoolRe:/^[<]([^<>@:]*)(?:[@]([^<>@:]+))?[>](.+)$/, resolveResource:function(url) {
  var ret = url, m;
  if (url && url.charAt(0) === '\x3c') {
    m = Ext._resourcePoolRe.exec(url);
    if (m) {
      ret = Ext.getResourcePath(m[3], m[1], m[2]);
    }
  }
  return ret;
}, urlEncode:function() {
  var args = Ext.Array.from(arguments), prefix = '';
  if (Ext.isString(args[1])) {
    prefix = args[1] + '\x26';
    args[1] = false;
  }
  return prefix + Ext.Object.toQueryString.apply(Ext.Object, args);
}, urlDecode:function() {
  return Ext.Object.fromQueryString.apply(Ext.Object, arguments);
}, getScrollbarSize:function(force) {
  if (!Ext.isDomReady) {
    Ext.raise('getScrollbarSize called before DomReady');
  }
  var scrollbarSize = Ext._scrollbarSize;
  if (force || !scrollbarSize) {
    var db = document.body, div = document.createElement('div');
    div.style.width = div.style.height = '100px';
    div.style.overflow = 'scroll';
    div.style.position = 'absolute';
    db.appendChild(div);
    Ext._scrollbarSize = scrollbarSize = {width:div.offsetWidth - div.clientWidth, height:div.offsetHeight - div.clientHeight};
    db.removeChild(div);
  }
  return scrollbarSize;
}, typeOf:function() {
  var nonWhitespaceRe = /\S/, toString = Object.prototype.toString, typeofTypes = {number:1, string:1, 'boolean':1, 'undefined':1}, toStringTypes = {'[object Array]':'array', '[object Date]':'date', '[object Boolean]':'boolean', '[object Number]':'number', '[object RegExp]':'regexp'};
  return function(value) {
    if (value === null) {
      return 'null';
    }
    var type = typeof value, ret, typeToString;
    if (typeofTypes[type]) {
      return type;
    }
    ret = toStringTypes[typeToString = toString.call(value)];
    if (ret) {
      return ret;
    }
    if (type === 'function') {
      return 'function';
    }
    if (type === 'object') {
      if (value.nodeType !== undefined) {
        if (value.nodeType === 3) {
          return nonWhitespaceRe.test(value.nodeValue) ? 'textnode' : 'whitespace';
        } else {
          return 'element';
        }
      }
      return 'object';
    }
    Ext.raise({sourceClass:'Ext', sourceMethod:'typeOf', msg:'Failed to determine the type of "' + value + '".'});
    return typeToString;
  };
}(), factory:function(config, classReference, instance, aliasNamespace) {
  var manager = Ext.ClassManager, newInstance;
  if (!config || config.isInstance) {
    if (instance && instance !== config) {
      instance.destroy();
    }
    return config;
  }
  if (aliasNamespace) {
    if (typeof config === 'string') {
      return manager.instantiateByAlias(aliasNamespace + '.' + config);
    } else {
      if (Ext.isObject(config) && 'type' in config) {
        return manager.instantiateByAlias(aliasNamespace + '.' + config.type, config);
      }
    }
  }
  if (config === true) {
    if (!instance && !classReference) {
      Ext.raise('[Ext.factory] Cannot determine type of class to create');
    }
    return instance || Ext.create(classReference);
  }
  if (!Ext.isObject(config)) {
    Ext.raise('Invalid config, must be a valid config object');
  }
  if ('xtype' in config) {
    newInstance = manager.instantiateByAlias('widget.' + config.xtype, config);
  } else {
    if ('xclass' in config) {
      newInstance = Ext.create(config.xclass, config);
    }
  }
  if (newInstance) {
    if (instance) {
      instance.destroy();
    }
    return newInstance;
  }
  if (instance) {
    return instance.setConfig(config);
  }
  return Ext.create(classReference, config);
}, log:function() {
  var primitiveRe = /string|number|boolean/;
  function dumpObject(object, level, maxLevel, withFunctions) {
    var member, type, value, name, prefix, suffix, members = [];
    if (Ext.isArray(object)) {
      prefix = '[';
      suffix = ']';
    } else {
      if (Ext.isObject(object)) {
        prefix = '{';
        suffix = '}';
      }
    }
    if (!maxLevel) {
      maxLevel = 3;
    }
    if (level > maxLevel) {
      return prefix + '...' + suffix;
    }
    level = level || 1;
    var spacer = (new Array(level)).join('    ');
    for (name in object) {
      if (object.hasOwnProperty(name)) {
        value = object[name];
        type = typeof value;
        if (type === 'function') {
          if (!withFunctions) {
            continue;
          }
          member = type;
        } else {
          if (type === 'undefined') {
            member = type;
          } else {
            if (value === null || primitiveRe.test(type) || Ext.isDate(value)) {
              member = Ext.encode(value);
            } else {
              if (Ext.isArray(value)) {
                member = dumpObject(value, level + 1, maxLevel, withFunctions);
              } else {
                if (Ext.isObject(value)) {
                  member = dumpObject(value, level + 1, maxLevel, withFunctions);
                } else {
                  member = type;
                }
              }
            }
          }
        }
        members.push(spacer + name + ': ' + member);
      }
    }
    if (members.length) {
      return prefix + '\n    ' + members.join(',\n    ') + '\n' + spacer + suffix;
    }
    return prefix + suffix;
  }
  function log(message) {
    var options, dump, con = Ext.global.console, level = 'log', indent = log.indent || 0, prefix, stack, fn, out, max;
    log.indent = indent;
    if (typeof message !== 'string') {
      options = message;
      message = options.msg || '';
      level = options.level || level;
      dump = options.dump;
      stack = options.stack;
      prefix = options.prefix;
      fn = options.fn;
      if (options.indent) {
        ++log.indent;
      } else {
        if (options.outdent) {
          log.indent = indent = Math.max(indent - 1, 0);
        }
      }
      if (dump && !(con && con.dir)) {
        message += dumpObject(dump);
        dump = null;
      }
    }
    if (arguments.length > 1) {
      message += Array.prototype.slice.call(arguments, 1).join('');
    }
    if (prefix) {
      message = prefix + ' - ' + message;
    }
    message = indent ? Ext.String.repeat(' ', log.indentSize * indent) + message : message;
    if (level !== 'log') {
      message = '[' + level.charAt(0).toUpperCase() + '] ' + message;
    }
    if (fn) {
      message += '\nCaller: ' + fn.toString();
    }
    if (con) {
      if (con[level]) {
        con[level](message);
      } else {
        con.log(message);
      }
      if (dump) {
        con.dir(dump);
      }
      if (stack && con.trace) {
        if (!con.firebug || level !== 'error') {
          con.trace();
        }
      }
    } else {
      if (Ext.isOpera) {
        opera.postError(message);
      } else {
        out = log.out;
        max = log.max;
        if (out.length >= max) {
          Ext.Array.erase(out, 0, out.length - 3 * Math.floor(max / 4));
        }
        out.push(message);
      }
    }
    ++log.count;
    ++log.counters[level];
  }
  function logx(level, args) {
    if (typeof args[0] === 'string') {
      args.unshift({});
    }
    args[0].level = level;
    log.apply(this, args);
  }
  log.error = function() {
    logx('error', Array.prototype.slice.call(arguments));
  };
  log.info = function() {
    logx('info', Array.prototype.slice.call(arguments));
  };
  log.warn = function() {
    logx('warn', Array.prototype.slice.call(arguments));
  };
  log.count = 0;
  log.counters = {error:0, warn:0, info:0, log:0};
  log.indentSize = 2;
  log.out = [];
  log.max = 750;
  return log;
}() || function() {
  var nullLog = function() {
  };
  nullLog.info = nullLog.warn = nullLog.error = Ext.emptyFn;
  return nullLog;
}()});
(function() {
  var checkVerTemp = [''], endOfVersionRe = /([^\d\.])/, notDigitsRe = /[^\d]/g, plusMinusRe = /[\-+]/g, stripRe = /\s/g, underscoreRe = /_/g, toolkitNames = {classic:1, modern:1}, Version;
  Ext.Version = Version = function(version, defaultMode) {
    var me = this, padModes = me.padModes, ch, i, pad, parts, release, releaseStartIndex, ver;
    if (version.isVersion) {
      version = version.version;
    }
    me.version = ver = String(version).toLowerCase().replace(underscoreRe, '.').replace(plusMinusRe, '');
    ch = ver.charAt(0);
    if (ch in padModes) {
      ver = ver.substring(1);
      pad = padModes[ch];
    } else {
      pad = defaultMode ? padModes[defaultMode] : 0;
    }
    me.pad = pad;
    releaseStartIndex = ver.search(endOfVersionRe);
    me.shortVersion = ver;
    if (releaseStartIndex !== -1) {
      me.release = release = ver.substr(releaseStartIndex, version.length);
      me.shortVersion = ver.substr(0, releaseStartIndex);
      release = Version.releaseValueMap[release] || release;
    }
    me.releaseValue = release || pad;
    me.shortVersion = me.shortVersion.replace(notDigitsRe, '');
    me.parts = parts = ver.split('.');
    for (i = parts.length; i--;) {
      parts[i] = parseInt(parts[i], 10);
    }
    if (pad === Infinity) {
      parts.push(pad);
    }
    me.major = parts[0] || pad;
    me.minor = parts[1] || pad;
    me.patch = parts[2] || pad;
    me.build = parts[3] || pad;
    return me;
  };
  Version.prototype = {isVersion:true, padModes:{'~':NaN, '^':Infinity}, release:'', compareTo:function(other) {
    var me = this, lhsPad = me.pad, lhsParts = me.parts, lhsLength = lhsParts.length, rhsVersion = other.isVersion ? other : new Version(other), rhsPad = rhsVersion.pad, rhsParts = rhsVersion.parts, rhsLength = rhsParts.length, length = Math.max(lhsLength, rhsLength), i, lhs, rhs;
    for (i = 0; i < length; i++) {
      lhs = i < lhsLength ? lhsParts[i] : lhsPad;
      rhs = i < rhsLength ? rhsParts[i] : rhsPad;
      if (lhs < rhs) {
        return -1;
      }
      if (lhs > rhs) {
        return 1;
      }
    }
    lhs = me.releaseValue;
    rhs = rhsVersion.releaseValue;
    if (lhs < rhs) {
      return -1;
    }
    if (lhs > rhs) {
      return 1;
    }
    return 0;
  }, toString:function() {
    return this.version;
  }, valueOf:function() {
    return this.version;
  }, getMajor:function() {
    return this.major;
  }, getMinor:function() {
    return this.minor;
  }, getPatch:function() {
    return this.patch;
  }, getBuild:function() {
    return this.build;
  }, getRelease:function() {
    return this.release;
  }, getReleaseValue:function() {
    return this.releaseValue;
  }, isGreaterThan:function(target) {
    return this.compareTo(target) > 0;
  }, isGreaterThanOrEqual:function(target) {
    return this.compareTo(target) >= 0;
  }, isLessThan:function(target) {
    return this.compareTo(target) < 0;
  }, isLessThanOrEqual:function(target) {
    return this.compareTo(target) <= 0;
  }, equals:function(target) {
    return this.compareTo(target) === 0;
  }, match:function(target) {
    target = String(target);
    return this.version.substr(0, target.length) === target;
  }, toArray:function() {
    var me = this;
    return [me.getMajor(), me.getMinor(), me.getPatch(), me.getBuild(), me.getRelease()];
  }, getShortVersion:function() {
    return this.shortVersion;
  }, gt:function(target) {
    return this.compareTo(target) > 0;
  }, lt:function(target) {
    return this.compareTo(target) < 0;
  }, gtEq:function(target) {
    return this.compareTo(target) >= 0;
  }, ltEq:function(target) {
    return this.compareTo(target) <= 0;
  }};
  Ext.apply(Version, {aliases:{from:{extjs:'ext', core:'core', touch:'modern'}, to:{ext:['extjs'], 'core':['core'], modern:['touch']}}, releaseValueMap:{dev:-6, alpha:-5, a:-5, beta:-4, b:-4, rc:-3, '#':-2, p:-1, pl:-1}, getComponentValue:function(value) {
    return !value ? 0 : isNaN(value) ? this.releaseValueMap[value] || value : parseInt(value, 10);
  }, compare:function(current, target) {
    var ver = current.isVersion ? current : new Version(current);
    return ver.compareTo(target);
  }, set:function(collection, packageName, version) {
    var aliases = Version.aliases.to[packageName], ver = version.isVersion ? version : new Version(version), i;
    collection[packageName] = ver;
    if (aliases) {
      for (i = aliases.length; i-- > 0;) {
        collection[aliases[i]] = ver;
      }
    }
    return ver;
  }});
  Ext.apply(Ext, {compatVersions:{}, versions:{}, lastRegisteredVersion:null, getCompatVersion:function(packageName) {
    var versions = Ext.compatVersions, compat;
    if (!packageName) {
      compat = versions.ext || versions.touch || versions.core;
    } else {
      compat = versions[Version.aliases.from[packageName] || packageName];
    }
    return compat || Ext.getVersion(packageName);
  }, setCompatVersion:function(packageName, version) {
    Version.set(Ext.compatVersions, packageName, version);
  }, setVersion:function(packageName, version) {
    if (packageName in toolkitNames) {
      Ext.toolkit = packageName;
    }
    Ext.lastRegisteredVersion = Version.set(Ext.versions, packageName, version);
    return this;
  }, getVersion:function(packageName) {
    var versions = Ext.versions;
    if (!packageName) {
      return versions.ext || versions.touch || versions.core;
    }
    return versions[Version.aliases.from[packageName] || packageName];
  }, checkVersion:function(specs, matchAll) {
    var isArray = Ext.isArray(specs), aliases = Version.aliases.from, compat = isArray ? specs : checkVerTemp, length = compat.length, versions = Ext.versions, frameworkVer = versions.ext || versions.touch, i, index, matches, minVer, maxVer, packageName, spec, range, ver;
    if (!isArray) {
      checkVerTemp[0] = specs;
    }
    for (i = 0; i < length; ++i) {
      if (!Ext.isString(spec = compat[i])) {
        matches = Ext.checkVersion(spec.and || spec.or, !spec.or);
        if (spec.not) {
          matches = !matches;
        }
      } else {
        if (spec.indexOf(' ') >= 0) {
          spec = spec.replace(stripRe, '');
        }
        index = spec.indexOf('@');
        if (index < 0) {
          range = spec;
          ver = frameworkVer;
        } else {
          packageName = spec.substring(0, index);
          if (!(ver = versions[aliases[packageName] || packageName])) {
            if (matchAll) {
              return false;
            }
            continue;
          }
          range = spec.substring(index + 1);
        }
        index = range.indexOf('-');
        if (index < 0) {
          if (range.charAt(index = range.length - 1) === '+') {
            minVer = range.substring(0, index);
            maxVer = null;
          } else {
            minVer = maxVer = range;
          }
        } else {
          if (index > 0) {
            minVer = range.substring(0, index);
            maxVer = range.substring(index + 1);
          } else {
            minVer = null;
            maxVer = range.substring(index + 1);
          }
        }
        matches = true;
        if (minVer) {
          minVer = new Version(minVer, '~');
          matches = minVer.ltEq(ver);
        }
        if (matches && maxVer) {
          maxVer = new Version(maxVer, '~');
          matches = maxVer.gtEq(ver);
        }
      }
      if (matches) {
        if (!matchAll) {
          return true;
        }
      } else {
        if (matchAll) {
          return false;
        }
      }
    }
    return !!matchAll;
  }, deprecate:function(packageName, since, closure, scope) {
    if (Version.compare(Ext.getVersion(packageName), since) < 1) {
      closure.call(scope);
    }
  }});
})();
(function(manifest) {
  var packages = manifest && manifest.packages || {}, compat = manifest && manifest.compatibility, name, pkg;
  for (name in packages) {
    pkg = packages[name];
    Ext.setVersion(name, pkg.version);
  }
  if (compat) {
    if (Ext.isString(compat)) {
      Ext.setCompatVersion('core', compat);
    } else {
      for (name in compat) {
        Ext.setCompatVersion(name, compat[name]);
      }
    }
  }
  if (!packages.ext && !packages.touch) {
    Ext.setVersion('ext', '6.0.1.250');
    Ext.setVersion('core', '6.0.1.250');
  }
})(Ext.manifest);
Ext.Config = function(name) {
  var me = this, capitalizedName = name.charAt(0).toUpperCase() + name.substr(1);
  me.name = name;
  me.names = {internal:'_' + name, initializing:'is' + capitalizedName + 'Initializing', apply:'apply' + capitalizedName, update:'update' + capitalizedName, get:'get' + capitalizedName, set:'set' + capitalizedName, initGet:'initGet' + capitalizedName, changeEvent:name.toLowerCase() + 'change'};
  me.root = me;
};
Ext.Config.map = {};
Ext.Config.get = function(name) {
  var map = Ext.Config.map, ret = map[name] || (map[name] = new Ext.Config(name));
  return ret;
};
Ext.Config.prototype = {self:Ext.Config, isConfig:true, getGetter:function() {
  return this.getter || (this.root.getter = this.makeGetter());
}, getInitGetter:function() {
  return this.initGetter || (this.root.initGetter = this.makeInitGetter());
}, getSetter:function() {
  return this.setter || (this.root.setter = this.makeSetter());
}, getEventedSetter:function() {
  return this.eventedSetter || (this.root.eventedSetter = this.makeEventedSetter());
}, getInternalName:function(target) {
  return target.$configPrefixed ? this.names.internal : this.name;
}, mergeNew:function(newValue, oldValue, target, mixinClass) {
  var ret, key;
  if (!oldValue) {
    ret = newValue;
  } else {
    if (!newValue) {
      ret = oldValue;
    } else {
      ret = Ext.Object.chain(oldValue);
      for (key in newValue) {
        if (!mixinClass || !(key in ret)) {
          ret[key] = newValue[key];
        }
      }
    }
  }
  return ret;
}, mergeSets:function(newValue, oldValue, preserveExisting) {
  var ret = oldValue ? Ext.Object.chain(oldValue) : {}, i, val;
  if (newValue instanceof Array) {
    for (i = newValue.length; i--;) {
      val = newValue[i];
      if (!preserveExisting || !(val in ret)) {
        ret[val] = true;
      }
    }
  } else {
    if (newValue) {
      if (newValue.constructor === Object) {
        for (i in newValue) {
          val = newValue[i];
          if (!preserveExisting || !(i in ret)) {
            ret[i] = val;
          }
        }
      } else {
        if (!preserveExisting || !(newValue in ret)) {
          ret[newValue] = true;
        }
      }
    }
  }
  return ret;
}, makeGetter:function() {
  var name = this.name, prefixedName = this.names.internal;
  return function() {
    var internalName = this.$configPrefixed ? prefixedName : name;
    return this[internalName];
  };
}, makeInitGetter:function() {
  var name = this.name, names = this.names, setName = names.set, getName = names.get, initializingName = names.initializing;
  return function() {
    var me = this;
    me[initializingName] = true;
    delete me[getName];
    me[setName](me.config[name]);
    delete me[initializingName];
    return me[getName].apply(me, arguments);
  };
}, makeSetter:function() {
  var name = this.name, names = this.names, prefixedName = names.internal, getName = names.get, applyName = names.apply, updateName = names.update, setter;
  setter = function(value) {
    var me = this, internalName = me.$configPrefixed ? prefixedName : name, oldValue = me[internalName];
    delete me[getName];
    if (!me[applyName] || (value = me[applyName](value, oldValue)) !== undefined) {
      if (value !== (oldValue = me[internalName])) {
        me[internalName] = value;
        if (me[updateName]) {
          me[updateName](value, oldValue);
        }
      }
    }
    return me;
  };
  setter.$isDefault = true;
  return setter;
}, makeEventedSetter:function() {
  var name = this.name, names = this.names, prefixedName = names.internal, getName = names.get, applyName = names.apply, updateName = names.update, changeEventName = names.changeEvent, updateFn = function(me, value, oldValue, internalName) {
    me[internalName] = value;
    if (me[updateName]) {
      me[updateName](value, oldValue);
    }
  }, setter;
  setter = function(value) {
    var me = this, internalName = me.$configPrefixed ? prefixedName : name, oldValue = me[internalName];
    delete me[getName];
    if (!me[applyName] || (value = me[applyName](value, oldValue)) !== undefined) {
      if (value !== (oldValue = me[internalName])) {
        if (me.isConfiguring) {
          me[internalName] = value;
          if (me[updateName]) {
            me[updateName](value, oldValue);
          }
        } else {
          me.fireEventedAction(changeEventName, [me, value, oldValue], updateFn, me, [me, value, oldValue, internalName]);
        }
      }
    }
    return me;
  };
  setter.$isDefault = true;
  return setter;
}};
(function() {
  var ExtConfig = Ext.Config, configPropMap = ExtConfig.map, ExtObject = Ext.Object;
  Ext.Configurator = function(cls) {
    var me = this, prototype = cls.prototype, superCfg = cls.superclass ? cls.superclass.self.$config : null;
    me.cls = cls;
    me.superCfg = superCfg;
    if (superCfg) {
      me.configs = ExtObject.chain(superCfg.configs);
      me.cachedConfigs = ExtObject.chain(superCfg.cachedConfigs);
      me.initMap = ExtObject.chain(superCfg.initMap);
      me.values = ExtObject.chain(superCfg.values);
      me.needsFork = superCfg.needsFork;
      me.deprecations = ExtObject.chain(superCfg.deprecations);
    } else {
      me.configs = {};
      me.cachedConfigs = {};
      me.initMap = {};
      me.values = {};
      me.deprecations = {};
    }
    prototype.config = prototype.defaultConfig = me.values;
    cls.$config = me;
  };
  Ext.Configurator.prototype = {self:Ext.Configurator, needsFork:false, initList:null, add:function(config, mixinClass) {
    var me = this, Cls = me.cls, configs = me.configs, cachedConfigs = me.cachedConfigs, initMap = me.initMap, prototype = Cls.prototype, mixinConfigs = mixinClass && mixinClass.$config.configs, values = me.values, isObject, meta, isCached, merge, cfg, currentValue, name, names, s, value;
    for (name in config) {
      value = config[name];
      isObject = value && value.constructor === Object;
      meta = isObject && '$value' in value ? value : null;
      if (meta) {
        isCached = !!meta.cached;
        value = meta.$value;
        isObject = value && value.constructor === Object;
      }
      merge = meta && meta.merge;
      cfg = configs[name];
      if (cfg) {
        if (mixinClass) {
          merge = cfg.merge;
          if (!merge) {
            continue;
          }
          meta = null;
        } else {
          merge = merge || cfg.merge;
        }
        if (!mixinClass && isCached && !cachedConfigs[name]) {
          Ext.raise('Redefining config as cached: ' + name + ' in class: ' + Cls.$className);
        }
        currentValue = values[name];
        if (merge) {
          value = merge.call(cfg, value, currentValue, Cls, mixinClass);
        } else {
          if (isObject) {
            if (currentValue && currentValue.constructor === Object) {
              value = ExtObject.merge({}, currentValue, value);
            }
          }
        }
      } else {
        if (mixinConfigs) {
          cfg = mixinConfigs[name];
          meta = null;
        } else {
          cfg = ExtConfig.get(name);
        }
        configs[name] = cfg;
        if (cfg.cached || isCached) {
          cachedConfigs[name] = true;
        }
        names = cfg.names;
        if (!prototype[s = names.get]) {
          prototype[s] = cfg.getter || cfg.getGetter();
        }
        if (!prototype[s = names.set]) {
          prototype[s] = meta && meta.evented ? cfg.eventedSetter || cfg.getEventedSetter() : cfg.setter || cfg.getSetter();
        }
      }
      if (meta) {
        if (cfg.owner !== Cls) {
          configs[name] = cfg = Ext.Object.chain(cfg);
          cfg.owner = Cls;
        }
        Ext.apply(cfg, meta);
        delete cfg.$value;
      }
      if (!me.needsFork && value && (value.constructor === Object || value instanceof Array)) {
        me.needsFork = true;
      }
      if (value !== null) {
        initMap[name] = true;
      } else {
        if (prototype.$configPrefixed) {
          prototype[configs[name].names.internal] = null;
        } else {
          prototype[configs[name].name] = null;
        }
        if (name in initMap) {
          initMap[name] = false;
        }
      }
      values[name] = value;
    }
  }, addDeprecations:function(configs) {
    var me = this, deprecations = me.deprecations, className = (me.cls.$className || '') + '#', message, newName, oldName;
    for (oldName in configs) {
      newName = configs[oldName];
      if (!newName) {
        message = 'This config has been removed.';
      } else {
        if (!(message = newName.message)) {
          message = 'This config has been renamed to "' + newName + '"';
        }
      }
      deprecations[oldName] = className + oldName + ': ' + message;
    }
  }, configure:function(instance, instanceConfig) {
    var me = this, configs = me.configs, deprecations = me.deprecations, initMap = me.initMap, initListMap = me.initListMap, initList = me.initList, prototype = me.cls.prototype, values = me.values, remaining = 0, firstInstance = !initList, cachedInitList, cfg, getter, needsInit, i, internalName, ln, names, name, value, isCached, valuesKey, field;
    values = me.needsFork ? ExtObject.fork(values) : ExtObject.chain(values);
    instance.isConfiguring = true;
    if (firstInstance) {
      me.initList = initList = [];
      me.initListMap = initListMap = {};
      instance.isFirstInstance = true;
      for (name in initMap) {
        needsInit = initMap[name];
        cfg = configs[name];
        isCached = cfg.cached;
        if (needsInit) {
          names = cfg.names;
          value = values[name];
          if (!prototype[names.set].$isDefault || prototype[names.apply] || prototype[names.update] || typeof value === 'object') {
            if (isCached) {
              (cachedInitList || (cachedInitList = [])).push(cfg);
            } else {
              initList.push(cfg);
              initListMap[name] = true;
            }
            instance[names.get] = cfg.initGetter || cfg.getInitGetter();
          } else {
            prototype[cfg.getInternalName(prototype)] = value;
          }
        } else {
          if (isCached) {
            prototype[cfg.getInternalName(prototype)] = undefined;
          }
        }
      }
    }
    ln = cachedInitList && cachedInitList.length;
    if (ln) {
      for (i = 0; i < ln; ++i) {
        internalName = cachedInitList[i].getInternalName(prototype);
        instance[internalName] = null;
      }
      for (i = 0; i < ln; ++i) {
        names = (cfg = cachedInitList[i]).names;
        getter = names.get;
        if (instance.hasOwnProperty(getter)) {
          instance[names.set](values[cfg.name]);
          delete instance[getter];
        }
      }
      for (i = 0; i < ln; ++i) {
        internalName = cachedInitList[i].getInternalName(prototype);
        prototype[internalName] = instance[internalName];
        delete instance[internalName];
      }
    }
    if (instanceConfig && instanceConfig.platformConfig) {
      instanceConfig = me.resolvePlatformConfig(instance, instanceConfig);
    }
    if (firstInstance) {
      if (instance.afterCachedConfig && !instance.afterCachedConfig.$nullFn) {
        instance.afterCachedConfig(instanceConfig);
      }
    }
    instance.config = values;
    for (i = 0, ln = initList.length; i < ln; ++i) {
      cfg = initList[i];
      instance[cfg.names.get] = cfg.initGetter || cfg.getInitGetter();
    }
    if (instance.transformInstanceConfig) {
      instanceConfig = instance.transformInstanceConfig(instanceConfig);
    }
    if (instanceConfig) {
      for (name in instanceConfig) {
        value = instanceConfig[name];
        cfg = configs[name];
        if (deprecations[name]) {
          Ext.log.warn(deprecations[name]);
          if (!cfg) {
            continue;
          }
        }
        if (!cfg) {
          field = instance.self.prototype[name];
          if (instance.$configStrict && typeof field === 'function' && !field.$nullFn) {
            Ext.raise('Cannot override method ' + name + ' on ' + instance.$className + ' instance.');
          }
          instance[name] = value;
        } else {
          if (!cfg.lazy) {
            ++remaining;
          }
          if (!initListMap[name]) {
            instance[cfg.names.get] = cfg.initGetter || cfg.getInitGetter();
          }
          if (cfg.merge) {
            value = cfg.merge(value, values[name], instance);
          } else {
            if (value && value.constructor === Object) {
              valuesKey = values[name];
              if (valuesKey && valuesKey.constructor === Object) {
                value = ExtObject.merge(values[name], value);
              } else {
                value = Ext.clone(value);
              }
            }
          }
        }
        values[name] = value;
      }
    }
    if (instance.beforeInitConfig && !instance.beforeInitConfig.$nullFn) {
      if (instance.beforeInitConfig(instanceConfig) === false) {
        return;
      }
    }
    if (instanceConfig) {
      for (name in instanceConfig) {
        if (!remaining) {
          break;
        }
        cfg = configs[name];
        if (cfg && !cfg.lazy) {
          --remaining;
          names = cfg.names;
          getter = names.get;
          if (instance.hasOwnProperty(getter)) {
            instance[names.set](values[name]);
            delete instance[names.get];
          }
        }
      }
    }
    for (i = 0, ln = initList.length; i < ln; ++i) {
      cfg = initList[i];
      names = cfg.names;
      getter = names.get;
      if (!cfg.lazy && instance.hasOwnProperty(getter)) {
        instance[names.set](values[cfg.name]);
        delete instance[getter];
      }
    }
    delete instance.isConfiguring;
  }, getCurrentConfig:function(instance) {
    var defaultConfig = instance.defaultConfig, config = {}, name;
    for (name in defaultConfig) {
      config[name] = instance[configPropMap[name].names.get]();
    }
    return config;
  }, merge:function(instance, baseConfig, config) {
    var configs = this.configs, name, value, baseValue, cfg;
    for (name in config) {
      value = config[name];
      cfg = configs[name];
      if (cfg) {
        if (cfg.merge) {
          value = cfg.merge(value, baseConfig[name], instance);
        } else {
          if (value && value.constructor === Object) {
            baseValue = baseConfig[name];
            if (baseValue && baseValue.constructor === Object) {
              value = Ext.Object.merge(baseValue, value);
            } else {
              value = Ext.clone(value);
            }
          }
        }
      }
      baseConfig[name] = value;
    }
    return baseConfig;
  }, reconfigure:function(instance, instanceConfig, options) {
    var currentConfig = instance.config, configList = [], strict = instance.$configStrict && !(options && options.strict === false), configs = this.configs, defaults = options && options.defaults, cfg, getter, i, len, name, names, prop;
    for (name in instanceConfig) {
      if (defaults && instance.hasOwnProperty(name)) {
        continue;
      }
      currentConfig[name] = instanceConfig[name];
      cfg = configs[name];
      if (this.deprecations[name]) {
        Ext.log.warn(this.deprecations[name]);
        if (!cfg) {
          continue;
        }
      }
      if (cfg) {
        instance[cfg.names.get] = cfg.initGetter || cfg.getInitGetter();
      } else {
        prop = instance.self.prototype[name];
        if (strict) {
          if (typeof prop === 'function' && !prop.$nullFn) {
            Ext.Error.raise('Cannot override method ' + name + ' on ' + instance.$className + ' instance.');
            continue;
          } else {
            if (name !== 'type') {
              Ext.log.warn('No such config "' + name + '" for class ' + instance.$className);
            }
          }
        }
      }
      configList.push(name);
    }
    for (i = 0, len = configList.length; i < len; i++) {
      name = configList[i];
      cfg = configs[name];
      if (cfg) {
        names = cfg.names;
        getter = names.get;
        if (instance.hasOwnProperty(getter)) {
          instance[names.set](instanceConfig[name]);
          delete instance[getter];
        }
      } else {
        cfg = configPropMap[name] || Ext.Config.get(name);
        names = cfg.names;
        if (instance[names.set]) {
          instance[names.set](instanceConfig[name]);
        } else {
          instance[name] = instanceConfig[name];
        }
      }
    }
  }, resolvePlatformConfig:function(instance, instanceConfig) {
    var platformConfig = instanceConfig && instanceConfig.platformConfig, ret = instanceConfig, i, keys, n;
    if (platformConfig) {
      keys = Ext.getPlatformConfigKeys(platformConfig);
      n = keys.length;
      if (n) {
        ret = Ext.merge({}, ret);
        for (i = 0, n = keys.length; i < n; ++i) {
          this.merge(instance, ret, platformConfig[keys[i]]);
        }
      }
    }
    return ret;
  }};
})();
Ext.Base = function(flexSetter) {
  var noArgs = [], baseStaticMember, baseStaticMembers = [], getConfig = function(name, peek) {
    var me = this, ret, cfg, getterName;
    if (name) {
      cfg = Ext.Config.map[name];
      if (!cfg) {
        Ext.Logger.error("Invalid property name for getter: '" + name + "' for '" + me.$className + "'.");
      }
      getterName = cfg.names.get;
      if (peek && me.hasOwnProperty(getterName)) {
        ret = me.config[name];
      } else {
        ret = me[getterName]();
      }
    } else {
      ret = me.getCurrentConfig();
    }
    return ret;
  }, makeDeprecatedMethod = function(oldName, newName, msg) {
    var message = '"' + oldName + '" is deprecated.';
    if (msg) {
      message += ' ' + msg;
    } else {
      if (newName) {
        message += ' Please use "' + newName + '" instead.';
      }
    }
    return function() {
      Ext.raise(message);
    };
  }, addDeprecatedProperty = function(object, oldName, newName, message) {
    if (!message) {
      message = '"' + oldName + '" is deprecated.';
    }
    if (newName) {
      message += ' Please use "' + newName + '" instead.';
    }
    if (message) {
      Ext.Object.defineProperty(object, oldName, {get:function() {
        Ext.raise(message);
      }, set:function(value) {
        Ext.raise(message);
      }, configurable:true});
    }
  }, makeAliasFn = function(name) {
    return function() {
      return this[name].apply(this, arguments);
    };
  }, Version = Ext.Version, leadingDigitRe = /^\d/, oneMember = {}, aliasOneMember = {}, Base = function() {
  }, BasePrototype = Base.prototype;
  Ext.apply(Base, {$className:'Ext.Base', $isClass:true, create:function() {
    return Ext.create.apply(Ext, [this].concat(Array.prototype.slice.call(arguments, 0)));
  }, addDeprecations:function(deprecations) {
    var me = this, all = [], compatVersion = Ext.getCompatVersion(deprecations.name), configurator = me.getConfigurator(), displayName = (me.$className || '') + '#', deprecate, versionSpec, index, message, target, enabled, existing, fn, names, oldName, newName, member, statics, version;
    for (versionSpec in deprecations) {
      if (leadingDigitRe.test(versionSpec)) {
        version = new Ext.Version(versionSpec);
        version.deprecations = deprecations[versionSpec];
        all.push(version);
      }
    }
    all.sort(Version.compare);
    for (index = all.length; index--;) {
      deprecate = (version = all[index]).deprecations;
      target = me.prototype;
      statics = deprecate.statics;
      enabled = compatVersion && compatVersion.lt(version);
      if (!enabled) {
      } else {
        if (!enabled) {
          break;
        }
      }
      while (deprecate) {
        names = deprecate.methods;
        if (names) {
          for (oldName in names) {
            member = names[oldName];
            fn = null;
            if (!member) {
              Ext.Assert.isNotDefinedProp(target, oldName);
              fn = makeDeprecatedMethod(displayName + oldName);
            } else {
              if (Ext.isString(member)) {
                Ext.Assert.isNotDefinedProp(target, oldName);
                Ext.Assert.isDefinedProp(target, member);
                if (enabled) {
                  fn = makeAliasFn(member);
                } else {
                  fn = makeDeprecatedMethod(displayName + oldName, member);
                }
              } else {
                message = '';
                if (member.message || member.fn) {
                  message = member.message;
                  member = member.fn;
                }
                existing = target.hasOwnProperty(oldName) && target[oldName];
                if (enabled && member) {
                  member.$owner = me;
                  member.$name = oldName;
                  member.name = displayName + oldName;
                  if (existing) {
                    member.$previous = existing;
                  }
                  fn = member;
                } else {
                  if (!existing) {
                    fn = makeDeprecatedMethod(displayName + oldName, null, message);
                  }
                }
              }
            }
            if (fn) {
              target[oldName] = fn;
            }
          }
        }
        names = deprecate.configs;
        if (names) {
          configurator.addDeprecations(names);
        }
        names = deprecate.properties;
        if (names && !enabled) {
          for (oldName in names) {
            newName = names[oldName];
            if (Ext.isString(newName)) {
              addDeprecatedProperty(target, displayName + oldName, newName);
            } else {
              if (newName && newName.message) {
                addDeprecatedProperty(target, displayName + oldName, null, newName.message);
              } else {
                addDeprecatedProperty(target, displayName + oldName);
              }
            }
          }
        }
        deprecate = statics;
        statics = null;
        target = me;
      }
    }
  }, extend:function(parent) {
    var me = this, parentPrototype = parent.prototype, prototype, i, ln, name, statics;
    prototype = me.prototype = Ext.Object.chain(parentPrototype);
    prototype.self = me;
    me.superclass = prototype.superclass = parentPrototype;
    if (!parent.$isClass) {
      for (i in BasePrototype) {
        if (i in prototype) {
          prototype[i] = BasePrototype[i];
        }
      }
    }
    statics = parentPrototype.$inheritableStatics;
    if (statics) {
      for (i = 0, ln = statics.length; i < ln; i++) {
        name = statics[i];
        if (!me.hasOwnProperty(name)) {
          me[name] = parent[name];
        }
      }
    }
    if (parent.$onExtended) {
      me.$onExtended = parent.$onExtended.slice();
    }
    me.getConfigurator();
  }, $onExtended:[], triggerExtended:function() {
    Ext.classSystemMonitor && Ext.classSystemMonitor(this, 'Ext.Base#triggerExtended', arguments);
    var callbacks = this.$onExtended, ln = callbacks.length, i, callback;
    if (ln > 0) {
      for (i = 0; i < ln; i++) {
        callback = callbacks[i];
        callback.fn.apply(callback.scope || this, arguments);
      }
    }
  }, onExtended:function(fn, scope) {
    this.$onExtended.push({fn:fn, scope:scope});
    return this;
  }, addStatics:function(members) {
    this.addMembers(members, true);
    return this;
  }, addInheritableStatics:function(members) {
    var inheritableStatics, hasInheritableStatics, prototype = this.prototype, name, member;
    inheritableStatics = prototype.$inheritableStatics;
    hasInheritableStatics = prototype.$hasInheritableStatics;
    if (!inheritableStatics) {
      inheritableStatics = prototype.$inheritableStatics = [];
      hasInheritableStatics = prototype.$hasInheritableStatics = {};
    }
    var className = Ext.getClassName(this) + '.';
    for (name in members) {
      if (members.hasOwnProperty(name)) {
        member = members[name];
        if (typeof member == 'function') {
          member.name = className + name;
        }
        this[name] = member;
        if (!hasInheritableStatics[name]) {
          hasInheritableStatics[name] = true;
          inheritableStatics.push(name);
        }
      }
    }
    return this;
  }, addMembers:function(members, isStatic, privacy) {
    var me = this, cloneFunction = Ext.Function.clone, target = isStatic ? me : me.prototype, defaultConfig = !isStatic && target.defaultConfig, enumerables = Ext.enumerables, privates = members.privates, configs, i, ln, member, name, subPrivacy, privateStatics;
    var displayName = (me.$className || '') + '#';
    if (privates) {
      delete members.privates;
      if (!isStatic) {
        privateStatics = privates.statics;
        delete privates.statics;
      }
      subPrivacy = privates.privacy || privacy || 'framework';
      me.addMembers(privates, isStatic, subPrivacy);
      if (privateStatics) {
        me.addMembers(privateStatics, true, subPrivacy);
      }
    }
    for (name in members) {
      if (members.hasOwnProperty(name)) {
        member = members[name];
        if (privacy === true) {
          privacy = 'framework';
        }
        if (member && member.$nullFn && privacy !== member.$privacy) {
          Ext.raise('Cannot use stock function for private method ' + (me.$className ? me.$className + '#' : '') + name);
        }
        if (typeof member === 'function' && !member.$isClass && !member.$nullFn) {
          if (member.$owner) {
            member = cloneFunction(member);
          }
          if (target.hasOwnProperty(name)) {
            member.$previous = target[name];
          }
          member.$owner = me;
          member.$name = name;
          member.name = displayName + name;
          var existing = target[name];
          if (privacy) {
            member.$privacy = privacy;
            if (existing && existing.$privacy && existing.$privacy !== privacy) {
              Ext.privacyViolation(me, existing, member, isStatic);
            }
          } else {
            if (existing && existing.$privacy) {
              Ext.privacyViolation(me, existing, member, isStatic);
            }
          }
        } else {
          if (defaultConfig && name in defaultConfig && !target.config.hasOwnProperty(name)) {
            (configs || (configs = {}))[name] = member;
            continue;
          }
        }
        target[name] = member;
      }
    }
    if (configs) {
      me.addConfig(configs);
    }
    if (enumerables) {
      for (i = 0, ln = enumerables.length; i < ln; ++i) {
        if (members.hasOwnProperty(name = enumerables[i])) {
          member = members[name];
          if (member && !member.$nullFn) {
            if (member.$owner) {
              member = cloneFunction(member);
            }
            member.$owner = me;
            member.$name = name;
            member.name = displayName + name;
            if (target.hasOwnProperty(name)) {
              member.$previous = target[name];
            }
          }
          target[name] = member;
        }
      }
    }
    return this;
  }, addMember:function(name, member) {
    oneMember[name] = member;
    this.addMembers(oneMember);
    delete oneMember[name];
    return this;
  }, borrow:function(fromClass, members) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(this, 'Ext.Base#borrow', arguments);
    var prototype = fromClass.prototype, membersObj = {}, i, ln, name;
    members = Ext.Array.from(members);
    for (i = 0, ln = members.length; i < ln; i++) {
      name = members[i];
      membersObj[name] = prototype[name];
    }
    return this.addMembers(membersObj);
  }, override:function(members) {
    var me = this, statics = members.statics, inheritableStatics = members.inheritableStatics, config = members.config, mixins = members.mixins, cachedConfig = members.cachedConfig;
    if (statics || inheritableStatics || config) {
      members = Ext.apply({}, members);
    }
    if (statics) {
      me.addMembers(statics, true);
      delete members.statics;
    }
    if (inheritableStatics) {
      me.addInheritableStatics(inheritableStatics);
      delete members.inheritableStatics;
    }
    if (config) {
      me.addConfig(config);
      delete members.config;
    }
    if (cachedConfig) {
      me.addCachedConfig(cachedConfig);
      delete members.cachedConfig;
    }
    delete members.mixins;
    me.addMembers(members);
    if (mixins) {
      me.mixin(mixins);
    }
    return me;
  }, callParent:function(args) {
    var method;
    return (method = this.callParent.caller) && (method.$previous || (method = method.$owner ? method : method.caller) && method.$owner.superclass.self[method.$name]).apply(this, args || noArgs);
  }, callSuper:function(args) {
    var method;
    return (method = this.callSuper.caller) && ((method = method.$owner ? method : method.caller) && method.$owner.superclass.self[method.$name]).apply(this, args || noArgs);
  }, mixin:function(name, mixinClass) {
    var me = this, mixin, prototype, key, statics, i, ln, staticName, mixinValue, mixins;
    if (typeof name !== 'string') {
      mixins = name;
      if (mixins instanceof Array) {
        for (i = 0, ln = mixins.length; i < ln; i++) {
          mixin = mixins[i];
          me.mixin(mixin.prototype.mixinId || mixin.$className, mixin);
        }
      } else {
        for (var mixinName in mixins) {
          me.mixin(mixinName, mixins[mixinName]);
        }
      }
      return;
    }
    mixin = mixinClass.prototype;
    prototype = me.prototype;
    if (mixin.onClassMixedIn) {
      mixin.onClassMixedIn.call(mixinClass, me);
    }
    if (!prototype.hasOwnProperty('mixins')) {
      if ('mixins' in prototype) {
        prototype.mixins = Ext.Object.chain(prototype.mixins);
      } else {
        prototype.mixins = {};
      }
    }
    for (key in mixin) {
      mixinValue = mixin[key];
      if (key === 'mixins') {
        Ext.applyIf(prototype.mixins, mixinValue);
      } else {
        if (!(key === 'mixinId' || key === 'config') && prototype[key] === undefined) {
          prototype[key] = mixinValue;
        }
      }
    }
    statics = mixin.$inheritableStatics;
    if (statics) {
      for (i = 0, ln = statics.length; i < ln; i++) {
        staticName = statics[i];
        if (!me.hasOwnProperty(staticName)) {
          me[staticName] = mixinClass[staticName];
        }
      }
    }
    if ('config' in mixin) {
      me.addConfig(mixin.config, mixinClass);
    }
    prototype.mixins[name] = mixin;
    if (mixin.afterClassMixedIn) {
      mixin.afterClassMixedIn.call(mixinClass, me);
    }
    return me;
  }, addConfig:function(config, mixinClass) {
    var cfg = this.$config || this.getConfigurator();
    cfg.add(config, mixinClass);
  }, addCachedConfig:function(config, isMixin) {
    var cached = {}, key;
    for (key in config) {
      cached[key] = {cached:true, $value:config[key]};
    }
    this.addConfig(cached, isMixin);
  }, getConfigurator:function() {
    return this.$config || new Ext.Configurator(this);
  }, getName:function() {
    return Ext.getClassName(this);
  }, createAlias:flexSetter(function(alias, origin) {
    aliasOneMember[alias] = function() {
      return this[origin].apply(this, arguments);
    };
    this.override(aliasOneMember);
    delete aliasOneMember[alias];
  })});
  for (baseStaticMember in Base) {
    if (Base.hasOwnProperty(baseStaticMember)) {
      baseStaticMembers.push(baseStaticMember);
    }
  }
  Base.$staticMembers = baseStaticMembers;
  Base.getConfigurator();
  Base.addMembers({$className:'Ext.Base', isInstance:true, $configPrefixed:true, $configStrict:true, isConfiguring:false, isFirstInstance:false, destroyed:false, statics:function() {
    var method = this.statics.caller, self = this.self;
    if (!method) {
      return self;
    }
    return method.$owner;
  }, callParent:function(args) {
    var method, superMethod = (method = this.callParent.caller) && (method.$previous || (method = method.$owner ? method : method.caller) && method.$owner.superclass[method.$name]);
    if (!superMethod) {
      method = this.callParent.caller;
      var parentClass, methodName;
      if (!method.$owner) {
        if (!method.caller) {
          throw new Error('Attempting to call a protected method from the public scope, which is not allowed');
        }
        method = method.caller;
      }
      parentClass = method.$owner.superclass;
      methodName = method.$name;
      if (!(methodName in parentClass)) {
        throw new Error("this.callParent() was called but there's no such method (" + methodName + ') found in the parent class (' + (Ext.getClassName(parentClass) || 'Object') + ')');
      }
    }
    return superMethod.apply(this, args || noArgs);
  }, callSuper:function(args) {
    var method, superMethod = (method = this.callSuper.caller) && ((method = method.$owner ? method : method.caller) && method.$owner.superclass[method.$name]);
    if (!superMethod) {
      method = this.callSuper.caller;
      var parentClass, methodName;
      if (!method.$owner) {
        if (!method.caller) {
          throw new Error('Attempting to call a protected method from the public scope, which is not allowed');
        }
        method = method.caller;
      }
      parentClass = method.$owner.superclass;
      methodName = method.$name;
      if (!(methodName in parentClass)) {
        throw new Error("this.callSuper() was called but there's no such method (" + methodName + ') found in the parent class (' + (Ext.getClassName(parentClass) || 'Object') + ')');
      }
    }
    return superMethod.apply(this, args || noArgs);
  }, self:Base, constructor:function() {
    return this;
  }, getConfigurator:function() {
    return this.$config || this.self.getConfigurator();
  }, initConfig:function(instanceConfig) {
    var me = this, cfg = me.getConfigurator();
    me.initConfig = Ext.emptyFn;
    me.initialConfig = instanceConfig || {};
    cfg.configure(me, instanceConfig);
    return me;
  }, beforeInitConfig:Ext.emptyFn, getConfig:getConfig, setConfig:function(name, value, options) {
    var me = this, config;
    if (name) {
      if (typeof name === 'string') {
        config = {};
        config[name] = value;
      } else {
        config = name;
      }
      me.getConfigurator().reconfigure(me, config, options);
    }
    return me;
  }, getCurrentConfig:function() {
    var cfg = this.getConfigurator();
    return cfg.getCurrentConfig(this);
  }, hasConfig:function(name) {
    return name in this.defaultConfig;
  }, getInitialConfig:function(name) {
    var config = this.config;
    if (!name) {
      return config;
    }
    return config[name];
  }, $links:null, link:function(name, value) {
    var me = this, links = me.$links || (me.$links = {});
    links[name] = true;
    me[name] = value;
    return value;
  }, unlink:function(names) {
    var me = this, i, ln, link, value;
    if (!Ext.isArray(names)) {
      Ext.raise('Invalid argument - expected array of strings');
    }
    for (i = 0, ln = names.length; i < ln; i++) {
      link = names[i];
      value = me[link];
      if (value) {
        if (value.isInstance && !value.destroyed) {
          value.destroy();
        } else {
          if (value.parentNode && 'nodeType' in value) {
            value.parentNode.removeChild(value);
          }
        }
      }
      me[link] = null;
    }
    return me;
  }, destroy:function() {
    var me = this, links = me.$links;
    me.initialConfig = me.config = null;
    me.destroy = Ext.emptyFn;
    me.isDestroyed = me.destroyed = true;
    if (links) {
      me.$links = null;
      me.unlink(Ext.Object.getKeys(links));
    }
  }});
  BasePrototype.callOverridden = BasePrototype.callParent;
  Ext.privacyViolation = function(cls, existing, member, isStatic) {
    var name = member.$name, conflictCls = existing.$owner && existing.$owner.$className, s = isStatic ? 'static ' : '', msg = member.$privacy ? 'Private ' + s + member.$privacy + ' method "' + name + '"' : 'Public ' + s + 'method "' + name + '"';
    if (cls.$className) {
      msg = cls.$className + ': ' + msg;
    }
    if (!existing.$privacy) {
      msg += conflictCls ? ' hides public method inherited from ' + conflictCls : ' hides inherited public method.';
    } else {
      msg += conflictCls ? ' conflicts with private ' + existing.$privacy + ' method declared by ' + conflictCls : ' conflicts with inherited private ' + existing.$privacy + ' method.';
    }
    var compat = Ext.getCompatVersion();
    var ver = Ext.getVersion();
    if (ver && compat && compat.lt(ver)) {
      Ext.log.error(msg);
    } else {
      Ext.raise(msg);
    }
  };
  return Base;
}(Ext.Function.flexSetter);
(function(Cache, prototype) {
  (Ext.util || (Ext.util = {})).Cache = Cache = function(config) {
    var me = this, head;
    if (config) {
      Ext.apply(me, config);
    }
    me.head = head = {id:me.seed = 0, key:null, value:null};
    me.map = {};
    head.next = head.prev = head;
  };
  Cache.prototype = prototype = {maxSize:100, count:0, clear:function() {
    var me = this, head = me.head, entry = head.next;
    head.next = head.prev = head;
    if (!me.evict.$nullFn) {
      for (; entry !== head; entry = entry.next) {
        me.evict(entry.key, entry.value);
      }
    }
    me.count = 0;
  }, each:function(fn, scope) {
    scope = scope || this;
    for (var head = this.head, ent = head.next; ent !== head; ent = ent.next) {
      if (fn.call(scope, ent.key, ent.value)) {
        break;
      }
    }
  }, get:function(key) {
    var me = this, head = me.head, map = me.map, entry = map[key];
    if (entry) {
      if (entry.prev !== head) {
        me.unlinkEntry(entry);
        me.linkEntry(entry);
      }
    } else {
      map[key] = entry = {id:++me.seed, key:key, value:me.miss.apply(me, arguments)};
      me.linkEntry(entry);
      ++me.count;
      while (me.count > me.maxSize) {
        me.unlinkEntry(head.prev, true);
        --me.count;
      }
    }
    return entry.value;
  }, evict:Ext.emptyFn, linkEntry:function(entry) {
    var head = this.head, first = head.next;
    entry.next = first;
    entry.prev = head;
    head.next = entry;
    first.prev = entry;
  }, unlinkEntry:function(entry, evicted) {
    var next = entry.next, prev = entry.prev;
    prev.next = next;
    next.prev = prev;
    if (evicted) {
      this.evict(entry.key, entry.value);
    }
  }};
  prototype.destroy = prototype.clear;
})();
(function() {
  var ExtClass, Base = Ext.Base, baseStaticMembers = Base.$staticMembers, ruleKeySortFn = function(a, b) {
    return a.length - b.length || (a < b ? -1 : a > b ? 1 : 0);
  };
  function makeCtor(className) {
    function constructor() {
      return this.constructor.apply(this, arguments) || null;
    }
    if (className) {
      constructor.name = className;
    }
    return constructor;
  }
  Ext.Class = ExtClass = function(Class, data, onCreated) {
    if (typeof Class != 'function') {
      onCreated = data;
      data = Class;
      Class = null;
    }
    if (!data) {
      data = {};
    }
    Class = ExtClass.create(Class, data);
    ExtClass.process(Class, data, onCreated);
    return Class;
  };
  Ext.apply(ExtClass, {makeCtor:makeCtor, onBeforeCreated:function(Class, data, hooks) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(Class, '\x3e\x3e Ext.Class#onBeforeCreated', arguments);
    Class.addMembers(data);
    hooks.onCreated.call(Class, Class);
    Ext.classSystemMonitor && Ext.classSystemMonitor(Class, '\x3c\x3c Ext.Class#onBeforeCreated', arguments);
  }, create:function(Class, data) {
    var i = baseStaticMembers.length, name;
    if (!Class) {
      Class = makeCtor(data.$className);
    }
    while (i--) {
      name = baseStaticMembers[i];
      Class[name] = Base[name];
    }
    return Class;
  }, process:function(Class, data, onCreated) {
    var preprocessorStack = data.preprocessors || ExtClass.defaultPreprocessors, registeredPreprocessors = this.preprocessors, hooks = {onBeforeCreated:this.onBeforeCreated}, preprocessors = [], preprocessor, preprocessorsProperties, i, ln, j, subLn, preprocessorProperty;
    delete data.preprocessors;
    Class._classHooks = hooks;
    for (i = 0, ln = preprocessorStack.length; i < ln; i++) {
      preprocessor = preprocessorStack[i];
      if (typeof preprocessor == 'string') {
        preprocessor = registeredPreprocessors[preprocessor];
        preprocessorsProperties = preprocessor.properties;
        if (preprocessorsProperties === true) {
          preprocessors.push(preprocessor.fn);
        } else {
          if (preprocessorsProperties) {
            for (j = 0, subLn = preprocessorsProperties.length; j < subLn; j++) {
              preprocessorProperty = preprocessorsProperties[j];
              if (data.hasOwnProperty(preprocessorProperty)) {
                preprocessors.push(preprocessor.fn);
                break;
              }
            }
          }
        }
      } else {
        preprocessors.push(preprocessor);
      }
    }
    hooks.onCreated = onCreated ? onCreated : Ext.emptyFn;
    hooks.preprocessors = preprocessors;
    this.doProcess(Class, data, hooks);
  }, doProcess:function(Class, data, hooks) {
    var me = this, preprocessors = hooks.preprocessors, preprocessor = preprocessors.shift(), doProcess = me.doProcess;
    for (; preprocessor; preprocessor = preprocessors.shift()) {
      if (preprocessor.call(me, Class, data, hooks, doProcess) === false) {
        return;
      }
    }
    hooks.onBeforeCreated.apply(me, arguments);
  }, preprocessors:{}, registerPreprocessor:function(name, fn, properties, position, relativeTo) {
    if (!position) {
      position = 'last';
    }
    if (!properties) {
      properties = [name];
    }
    this.preprocessors[name] = {name:name, properties:properties || false, fn:fn};
    this.setDefaultPreprocessorPosition(name, position, relativeTo);
    return this;
  }, getPreprocessor:function(name) {
    return this.preprocessors[name];
  }, getPreprocessors:function() {
    return this.preprocessors;
  }, defaultPreprocessors:[], getDefaultPreprocessors:function() {
    return this.defaultPreprocessors;
  }, setDefaultPreprocessors:function(preprocessors) {
    this.defaultPreprocessors = Ext.Array.from(preprocessors);
    return this;
  }, setDefaultPreprocessorPosition:function(name, offset, relativeName) {
    var defaultPreprocessors = this.defaultPreprocessors, index;
    if (typeof offset == 'string') {
      if (offset === 'first') {
        defaultPreprocessors.unshift(name);
        return this;
      } else {
        if (offset === 'last') {
          defaultPreprocessors.push(name);
          return this;
        }
      }
      offset = offset === 'after' ? 1 : -1;
    }
    index = Ext.Array.indexOf(defaultPreprocessors, relativeName);
    if (index !== -1) {
      Ext.Array.splice(defaultPreprocessors, Math.max(0, index + offset), 0, name);
    }
    return this;
  }});
  ExtClass.registerPreprocessor('extend', function(Class, data, hooks) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(Class, 'Ext.Class#extendPreProcessor', arguments);
    var Base = Ext.Base, basePrototype = Base.prototype, extend = data.extend, Parent, parentPrototype, i;
    delete data.extend;
    if (extend && extend !== Object) {
      Parent = extend;
    } else {
      Parent = Base;
    }
    parentPrototype = Parent.prototype;
    if (!Parent.$isClass) {
      for (i in basePrototype) {
        if (!parentPrototype[i]) {
          parentPrototype[i] = basePrototype[i];
        }
      }
    }
    Class.extend(Parent);
    Class.triggerExtended.apply(Class, arguments);
    if (data.onClassExtended) {
      Class.onExtended(data.onClassExtended, Class);
      delete data.onClassExtended;
    }
  }, true);
  ExtClass.registerPreprocessor('privates', function(Class, data) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(Class, 'Ext.Class#privatePreprocessor', arguments);
    var privates = data.privates, statics = privates.statics, privacy = privates.privacy || true;
    delete data.privates;
    delete privates.statics;
    Class.addMembers(privates, false, privacy);
    if (statics) {
      Class.addMembers(statics, true, privacy);
    }
  });
  ExtClass.registerPreprocessor('statics', function(Class, data) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(Class, 'Ext.Class#staticsPreprocessor', arguments);
    Class.addStatics(data.statics);
    delete data.statics;
  });
  ExtClass.registerPreprocessor('inheritableStatics', function(Class, data) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(Class, 'Ext.Class#inheritableStaticsPreprocessor', arguments);
    Class.addInheritableStatics(data.inheritableStatics);
    delete data.inheritableStatics;
  });
  Ext.createRuleFn = function(code) {
    return new Function('$c', 'with($c) { return (' + code + '); }');
  };
  Ext.expressionCache = new Ext.util.Cache({miss:Ext.createRuleFn});
  Ext.ruleKeySortFn = ruleKeySortFn;
  Ext.getPlatformConfigKeys = function(platformConfig) {
    var ret = [], platform, rule;
    for (platform in platformConfig) {
      rule = Ext.expressionCache.get(platform);
      if (rule(Ext.platformTags)) {
        ret.push(platform);
      }
    }
    ret.sort(ruleKeySortFn);
    return ret;
  };
  ExtClass.registerPreprocessor('platformConfig', function(Class, data, hooks) {
    var platformConfigs = data.platformConfig, config = data.config, added, classConfigs, configs, configurator, hoisted, keys, name, value, i, ln;
    delete data.platformConfig;
    if (platformConfigs instanceof Array) {
      throw new Error('platformConfigs must be specified as an object.');
    }
    configurator = Class.getConfigurator();
    classConfigs = configurator.configs;
    keys = Ext.getPlatformConfigKeys(platformConfigs);
    for (i = 0, ln = keys.length; i < ln; ++i) {
      configs = platformConfigs[keys[i]];
      hoisted = added = null;
      for (name in configs) {
        value = configs[name];
        if (config && name in config) {
          (added || (added = {}))[name] = value;
          (hoisted || (hoisted = {}))[name] = config[name];
          delete config[name];
        } else {
          if (name in classConfigs) {
            (added || (added = {}))[name] = value;
          } else {
            data[name] = value;
          }
        }
      }
      if (hoisted) {
        configurator.add(hoisted);
      }
      if (added) {
        configurator.add(added);
      }
    }
  });
  ExtClass.registerPreprocessor('config', function(Class, data) {
    if (data.hasOwnProperty('$configPrefixed')) {
      Class.prototype.$configPrefixed = data.$configPrefixed;
    }
    Class.addConfig(data.config);
    delete data.config;
  });
  ExtClass.registerPreprocessor('cachedConfig', function(Class, data) {
    if (data.hasOwnProperty('$configPrefixed')) {
      Class.prototype.$configPrefixed = data.$configPrefixed;
    }
    Class.addCachedConfig(data.cachedConfig);
    delete data.cachedConfig;
  });
  ExtClass.registerPreprocessor('mixins', function(Class, data, hooks) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(Class, 'Ext.Class#mixinsPreprocessor', arguments);
    var mixins = data.mixins, onCreated = hooks.onCreated;
    delete data.mixins;
    hooks.onCreated = function() {
      Ext.classSystemMonitor && Ext.classSystemMonitor(Class, 'Ext.Class#mixinsPreprocessor#beforeCreated', arguments);
      hooks.onCreated = onCreated;
      Class.mixin(mixins);
      return hooks.onCreated.apply(this, arguments);
    };
  });
  Ext.extend = function(Class, Parent, members) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(Class, 'Ext.Class#extend-backwards-compatible', arguments);
    if (arguments.length === 2 && Ext.isObject(Parent)) {
      members = Parent;
      Parent = Class;
      Class = null;
    }
    var cls;
    if (!Parent) {
      throw new Error('[Ext.extend] Attempting to extend from a class which has not been loaded on the page.');
    }
    members.extend = Parent;
    members.preprocessors = ['extend', 'statics', 'inheritableStatics', 'mixins', 'platformConfig', 'config'];
    if (Class) {
      cls = new ExtClass(Class, members);
      cls.prototype.constructor = Class;
    } else {
      cls = new ExtClass(members);
    }
    cls.prototype.override = function(o) {
      for (var m in o) {
        if (o.hasOwnProperty(m)) {
          this[m] = o[m];
        }
      }
    };
    return cls;
  };
})();
Ext.Inventory = function() {
  var me = this;
  me.names = [];
  me.paths = {};
  me.alternateToName = {};
  me.aliasToName = {};
  me.nameToAliases = {};
  me.nameToAlternates = {};
};
Ext.Inventory.prototype = {_array1:[0], prefixes:null, dotRe:/\./g, wildcardRe:/\*/g, addAlias:function(className, alias, update) {
  return this.addMapping(className, alias, this.aliasToName, this.nameToAliases, update);
}, addAlternate:function(className, alternate) {
  return this.addMapping(className, alternate, this.alternateToName, this.nameToAlternates);
}, addMapping:function(className, alternate, toName, nameTo, update) {
  var name = className.$className || className, mappings = name, array = this._array1, a, aliases, cls, i, length, nameMapping;
  if (Ext.isString(name)) {
    mappings = {};
    mappings[name] = alternate;
  }
  for (cls in mappings) {
    aliases = mappings[cls];
    if (Ext.isString(aliases)) {
      array[0] = aliases;
      aliases = array;
    }
    length = aliases.length;
    nameMapping = nameTo[cls] || (nameTo[cls] = []);
    for (i = 0; i < length; ++i) {
      if (!(a = aliases[i])) {
        continue;
      }
      if (toName[a] !== cls) {
        if (!update && toName[a]) {
          Ext.log.warn("Overriding existing mapping: '" + a + "' From '" + toName[a] + "' to '" + cls + "'. Is this intentional?");
        }
        toName[a] = cls;
        nameMapping.push(a);
      }
    }
  }
}, getAliasesByName:function(name) {
  return this.nameToAliases[name] || null;
}, getAlternatesByName:function(name) {
  return this.nameToAlternates[name] || null;
}, getNameByAlias:function(alias) {
  return this.aliasToName[alias] || '';
}, getNameByAlternate:function(alternate) {
  return this.alternateToName[alternate] || '';
}, getNamesByExpression:function(expression, exclude, accumulate) {
  var me = this, aliasToName = me.aliasToName, alternateToName = me.alternateToName, nameToAliases = me.nameToAliases, nameToAlternates = me.nameToAlternates, map = accumulate ? exclude : {}, names = [], expressions = Ext.isString(expression) ? [expression] : expression, length = expressions.length, wildcardRe = me.wildcardRe, expr, i, list, match, n, name, regex;
  for (i = 0; i < length; ++i) {
    if ((expr = expressions[i]).indexOf('*') < 0) {
      if (!(name = aliasToName[expr])) {
        if (!(name = alternateToName[expr])) {
          name = expr;
        }
      }
      if (!(name in map) && !(exclude && name in exclude)) {
        map[name] = 1;
        names.push(name);
      }
    } else {
      regex = new RegExp('^' + expr.replace(wildcardRe, '(.*?)') + '$');
      for (name in nameToAliases) {
        if (!(name in map) && !(exclude && name in exclude)) {
          if (!(match = regex.test(name))) {
            n = (list = nameToAliases[name]).length;
            while (!match && n-- > 0) {
              match = regex.test(list[n]);
            }
            list = nameToAlternates[name];
            if (list && !match) {
              n = list.length;
              while (!match && n-- > 0) {
                match = regex.test(list[n]);
              }
            }
          }
          if (match) {
            map[name] = 1;
            names.push(name);
          }
        }
      }
    }
  }
  return names;
}, getPath:function(className) {
  var me = this, paths = me.paths, ret = '', prefix;
  if (className in paths) {
    ret = paths[className];
  } else {
    prefix = me.getPrefix(className);
    if (prefix) {
      className = className.substring(prefix.length + 1);
      ret = paths[prefix];
      if (ret) {
        ret += '/';
      }
    }
    ret += className.replace(me.dotRe, '/') + '.js';
  }
  return ret;
}, getPrefix:function(className) {
  if (className in this.paths) {
    return className;
  }
  var prefixes = this.getPrefixes(), i = prefixes.length, length, prefix;
  while (i-- > 0) {
    length = (prefix = prefixes[i]).length;
    if (length < className.length && className.charAt(length) === '.' && prefix === className.substring(0, length)) {
      return prefix;
    }
  }
  return '';
}, getPrefixes:function() {
  var me = this, prefixes = me.prefixes;
  if (!prefixes) {
    me.prefixes = prefixes = me.names.slice(0);
    prefixes.sort(me._compareNames);
  }
  return prefixes;
}, removeName:function(name) {
  var me = this, aliasToName = me.aliasToName, alternateToName = me.alternateToName, nameToAliases = me.nameToAliases, nameToAlternates = me.nameToAlternates, aliases = nameToAliases[name], alternates = nameToAlternates[name], i, a;
  delete nameToAliases[name];
  delete nameToAlternates[name];
  if (aliases) {
    for (i = aliases.length; i--;) {
      if (name === (a = aliases[i])) {
        delete aliasToName[a];
      }
    }
  }
  if (alternates) {
    for (i = alternates.length; i--;) {
      if (name === (a = alternates[i])) {
        delete alternateToName[a];
      }
    }
  }
}, resolveName:function(name) {
  var me = this, trueName;
  if (!(name in me.nameToAliases)) {
    if (!(trueName = me.aliasToName[name])) {
      trueName = me.alternateToName[name];
    }
  }
  return trueName || name;
}, select:function(receiver, scope) {
  var me = this, excludes = {}, ret = {excludes:excludes, exclude:function() {
    me.getNamesByExpression(arguments, excludes, true);
    return this;
  }}, name;
  for (name in receiver) {
    ret[name] = me.selectMethod(excludes, receiver[name], scope || receiver);
  }
  return ret;
}, selectMethod:function(excludes, fn, scope) {
  var me = this;
  return function(include) {
    var args = Ext.Array.slice(arguments, 1);
    args.unshift(me.getNamesByExpression(include, excludes));
    return fn.apply(scope, args);
  };
}, setPath:Ext.Function.flexSetter(function(name, path) {
  var me = this;
  me.paths[name] = path;
  me.names.push(name);
  me.prefixes = null;
  return me;
}), _compareNames:function(lhs, rhs) {
  var cmp = lhs.length - rhs.length;
  if (!cmp) {
    cmp = lhs < rhs ? -1 : 1;
  }
  return cmp;
}};
Ext.ClassManager = function(Class, alias, arraySlice, arrayFrom, global) {
  var makeCtor = Ext.Class.makeCtor, nameLookupStack = [], namespaceCache = {Ext:{name:'Ext', value:Ext}}, Manager = Ext.apply(new Ext.Inventory, {classes:{}, classState:{}, existCache:{}, instantiators:[], isCreated:function(className) {
    if (typeof className !== 'string' || className.length < 1) {
      throw new Error('[Ext.ClassManager] Invalid classname, must be a string and must not be empty');
    }
    if (Manager.classes[className] || Manager.existCache[className]) {
      return true;
    }
    if (!Manager.lookupName(className, false)) {
      return false;
    }
    Manager.triggerCreated(className);
    return true;
  }, createdListeners:[], nameCreatedListeners:{}, existsListeners:[], nameExistsListeners:{}, overrideMap:{}, triggerCreated:function(className, state) {
    Manager.existCache[className] = state || 1;
    Manager.classState[className] += 40;
    Manager.notify(className, Manager.createdListeners, Manager.nameCreatedListeners);
  }, onCreated:function(fn, scope, className) {
    Manager.addListener(fn, scope, className, Manager.createdListeners, Manager.nameCreatedListeners);
  }, notify:function(className, listeners, nameListeners) {
    var alternateNames = Manager.getAlternatesByName(className), names = [className], i, ln, j, subLn, listener, name;
    for (i = 0, ln = listeners.length; i < ln; i++) {
      listener = listeners[i];
      listener.fn.call(listener.scope, className);
    }
    while (names) {
      for (i = 0, ln = names.length; i < ln; i++) {
        name = names[i];
        listeners = nameListeners[name];
        if (listeners) {
          for (j = 0, subLn = listeners.length; j < subLn; j++) {
            listener = listeners[j];
            listener.fn.call(listener.scope, name);
          }
          delete nameListeners[name];
        }
      }
      names = alternateNames;
      alternateNames = null;
    }
  }, addListener:function(fn, scope, className, listeners, nameListeners) {
    if (Ext.isArray(className)) {
      fn = Ext.Function.createBarrier(className.length, fn, scope);
      for (i = 0; i < className.length; i++) {
        this.addListener(fn, null, className[i], listeners, nameListeners);
      }
      return;
    }
    var i, listener = {fn:fn, scope:scope};
    if (className) {
      if (this.isCreated(className)) {
        fn.call(scope, className);
        return;
      }
      if (!nameListeners[className]) {
        nameListeners[className] = [];
      }
      nameListeners[className].push(listener);
    } else {
      listeners.push(listener);
    }
  }, $namespaceCache:namespaceCache, addRootNamespaces:function(namespaces) {
    for (var name in namespaces) {
      namespaceCache[name] = {name:name, value:namespaces[name]};
    }
  }, clearNamespaceCache:function() {
    nameLookupStack.length = 0;
    for (var name in namespaceCache) {
      if (!namespaceCache[name].value) {
        delete namespaceCache[name];
      }
    }
  }, getNamespaceEntry:function(namespace) {
    if (typeof namespace !== 'string') {
      return namespace;
    }
    var entry = namespaceCache[namespace], i;
    if (!entry) {
      i = namespace.lastIndexOf('.');
      if (i < 0) {
        entry = {name:namespace};
      } else {
        entry = {name:namespace.substring(i + 1), parent:Manager.getNamespaceEntry(namespace.substring(0, i))};
      }
      namespaceCache[namespace] = entry;
    }
    return entry;
  }, lookupName:function(namespace, autoCreate) {
    var entry = Manager.getNamespaceEntry(namespace), scope = Ext.global, i = 0, e, parent;
    for (e = entry; e; e = e.parent) {
      nameLookupStack[i++] = e;
    }
    while (scope && i-- > 0) {
      e = nameLookupStack[i];
      parent = scope;
      scope = e.value || scope[e.name];
      if (!scope && autoCreate) {
        parent[e.name] = scope = {};
      }
    }
    return scope;
  }, setNamespace:function(namespace, value) {
    var entry = Manager.getNamespaceEntry(namespace), scope = Ext.global;
    if (entry.parent) {
      scope = Manager.lookupName(entry.parent, true);
    }
    scope[entry.name] = value;
    return value;
  }, setXType:function(cls, xtype) {
    var className = cls.$className, C = className ? cls : Manager.get(className = cls), proto = C.prototype, xtypes = proto.xtypes, xtypesChain = proto.xtypesChain, xtypesMap = proto.xtypesMap;
    if (!proto.hasOwnProperty('xtypes')) {
      proto.xtypes = xtypes = [];
      proto.xtypesChain = xtypesChain = xtypesChain ? xtypesChain.slice(0) : [];
      proto.xtypesMap = xtypesMap = Ext.apply({}, xtypesMap);
    }
    Manager.addAlias(className, 'widget.' + xtype, true);
    xtypes.push(xtype);
    xtypesChain.push(xtype);
    xtypesMap[xtype] = true;
  }, set:function(name, value) {
    var targetName = Manager.getName(value);
    Manager.classes[name] = Manager.setNamespace(name, value);
    if (targetName && targetName !== name) {
      Manager.addAlternate(targetName, name);
    }
    return Manager;
  }, get:function(name) {
    return Manager.classes[name] || Manager.lookupName(name, false);
  }, addNameAliasMappings:function(aliases) {
    Manager.addAlias(aliases);
  }, addNameAlternateMappings:function(alternates) {
    Manager.addAlternate(alternates);
  }, getByAlias:function(alias) {
    return Manager.get(Manager.getNameByAlias(alias));
  }, getByConfig:function(config, aliasPrefix) {
    var xclass = config.xclass, name;
    if (xclass) {
      name = xclass;
    } else {
      name = config.xtype;
      if (name) {
        aliasPrefix = 'widget.';
      } else {
        name = config.type;
      }
      name = Manager.getNameByAlias(aliasPrefix + name);
    }
    return Manager.get(name);
  }, getName:function(object) {
    return object && object.$className || '';
  }, getClass:function(object) {
    return object && object.self || null;
  }, create:function(className, data, createdFn) {
    if (className != null && typeof className !== 'string') {
      throw new Error("[Ext.define] Invalid class name '" + className + "' specified, must be a non-empty string");
    }
    var ctor = makeCtor(className);
    if (typeof data === 'function') {
      data = data(ctor);
    }
    if (className) {
      if (Manager.classes[className]) {
        Ext.log.warn("[Ext.define] Duplicate class name '" + className + "' specified, must be a non-empty string");
      }
      ctor.name = className;
    }
    data.$className = className;
    return new Class(ctor, data, function() {
      var postprocessorStack = data.postprocessors || Manager.defaultPostprocessors, registeredPostprocessors = Manager.postprocessors, postprocessors = [], postprocessor, i, ln, j, subLn, postprocessorProperties, postprocessorProperty;
      delete data.postprocessors;
      for (i = 0, ln = postprocessorStack.length; i < ln; i++) {
        postprocessor = postprocessorStack[i];
        if (typeof postprocessor === 'string') {
          postprocessor = registeredPostprocessors[postprocessor];
          postprocessorProperties = postprocessor.properties;
          if (postprocessorProperties === true) {
            postprocessors.push(postprocessor.fn);
          } else {
            if (postprocessorProperties) {
              for (j = 0, subLn = postprocessorProperties.length; j < subLn; j++) {
                postprocessorProperty = postprocessorProperties[j];
                if (data.hasOwnProperty(postprocessorProperty)) {
                  postprocessors.push(postprocessor.fn);
                  break;
                }
              }
            }
          }
        } else {
          postprocessors.push(postprocessor);
        }
      }
      data.postprocessors = postprocessors;
      data.createdFn = createdFn;
      Manager.processCreate(className, this, data);
    });
  }, processCreate:function(className, cls, clsData) {
    var me = this, postprocessor = clsData.postprocessors.shift(), createdFn = clsData.createdFn;
    if (!postprocessor) {
      Ext.classSystemMonitor && Ext.classSystemMonitor(className, 'Ext.ClassManager#classCreated', arguments);
      if (className) {
        me.set(className, cls);
      }
      delete cls._classHooks;
      if (createdFn) {
        createdFn.call(cls, cls);
      }
      if (className) {
        me.triggerCreated(className);
      }
      return;
    }
    if (postprocessor.call(me, className, cls, clsData, me.processCreate) !== false) {
      me.processCreate(className, cls, clsData);
    }
  }, createOverride:function(className, data, createdFn) {
    var me = this, overriddenClassName = data.override, requires = data.requires, uses = data.uses, mixins = data.mixins, mixinsIsArray, compat = 1, depedenciesLoaded, classReady = function() {
      var cls, dependencies, i, key, temp;
      if (!depedenciesLoaded) {
        dependencies = requires ? requires.slice(0) : [];
        if (mixins) {
          if (!(mixinsIsArray = mixins instanceof Array)) {
            for (key in mixins) {
              if (Ext.isString(cls = mixins[key])) {
                dependencies.push(cls);
              }
            }
          } else {
            for (i = 0, temp = mixins.length; i < temp; ++i) {
              if (Ext.isString(cls = mixins[i])) {
                dependencies.push(cls);
              }
            }
          }
        }
        depedenciesLoaded = true;
        if (dependencies.length) {
          Ext.require(dependencies, classReady);
          return;
        }
      }
      if (mixinsIsArray) {
        for (i = 0, temp = mixins.length; i < temp; ++i) {
          if (Ext.isString(cls = mixins[i])) {
            mixins[i] = Ext.ClassManager.get(cls);
          }
        }
      } else {
        if (mixins) {
          for (key in mixins) {
            if (Ext.isString(cls = mixins[key])) {
              mixins[key] = Ext.ClassManager.get(cls);
            }
          }
        }
      }
      cls = me.get(overriddenClassName);
      delete data.override;
      delete data.compatibility;
      delete data.requires;
      delete data.uses;
      Ext.override(cls, data);
      Ext.Loader.history.push(className);
      if (uses) {
        Ext['Loader'].addUsedClasses(uses);
      }
      if (createdFn) {
        createdFn.call(cls, cls);
      }
    };
    Manager.overrideMap[className] = true;
    if ('compatibility' in data && Ext.isString(compat = data.compatibility)) {
      compat = Ext.checkVersion(compat);
    }
    if (compat) {
      me.onCreated(classReady, me, overriddenClassName);
    }
    me.triggerCreated(className, 2);
    return me;
  }, instantiateByAlias:function() {
    var alias = arguments[0], args = arraySlice.call(arguments), className = this.getNameByAlias(alias);
    if (!className) {
      throw new Error('[Ext.createByAlias] Unrecognized alias: ' + alias);
    }
    args[0] = className;
    return Ext.create.apply(Ext, args);
  }, instantiate:function() {
    Ext.log.warn('Ext.ClassManager.instantiate() is deprecated.  Use Ext.create() instead.');
    return Ext.create.apply(Ext, arguments);
  }, dynInstantiate:function(name, args) {
    args = arrayFrom(args, true);
    args.unshift(name);
    return Ext.create.apply(Ext, args);
  }, getInstantiator:function(length) {
    var instantiators = this.instantiators, instantiator, i, args;
    instantiator = instantiators[length];
    if (!instantiator) {
      i = length;
      args = [];
      for (i = 0; i < length; i++) {
        args.push('a[' + i + ']');
      }
      instantiator = instantiators[length] = new Function('c', 'a', 'return new c(' + args.join(',') + ')');
      instantiator.name = 'Ext.create' + length;
    }
    return instantiator;
  }, postprocessors:{}, defaultPostprocessors:[], registerPostprocessor:function(name, fn, properties, position, relativeTo) {
    if (!position) {
      position = 'last';
    }
    if (!properties) {
      properties = [name];
    }
    this.postprocessors[name] = {name:name, properties:properties || false, fn:fn};
    this.setDefaultPostprocessorPosition(name, position, relativeTo);
    return this;
  }, setDefaultPostprocessors:function(postprocessors) {
    this.defaultPostprocessors = arrayFrom(postprocessors);
    return this;
  }, setDefaultPostprocessorPosition:function(name, offset, relativeName) {
    var defaultPostprocessors = this.defaultPostprocessors, index;
    if (typeof offset === 'string') {
      if (offset === 'first') {
        defaultPostprocessors.unshift(name);
        return this;
      } else {
        if (offset === 'last') {
          defaultPostprocessors.push(name);
          return this;
        }
      }
      offset = offset === 'after' ? 1 : -1;
    }
    index = Ext.Array.indexOf(defaultPostprocessors, relativeName);
    if (index !== -1) {
      Ext.Array.splice(defaultPostprocessors, Math.max(0, index + offset), 0, name);
    }
    return this;
  }});
  Manager.registerPostprocessor('alias', function(name, cls, data) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(name, 'Ext.ClassManager#aliasPostProcessor', arguments);
    var aliases = Ext.Array.from(data.alias), i, ln;
    for (i = 0, ln = aliases.length; i < ln; i++) {
      alias = aliases[i];
      this.addAlias(cls, alias);
    }
  }, ['xtype', 'alias']);
  Manager.registerPostprocessor('singleton', function(name, cls, data, fn) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(name, 'Ext.ClassManager#singletonPostProcessor', arguments);
    if (data.singleton) {
      fn.call(this, name, new cls, data);
    } else {
      return true;
    }
    return false;
  });
  Manager.registerPostprocessor('alternateClassName', function(name, cls, data) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(name, 'Ext.ClassManager#alternateClassNamePostprocessor', arguments);
    var alternates = data.alternateClassName, i, ln, alternate;
    if (!(alternates instanceof Array)) {
      alternates = [alternates];
    }
    for (i = 0, ln = alternates.length; i < ln; i++) {
      alternate = alternates[i];
      if (typeof alternate !== 'string') {
        throw new Error("[Ext.define] Invalid alternate of: '" + alternate + "' for class: '" + name + "'; must be a valid string");
      }
      this.set(alternate, cls);
    }
  });
  Manager.registerPostprocessor('debugHooks', function(name, Class, data) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(Class, 'Ext.Class#debugHooks', arguments);
    if (Ext.isDebugEnabled(Class.$className, data.debugHooks.$enabled)) {
      delete data.debugHooks.$enabled;
      Ext.override(Class, data.debugHooks);
    }
    var target = Class.isInstance ? Class.self : Class;
    delete target.prototype.debugHooks;
  });
  Manager.registerPostprocessor('deprecated', function(name, Class, data) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(Class, 'Ext.Class#deprecated', arguments);
    var target = Class.isInstance ? Class.self : Class;
    target.addDeprecations(data.deprecated);
    delete target.prototype.deprecated;
  });
  Ext.apply(Ext, {create:function() {
    var name = arguments[0], nameType = typeof name, args = arraySlice.call(arguments, 1), cls;
    if (nameType === 'function') {
      cls = name;
    } else {
      if (nameType !== 'string' && args.length === 0) {
        args = [name];
        if (!(name = name.xclass)) {
          name = args[0].xtype;
          if (name) {
            name = 'widget.' + name;
          }
        }
      }
      if (typeof name !== 'string' || name.length < 1) {
        throw new Error("[Ext.create] Invalid class name or alias '" + name + "' specified, must be a non-empty string");
      }
      name = Manager.resolveName(name);
      cls = Manager.get(name);
    }
    if (!cls) {
      Ext.log.warn("[Ext.Loader] Synchronously loading '" + name + "'; consider adding " + "Ext.require('" + name + "') above Ext.onReady");
      Ext.syncRequire(name);
      cls = Manager.get(name);
    }
    if (!cls) {
      throw new Error('[Ext.create] Unrecognized class name / alias: ' + name);
    }
    if (typeof cls !== 'function') {
      throw new Error("[Ext.create] Singleton '" + name + "' cannot be instantiated.");
    }
    return Manager.getInstantiator(args.length)(cls, args);
  }, widget:function(name, config) {
    var xtype = name, alias, className, T;
    if (typeof xtype !== 'string') {
      config = name;
      xtype = config.xtype;
      className = config.xclass;
    } else {
      config = config || {};
    }
    if (config.isComponent) {
      return config;
    }
    if (!className) {
      alias = 'widget.' + xtype;
      className = Manager.getNameByAlias(alias);
    }
    if (className) {
      T = Manager.get(className);
    }
    if (!T) {
      return Ext.create(className || alias, config);
    }
    return new T(config);
  }, createByAlias:alias(Manager, 'instantiateByAlias'), define:function(className, data, createdFn) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(className, 'ClassManager#define', arguments);
    if (data.override) {
      Manager.classState[className] = 20;
      return Manager.createOverride.apply(Manager, arguments);
    }
    Manager.classState[className] = 10;
    return Manager.create.apply(Manager, arguments);
  }, undefine:function(className) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(className, 'Ext.ClassManager#undefine', arguments);
    var classes = Manager.classes;
    delete classes[className];
    delete Manager.existCache[className];
    delete Manager.classState[className];
    Manager.removeName(className);
    var entry = Manager.getNamespaceEntry(className), scope = entry.parent ? Manager.lookupName(entry.parent, false) : Ext.global;
    if (scope) {
      try {
        delete scope[entry.name];
      } catch (e$1) {
        scope[entry.name] = undefined;
      }
    }
  }, getClassName:alias(Manager, 'getName'), getDisplayName:function(object) {
    if (object) {
      if (object.displayName) {
        return object.displayName;
      }
      if (object.$name && object.$class) {
        return Ext.getClassName(object.$class) + '#' + object.$name;
      }
      if (object.$className) {
        return object.$className;
      }
    }
    return 'Anonymous';
  }, getClass:alias(Manager, 'getClass'), namespace:function() {
    var root = global, i;
    for (i = arguments.length; i-- > 0;) {
      root = Manager.lookupName(arguments[i], true);
    }
    return root;
  }});
  Ext.addRootNamespaces = Manager.addRootNamespaces;
  Ext.createWidget = Ext.widget;
  Ext.ns = Ext.namespace;
  Class.registerPreprocessor('className', function(cls, data) {
    if ('$className' in data) {
      cls.$className = data.$className;
      cls.displayName = cls.$className;
    }
    Ext.classSystemMonitor && Ext.classSystemMonitor(cls, 'Ext.ClassManager#classNamePreprocessor', arguments);
  }, true, 'first');
  Class.registerPreprocessor('alias', function(cls, data) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(cls, 'Ext.ClassManager#aliasPreprocessor', arguments);
    var prototype = cls.prototype, xtypes = arrayFrom(data.xtype), aliases = arrayFrom(data.alias), widgetPrefix = 'widget.', widgetPrefixLength = widgetPrefix.length, xtypesChain = Array.prototype.slice.call(prototype.xtypesChain || []), xtypesMap = Ext.merge({}, prototype.xtypesMap || {}), i, ln, alias, xtype;
    for (i = 0, ln = aliases.length; i < ln; i++) {
      alias = aliases[i];
      if (typeof alias !== 'string' || alias.length < 1) {
        throw new Error("[Ext.define] Invalid alias of: '" + alias + "' for class: '" + name + "'; must be a valid string");
      }
      if (alias.substring(0, widgetPrefixLength) === widgetPrefix) {
        xtype = alias.substring(widgetPrefixLength);
        Ext.Array.include(xtypes, xtype);
      }
    }
    cls.xtype = data.xtype = xtypes[0];
    data.xtypes = xtypes;
    for (i = 0, ln = xtypes.length; i < ln; i++) {
      xtype = xtypes[i];
      if (!xtypesMap[xtype]) {
        xtypesMap[xtype] = true;
        xtypesChain.push(xtype);
      }
    }
    data.xtypesChain = xtypesChain;
    data.xtypesMap = xtypesMap;
    Ext.Function.interceptAfter(data, 'onClassCreated', function() {
      Ext.classSystemMonitor && Ext.classSystemMonitor(cls, 'Ext.ClassManager#aliasPreprocessor#afterClassCreated', arguments);
      var mixins = prototype.mixins, key, mixin;
      for (key in mixins) {
        if (mixins.hasOwnProperty(key)) {
          mixin = mixins[key];
          xtypes = mixin.xtypes;
          if (xtypes) {
            for (i = 0, ln = xtypes.length; i < ln; i++) {
              xtype = xtypes[i];
              if (!xtypesMap[xtype]) {
                xtypesMap[xtype] = true;
                xtypesChain.push(xtype);
              }
            }
          }
        }
      }
    });
    for (i = 0, ln = xtypes.length; i < ln; i++) {
      xtype = xtypes[i];
      if (typeof xtype !== 'string' || xtype.length < 1) {
        throw new Error("[Ext.define] Invalid xtype of: '" + xtype + "' for class: '" + name + "'; must be a valid non-empty string");
      }
      Ext.Array.include(aliases, widgetPrefix + xtype);
    }
    data.alias = aliases;
  }, ['xtype', 'alias']);
  if (Ext.manifest) {
    var manifest = Ext.manifest, classes = manifest.classes, paths = manifest.paths, aliases = {}, alternates = {}, className, obj, name, path, baseUrl;
    if (paths) {
      if (manifest.bootRelative) {
        baseUrl = Ext.Boot.baseUrl;
        for (path in paths) {
          if (paths.hasOwnProperty(path)) {
            paths[path] = baseUrl + paths[path];
          }
        }
      }
      Manager.setPath(paths);
    }
    if (classes) {
      for (className in classes) {
        alternates[className] = [];
        aliases[className] = [];
        obj = classes[className];
        if (obj.alias) {
          aliases[className] = obj.alias;
        }
        if (obj.alternates) {
          alternates[className] = obj.alternates;
        }
      }
    }
    Manager.addAlias(aliases);
    Manager.addAlternate(alternates);
  }
  return Manager;
}(Ext.Class, Ext.Function.alias, Array.prototype.slice, Ext.Array.from, Ext.global);
(Ext.env || (Ext.env = {})).Browser = function(userAgent, publish) {
  var me = this, browserPrefixes = Ext.Boot.browserPrefixes, browserNames = Ext.Boot.browserNames, enginePrefixes = me.enginePrefixes, engineNames = me.engineNames, browserMatch = userAgent.match(new RegExp('((?:' + Ext.Object.getValues(browserPrefixes).join(')|(?:') + '))([\\w\\._]+)')), engineMatch = userAgent.match(new RegExp('((?:' + Ext.Object.getValues(enginePrefixes).join(')|(?:') + '))([\\w\\._]+)')), browserName = browserNames.other, engineName = engineNames.other, browserVersion = '', engineVersion = 
  '', majorVer = '', isWebView = false, i, prefix, mode, name, maxIEVersion;
  me.userAgent = userAgent;
  if (/Edge\//.test(userAgent)) {
    browserMatch = userAgent.match(/(Edge\/)([\w.]+)/);
  }
  if (browserMatch) {
    browserName = browserNames[Ext.Object.getKey(browserPrefixes, browserMatch[1])];
    if (browserName === 'Safari' && /^Opera/.test(userAgent)) {
      browserName = 'Opera';
    }
    browserVersion = new Ext.Version(browserMatch[2]);
  }
  if (engineMatch) {
    engineName = engineNames[Ext.Object.getKey(enginePrefixes, engineMatch[1])];
    engineVersion = new Ext.Version(engineMatch[2]);
  }
  if (engineName === 'Trident' && browserName !== 'IE') {
    browserName = 'IE';
    var version = userAgent.match(/.*rv:(\d+.\d+)/);
    if (version && version.length) {
      version = version[1];
      browserVersion = new Ext.Version(version);
    }
  }
  if (browserName && browserVersion) {
    Ext.setVersion(browserName, browserVersion);
  }
  if (userAgent.match(/FB/) && browserName === 'Other') {
    browserName = browserNames.safari;
    engineName = engineNames.webkit;
  }
  if (userAgent.match(/Android.*Chrome/g)) {
    browserName = 'ChromeMobile';
  }
  if (userAgent.match(/OPR/)) {
    browserName = 'Opera';
    browserMatch = userAgent.match(/OPR\/(\d+.\d+)/);
    browserVersion = new Ext.Version(browserMatch[1]);
  }
  Ext.apply(this, {engineName:engineName, engineVersion:engineVersion, name:browserName, version:browserVersion});
  this.setFlag(browserName, true, publish);
  if (browserVersion) {
    majorVer = browserVersion.getMajor() || '';
    if (me.is.IE) {
      majorVer = parseInt(majorVer, 10);
      mode = document.documentMode;
      if (mode === 7 || majorVer === 7 && mode !== 8 && mode !== 9 && mode !== 10) {
        majorVer = 7;
      } else {
        if (mode === 8 || majorVer === 8 && mode !== 8 && mode !== 9 && mode !== 10) {
          majorVer = 8;
        } else {
          if (mode === 9 || majorVer === 9 && mode !== 7 && mode !== 8 && mode !== 10) {
            majorVer = 9;
          } else {
            if (mode === 10 || majorVer === 10 && mode !== 7 && mode !== 8 && mode !== 9) {
              majorVer = 10;
            } else {
              if (mode === 11 || majorVer === 11 && mode !== 7 && mode !== 8 && mode !== 9 && mode !== 10) {
                majorVer = 11;
              }
            }
          }
        }
      }
      maxIEVersion = Math.max(majorVer, Ext.Boot.maxIEVersion);
      for (i = 7; i <= maxIEVersion; ++i) {
        prefix = 'isIE' + i;
        if (majorVer <= i) {
          Ext[prefix + 'm'] = true;
        }
        if (majorVer === i) {
          Ext[prefix] = true;
        }
        if (majorVer >= i) {
          Ext[prefix + 'p'] = true;
        }
      }
    }
    if (me.is.Opera && parseInt(majorVer, 10) <= 12) {
      Ext.isOpera12m = true;
    }
    Ext.chromeVersion = Ext.isChrome ? majorVer : 0;
    Ext.firefoxVersion = Ext.isFirefox ? majorVer : 0;
    Ext.ieVersion = Ext.isIE ? majorVer : 0;
    Ext.operaVersion = Ext.isOpera ? majorVer : 0;
    Ext.safariVersion = Ext.isSafari ? majorVer : 0;
    Ext.webKitVersion = Ext.isWebKit ? majorVer : 0;
    this.setFlag(browserName + majorVer, true, publish);
    this.setFlag(browserName + browserVersion.getShortVersion());
  }
  for (i in browserNames) {
    if (browserNames.hasOwnProperty(i)) {
      name = browserNames[i];
      this.setFlag(name, browserName === name);
    }
  }
  this.setFlag(name);
  if (engineVersion) {
    this.setFlag(engineName + (engineVersion.getMajor() || ''));
    this.setFlag(engineName + engineVersion.getShortVersion());
  }
  for (i in engineNames) {
    if (engineNames.hasOwnProperty(i)) {
      name = engineNames[i];
      this.setFlag(name, engineName === name, publish);
    }
  }
  this.setFlag('Standalone', !!navigator.standalone);
  this.setFlag('Ripple', !!document.getElementById('tinyhippos-injected') && !Ext.isEmpty(window.top.ripple));
  this.setFlag('WebWorks', !!window.blackberry);
  if (window.PhoneGap !== undefined || window.Cordova !== undefined || window.cordova !== undefined) {
    isWebView = true;
    this.setFlag('PhoneGap');
    this.setFlag('Cordova');
  }
  if (/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)(?!.*FBAN)/i.test(userAgent)) {
    isWebView = true;
  }
  this.setFlag('WebView', isWebView);
  this.isStrict = Ext.isStrict = document.compatMode === 'CSS1Compat';
  this.isSecure = Ext.isSecure;
  this.identity = browserName + majorVer + (this.isStrict ? 'Strict' : 'Quirks');
};
Ext.env.Browser.prototype = {constructor:Ext.env.Browser, engineNames:{webkit:'WebKit', gecko:'Gecko', presto:'Presto', trident:'Trident', other:'Other'}, enginePrefixes:{webkit:'AppleWebKit/', gecko:'Gecko/', presto:'Presto/', trident:'Trident/'}, styleDashPrefixes:{WebKit:'-webkit-', Gecko:'-moz-', Trident:'-ms-', Presto:'-o-', Other:''}, stylePrefixes:{WebKit:'Webkit', Gecko:'Moz', Trident:'ms', Presto:'O', Other:''}, propertyPrefixes:{WebKit:'webkit', Gecko:'moz', Trident:'ms', Presto:'o', Other:''}, 
is:function(name) {
  return !!this.is[name];
}, name:null, version:null, engineName:null, engineVersion:null, setFlag:function(name, value, publish) {
  if (value === undefined) {
    value = true;
  }
  this.is[name] = value;
  this.is[name.toLowerCase()] = value;
  if (publish) {
    Ext['is' + name] = value;
  }
  return this;
}, getStyleDashPrefix:function() {
  return this.styleDashPrefixes[this.engineName];
}, getStylePrefix:function() {
  return this.stylePrefixes[this.engineName];
}, getVendorProperyName:function(name) {
  var prefix = this.propertyPrefixes[this.engineName];
  if (prefix.length > 0) {
    return prefix + Ext.String.capitalize(name);
  }
  return name;
}, getPreferredTranslationMethod:function(config) {
  if (typeof config === 'object' && 'translationMethod' in config && config.translationMethod !== 'auto') {
    return config.translationMethod;
  } else {
    return 'csstransform';
  }
}};
(function(userAgent) {
  Ext.browser = new Ext.env.Browser(userAgent, true);
  Ext.userAgent = userAgent.toLowerCase();
  Ext.SSL_SECURE_URL = Ext.isSecure && Ext.isIE ? "javascript:''" : 'about:blank';
})(Ext.global.navigator.userAgent);
Ext.env.OS = function(userAgent, platform, browserScope) {
  var me = this, names = Ext.Boot.osNames, prefixes = Ext.Boot.osPrefixes, name, version = '', is = me.is, i, prefix, match, item, match1;
  browserScope = browserScope || Ext.browser;
  for (i in prefixes) {
    if (prefixes.hasOwnProperty(i)) {
      prefix = prefixes[i];
      match = userAgent.match(new RegExp('(?:' + prefix + ')([^\\s;]+)'));
      if (match) {
        name = names[i];
        match1 = match[1];
        if (match1 && match1 === 'HTC_') {
          version = new Ext.Version('2.3');
        } else {
          if (match1 && match1 === 'Silk/') {
            version = new Ext.Version('2.3');
          } else {
            version = new Ext.Version(match[match.length - 1]);
          }
        }
        break;
      }
    }
  }
  if (!name) {
    name = names[(userAgent.toLowerCase().match(/mac|win|linux/) || ['other'])[0]];
    version = new Ext.Version('');
  }
  this.name = name;
  this.version = version;
  if (platform) {
    this.setFlag(platform.replace(/ simulator$/i, ''));
  }
  this.setFlag(name);
  if (version) {
    this.setFlag(name + (version.getMajor() || ''));
    this.setFlag(name + version.getShortVersion());
  }
  for (i in names) {
    if (names.hasOwnProperty(i)) {
      item = names[i];
      if (!is.hasOwnProperty(name)) {
        this.setFlag(item, name === item);
      }
    }
  }
  if (this.name === 'iOS' && window.screen.height === 568) {
    this.setFlag('iPhone5');
  }
  if (browserScope.is.Safari || browserScope.is.Silk) {
    if (this.is.Android2 || this.is.Android3 || browserScope.version.shortVersion === 501) {
      browserScope.setFlag('AndroidStock');
    }
    if (this.is.Android4) {
      browserScope.setFlag('AndroidStock');
      browserScope.setFlag('AndroidStock4');
    }
  }
};
Ext.env.OS.prototype = {constructor:Ext.env.OS, is:function(name) {
  return !!this[name];
}, name:null, version:null, setFlag:function(name, value) {
  if (value === undefined) {
    value = true;
  }
  if (this.flags) {
    this.flags[name] = value;
  }
  this.is[name] = value;
  this.is[name.toLowerCase()] = value;
  return this;
}};
(function() {
  var navigation = Ext.global.navigator, userAgent = navigation.userAgent, OS = Ext.env.OS, is = Ext.is || (Ext.is = {}), osEnv, osName, deviceType;
  OS.prototype.flags = is;
  Ext.os = osEnv = new OS(userAgent, navigation.platform);
  osName = osEnv.name;
  Ext['is' + osName] = true;
  Ext.isMac = is.Mac = is.MacOS;
  var search = window.location.search.match(/deviceType=(Tablet|Phone)/), nativeDeviceType = window.deviceType;
  if (search && search[1]) {
    deviceType = search[1];
  } else {
    if (nativeDeviceType === 'iPhone') {
      deviceType = 'Phone';
    } else {
      if (nativeDeviceType === 'iPad') {
        deviceType = 'Tablet';
      } else {
        if (!osEnv.is.Android && !osEnv.is.iOS && !osEnv.is.WindowsPhone && /Windows|Linux|MacOS/.test(osName)) {
          deviceType = 'Desktop';
          Ext.browser.is.WebView = !!Ext.browser.is.Ripple;
        } else {
          if (osEnv.is.iPad || osEnv.is.RIMTablet || osEnv.is.Android3 || Ext.browser.is.Silk || osEnv.is.Android && userAgent.search(/mobile/i) === -1) {
            deviceType = 'Tablet';
          } else {
            deviceType = 'Phone';
          }
        }
      }
    }
  }
  osEnv.setFlag(deviceType, true);
  osEnv.deviceType = deviceType;
  delete OS.prototype.flags;
})();
Ext.feature = {has:function(name) {
  return !!this.has[name];
}, testElements:{}, getTestElement:function(tag, createNew) {
  if (tag === undefined) {
    tag = 'div';
  } else {
    if (typeof tag !== 'string') {
      return tag;
    }
  }
  if (createNew) {
    return document.createElement(tag);
  }
  if (!this.testElements[tag]) {
    this.testElements[tag] = document.createElement(tag);
  }
  return this.testElements[tag];
}, isStyleSupported:function(name, tag) {
  var elementStyle = this.getTestElement(tag).style, cName = Ext.String.capitalize(name);
  if (typeof elementStyle[name] !== 'undefined' || typeof elementStyle[Ext.browser.getStylePrefix(name) + cName] !== 'undefined') {
    return true;
  }
  return false;
}, isStyleSupportedWithoutPrefix:function(name, tag) {
  var elementStyle = this.getTestElement(tag).style;
  if (typeof elementStyle[name] !== 'undefined') {
    return true;
  }
  return false;
}, isEventSupported:function(name, tag) {
  if (tag === undefined) {
    tag = window;
  }
  var element = this.getTestElement(tag), eventName = 'on' + name.toLowerCase(), isSupported = eventName in element;
  if (!isSupported) {
    if (element.setAttribute && element.removeAttribute) {
      element.setAttribute(eventName, '');
      isSupported = typeof element[eventName] === 'function';
      if (typeof element[eventName] !== 'undefined') {
        element[eventName] = undefined;
      }
      element.removeAttribute(eventName);
    }
  }
  return isSupported;
}, getStyle:function(element, styleName) {
  var view = element.ownerDocument.defaultView, style = view ? view.getComputedStyle(element, null) : element.currentStyle;
  return (style || element.style)[styleName];
}, getSupportedPropertyName:function(object, name) {
  var vendorName = Ext.browser.getVendorProperyName(name);
  if (vendorName in object) {
    return vendorName;
  } else {
    if (name in object) {
      return name;
    }
  }
  return null;
}, detect:function(isReady) {
  var me = this, doc = document, toRun = me.toRun || me.tests, n = toRun.length, div = doc.createElement('div'), notRun = [], supports = Ext.supports, has = me.has, name, names, test, vector, value;
  div.innerHTML = '\x3cdiv style\x3d"height:30px;width:50px;"\x3e' + '\x3cdiv style\x3d"height:20px;width:20px;"\x3e\x3c/div\x3e' + '\x3c/div\x3e' + '\x3cdiv style\x3d"width: 200px; height: 200px; position: relative; padding: 5px;"\x3e' + '\x3cdiv style\x3d"position: absolute; top: 0; left: 0; width: 100%; height: 100%;"\x3e\x3c/div\x3e' + '\x3c/div\x3e' + '\x3cdiv style\x3d"position: absolute; left: 10%; top: 10%;"\x3e\x3c/div\x3e' + '\x3cdiv style\x3d"float:left; background-color:transparent;"\x3e\x3c/div\x3e';
  if (isReady) {
    doc.body.appendChild(div);
  }
  vector = me.preDetected[Ext.browser.identity] || [];
  while (n--) {
    test = toRun[n];
    value = vector[n];
    name = test.name;
    names = test.names;
    if (value === undefined) {
      if (!isReady && test.ready) {
        notRun.push(test);
        continue;
      }
      value = test.fn.call(me, doc, div);
    }
    if (name) {
      supports[name] = has[name] = value;
    } else {
      if (names) {
        while (names.length) {
          name = names.pop();
          supports[name] = has[name] = value;
        }
      }
    }
  }
  if (isReady) {
    doc.body.removeChild(div);
  }
  me.toRun = notRun;
}, report:function() {
  var values = [], len = this.tests.length, i;
  for (i = 0; i < len; ++i) {
    values.push(this.has[this.tests[i].name] ? 1 : 0);
  }
  Ext.log(Ext.browser.identity + ': [' + values.join(',') + ']');
}, preDetected:{}, tests:[{name:'CloneNodeCopiesExpando', fn:function() {
  var el = document.createElement('div');
  el.expandoProp = {};
  return el.cloneNode().expandoProp === el.expandoProp;
}}, {name:'CSSPointerEvents', fn:function(doc) {
  return 'pointerEvents' in doc.documentElement.style;
}}, {name:'CSS3BoxShadow', fn:function(doc) {
  return 'boxShadow' in doc.documentElement.style || 'WebkitBoxShadow' in doc.documentElement.style || 'MozBoxShadow' in doc.documentElement.style;
}}, {name:'CSS3NegationSelector', fn:function(doc) {
  try {
    doc.querySelectorAll('foo:not(bar)');
  } catch (e$2) {
    return false;
  }
  return true;
}}, {name:'ClassList', fn:function(doc) {
  return !!doc.documentElement.classList;
}}, {name:'Canvas', fn:function() {
  var element = this.getTestElement('canvas');
  return !!(element && element.getContext && element.getContext('2d'));
}}, {name:'Svg', fn:function(doc) {
  return !!(doc.createElementNS && !!doc.createElementNS('http:/' + '/www.w3.org/2000/svg', 'svg').createSVGRect);
}}, {name:'Vml', fn:function() {
  var element = this.getTestElement(), ret = false;
  element.innerHTML = '\x3c!--[if vml]\x3e\x3cbr\x3e\x3c![endif]--\x3e';
  ret = element.childNodes.length === 1;
  element.innerHTML = '';
  return ret;
}}, {name:'touchScroll', fn:function() {
  var touchScroll = 0;
  if (Ext.os.is.Desktop && (navigator.maxTouchPoints || navigator.msMaxTouchPoints)) {
    touchScroll = 1;
  } else {
    if (Ext.supports.Touch) {
      touchScroll = 2;
    }
  }
  return touchScroll;
}}, {name:'Touch', fn:function() {
  var maxTouchPoints = navigator.msMaxTouchPoints || navigator.maxTouchPoints;
  if (Ext.browser.is.Chrome && Ext.browser.version.isLessThanOrEqual(39)) {
    return Ext.supports.TouchEvents && maxTouchPoints !== 1 || maxTouchPoints > 1;
  } else {
    return Ext.supports.TouchEvents || maxTouchPoints > 0;
  }
}}, {name:'TouchEvents', fn:function() {
  return this.isEventSupported('touchend');
}}, {name:'PointerEvents', fn:function() {
  return navigator.pointerEnabled;
}}, {name:'MSPointerEvents', fn:function() {
  return navigator.msPointerEnabled;
}}, {name:'Orientation', fn:function() {
  return 'orientation' in window && this.isEventSupported('orientationchange');
}}, {name:'OrientationChange', fn:function() {
  return this.isEventSupported('orientationchange');
}}, {name:'DeviceMotion', fn:function() {
  return this.isEventSupported('devicemotion');
}}, {names:['Geolocation', 'GeoLocation'], fn:function() {
  return 'geolocation' in window.navigator;
}}, {name:'SqlDatabase', fn:function() {
  return 'openDatabase' in window;
}}, {name:'WebSockets', fn:function() {
  return 'WebSocket' in window;
}}, {name:'Range', fn:function() {
  return !!document.createRange;
}}, {name:'CreateContextualFragment', fn:function() {
  var range = !!document.createRange ? document.createRange() : false;
  return range && !!range.createContextualFragment;
}}, {name:'History', fn:function() {
  return 'history' in window && 'pushState' in window.history;
}}, {name:'Css3dTransforms', fn:function() {
  return this.has('CssTransforms') && this.isStyleSupported('perspective');
}}, {name:'CssTransforms', fn:function() {
  return this.isStyleSupported('transform');
}}, {name:'CssTransformNoPrefix', fn:function() {
  return this.isStyleSupportedWithoutPrefix('transform');
}}, {name:'CssAnimations', fn:function() {
  return this.isStyleSupported('animationName');
}}, {names:['CssTransitions', 'Transitions'], fn:function() {
  return this.isStyleSupported('transitionProperty');
}}, {names:['Audio', 'AudioTag'], fn:function() {
  return !!this.getTestElement('audio').canPlayType;
}}, {name:'Video', fn:function() {
  return !!this.getTestElement('video').canPlayType;
}}, {name:'LocalStorage', fn:function() {
  try {
    if ('localStorage' in window && window['localStorage'] !== null) {
      localStorage.setItem('sencha-localstorage-test', 'test success');
      localStorage.removeItem('sencha-localstorage-test');
      return true;
    }
  } catch (e$3) {
  }
  return false;
}}, {name:'XHR2', fn:function() {
  return window.ProgressEvent && window.FormData && window.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest;
}}, {name:'XHRUploadProgress', fn:function() {
  if (window.XMLHttpRequest && !Ext.browser.is.AndroidStock) {
    var xhr = new XMLHttpRequest;
    return xhr && 'upload' in xhr && 'onprogress' in xhr.upload;
  }
  return false;
}}, {name:'NumericInputPlaceHolder', fn:function() {
  return !(Ext.browser.is.AndroidStock4 && Ext.os.version.getMinor() < 2);
}}, {name:'matchesSelector', fn:function() {
  var el = document.documentElement, w3 = 'matches', wk = 'webkitMatchesSelector', ms = 'msMatchesSelector', mz = 'mozMatchesSelector';
  return el[w3] ? w3 : el[wk] ? wk : el[ms] ? ms : el[mz] ? mz : null;
}}, {name:'RightMargin', ready:true, fn:function(doc, div) {
  var view = doc.defaultView;
  return !(view && view.getComputedStyle(div.firstChild.firstChild, null).marginRight !== '0px');
}}, {name:'DisplayChangeInputSelectionBug', fn:function() {
  var webKitVersion = Ext.webKitVersion;
  return 0 < webKitVersion && webKitVersion < 533;
}}, {name:'DisplayChangeTextAreaSelectionBug', fn:function() {
  var webKitVersion = Ext.webKitVersion;
  return 0 < webKitVersion && webKitVersion < 534.24;
}}, {name:'TransparentColor', ready:true, fn:function(doc, div, view) {
  view = doc.defaultView;
  return !(view && view.getComputedStyle(div.lastChild, null).backgroundColor !== 'transparent');
}}, {name:'ComputedStyle', ready:true, fn:function(doc, div, view) {
  view = doc.defaultView;
  return view && view.getComputedStyle;
}}, {name:'Float', fn:function(doc) {
  return 'cssFloat' in doc.documentElement.style;
}}, {name:'CSS3BorderRadius', ready:true, fn:function(doc) {
  var domPrefixes = ['borderRadius', 'BorderRadius', 'MozBorderRadius', 'WebkitBorderRadius', 'OBorderRadius', 'KhtmlBorderRadius'], pass = false, i;
  for (i = 0; i < domPrefixes.length; i++) {
    if (doc.documentElement.style[domPrefixes[i]] !== undefined) {
      pass = true;
    }
  }
  return pass && !Ext.isIE9;
}}, {name:'CSS3LinearGradient', fn:function(doc, div) {
  var property = 'background-image:', webkit = '-webkit-gradient(linear, left top, right bottom, from(black), to(white))', w3c = 'linear-gradient(left top, black, white)', moz = '-moz-' + w3c, ms = '-ms-' + w3c, opera = '-o-' + w3c, options = [property + webkit, property + w3c, property + moz, property + ms, property + opera];
  div.style.cssText = options.join(';');
  return ('' + div.style.backgroundImage).indexOf('gradient') !== -1 && !Ext.isIE9;
}}, {name:'MouseEnterLeave', fn:function(doc) {
  return 'onmouseenter' in doc.documentElement && 'onmouseleave' in doc.documentElement;
}}, {name:'MouseWheel', fn:function(doc) {
  return 'onmousewheel' in doc.documentElement;
}}, {name:'Opacity', fn:function(doc, div) {
  if (Ext.isIE8) {
    return false;
  }
  div.firstChild.style.cssText = 'opacity:0.73';
  return div.firstChild.style.opacity == '0.73';
}}, {name:'Placeholder', fn:function(doc) {
  return 'placeholder' in doc.createElement('input');
}}, {name:'Direct2DBug', fn:function(doc) {
  return Ext.isString(doc.documentElement.style.msTransformOrigin) && Ext.isIE9m;
}}, {name:'BoundingClientRect', fn:function(doc) {
  return 'getBoundingClientRect' in doc.documentElement;
}}, {name:'RotatedBoundingClientRect', ready:true, fn:function(doc) {
  var body = doc.body, supports = false, el = doc.createElement('div'), style = el.style;
  if (el.getBoundingClientRect) {
    style.position = 'absolute';
    style.top = '0';
    style.WebkitTransform = style.MozTransform = style.msTransform = style.OTransform = style.transform = 'rotate(90deg)';
    style.width = '100px';
    style.height = '30px';
    body.appendChild(el);
    supports = el.getBoundingClientRect().height !== 100;
    body.removeChild(el);
  }
  return supports;
}}, {name:'ChildContentClearedWhenSettingInnerHTML', ready:true, fn:function() {
  var el = this.getTestElement(), child;
  el.innerHTML = '\x3cdiv\x3ea\x3c/div\x3e';
  child = el.firstChild;
  el.innerHTML = '\x3cdiv\x3eb\x3c/div\x3e';
  return child.innerHTML !== 'a';
}}, {name:'IncludePaddingInWidthCalculation', ready:true, fn:function(doc, div) {
  return div.childNodes[1].firstChild.offsetWidth === 210;
}}, {name:'IncludePaddingInHeightCalculation', ready:true, fn:function(doc, div) {
  return div.childNodes[1].firstChild.offsetHeight === 210;
}}, {name:'TextAreaMaxLength', fn:function(doc) {
  return 'maxlength' in doc.createElement('textarea');
}}, {name:'GetPositionPercentage', ready:true, fn:function(doc, div) {
  return Ext.feature.getStyle(div.childNodes[2], 'left') === '10%';
}}, {name:'PercentageHeightOverflowBug', ready:true, fn:function(doc) {
  var hasBug = false, style, el;
  if (Ext.getScrollbarSize().height) {
    el = this.getTestElement();
    style = el.style;
    style.height = '50px';
    style.width = '50px';
    style.overflow = 'auto';
    style.position = 'absolute';
    el.innerHTML = ['\x3cdiv style\x3d"display:table;height:100%;"\x3e', '\x3cdiv style\x3d"width:51px;"\x3e\x3c/div\x3e', '\x3c/div\x3e'].join('');
    doc.body.appendChild(el);
    if (el.firstChild.offsetHeight === 50) {
      hasBug = true;
    }
    doc.body.removeChild(el);
  }
  return hasBug;
}}, {name:'xOriginBug', ready:true, fn:function(doc, div) {
  div.innerHTML = '\x3cdiv id\x3d"b1" style\x3d"height:100px;width:100px;direction:rtl;position:relative;overflow:scroll"\x3e' + '\x3cdiv id\x3d"b2" style\x3d"position:relative;width:100%;height:20px;"\x3e\x3c/div\x3e' + '\x3cdiv id\x3d"b3" style\x3d"position:absolute;width:20px;height:20px;top:0px;right:0px"\x3e\x3c/div\x3e' + '\x3c/div\x3e';
  var outerBox = document.getElementById('b1').getBoundingClientRect(), b2 = document.getElementById('b2').getBoundingClientRect(), b3 = document.getElementById('b3').getBoundingClientRect();
  return b2.left !== outerBox.left && b3.right !== outerBox.right;
}}, {name:'ScrollWidthInlinePaddingBug', ready:true, fn:function(doc) {
  var hasBug = false, style, el;
  el = doc.createElement('div');
  style = el.style;
  style.height = '50px';
  style.width = '50px';
  style.padding = '10px';
  style.overflow = 'hidden';
  style.position = 'absolute';
  el.innerHTML = '\x3cspan style\x3d"display:inline-block;zoom:1;height:60px;width:60px;"\x3e\x3c/span\x3e';
  doc.body.appendChild(el);
  if (el.scrollWidth === 70) {
    hasBug = true;
  }
  doc.body.removeChild(el);
  return hasBug;
}}, {name:'rtlVertScrollbarOnRight', ready:true, fn:function(doc, div) {
  div.innerHTML = '\x3cdiv style\x3d"height:100px;width:100px;direction:rtl;overflow:scroll"\x3e' + '\x3cdiv style\x3d"width:20px;height:200px;"\x3e\x3c/div\x3e' + '\x3c/div\x3e';
  var outerBox = div.firstChild, innerBox = outerBox.firstChild;
  return innerBox.offsetLeft + innerBox.offsetWidth !== outerBox.offsetLeft + outerBox.offsetWidth;
}}, {name:'rtlVertScrollbarOverflowBug', ready:true, fn:function(doc, div) {
  div.innerHTML = '\x3cdiv style\x3d"height:100px;width:100px;direction:rtl;overflow:auto"\x3e' + '\x3cdiv style\x3d"width:95px;height:200px;"\x3e\x3c/div\x3e' + '\x3c/div\x3e';
  var outerBox = div.firstChild;
  return outerBox.clientHeight === outerBox.offsetHeight;
}}, {identity:'defineProperty', fn:function() {
  if (Ext.isIE8m) {
    Ext.Object.defineProperty = Ext.emptyFn;
    return false;
  }
  return true;
}}, {identify:'nativeXhr', fn:function() {
  if (typeof XMLHttpRequest !== 'undefined') {
    return true;
  }
  XMLHttpRequest = function() {
    try {
      return new ActiveXObject('MSXML2.XMLHTTP.3.0');
    } catch (ex) {
      return null;
    }
  };
  return false;
}}, {name:'SpecialKeyDownRepeat', fn:function() {
  return Ext.isWebKit ? parseInt(navigator.userAgent.match(/AppleWebKit\/(\d+)/)[1], 10) >= 525 : !(Ext.isGecko && !Ext.isWindows || Ext.isOpera && Ext.operaVersion < 12);
}}, {name:'EmulatedMouseOver', fn:function() {
  return Ext.os.is.iOS;
}}, {name:'Hashchange', fn:function() {
  var docMode = document.documentMode;
  return 'onhashchange' in window && (docMode === undefined || docMode > 7);
}}, {name:'FixedTableWidthBug', ready:true, fn:function() {
  if (Ext.isIE8) {
    return false;
  }
  var outer = document.createElement('div'), inner = document.createElement('div'), width;
  outer.setAttribute('style', 'display:table;table-layout:fixed;');
  inner.setAttribute('style', 'display:table-cell;min-width:50px;');
  outer.appendChild(inner);
  document.body.appendChild(outer);
  outer.offsetWidth;
  outer.style.width = '25px';
  width = outer.offsetWidth;
  document.body.removeChild(outer);
  return width === 50;
}}, {name:'FocusinFocusoutEvents', fn:function() {
  return !Ext.isGecko;
}}, {name:'AsyncFocusEvents', fn:function() {
  return Ext.asyncFocus = !!Ext.isIE;
}}, {name:'accessibility', ready:true, fn:function(doc) {
  var body = doc.body, div, img, style, supports, bgImg;
  function getColor(colorTxt) {
    var values = [], colorValue = 0, regex, match;
    if (colorTxt.indexOf('rgb(') !== -1) {
      values = colorTxt.replace('rgb(', '').replace(')', '').split(', ');
    } else {
      if (colorTxt.indexOf('#') !== -1) {
        regex = colorTxt.length === 7 ? /^#(\S\S)(\S\S)(\S\S)$/ : /^#(\S)(\S)(\S)$/;
        match = colorTxt.match(regex);
        if (match) {
          values = ['0x' + match[1], '0x' + match[2], '0x' + match[3]];
        }
      }
    }
    for (var i = 0; i < values.length; i++) {
      colorValue += parseInt(values[i]);
    }
    return colorValue;
  }
  div = doc.createElement('div');
  img = doc.createElement('img');
  style = div.style;
  Ext.apply(style, {width:'2px', position:'absolute', clip:'rect(1px,1px,1px,1px)', borderWidth:'1px', borderStyle:'solid', borderTopTolor:'#f00', borderRightColor:'#ff0', backgroundColor:'#fff', backgroundImage:'url(' + Ext.BLANK_IMAGE_URL + ')'});
  img.alt = '';
  img.src = Ext.BLANK_IMAGE_URL;
  div.appendChild(img);
  body.appendChild(div);
  style = div.currentStyle || div.style;
  bgImg = style.backgroundImage;
  supports = {Images:img.offsetWidth === 1 && img.readyState !== 'uninitialized', BackgroundImages:!(bgImg !== null && (bgImg === 'none' || bgImg === 'url(invalid-url:)')), BorderColors:style.borderTopColor !== style.borderRightColor, LightOnDark:getColor(style.color) - getColor(style.backgroundColor) > 0};
  Ext.supports.HighContrastMode = !supports.BackgroundImages;
  body.removeChild(div);
  div = img = null;
  return supports;
}}, 0]};
Ext.feature.tests.pop();
Ext.supports = {};
Ext.feature.detect();
Ext.env.Ready = {blocks:(location.search || '').indexOf('ext-pauseReadyFire') > 0 ? 1 : 0, bound:0, delay:1, events:[], firing:false, generation:0, listeners:[], nextId:0, sortGeneration:0, state:0, timer:null, bind:function() {
  var me = Ext.env.Ready, doc = document;
  if (!me.bound) {
    if (doc.readyState === 'complete') {
      me.onReadyEvent({type:doc.readyState || 'body'});
    } else {
      me.bound = 1;
      if (Ext.browser.is.PhoneGap && !Ext.os.is.Desktop) {
        me.bound = 2;
        doc.addEventListener('deviceready', me.onReadyEvent, false);
      }
      doc.addEventListener('DOMContentLoaded', me.onReadyEvent, false);
      window.addEventListener('load', me.onReadyEvent, false);
    }
  }
}, block:function() {
  ++this.blocks;
  Ext.isReady = false;
}, fireReady:function() {
  var me = Ext.env.Ready;
  if (!me.state) {
    Ext._readyTime = Ext.ticks();
    Ext.isDomReady = true;
    me.state = 1;
    Ext.feature.detect(true);
    if (!me.delay) {
      me.handleReady();
    } else {
      if (navigator.standalone) {
        me.timer = Ext.defer(function() {
          me.timer = null;
          me.handleReadySoon();
        }, 1);
      } else {
        me.handleReadySoon();
      }
    }
  }
}, handleReady:function() {
  var me = this;
  if (me.state === 1) {
    me.state = 2;
    Ext._beforeReadyTime = Ext.ticks();
    me.invokeAll();
    Ext._afterReadyTime = Ext.ticks();
  }
}, handleReadySoon:function(delay) {
  var me = this;
  if (!me.timer) {
    me.timer = Ext.defer(function() {
      me.timer = null;
      me.handleReady();
    }, delay || me.delay);
  }
}, invoke:function(listener) {
  var delay = listener.delay;
  if (delay) {
    Ext.defer(listener.fn, delay, listener.scope);
  } else {
    if (Ext.elevateFunction) {
      Ext.elevateFunction(listener.fn, listener.scope);
    } else {
      listener.fn.call(listener.scope);
    }
  }
}, invokeAll:function() {
  if (Ext.elevateFunction) {
    Ext.elevateFunction(this.doInvokeAll, this);
  } else {
    this.doInvokeAll();
  }
}, doInvokeAll:function() {
  var me = this, listeners = me.listeners, listener;
  if (!me.blocks) {
    Ext.isReady = true;
  }
  me.firing = true;
  while (listeners.length) {
    if (me.sortGeneration !== me.generation) {
      me.sortGeneration = me.generation;
      listeners.sort(me.sortFn);
    }
    listener = listeners.pop();
    if (me.blocks && !listener.dom) {
      listeners.push(listener);
      break;
    }
    me.invoke(listener);
  }
  me.firing = false;
}, makeListener:function(fn, scope, options) {
  var ret = {fn:fn, id:++this.nextId, scope:scope, dom:false, priority:0};
  if (options) {
    Ext.apply(ret, options);
  }
  ret.phase = ret.dom ? 0 : 1;
  return ret;
}, on:function(fn, scope, options) {
  var me = Ext.env.Ready, listener = me.makeListener(fn, scope, options);
  if (me.state === 2 && !me.firing && (listener.dom || !me.blocks)) {
    me.invoke(listener);
  } else {
    me.listeners.push(listener);
    ++me.generation;
    if (!me.bound) {
      me.bind();
    }
  }
}, onReadyEvent:function(ev) {
  var me = Ext.env.Ready;
  if (Ext.elevateFunction) {
    Ext.elevateFunction(me.doReadyEvent, me, arguments);
  } else {
    me.doReadyEvent(ev);
  }
}, doReadyEvent:function(ev) {
  var me = this;
  if (ev && ev.type) {
    me.events.push(ev);
  }
  if (me.bound > 0) {
    me.unbind();
    me.bound = -1;
  }
  if (!me.state) {
    me.fireReady();
  }
}, sortFn:function(a, b) {
  return -(a.phase - b.phase || b.priority - a.priority || a.id - b.id);
}, unblock:function() {
  var me = this;
  if (me.blocks) {
    if (!--me.blocks) {
      if (me.state === 2 && !me.firing) {
        me.invokeAll();
      }
    }
  }
}, unbind:function() {
  var me = this, doc = document;
  if (me.bound > 1) {
    doc.removeEventListener('deviceready', me.onReadyEvent, false);
  }
  doc.removeEventListener('DOMContentLoaded', me.onReadyEvent, false);
  window.removeEventListener('load', me.onReadyEvent, false);
}};
(function() {
  var Ready = Ext.env.Ready;
  if (Ext.isIE9m) {
    Ext.apply(Ready, {scrollTimer:null, readyStatesRe:/complete/i, pollScroll:function() {
      var scrollable = true;
      try {
        document.documentElement.doScroll('left');
      } catch (e$4) {
        scrollable = false;
      }
      if (scrollable && document.body) {
        Ready.onReadyEvent({type:'doScroll'});
      } else {
        Ready.scrollTimer = Ext.defer(Ready.pollScroll, 20);
      }
      return scrollable;
    }, bind:function() {
      if (Ready.bound) {
        return;
      }
      var doc = document, topContext;
      try {
        topContext = window.frameElement === undefined;
      } catch (e$5) {
      }
      if (!topContext || !doc.documentElement.doScroll) {
        Ready.pollScroll = Ext.emptyFn;
      } else {
        if (Ready.pollScroll()) {
          return;
        }
      }
      if (doc.readyState === 'complete') {
        Ready.onReadyEvent({type:'already ' + (doc.readyState || 'body')});
      } else {
        doc.attachEvent('onreadystatechange', Ready.onReadyStateChange);
        window.attachEvent('onload', Ready.onReadyEvent);
        Ready.bound = 1;
      }
    }, unbind:function() {
      document.detachEvent('onreadystatechange', Ready.onReadyStateChange);
      window.detachEvent('onload', Ready.onReadyEvent);
      if (Ext.isNumber(Ready.scrollTimer)) {
        clearTimeout(Ready.scrollTimer);
        Ready.scrollTimer = null;
      }
    }, onReadyStateChange:function() {
      var state = document.readyState;
      if (Ready.readyStatesRe.test(state)) {
        Ready.onReadyEvent({type:state});
      }
    }});
  }
  Ext.onDocumentReady = function(fn, scope, options) {
    var opt = {dom:true};
    if (options) {
      Ext.apply(opt, options);
    }
    Ready.on(fn, scope, opt);
  };
  Ext.onReady = function(fn, scope, options) {
    Ready.on(fn, scope, options);
  };
  Ext.onInternalReady = function(fn, scope, options) {
    Ready.on(fn, scope, Ext.apply({priority:1000}, options));
  };
  Ready.bind();
})();
Ext.Loader = new function() {
  var Loader = this, Manager = Ext.ClassManager, Boot = Ext.Boot, Class = Ext.Class, Ready = Ext.env.Ready, alias = Ext.Function.alias, dependencyProperties = ['extend', 'mixins', 'requires'], isInHistory = {}, history = [], readyListeners = [], usedClasses = [], _requiresMap = {}, _missingQueue = {}, _config = {enabled:true, scriptChainDelay:false, disableCaching:true, disableCachingParam:'_dc', paths:Manager.paths, preserveScripts:true, scriptCharset:undefined}, delegatedConfigs = {disableCaching:true, 
  disableCachingParam:true, preserveScripts:true, scriptChainDelay:'loadDelay'};
  Ext.apply(Loader, {isInHistory:isInHistory, isLoading:false, history:history, config:_config, readyListeners:readyListeners, optionalRequires:usedClasses, requiresMap:_requiresMap, hasFileLoadError:false, scriptsLoading:0, classesLoading:[], syncModeEnabled:false, missingQueue:_missingQueue, init:function() {
    var scripts = document.getElementsByTagName('script'), src = scripts[scripts.length - 1].src, path = src.substring(0, src.lastIndexOf('/') + 1), meta = Ext._classPathMetadata, microloader = Ext.Microloader, manifest = Ext.manifest, loadOrder, baseUrl, loadlen, l, loadItem;
    if (src.indexOf('packages/core/src/') !== -1) {
      path = path + '../../';
    } else {
      if (src.indexOf('/core/src/class/') !== -1) {
        path = path + '../../../';
      }
    }
    if (!Manager.getPath('Ext')) {
      Manager.setPath('Ext', path + 'src');
    }
    if (meta) {
      Ext._classPathMetadata = null;
      Loader.addClassPathMappings(meta);
    }
    if (manifest) {
      loadOrder = manifest.loadOrder;
      baseUrl = Ext.Boot.baseUrl;
      if (loadOrder && manifest.bootRelative) {
        for (loadlen = loadOrder.length, l = 0; l < loadlen; l++) {
          loadItem = loadOrder[l];
          loadItem.path = baseUrl + loadItem.path;
        }
      }
    }
    if (microloader) {
      Ready.block();
      microloader.onMicroloaderReady(function() {
        Ready.unblock();
      });
    }
  }, setConfig:Ext.Function.flexSetter(function(name, value) {
    if (name === 'paths') {
      Loader.setPath(value);
    } else {
      _config[name] = value;
      var delegated = delegatedConfigs[name];
      if (delegated) {
        Boot.setConfig(delegated === true ? name : delegated, value);
      }
    }
    return Loader;
  }), getConfig:function(name) {
    return name ? _config[name] : _config;
  }, setPath:function() {
    Manager.setPath.apply(Manager, arguments);
    return Loader;
  }, addClassPathMappings:function(paths) {
    Manager.setPath(paths);
    return Loader;
  }, addBaseUrlClassPathMappings:function(pathConfig) {
    for (var name in pathConfig) {
      pathConfig[name] = Boot.baseUrl + pathConfig[name];
    }
    Ext.Loader.addClassPathMappings(pathConfig);
  }, getPath:function(className) {
    return Manager.getPath(className);
  }, require:function(expressions, fn, scope, excludes) {
    if (excludes) {
      return Loader.exclude(excludes).require(expressions, fn, scope);
    }
    var classNames = Manager.getNamesByExpression(expressions);
    return Loader.load(classNames, fn, scope);
  }, syncRequire:function() {
    var wasEnabled = Loader.syncModeEnabled;
    Loader.syncModeEnabled = true;
    var ret = Loader.require.apply(Loader, arguments);
    Loader.syncModeEnabled = wasEnabled;
    return ret;
  }, exclude:function(excludes) {
    var selector = Manager.select({require:function(classNames, fn, scope) {
      return Loader.load(classNames, fn, scope);
    }, syncRequire:function(classNames, fn, scope) {
      var wasEnabled = Loader.syncModeEnabled;
      Loader.syncModeEnabled = true;
      var ret = Loader.load(classNames, fn, scope);
      Loader.syncModeEnabled = wasEnabled;
      return ret;
    }});
    selector.exclude(excludes);
    return selector;
  }, load:function(classNames, callback, scope) {
    if (callback) {
      if (callback.length) {
        callback = Loader.makeLoadCallback(classNames, callback);
      }
      callback = callback.bind(scope || Ext.global);
    }
    var missingClassNames = [], numClasses = classNames.length, className, i, numMissing, urls = [], state = Manager.classState;
    for (i = 0; i < numClasses; ++i) {
      className = Manager.resolveName(classNames[i]);
      if (!Manager.isCreated(className)) {
        missingClassNames.push(className);
        _missingQueue[className] = Loader.getPath(className);
        if (!state[className]) {
          urls.push(_missingQueue[className]);
        }
      }
    }
    numMissing = missingClassNames.length;
    if (numMissing) {
      Loader.missingCount += numMissing;
      Ext.Array.push(Loader.classesLoading, missingClassNames);
      Manager.onCreated(function() {
        Ext.Array.remove(Loader.classesLoading, missingClassNames);
        Ext.each(missingClassNames, function(name) {
          Ext.Array.remove(Loader.classesLoading, name);
        });
        if (callback) {
          Ext.callback(callback, scope, arguments);
        }
        Loader.checkReady();
      }, Loader, missingClassNames);
      if (!_config.enabled) {
        Ext.raise('Ext.Loader is not enabled, so dependencies cannot be resolved dynamically. ' + 'Missing required class' + (missingClassNames.length > 1 ? 'es' : '') + ': ' + missingClassNames.join(', '));
      }
      if (urls.length) {
        Loader.loadScripts({url:urls, _classNames:missingClassNames});
      } else {
        Loader.checkReady();
      }
    } else {
      if (callback) {
        callback.call(scope);
      }
      Loader.checkReady();
    }
    if (Loader.syncModeEnabled) {
      if (numClasses === 1) {
        return Manager.get(classNames[0]);
      }
    }
    return Loader;
  }, makeLoadCallback:function(classNames, callback) {
    return function() {
      var classes = [], i = classNames.length;
      while (i-- > 0) {
        classes[i] = Manager.get(classNames[i]);
      }
      return callback.apply(this, classes);
    };
  }, onLoadFailure:function() {
    var options = this, onError = options.onError;
    Loader.hasFileLoadError = true;
    --Loader.scriptsLoading;
    if (onError) {
      onError.call(options.userScope, options);
    } else {
      Ext.log.error('[Ext.Loader] Some requested files failed to load.');
    }
    Loader.checkReady();
  }, onLoadSuccess:function() {
    var options = this, onLoad = options.onLoad;
    --Loader.scriptsLoading;
    if (onLoad) {
      onLoad.call(options.userScope, options);
    }
    Loader.checkReady();
  }, reportMissingClasses:function() {
    if (!Loader.syncModeEnabled && !Loader.scriptsLoading && Loader.isLoading && !Loader.hasFileLoadError) {
      var missingClasses = [], missingPaths = [];
      for (var missingClassName in _missingQueue) {
        missingClasses.push(missingClassName);
        missingPaths.push(_missingQueue[missingClassName]);
      }
      if (missingClasses.length) {
        throw new Error('The following classes are not declared even if their files have been ' + "loaded: '" + missingClasses.join("', '") + "'. Please check the source code of their " + "corresponding files for possible typos: '" + missingPaths.join("', '"));
      }
    }
  }, onReady:function(fn, scope, withDomReady, options) {
    if (withDomReady) {
      Ready.on(fn, scope, options);
    } else {
      var listener = Ready.makeListener(fn, scope, options);
      if (Loader.isLoading) {
        readyListeners.push(listener);
      } else {
        Ready.invoke(listener);
      }
    }
  }, addUsedClasses:function(classes) {
    var cls, i, ln;
    if (classes) {
      classes = typeof classes === 'string' ? [classes] : classes;
      for (i = 0, ln = classes.length; i < ln; i++) {
        cls = classes[i];
        if (typeof cls === 'string' && !Ext.Array.contains(usedClasses, cls)) {
          usedClasses.push(cls);
        }
      }
    }
    return Loader;
  }, triggerReady:function() {
    var listener, refClasses = usedClasses;
    if (Loader.isLoading && refClasses.length) {
      usedClasses = [];
      Loader.require(refClasses);
    } else {
      Loader.isLoading = false;
      readyListeners.sort(Ready.sortFn);
      while (readyListeners.length && !Loader.isLoading) {
        listener = readyListeners.pop();
        Ready.invoke(listener);
      }
      Ready.unblock();
    }
  }, historyPush:function(className) {
    if (className && !isInHistory[className] && !Manager.overrideMap[className]) {
      isInHistory[className] = true;
      history.push(className);
    }
    return Loader;
  }, loadScripts:function(params) {
    var manifest = Ext.manifest, loadOrder = manifest && manifest.loadOrder, loadOrderMap = manifest && manifest.loadOrderMap, options;
    ++Loader.scriptsLoading;
    if (loadOrder && !loadOrderMap) {
      manifest.loadOrderMap = loadOrderMap = Boot.createLoadOrderMap(loadOrder);
    }
    Loader.checkReady();
    options = Ext.apply({loadOrder:loadOrder, loadOrderMap:loadOrderMap, charset:_config.scriptCharset, success:Loader.onLoadSuccess, failure:Loader.onLoadFailure, sync:Loader.syncModeEnabled, _classNames:[]}, params);
    options.userScope = options.scope;
    options.scope = options;
    Boot.load(options);
  }, loadScriptsSync:function(urls) {
    var syncwas = Loader.syncModeEnabled;
    Loader.syncModeEnabled = true;
    Loader.loadScripts({url:urls});
    Loader.syncModeEnabled = syncwas;
  }, loadScriptsSyncBasePrefix:function(urls) {
    var syncwas = Loader.syncModeEnabled;
    Loader.syncModeEnabled = true;
    Loader.loadScripts({url:urls, prependBaseUrl:true});
    Loader.syncModeEnabled = syncwas;
  }, loadScript:function(options) {
    var isString = typeof options === 'string', isArray = options instanceof Array, isObject = !isArray && !isString, url = isObject ? options.url : options, onError = isObject && options.onError, onLoad = isObject && options.onLoad, scope = isObject && options.scope, request = {url:url, scope:scope, onLoad:onLoad, onError:onError, _classNames:[]};
    Loader.loadScripts(request);
  }, flushMissingQueue:function() {
    var name, val, missingwas = 0, missing = 0;
    for (name in _missingQueue) {
      missingwas++;
      val = _missingQueue[name];
      if (Manager.isCreated(name)) {
        delete _missingQueue[name];
      } else {
        if (Manager.existCache[name] === 2) {
          delete _missingQueue[name];
        } else {
          ++missing;
        }
      }
    }
    this.missingCount = missing;
  }, checkReady:function() {
    var wasLoading = Loader.isLoading, isLoading;
    Loader.flushMissingQueue();
    isLoading = Loader.missingCount + Loader.scriptsLoading;
    if (isLoading && !wasLoading) {
      Ready.block();
      Loader.isLoading = !!isLoading;
    } else {
      if (!isLoading && wasLoading) {
        Loader.triggerReady();
      }
    }
    if (!Loader.scriptsLoading && Loader.missingCount) {
      Ext.defer(function() {
        if (!Loader.scriptsLoading && Loader.missingCount) {
          Ext.log.error('[Loader] The following classes failed to load:');
          for (var name in Loader.missingQueue) {
            Ext.log.error('[Loader] ' + name + ' from ' + Loader.missingQueue[name]);
          }
        }
      }, 1000);
    }
  }});
  Ext.require = alias(Loader, 'require');
  Ext.syncRequire = alias(Loader, 'syncRequire');
  Ext.exclude = alias(Loader, 'exclude');
  Class.registerPreprocessor('loader', function(cls, data, hooks, continueFn) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(cls, 'Ext.Loader#loaderPreprocessor', arguments);
    var me = this, dependencies = [], dependency, className = Manager.getName(cls), i, j, ln, subLn, value, propertyName, propertyValue, requiredMap;
    for (i = 0, ln = dependencyProperties.length; i < ln; i++) {
      propertyName = dependencyProperties[i];
      if (data.hasOwnProperty(propertyName)) {
        propertyValue = data[propertyName];
        if (typeof propertyValue === 'string') {
          dependencies.push(propertyValue);
        } else {
          if (propertyValue instanceof Array) {
            for (j = 0, subLn = propertyValue.length; j < subLn; j++) {
              value = propertyValue[j];
              if (typeof value === 'string') {
                dependencies.push(value);
              }
            }
          } else {
            if (typeof propertyValue !== 'function') {
              for (j in propertyValue) {
                if (propertyValue.hasOwnProperty(j)) {
                  value = propertyValue[j];
                  if (typeof value === 'string') {
                    dependencies.push(value);
                  }
                }
              }
            }
          }
        }
      }
    }
    if (dependencies.length === 0) {
      return;
    }
    if (className) {
      _requiresMap[className] = dependencies;
    }
    var deadlockPath = [], detectDeadlock;
    if (className) {
      requiredMap = Loader.requiredByMap || (Loader.requiredByMap = {});
      for (i = 0, ln = dependencies.length; i < ln; i++) {
        dependency = dependencies[i];
        (requiredMap[dependency] || (requiredMap[dependency] = [])).push(className);
      }
      detectDeadlock = function(cls) {
        deadlockPath.push(cls);
        if (_requiresMap[cls]) {
          if (Ext.Array.contains(_requiresMap[cls], className)) {
            Ext.raise("Circular requirement detected! '" + className + "' and '" + deadlockPath[1] + "' mutually require each other. Path: " + deadlockPath.join(' -\x3e ') + ' -\x3e ' + deadlockPath[0]);
          }
          for (i = 0, ln = _requiresMap[cls].length; i < ln; i++) {
            detectDeadlock(_requiresMap[cls][i]);
          }
        }
      };
      detectDeadlock(className);
    }
    (className ? Loader.exclude(className) : Loader).require(dependencies, function() {
      for (i = 0, ln = dependencyProperties.length; i < ln; i++) {
        propertyName = dependencyProperties[i];
        if (data.hasOwnProperty(propertyName)) {
          propertyValue = data[propertyName];
          if (typeof propertyValue === 'string') {
            data[propertyName] = Manager.get(propertyValue);
          } else {
            if (propertyValue instanceof Array) {
              for (j = 0, subLn = propertyValue.length; j < subLn; j++) {
                value = propertyValue[j];
                if (typeof value === 'string') {
                  data[propertyName][j] = Manager.get(value);
                }
              }
            } else {
              if (typeof propertyValue !== 'function') {
                for (var k in propertyValue) {
                  if (propertyValue.hasOwnProperty(k)) {
                    value = propertyValue[k];
                    if (typeof value === 'string') {
                      data[propertyName][k] = Manager.get(value);
                    }
                  }
                }
              }
            }
          }
        }
      }
      continueFn.call(me, cls, data, hooks);
    });
    return false;
  }, true, 'after', 'className');
  Manager.registerPostprocessor('uses', function(name, cls, data) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(cls, 'Ext.Loader#usesPostprocessor', arguments);
    var manifest = Ext.manifest, loadOrder = manifest && manifest.loadOrder, classes = manifest && manifest.classes, uses, clazz, item, len, i, indexMap;
    if (loadOrder) {
      clazz = classes[name];
      if (clazz && !isNaN(i = clazz.idx)) {
        item = loadOrder[i];
        uses = item.uses;
        indexMap = {};
        for (len = uses.length, i = 0; i < len; i++) {
          indexMap[uses[i]] = true;
        }
        uses = Ext.Boot.getPathsFromIndexes(indexMap, loadOrder, true);
        if (uses.length > 0) {
          Loader.loadScripts({url:uses, sequential:true});
        }
      }
    }
    if (data.uses) {
      uses = data.uses;
      Loader.addUsedClasses(uses);
    }
  });
  Manager.onCreated(Loader.historyPush);
  Loader.init();
};
Ext._endTime = Ext.ticks();
if (Ext._beforereadyhandler) {
  Ext._beforereadyhandler();
}
Ext.define('Ext.Mixin', function(Mixin) {
  return {statics:{addHook:function(hookFn, targetClass, methodName, mixinClassPrototype) {
    var isFunc = Ext.isFunction(hookFn), hook = function() {
      var a = arguments, fn = isFunc ? hookFn : mixinClassPrototype[hookFn], result = this.callParent(a);
      fn.apply(this, a);
      return result;
    }, existingFn = targetClass.hasOwnProperty(methodName) && targetClass[methodName];
    if (isFunc) {
      hookFn.$previous = Ext.emptyFn;
    }
    hook.$name = methodName;
    hook.$owner = targetClass.self;
    if (existingFn) {
      hook.$previous = existingFn.$previous;
      existingFn.$previous = hook;
    } else {
      targetClass[methodName] = hook;
    }
  }}, onClassExtended:function(cls, data) {
    var mixinConfig = data.mixinConfig, hooks = data.xhooks, superclass = cls.superclass, onClassMixedIn = data.onClassMixedIn, parentMixinConfig, befores, afters, extended;
    if (hooks) {
      delete data.xhooks;
      (mixinConfig || (data.mixinConfig = mixinConfig = {})).on = hooks;
    }
    if (mixinConfig) {
      parentMixinConfig = superclass.mixinConfig;
      if (parentMixinConfig) {
        data.mixinConfig = mixinConfig = Ext.merge({}, parentMixinConfig, mixinConfig);
      }
      data.mixinId = mixinConfig.id;
      if (mixinConfig.beforeHooks) {
        Ext.raise('Use of "beforeHooks" is deprecated - use "before" instead');
      }
      if (mixinConfig.hooks) {
        Ext.raise('Use of "hooks" is deprecated - use "after" instead');
      }
      if (mixinConfig.afterHooks) {
        Ext.raise('Use of "afterHooks" is deprecated - use "after" instead');
      }
      befores = mixinConfig.before;
      afters = mixinConfig.after;
      hooks = mixinConfig.on;
      extended = mixinConfig.extended;
    }
    if (befores || afters || hooks || extended) {
      data.onClassMixedIn = function(targetClass) {
        var mixin = this.prototype, targetProto = targetClass.prototype, key;
        if (befores) {
          Ext.Object.each(befores, function(key, value) {
            targetClass.addMember(key, function() {
              if (mixin[value].apply(this, arguments) !== false) {
                return this.callParent(arguments);
              }
            });
          });
        }
        if (afters) {
          Ext.Object.each(afters, function(key, value) {
            targetClass.addMember(key, function() {
              var ret = this.callParent(arguments);
              mixin[value].apply(this, arguments);
              return ret;
            });
          });
        }
        if (hooks) {
          for (key in hooks) {
            Mixin.addHook(hooks[key], targetProto, key, mixin);
          }
        }
        if (extended) {
          targetClass.onExtended(function() {
            var args = Ext.Array.slice(arguments, 0);
            args.unshift(targetClass);
            return extended.apply(this, args);
          }, this);
        }
        if (onClassMixedIn) {
          onClassMixedIn.apply(this, arguments);
        }
      };
    }
  }};
});
Ext.util = Ext.util || {};
Ext.util.DelayedTask = function(fn, scope, args, cancelOnDelay, fireIdleEvent) {
  var me = this, delay, call = function() {
    var globalEvents = Ext.GlobalEvents;
    clearInterval(me.id);
    me.id = null;
    fn.apply(scope, args || []);
    if (fireIdleEvent !== false && globalEvents.hasListeners.idle) {
      globalEvents.fireEvent('idle');
    }
  };
  cancelOnDelay = typeof cancelOnDelay === 'boolean' ? cancelOnDelay : true;
  me.id = null;
  me.delay = function(newDelay, newFn, newScope, newArgs) {
    if (cancelOnDelay) {
      me.cancel();
    }
    if (typeof newDelay === 'number') {
      delay = newDelay;
    }
    fn = newFn || fn;
    scope = newScope || scope;
    args = newArgs || args;
    if (!me.id) {
      me.id = Ext.interval(call, delay);
    }
  };
  me.cancel = function() {
    if (me.id) {
      clearInterval(me.id);
      me.id = null;
    }
  };
};
Ext.define('Ext.util.Event', function() {
  var arraySlice = Array.prototype.slice, arrayInsert = Ext.Array.insert, toArray = Ext.Array.toArray, fireArgs = {};
  return {isEvent:true, suspended:0, noOptions:{}, constructor:function(observable, name) {
    this.name = name;
    this.observable = observable;
    this.listeners = [];
  }, addListener:function(fn, scope, options, caller, manager) {
    var me = this, added = false, observable = me.observable, eventName = me.name, listeners, listener, priority, isNegativePriority, highestNegativePriorityIndex, hasNegativePriorityIndex, length, index, i, listenerPriority;
    if (scope && !Ext._namedScopes[scope] && typeof fn === 'string' && typeof scope[fn] !== 'function') {
      Ext.raise("No method named '" + fn + "' found on scope object");
    }
    if (me.findListener(fn, scope) === -1) {
      listener = me.createListener(fn, scope, options, caller, manager);
      if (me.firing) {
        me.listeners = me.listeners.slice(0);
      }
      listeners = me.listeners;
      index = length = listeners.length;
      priority = options && options.priority;
      highestNegativePriorityIndex = me._highestNegativePriorityIndex;
      hasNegativePriorityIndex = highestNegativePriorityIndex !== undefined;
      if (priority) {
        isNegativePriority = priority < 0;
        if (!isNegativePriority || hasNegativePriorityIndex) {
          for (i = isNegativePriority ? highestNegativePriorityIndex : 0; i < length; i++) {
            listenerPriority = listeners[i].o ? listeners[i].o.priority || 0 : 0;
            if (listenerPriority < priority) {
              index = i;
              break;
            }
          }
        } else {
          me._highestNegativePriorityIndex = index;
        }
      } else {
        if (hasNegativePriorityIndex) {
          index = highestNegativePriorityIndex;
        }
      }
      if (!isNegativePriority && index <= highestNegativePriorityIndex) {
        me._highestNegativePriorityIndex++;
      }
      if (index === length) {
        listeners[length] = listener;
      } else {
        arrayInsert(listeners, index, [listener]);
      }
      if (observable.isElement) {
        observable._getPublisher(eventName).subscribe(observable, eventName, options.delegated !== false, options.capture);
      }
      added = true;
    }
    return added;
  }, createListener:function(fn, scope, o, caller, manager) {
    var me = this, namedScope = Ext._namedScopes[scope], listener = {fn:fn, scope:scope, ev:me, caller:caller, manager:manager, namedScope:namedScope, defaultScope:namedScope ? scope || me.observable : undefined, lateBound:typeof fn === 'string'}, handler = fn, wrapped = false, type;
    if (o) {
      listener.o = o;
      if (o.single) {
        handler = me.createSingle(handler, listener, o, scope);
        wrapped = true;
      }
      if (o.target) {
        handler = me.createTargeted(handler, listener, o, scope, wrapped);
        wrapped = true;
      }
      if (o.delay) {
        handler = me.createDelayed(handler, listener, o, scope, wrapped);
        wrapped = true;
      }
      if (o.buffer) {
        handler = me.createBuffered(handler, listener, o, scope, wrapped);
        wrapped = true;
      }
      if (me.observable.isElement) {
        type = o.type;
        if (type) {
          listener.type = type;
        }
      }
    }
    listener.fireFn = handler;
    listener.wrapped = wrapped;
    return listener;
  }, findListener:function(fn, scope) {
    var listeners = this.listeners, i = listeners.length, listener;
    while (i--) {
      listener = listeners[i];
      if (listener) {
        if (listener.fn === fn && listener.scope == scope) {
          return i;
        }
      }
    }
    return -1;
  }, removeListener:function(fn, scope, index) {
    var me = this, removed = false, observable = me.observable, eventName = me.name, listener, highestNegativePriorityIndex, options, k, manager, managedListeners, managedListener, i;
    index = index || me.findListener(fn, scope);
    if (index != -1) {
      listener = me.listeners[index];
      options = listener.o;
      highestNegativePriorityIndex = me._highestNegativePriorityIndex;
      if (me.firing) {
        me.listeners = me.listeners.slice(0);
      }
      if (listener.task) {
        listener.task.cancel();
        delete listener.task;
      }
      k = listener.tasks && listener.tasks.length;
      if (k) {
        while (k--) {
          listener.tasks[k].cancel();
        }
        delete listener.tasks;
      }
      me.listeners.splice(index, 1);
      manager = listener.manager;
      if (manager) {
        managedListeners = manager.managedListeners;
        if (managedListeners) {
          for (i = managedListeners.length; i--;) {
            managedListener = managedListeners[i];
            if (managedListener.item === me.observable && managedListener.ename === eventName && managedListener.fn === fn && managedListener.scope === scope) {
              managedListeners.splice(i, 1);
            }
          }
        }
      }
      if (highestNegativePriorityIndex) {
        if (index < highestNegativePriorityIndex) {
          me._highestNegativePriorityIndex--;
        } else {
          if (index === highestNegativePriorityIndex && index === me.listeners.length) {
            delete me._highestNegativePriorityIndex;
          }
        }
      }
      if (observable.isElement) {
        observable._getPublisher(eventName).unsubscribe(observable, eventName, options.delegated !== false, options.capture);
      }
      removed = true;
    }
    return removed;
  }, clearListeners:function() {
    var listeners = this.listeners, i = listeners.length, listener;
    while (i--) {
      listener = listeners[i];
      this.removeListener(listener.fn, listener.scope);
    }
  }, suspend:function() {
    ++this.suspended;
  }, resume:function() {
    if (this.suspended) {
      --this.suspended;
    }
  }, isSuspended:function() {
    return this.suspended > 0;
  }, fireDelegated:function(firingObservable, args) {
    this.firingObservable = firingObservable;
    return this.fire.apply(this, args);
  }, fire:function() {
    var me = this, listeners = me.listeners, count = listeners.length, observable = me.observable, isElement = observable.isElement, isComponent = observable.isComponent, firingObservable = me.firingObservable, options, delegate, fireInfo, i, args, listener, len, delegateEl, currentTarget, type, chained, firingArgs, e, fireFn, fireScope;
    if (!me.suspended && count > 0) {
      me.firing = true;
      args = arguments.length ? arraySlice.call(arguments, 0) : [];
      len = args.length;
      if (isElement) {
        e = args[0];
      }
      for (i = 0; i < count; i++) {
        listener = listeners[i];
        options = listener.o;
        if (isElement) {
          if (currentTarget) {
            e.setCurrentTarget(currentTarget);
          }
          type = listener.type;
          if (type) {
            chained = e;
            e = args[0] = chained.chain({type:type});
          }
          Ext.EventObject = e;
        }
        firingArgs = args;
        if (options) {
          delegate = options.delegate;
          if (delegate) {
            if (isElement) {
              delegateEl = e.getTarget('#' + e.currentTarget.id + ' ' + delegate);
              if (delegateEl) {
                args[1] = delegateEl;
                currentTarget = e.currentTarget;
                e.setCurrentTarget(delegateEl);
              } else {
                continue;
              }
            } else {
              if (isComponent && !firingObservable.is('#' + observable.id + ' ' + options.delegate)) {
                continue;
              }
            }
          }
          if (isElement) {
            if (options.preventDefault) {
              e.preventDefault();
            }
            if (options.stopPropagation) {
              e.stopPropagation();
            }
            if (options.stopEvent) {
              e.stopEvent();
            }
          }
          args[len] = options;
          if (options.args) {
            firingArgs = options.args.concat(args);
          }
        }
        fireInfo = me.getFireInfo(listener);
        fireFn = fireInfo.fn;
        fireScope = fireInfo.scope;
        fireInfo.fn = fireInfo.scope = null;
        if (fireFn.apply(fireScope, firingArgs) === false) {
          Ext.EventObject = null;
          return me.firing = false;
        }
        if (chained) {
          e = args[0] = chained;
          chained = null;
        }
        Ext.EventObject = null;
      }
    }
    me.firing = false;
    return true;
  }, getFireInfo:function(listener, fromWrapped) {
    var observable = this.observable, fireFn = listener.fireFn, scope = listener.scope, namedScope = listener.namedScope, fn;
    if (!fromWrapped && listener.wrapped) {
      fireArgs.fn = fireFn;
      return fireArgs;
    }
    fn = fromWrapped ? listener.fn : fireFn;
    var name = fn;
    if (listener.lateBound) {
      if (!scope || namedScope) {
        scope = (listener.caller || observable).resolveListenerScope(listener.defaultScope);
      }
      if (!scope) {
        Ext.raise('Unable to dynamically resolve scope for "' + listener.ev.name + '" listener on ' + this.observable.id);
      }
      if (!Ext.isFunction(scope[fn])) {
        Ext.raise('No method named "' + fn + '" on ' + (scope.$className || 'scope object.'));
      }
      fn = scope[fn];
    } else {
      if (namedScope && namedScope.isController) {
        scope = (listener.caller || observable).resolveListenerScope(listener.defaultScope);
        if (!scope) {
          Ext.raise('Unable to dynamically resolve scope for "' + listener.ev.name + '" listener on ' + this.observable.id);
        }
      } else {
        if (!scope || namedScope) {
          scope = observable;
        }
      }
    }
    fireArgs.fn = fn;
    fireArgs.scope = scope;
    if (!fn) {
      Ext.raise('Unable to dynamically resolve method "' + name + '" on ' + this.observable.$className);
    }
    return fireArgs;
  }, createTargeted:function(handler, listener, o, scope, wrapped) {
    return function() {
      if (o.target === arguments[0]) {
        var fireInfo;
        if (!wrapped) {
          fireInfo = listener.ev.getFireInfo(listener, true);
          handler = fireInfo.fn;
          scope = fireInfo.scope;
          fireInfo.fn = fireInfo.scope = null;
        }
        return handler.apply(scope, arguments);
      }
    };
  }, createBuffered:function(handler, listener, o, scope, wrapped) {
    listener.task = new Ext.util.DelayedTask;
    return function() {
      var fireInfo;
      if (!wrapped) {
        fireInfo = listener.ev.getFireInfo(listener, true);
        handler = fireInfo.fn;
        scope = fireInfo.scope;
        fireInfo.fn = fireInfo.scope = null;
      }
      listener.task.delay(o.buffer, handler, scope, toArray(arguments));
    };
  }, createDelayed:function(handler, listener, o, scope, wrapped) {
    return function() {
      var task = new Ext.util.DelayedTask, fireInfo;
      if (!wrapped) {
        fireInfo = listener.ev.getFireInfo(listener, true);
        handler = fireInfo.fn;
        scope = fireInfo.scope;
        fireInfo.fn = fireInfo.scope = null;
      }
      if (!listener.tasks) {
        listener.tasks = [];
      }
      listener.tasks.push(task);
      task.delay(o.delay || 10, handler, scope, toArray(arguments));
    };
  }, createSingle:function(handler, listener, o, scope, wrapped) {
    return function() {
      var event = listener.ev, fireInfo;
      if (event.removeListener(listener.fn, scope) && event.observable) {
        event.observable.hasListeners[event.name]--;
      }
      if (!wrapped) {
        fireInfo = event.getFireInfo(listener, true);
        handler = fireInfo.fn;
        scope = fireInfo.scope;
        fireInfo.fn = fireInfo.scope = null;
      }
      return handler.apply(scope, arguments);
    };
  }};
});
Ext.define('Ext.mixin.Identifiable', {statics:{uniqueIds:{}}, isIdentifiable:true, mixinId:'identifiable', idCleanRegex:/\.|[^\w\-]/g, defaultIdPrefix:'ext-', defaultIdSeparator:'-', getOptimizedId:function() {
  return this.id;
}, getUniqueId:function() {
  var id = this.id, prototype, separator, xtype, uniqueIds, prefix;
  if (!(id || id === 0)) {
    prototype = this.self.prototype;
    separator = this.defaultIdSeparator;
    uniqueIds = Ext.mixin.Identifiable.uniqueIds;
    if (!prototype.hasOwnProperty('identifiablePrefix')) {
      xtype = this.xtype;
      if (xtype) {
        prefix = this.defaultIdPrefix + xtype.replace(this.idCleanRegex, separator) + separator;
      } else {
        if (!(prefix = prototype.$className)) {
          prefix = this.defaultIdPrefix + 'anonymous' + separator;
        } else {
          prefix = prefix.replace(this.idCleanRegex, separator).toLowerCase() + separator;
        }
      }
      prototype.identifiablePrefix = prefix;
    }
    prefix = this.identifiablePrefix;
    if (!uniqueIds.hasOwnProperty(prefix)) {
      uniqueIds[prefix] = 0;
    }
    id = this.id = this.id = prefix + ++uniqueIds[prefix];
  }
  this.getUniqueId = this.getOptimizedId;
  return id;
}, setId:function(id) {
  this.id = this.id = id;
}, getId:function() {
  var id = this.id;
  if (!id) {
    id = this.getUniqueId();
  }
  this.getId = this.getOptimizedId;
  return id;
}});
Ext.define('Ext.mixin.Observable', function(Observable) {
  var emptyFn = Ext.emptyFn, emptyArray = [], arrayProto = Array.prototype, arraySlice = arrayProto.slice, ListenerRemover = function(observable) {
    if (observable instanceof ListenerRemover) {
      return observable;
    }
    this.observable = observable;
    if (arguments[1].isObservable) {
      this.managedListeners = true;
    }
    this.args = arraySlice.call(arguments, 1);
  };
  ListenerRemover.prototype.destroy = function() {
    this.destroy = Ext.emptyFn;
    var observable = this.observable;
    observable[this.managedListeners ? 'mun' : 'un'].apply(observable, this.args);
  };
  return {extend:Ext.Mixin, mixinConfig:{id:'observable', after:{destroy:'clearListeners'}}, mixins:[Ext.mixin.Identifiable], statics:{releaseCapture:function(o) {
    o.fireEventArgs = this.prototype.fireEventArgs;
  }, capture:function(o, fn, scope) {
    var newFn = function(eventName, args) {
      return fn.apply(scope, [eventName].concat(args));
    };
    this.captureArgs(o, newFn, scope);
  }, captureArgs:function(o, fn, scope) {
    o.fireEventArgs = Ext.Function.createInterceptor(o.fireEventArgs, fn, scope);
  }, observe:function(cls, listeners) {
    if (cls) {
      if (!cls.isObservable) {
        Ext.applyIf(cls, new this);
        this.captureArgs(cls.prototype, cls.fireEventArgs, cls);
      }
      if (Ext.isObject(listeners)) {
        cls.on(listeners);
      }
    }
    return cls;
  }, prepareClass:function(T, mixin, data) {
    var listeners = T.listeners = [], target = data || T.prototype, targetListeners = target.listeners, superListeners = mixin ? mixin.listeners : T.superclass.self.listeners, name, scope, namedScope;
    if (superListeners) {
      listeners.push(superListeners);
    }
    if (targetListeners) {
      scope = targetListeners.scope;
      if (!scope) {
        targetListeners.scope = 'self';
      } else {
        namedScope = Ext._namedScopes[scope];
        if (namedScope && namedScope.isController) {
          targetListeners.scope = 'self.controller';
        }
      }
      listeners.push(targetListeners);
      target.listeners = null;
    }
    if (!T.HasListeners) {
      var HasListeners = function() {
      }, SuperHL = T.superclass.HasListeners || mixin && mixin.HasListeners || Observable.HasListeners;
      T.prototype.HasListeners = T.HasListeners = HasListeners;
      HasListeners.prototype = T.hasListeners = new SuperHL;
    }
  }}, isObservable:true, eventsSuspended:0, constructor:function(config) {
    var me = this, self = me.self, declaredListeners, listeners, bubbleEvents, len, i;
    if (me.$observableInitialized) {
      return;
    }
    me.$observableInitialized = true;
    me.hasListeners = new me.HasListeners;
    me.eventedBeforeEventNames = {};
    me.events = me.events || {};
    declaredListeners = self.listeners;
    if (declaredListeners && !me._addDeclaredListeners(declaredListeners)) {
      self.listeners = null;
    }
    listeners = config && config.listeners || me.listeners;
    if (listeners) {
      if (listeners instanceof Array) {
        for (i = 0, len = listeners.length; i < len; ++i) {
          me.addListener(listeners[i]);
        }
      } else {
        me.addListener(listeners);
      }
    }
    bubbleEvents = config && config.bubbleEvents || me.bubbleEvents;
    if (bubbleEvents) {
      me.enableBubble(bubbleEvents);
    }
    if (me.$applyConfigs) {
      if (config) {
        Ext.apply(me, config);
      }
    } else {
      me.initConfig(config);
    }
    if (listeners) {
      me.listeners = null;
    }
  }, onClassExtended:function(T, data) {
    if (!T.HasListeners) {
      Observable.prepareClass(T, T.prototype.$observableMixedIn ? undefined : data);
    }
  }, $eventOptions:{scope:1, delay:1, buffer:1, onFrame:1, single:1, args:1, destroyable:1, priority:1, order:1}, $orderToPriority:{before:100, current:0, after:-100}, _addDeclaredListeners:function(listeners) {
    var me = this;
    if (listeners instanceof Array) {
      Ext.each(listeners, me._addDeclaredListeners, me);
    } else {
      me._addedDeclaredListeners = true;
      me.addListener(listeners);
    }
    return me._addedDeclaredListeners;
  }, addManagedListener:function(item, ename, fn, scope, options, noDestroy) {
    var me = this, managedListeners = me.managedListeners = me.managedListeners || [], config, passedOptions;
    if (typeof ename !== 'string') {
      passedOptions = arguments.length > 4 ? options : ename;
      options = ename;
      for (ename in options) {
        if (options.hasOwnProperty(ename)) {
          config = options[ename];
          if (!item.$eventOptions[ename]) {
            me.addManagedListener(item, ename, config.fn || config, config.scope || options.scope || scope, config.fn ? config : passedOptions, true);
          }
        }
      }
      if (options && options.destroyable) {
        return new ListenerRemover(me, item, options);
      }
    } else {
      if (fn !== emptyFn) {
        item.doAddListener(ename, fn, scope, options, null, me, me);
        if (!noDestroy && options && options.destroyable) {
          return new ListenerRemover(me, item, ename, fn, scope);
        }
      }
    }
  }, removeManagedListener:function(item, ename, fn, scope) {
    var me = this, options, config, managedListeners, length, i;
    if (typeof ename !== 'string') {
      options = ename;
      for (ename in options) {
        if (options.hasOwnProperty(ename)) {
          config = options[ename];
          if (!item.$eventOptions[ename]) {
            me.removeManagedListener(item, ename, config.fn || config, config.scope || options.scope || scope);
          }
        }
      }
    } else {
      managedListeners = me.managedListeners ? me.managedListeners.slice() : [];
      ename = Ext.canonicalEventName(ename);
      for (i = 0, length = managedListeners.length; i < length; i++) {
        me.removeManagedListenerItem(false, managedListeners[i], item, ename, fn, scope);
      }
    }
  }, fireEvent:function(eventName) {
    return this.fireEventArgs(eventName, arraySlice.call(arguments, 1));
  }, resolveListenerScope:function(defaultScope) {
    var namedScope = Ext._namedScopes[defaultScope];
    if (namedScope) {
      if (namedScope.isController) {
        Ext.raise('scope: "controller" can only be specified on classes that derive from Ext.Component or Ext.Widget');
      }
      if (namedScope.isSelf || namedScope.isThis) {
        defaultScope = null;
      }
    }
    return defaultScope || this;
  }, fireEventArgs:function(eventName, args) {
    eventName = Ext.canonicalEventName(eventName);
    var me = this, events = me.events, event = events && events[eventName], ret = true;
    if (me.hasListeners[eventName]) {
      ret = me.doFireEvent(eventName, args || emptyArray, event ? event.bubble : false);
    }
    return ret;
  }, fireAction:function(eventName, args, fn, scope, options, order) {
    if (typeof fn === 'string' && !scope) {
      fn = this[fn];
    }
    options = options ? Ext.Object.chain(options) : {};
    options.single = true;
    options.priority = order === 'after' ? -99.5 : 99.5;
    this.doAddListener(eventName, fn, scope, options);
    this.fireEventArgs(eventName, args);
  }, $eventedController:{_paused:1, pause:function() {
    ++this._paused;
  }, resume:function() {
    var me = this, fn = me.fn, scope = me.scope, fnArgs = me.fnArgs, owner = me.owner, args, ret;
    if (!--me._paused) {
      if (fn) {
        args = Ext.Array.slice(fnArgs || me.args);
        if (fnArgs === false) {
          args.shift();
        }
        me.fn = null;
        args.push(me);
        if (Ext.isFunction(fn)) {
          ret = fn.apply(scope, args);
        } else {
          if (scope && Ext.isString(fn) && Ext.isFunction(scope[fn])) {
            ret = scope[fn].apply(scope, args);
          }
        }
        if (ret === false) {
          return false;
        }
      }
      if (!me._paused) {
        return me.owner.fireEventArgs(me.eventName, me.args);
      }
    }
  }}, fireEventedAction:function(eventName, args, fn, scope, fnArgs) {
    var me = this, eventedBeforeEventNames = me.eventedBeforeEventNames, beforeEventName = eventedBeforeEventNames[eventName] || (eventedBeforeEventNames[eventName] = 'before' + eventName), controller = Ext.apply({owner:me, eventName:eventName, fn:fn, scope:scope, fnArgs:fnArgs, args:args}, me.$eventedController), value;
    args.push(controller);
    value = me.fireEventArgs(beforeEventName, args);
    args.pop();
    if (value === false) {
      return false;
    }
    return controller.resume();
  }, doFireEvent:function(eventName, args, bubbles) {
    var target = this, queue, event, ret = true;
    do {
      if (target.eventsSuspended) {
        if (queue = target.eventQueue) {
          queue.push([eventName, args]);
        }
        return ret;
      } else {
        event = target.events && target.events[eventName];
        if (event && event !== true) {
          if ((ret = event.fire.apply(event, args)) === false) {
            break;
          }
        }
      }
    } while (bubbles && (target = target.getBubbleParent()));
    return ret;
  }, getBubbleParent:function() {
    var me = this, parent = me.getBubbleTarget && me.getBubbleTarget();
    if (parent && parent.isObservable) {
      return parent;
    }
    return null;
  }, addListener:function(ename, fn, scope, options, order, caller) {
    var me = this, namedScopes = Ext._namedScopes, config, namedScope, isClassListener, innerScope, eventOptions;
    if (typeof ename !== 'string') {
      options = ename;
      scope = options.scope;
      namedScope = scope && namedScopes[scope];
      isClassListener = namedScope && namedScope.isSelf;
      eventOptions = (me.isComponent || me.isWidget) && options.element ? me.$elementEventOptions : me.$eventOptions;
      for (ename in options) {
        config = options[ename];
        if (!eventOptions[ename]) {
          innerScope = config.scope;
          if (innerScope && isClassListener) {
            namedScope = namedScopes[innerScope];
            if (namedScope && namedScope.isController) {
              innerScope = 'self.controller';
            }
          }
          me.doAddListener(ename, config.fn || config, innerScope || scope, config.fn ? config : options, order, caller);
        }
      }
      if (options && options.destroyable) {
        return new ListenerRemover(me, options);
      }
    } else {
      me.doAddListener(ename, fn, scope, options, order, caller);
      if (options && options.destroyable) {
        return new ListenerRemover(me, ename, fn, scope, options);
      }
    }
    return me;
  }, removeListener:function(ename, fn, scope, eventOptions) {
    var me = this, config, options;
    if (typeof ename !== 'string') {
      options = ename;
      eventOptions = eventOptions || me.$eventOptions;
      for (ename in options) {
        if (options.hasOwnProperty(ename)) {
          config = options[ename];
          if (!me.$eventOptions[ename]) {
            me.doRemoveListener(ename, config.fn || config, config.scope || options.scope);
          }
        }
      }
    } else {
      me.doRemoveListener(ename, fn, scope);
    }
    return me;
  }, onBefore:function(eventName, fn, scope, options) {
    return this.addListener(eventName, fn, scope, options, 'before');
  }, onAfter:function(eventName, fn, scope, options) {
    return this.addListener(eventName, fn, scope, options, 'after');
  }, unBefore:function(eventName, fn, scope, options) {
    return this.removeListener(eventName, fn, scope, options, 'before');
  }, unAfter:function(eventName, fn, scope, options) {
    return this.removeListener(eventName, fn, scope, options, 'after');
  }, addBeforeListener:function() {
    return this.onBefore.apply(this, arguments);
  }, addAfterListener:function() {
    return this.onAfter.apply(this, arguments);
  }, removeBeforeListener:function() {
    return this.unBefore.apply(this, arguments);
  }, removeAfterListener:function() {
    return this.unAfter.apply(this, arguments);
  }, clearListeners:function() {
    var me = this, events = me.events, hasListeners = me.hasListeners, event, key;
    if (events) {
      for (key in events) {
        if (events.hasOwnProperty(key)) {
          event = events[key];
          if (event.isEvent) {
            delete hasListeners[key];
            event.clearListeners();
          }
        }
      }
      me.events = null;
    }
    me.clearManagedListeners();
  }, purgeListeners:function() {
    if (Ext.global.console) {
      Ext.global.console.warn('Observable: purgeListeners has been deprecated. Please use clearListeners.');
    }
    return this.clearListeners.apply(this, arguments);
  }, clearManagedListeners:function() {
    var me = this, managedListeners = me.managedListeners ? me.managedListeners.slice() : [], i = 0, len = managedListeners.length;
    for (; i < len; i++) {
      me.removeManagedListenerItem(true, managedListeners[i]);
    }
    me.managedListeners = [];
  }, removeManagedListenerItem:function(isClear, managedListener, item, ename, fn, scope) {
    if (isClear || managedListener.item === item && managedListener.ename === ename && (!fn || managedListener.fn === fn) && (!scope || managedListener.scope === scope)) {
      managedListener.item.doRemoveListener(managedListener.ename, managedListener.fn, managedListener.scope, managedListener.options);
      if (!isClear) {
        Ext.Array.remove(this.managedListeners, managedListener);
      }
    }
  }, purgeManagedListeners:function() {
    if (Ext.global.console) {
      Ext.global.console.warn('Observable: purgeManagedListeners has been deprecated. Please use clearManagedListeners.');
    }
    return this.clearManagedListeners.apply(this, arguments);
  }, hasListener:function(ename) {
    ename = Ext.canonicalEventName(ename);
    return !!this.hasListeners[ename];
  }, isSuspended:function(event) {
    var suspended = this.eventsSuspended > 0, events = this.events;
    if (!suspended && event && events) {
      event = events[event];
      if (event && event.isEvent) {
        return event.isSuspended();
      }
    }
    return suspended;
  }, suspendEvents:function(queueSuspended) {
    ++this.eventsSuspended;
    if (queueSuspended && !this.eventQueue) {
      this.eventQueue = [];
    }
  }, suspendEvent:function() {
    var me = this, events = me.events, len = arguments.length, i, event, ename;
    for (i = 0; i < len; i++) {
      ename = arguments[i];
      ename = Ext.canonicalEventName(ename);
      event = events[ename];
      if (!event || !event.isEvent) {
        event = me._initEvent(ename);
      }
      event.suspend();
    }
  }, resumeEvent:function() {
    var events = this.events || 0, len = events && arguments.length, i, event;
    for (i = 0; i < len; i++) {
      event = events[arguments[i]];
      if (event && event.resume) {
        event.resume();
      }
    }
  }, resumeEvents:function(discardQueue) {
    var me = this, queued = me.eventQueue, qLen, q;
    if (me.eventsSuspended && !--me.eventsSuspended) {
      delete me.eventQueue;
      if (!discardQueue && queued) {
        qLen = queued.length;
        for (q = 0; q < qLen; q++) {
          me.fireEventArgs.apply(me, queued[q]);
        }
      }
    }
  }, relayEvents:function(origin, events, prefix) {
    var me = this, len = events.length, i = 0, oldName, newName, relayers = {};
    if (Ext.isObject(events)) {
      for (i in events) {
        newName = events[i];
        relayers[i] = me.createRelayer(newName);
      }
    } else {
      for (; i < len; i++) {
        oldName = events[i];
        relayers[oldName] = me.createRelayer(prefix ? prefix + oldName : oldName);
      }
    }
    me.mon(origin, relayers, null, null, undefined);
    return new ListenerRemover(me, origin, relayers);
  }, createRelayer:function(newName, beginEnd) {
    var me = this;
    return function() {
      return me.fireEventArgs.call(me, newName, beginEnd ? arraySlice.apply(arguments, beginEnd) : arguments);
    };
  }, enableBubble:function(eventNames) {
    if (eventNames) {
      var me = this, names = typeof eventNames == 'string' ? arguments : eventNames, events = me.events, length = events && names.length, ename, event, i;
      for (i = 0; i < length; ++i) {
        ename = names[i];
        ename = Ext.canonicalEventName(ename);
        event = events[ename];
        if (!event || !event.isEvent) {
          event = me._initEvent(ename);
        }
        me.hasListeners._incr_(ename);
        event.bubble = true;
      }
    }
  }, destroy:function() {
    this.clearListeners();
    this.callParent();
  }, privates:{doAddListener:function(ename, fn, scope, options, order, caller, manager) {
    var me = this, event, managedListeners, priority;
    order = order || options && options.order;
    if (order) {
      priority = options && options.priority;
      if (!priority) {
        options = options ? Ext.Object.chain(options) : {};
        options.priority = me.$orderToPriority[order];
      }
    }
    ename = Ext.canonicalEventName(ename);
    if (!fn) {
      Ext.raise("Cannot add '" + ename + "' listener to " + me.$className + ' instance.  No function specified.');
    }
    if (!manager && (scope && scope.isObservable && scope !== me)) {
      manager = scope;
    }
    if (manager) {
      managedListeners = manager.managedListeners = manager.managedListeners || [];
      managedListeners.push({item:me, ename:ename, fn:fn, scope:scope, options:options});
    }
    event = (me.events || (me.events = {}))[ename];
    if (!event || !event.isEvent) {
      event = me._initEvent(ename);
    }
    if (fn !== emptyFn) {
      if (event.addListener(fn, scope, options, caller, manager)) {
        me.hasListeners._incr_(ename);
      }
    }
  }, doRemoveListener:function(ename, fn, scope) {
    var me = this, events = me.events, event;
    ename = Ext.canonicalEventName(ename);
    event = events && events[ename];
    if (!fn) {
      Ext.raise("Cannot remove '" + ename + "' listener to " + me.$className + ' instance.  No function specified.');
    }
    if (event && event.isEvent) {
      if (event.removeListener(fn, scope)) {
        me.hasListeners._decr_(ename);
      }
    }
  }, _initEvent:function(eventName) {
    return this.events[eventName] = new Ext.util.Event(this, eventName);
  }}, deprecated:{'5.0':{methods:{addEvents:null}}}};
}, function() {
  var Observable = this, proto = Observable.prototype, HasListeners = function() {
  }, prepareMixin = function(T) {
    if (!T.HasListeners) {
      var proto = T.prototype;
      proto.$observableMixedIn = 1;
      Observable.prepareClass(T, this);
      T.onExtended(function(U, data) {
        Ext.classSystemMonitor && Ext.classSystemMonitor('extend mixin', arguments);
        Observable.prepareClass(U, null, data);
      });
      if (proto.onClassMixedIn) {
        Ext.override(T, {onClassMixedIn:function(U) {
          prepareMixin.call(this, U);
          this.callParent(arguments);
        }});
      } else {
        proto.onClassMixedIn = function(U) {
          prepareMixin.call(this, U);
        };
      }
    }
    superOnClassMixedIn.call(this, T);
  }, superOnClassMixedIn = proto.onClassMixedIn;
  HasListeners.prototype = {_decr_:function(ev, count) {
    if (count == null) {
      count = 1;
    }
    if (!(this[ev] -= count)) {
      delete this[ev];
    }
  }, _incr_:function(ev) {
    if (this.hasOwnProperty(ev)) {
      ++this[ev];
    } else {
      this[ev] = 1;
    }
  }};
  proto.HasListeners = Observable.HasListeners = HasListeners;
  Observable.createAlias({on:'addListener', un:'removeListener', mon:'addManagedListener', mun:'removeManagedListener', setListeners:'addListener'});
  Observable.observeClass = Observable.observe;
  function getMethodEvent(method) {
    var e = (this.methodEvents = this.methodEvents || {})[method], returnValue, v, cancel, obj = this, makeCall;
    if (!e) {
      this.methodEvents[method] = e = {};
      e.originalFn = this[method];
      e.methodName = method;
      e.before = [];
      e.after = [];
      makeCall = function(fn, scope, args) {
        if ((v = fn.apply(scope || obj, args)) !== undefined) {
          if (typeof v == 'object') {
            if (v.returnValue !== undefined) {
              returnValue = v.returnValue;
            } else {
              returnValue = v;
            }
            cancel = !!v.cancel;
          } else {
            if (v === false) {
              cancel = true;
            } else {
              returnValue = v;
            }
          }
        }
      };
      this[method] = function() {
        var args = Array.prototype.slice.call(arguments, 0), b, i, len;
        returnValue = v = undefined;
        cancel = false;
        for (i = 0, len = e.before.length; i < len; i++) {
          b = e.before[i];
          makeCall(b.fn, b.scope, args);
          if (cancel) {
            return returnValue;
          }
        }
        if ((v = e.originalFn.apply(obj, args)) !== undefined) {
          returnValue = v;
        }
        for (i = 0, len = e.after.length; i < len; i++) {
          b = e.after[i];
          makeCall(b.fn, b.scope, args);
          if (cancel) {
            return returnValue;
          }
        }
        return returnValue;
      };
    }
    return e;
  }
  Ext.apply(proto, {onClassMixedIn:prepareMixin, beforeMethod:function(method, fn, scope) {
    getMethodEvent.call(this, method).before.push({fn:fn, scope:scope});
  }, afterMethod:function(method, fn, scope) {
    getMethodEvent.call(this, method).after.push({fn:fn, scope:scope});
  }, removeMethodListener:function(method, fn, scope) {
    var e = this.getMethodEvent(method), i, len;
    for (i = 0, len = e.before.length; i < len; i++) {
      if (e.before[i].fn == fn && e.before[i].scope == scope) {
        Ext.Array.erase(e.before, i, 1);
        return;
      }
    }
    for (i = 0, len = e.after.length; i < len; i++) {
      if (e.after[i].fn == fn && e.after[i].scope == scope) {
        Ext.Array.erase(e.after, i, 1);
        return;
      }
    }
  }, toggleEventLogging:function(toggle) {
    Ext.util.Observable[toggle ? 'capture' : 'releaseCapture'](this, function(en) {
      if (Ext.isDefined(Ext.global.console)) {
        Ext.global.console.log(en, arguments);
      }
    });
  }});
});
Ext.define('Ext.util.HashMap', {mixins:[Ext.mixin.Observable], generation:0, config:{keyFn:null}, constructor:function(config) {
  var me = this, fn;
  me.mixins.observable.constructor.call(me, config);
  me.clear(true);
  fn = me.getKeyFn();
  if (fn) {
    me.getKey = fn;
  }
}, getCount:function() {
  return this.length;
}, getData:function(key, value) {
  if (value === undefined) {
    value = key;
    key = this.getKey(value);
  }
  return [key, value];
}, getKey:function(o) {
  return o.id;
}, add:function(key, value) {
  var me = this;
  if (arguments.length === 1) {
    value = key;
    key = me.getKey(value);
  }
  if (me.containsKey(key)) {
    return me.replace(key, value);
  }
  me.map[key] = value;
  ++me.length;
  me.generation++;
  if (me.hasListeners.add) {
    me.fireEvent('add', me, key, value);
  }
  return value;
}, replace:function(key, value) {
  var me = this, map = me.map, old;
  if (arguments.length === 1) {
    value = key;
    key = me.getKey(value);
  }
  if (!me.containsKey(key)) {
    me.add(key, value);
  }
  old = map[key];
  map[key] = value;
  me.generation++;
  if (me.hasListeners.replace) {
    me.fireEvent('replace', me, key, value, old);
  }
  return value;
}, remove:function(o) {
  var key = this.findKey(o);
  if (key !== undefined) {
    return this.removeAtKey(key);
  }
  return false;
}, removeAtKey:function(key) {
  var me = this, value;
  if (me.containsKey(key)) {
    value = me.map[key];
    delete me.map[key];
    --me.length;
    me.generation++;
    if (me.hasListeners.remove) {
      me.fireEvent('remove', me, key, value);
    }
    return true;
  }
  return false;
}, get:function(key) {
  var map = this.map;
  return map.hasOwnProperty(key) ? map[key] : undefined;
}, clear:function(initial) {
  var me = this;
  if (initial || me.generation) {
    me.map = {};
    me.length = 0;
    me.generation = initial ? 0 : me.generation + 1;
  }
  if (initial !== true && me.hasListeners.clear) {
    me.fireEvent('clear', me);
  }
  return me;
}, containsKey:function(key) {
  var map = this.map;
  return map.hasOwnProperty(key) && map[key] !== undefined;
}, contains:function(value) {
  return this.containsKey(this.findKey(value));
}, getKeys:function() {
  return this.getArray(true);
}, getValues:function() {
  return this.getArray(false);
}, getArray:function(isKey) {
  var arr = [], key, map = this.map;
  for (key in map) {
    if (map.hasOwnProperty(key)) {
      arr.push(isKey ? key : map[key]);
    }
  }
  return arr;
}, each:function(fn, scope) {
  var items = Ext.apply({}, this.map), key, length = this.length;
  scope = scope || this;
  for (key in items) {
    if (items.hasOwnProperty(key)) {
      if (fn.call(scope, key, items[key], length) === false) {
        break;
      }
    }
  }
  return this;
}, clone:function() {
  var hash = new this.self(this.initialConfig), map = this.map, key;
  hash.suspendEvents();
  for (key in map) {
    if (map.hasOwnProperty(key)) {
      hash.add(key, map[key]);
    }
  }
  hash.resumeEvents();
  return hash;
}, findKey:function(value) {
  var key, map = this.map;
  for (key in map) {
    if (map.hasOwnProperty(key) && map[key] === value) {
      return key;
    }
  }
  return undefined;
}, destroy:function() {
  this.callParent();
  this.map = null;
}}, function(HashMap) {
  var prototype = HashMap.prototype;
  prototype.removeByKey = prototype.removeAtKey;
});
Ext.define('Ext.promise.Consequence', function(Consequence) {
  return {promise:null, deferred:null, onFulfilled:null, onRejected:null, onProgress:null, constructor:function(onFulfilled, onRejected, onProgress) {
    var me = this;
    me.onFulfilled = onFulfilled;
    me.onRejected = onRejected;
    me.onProgress = onProgress;
    me.deferred = new Ext.promise.Deferred;
    me.promise = me.deferred.promise;
  }, trigger:function(action, value) {
    var me = this, deferred = me.deferred;
    switch(action) {
      case 'fulfill':
        me.propagate(value, me.onFulfilled, deferred, deferred.resolve);
        break;
      case 'reject':
        me.propagate(value, me.onRejected, deferred, deferred.reject);
        break;
    }
  }, update:function(progress) {
    if (Ext.isFunction(this.onProgress)) {
      progress = this.onProgress(progress);
    }
    this.deferred.update(progress);
  }, propagate:function(value, callback, deferred, deferredMethod) {
    if (Ext.isFunction(callback)) {
      this.schedule(function() {
        try {
          deferred.resolve(callback(value));
        } catch (e$6) {
          deferred.reject(e$6);
        }
      });
    } else {
      deferredMethod.call(this.deferred, value);
    }
  }, schedule:function(callback) {
    var n = Consequence.queueSize++;
    Consequence.queue[n] = callback;
    if (!n) {
      Ext.asap(Consequence.dispatch);
    }
  }, statics:{queue:new Array(10000), queueSize:0, dispatch:function() {
    var queue = Consequence.queue, fn, i;
    for (i = 0; i < Consequence.queueSize; ++i) {
      fn = queue[i];
      queue[i] = null;
      fn();
    }
    Consequence.queueSize = 0;
  }}};
});
Ext.define('Ext.promise.Deferred', {promise:null, consequences:[], completed:false, completionAction:null, completionValue:null, constructor:function() {
  var me = this;
  me.promise = new Ext.promise.Promise(me);
  me.consequences = [];
  me.completed = false;
  me.completionAction = null;
  me.completionValue = null;
}, then:function(onFulfilled, onRejected, onProgress) {
  var me = this, consequence = new Ext.promise.Consequence(onFulfilled, onRejected, onProgress);
  if (me.completed) {
    consequence.trigger(me.completionAction, me.completionValue);
  } else {
    me.consequences.push(consequence);
  }
  return consequence.promise;
}, resolve:function(value) {
  var me = this, isHandled, thenFn;
  if (me.completed) {
    return;
  }
  try {
    if (value === me.promise) {
      throw new TypeError('A Promise cannot be resolved with itself.');
    }
    if ((Ext.isObject(value) || Ext.isFunction(value)) && Ext.isFunction(thenFn = value.then)) {
      isHandled = false;
      try {
        thenFn.call(value, function(value) {
          if (!isHandled) {
            isHandled = true;
            me.resolve(value);
          }
        }, function(error) {
          if (!isHandled) {
            isHandled = true;
            me.reject(error);
          }
        });
      } catch (e$7) {
        if (!isHandled) {
          me.reject(e$7);
        }
      }
    } else {
      me.complete('fulfill', value);
    }
  } catch (e$8) {
    me.reject(e$8);
  }
}, reject:function(reason) {
  if (this.completed) {
    return;
  }
  this.complete('reject', reason);
}, update:function(progress) {
  var consequences = this.consequences, consequence, i, len;
  if (this.completed) {
    return;
  }
  for (i = 0, len = consequences.length; i < len; i++) {
    consequence = consequences[i];
    consequence.update(progress);
  }
}, complete:function(action, value) {
  var me = this, consequences = me.consequences, consequence, i, len;
  me.completionAction = action;
  me.completionValue = value;
  me.completed = true;
  for (i = 0, len = consequences.length; i < len; i++) {
    consequence = consequences[i];
    consequence.trigger(me.completionAction, me.completionValue);
  }
  me.consequences = null;
}});
Ext.define('Ext.promise.Promise', function(ExtPromise) {
  var Deferred;
  return {statics:{CancellationError:Ext.global.CancellationError || Error, _ready:function() {
    Deferred = Ext.promise.Deferred;
  }, all:function(promisesOrValues) {
    if (!(Ext.isArray(promisesOrValues) || ExtPromise.is(promisesOrValues))) {
      Ext.raise('Invalid parameter: expected an Array or Promise of an Array.');
    }
    return ExtPromise.when(promisesOrValues).then(function(promisesOrValues) {
      var deferred = new Deferred, remainingToResolve = promisesOrValues.length, results = new Array(remainingToResolve), index, promiseOrValue, resolve, i, len;
      if (!remainingToResolve) {
        deferred.resolve(results);
      } else {
        resolve = function(item, index) {
          return ExtPromise.when(item).then(function(value) {
            results[index] = value;
            if (!--remainingToResolve) {
              deferred.resolve(results);
            }
            return value;
          }, function(reason) {
            return deferred.reject(reason);
          });
        };
        for (index = i = 0, len = promisesOrValues.length; i < len; index = ++i) {
          promiseOrValue = promisesOrValues[index];
          if (index in promisesOrValues) {
            resolve(promiseOrValue, index);
          } else {
            remainingToResolve--;
          }
        }
      }
      return deferred.promise;
    });
  }, is:function(value) {
    return (Ext.isObject(value) || Ext.isFunction(value)) && Ext.isFunction(value.then);
  }, rethrowError:function(error) {
    Ext.asap(function() {
      throw error;
    });
  }, when:function(value) {
    var deferred = new Ext.promise.Deferred;
    deferred.resolve(value);
    return deferred.promise;
  }}, owner:null, constructor:function(owner) {
    this.owner = owner;
  }, then:function(onFulfilled, onRejected, onProgress, scope) {
    var ref;
    if (arguments.length === 1 && Ext.isObject(arguments[0])) {
      ref = arguments[0];
      onFulfilled = ref.success;
      onRejected = ref.failure;
      onProgress = ref.progress;
      scope = ref.scope;
    }
    if (scope) {
      if (onFulfilled) {
        onFulfilled = Ext.Function.bind(onFulfilled, scope);
      }
      if (onRejected) {
        onRejected = Ext.Function.bind(onRejected, scope);
      }
      if (onProgress) {
        onProgress = Ext.Function.bind(onProgress, scope);
      }
    }
    return this.owner.then(onFulfilled, onRejected, onProgress);
  }, otherwise:function(onRejected, scope) {
    var ref;
    if (arguments.length === 1 && Ext.isObject(arguments[0])) {
      ref = arguments[0];
      onRejected = ref.fn;
      scope = ref.scope;
    }
    if (scope != null) {
      onRejected = Ext.Function.bind(onRejected, scope);
    }
    return this.owner.then(null, onRejected);
  }, always:function(onCompleted, scope) {
    var ref;
    if (arguments.length === 1 && Ext.isObject(arguments[0])) {
      ref = arguments[0];
      onCompleted = ref.fn;
      scope = ref.scope;
    }
    if (scope != null) {
      onCompleted = Ext.Function.bind(onCompleted, scope);
    }
    return this.owner.then(function(value) {
      try {
        onCompleted();
      } catch (e$9) {
        ExtPromise.rethrowError(e$9);
      }
      return value;
    }, function(reason) {
      try {
        onCompleted();
      } catch (e$10) {
        ExtPromise.rethrowError(e$10);
      }
      throw reason;
    });
  }, done:function() {
    this.owner.then(null, ExtPromise.rethrowError);
  }, cancel:function(reason) {
    if (reason == null) {
      reason = null;
    }
    this.owner.reject(new this.self.CancellationError(reason));
  }, log:function(identifier) {
    if (identifier == null) {
      identifier = '';
    }
    return this._owner.then(function(value) {
      Ext.log('' + (identifier || 'Promise') + ' resolved with value: ' + value);
      return value;
    }, function(reason) {
      Ext.log('' + (identifier || 'Promise') + ' rejected with reason: ' + reason);
      throw reason;
    });
  }};
}, function(ExtPromise) {
  ExtPromise._ready();
});
Ext.define('Ext.Promise', function() {
  var Polyfiller;
  return {statics:{_ready:function() {
    Polyfiller = Ext.promise.Promise;
  }, all:function() {
    return Polyfiller.all.apply(Polyfiller, arguments);
  }, race:function() {
    Ext.raise('Not implemented');
  }, reject:function(reason) {
    var deferred = new Ext.promise.Deferred;
    deferred.reject(reason);
    return deferred.promise;
  }, resolve:function(value) {
    var deferred = new Ext.promise.Deferred;
    deferred.resolve(value);
    return deferred.promise;
  }}, constructor:function(action) {
    var deferred = new Ext.promise.Deferred;
    action(deferred.resolve.bind(deferred), deferred.reject.bind(deferred));
    return deferred.promise;
  }};
}, function(ExtPromise) {
  var P = Ext.global.Promise;
  if (P && P.resolve) {
    Ext.Promise = P;
  } else {
    ExtPromise._ready();
  }
});
Ext.define('Ext.Deferred', function(Deferred) {
  var ExtPromise, when;
  return {extend:Ext.promise.Deferred, statics:{_ready:function() {
    ExtPromise = Ext.promise.Promise;
    when = Ext.Promise.resolve;
  }, all:function() {
    return ExtPromise.all.apply(ExtPromise, arguments);
  }, any:function(promisesOrValues) {
    if (!(Ext.isArray(promisesOrValues) || ExtPromise.is(promisesOrValues))) {
      Ext.raise('Invalid parameter: expected an Array or Promise of an Array.');
    }
    return Deferred.some(promisesOrValues, 1).then(function(array) {
      return array[0];
    }, function(error) {
      if (error instanceof Error && error.message === 'Too few Promises were resolved.') {
        Ext.raise('No Promises were resolved.');
      } else {
        throw error;
      }
    });
  }, delay:function(promiseOrValue, milliseconds) {
    var deferred;
    if (arguments.length === 1) {
      milliseconds = promiseOrValue;
      promiseOrValue = undefined;
    }
    milliseconds = Math.max(milliseconds, 0);
    deferred = new Deferred;
    setTimeout(function() {
      deferred.resolve(promiseOrValue);
    }, milliseconds);
    return deferred.promise;
  }, map:function(promisesOrValues, mapFn) {
    if (!(Ext.isArray(promisesOrValues) || ExtPromise.is(promisesOrValues))) {
      Ext.raise('Invalid parameter: expected an Array or Promise of an Array.');
    }
    if (!Ext.isFunction(mapFn)) {
      Ext.raise('Invalid parameter: expected a function.');
    }
    return Deferred.resolved(promisesOrValues).then(function(promisesOrValues) {
      var deferred, index, promiseOrValue, remainingToResolve, resolve, results, i, len;
      remainingToResolve = promisesOrValues.length;
      results = new Array(promisesOrValues.length);
      deferred = new Deferred;
      if (!remainingToResolve) {
        deferred.resolve(results);
      } else {
        resolve = function(item, index) {
          return Deferred.resolved(item).then(function(value) {
            return mapFn(value, index, results);
          }).then(function(value) {
            results[index] = value;
            if (!--remainingToResolve) {
              deferred.resolve(results);
            }
            return value;
          }, function(reason) {
            return deferred.reject(reason);
          });
        };
        for (index = i = 0, len = promisesOrValues.length; i < len; index = ++i) {
          promiseOrValue = promisesOrValues[index];
          if (index in promisesOrValues) {
            resolve(promiseOrValue, index);
          } else {
            remainingToResolve--;
          }
        }
      }
      return deferred.promise;
    });
  }, memoize:function(fn, scope, hashFn) {
    var memoizedFn = Ext.Function.memoize(fn, scope, hashFn);
    return function() {
      return Deferred.all(Ext.Array.slice(arguments)).then(function(values) {
        return memoizedFn.apply(scope, values);
      });
    };
  }, parallel:function(fns, scope) {
    if (scope == null) {
      scope = null;
    }
    var args = Ext.Array.slice(arguments, 2);
    return Deferred.map(fns, function(fn) {
      if (!Ext.isFunction(fn)) {
        throw new Error('Invalid parameter: expected a function.');
      }
      return fn.apply(scope, args);
    });
  }, pipeline:function(fns, initialValue, scope) {
    if (scope == null) {
      scope = null;
    }
    return Deferred.reduce(fns, function(value, fn) {
      if (!Ext.isFunction(fn)) {
        throw new Error('Invalid parameter: expected a function.');
      }
      return fn.call(scope, value);
    }, initialValue);
  }, reduce:function(values, reduceFn, initialValue) {
    if (!(Ext.isArray(values) || ExtPromise.is(values))) {
      Ext.raise('Invalid parameter: expected an Array or Promise of an Array.');
    }
    if (!Ext.isFunction(reduceFn)) {
      Ext.raise('Invalid parameter: expected a function.');
    }
    var initialValueSpecified = arguments.length === 3;
    return Deferred.resolved(values).then(function(promisesOrValues) {
      var reduceArguments = [promisesOrValues, function(previousValueOrPromise, currentValueOrPromise, currentIndex) {
        return Deferred.resolved(previousValueOrPromise).then(function(previousValue) {
          return Deferred.resolved(currentValueOrPromise).then(function(currentValue) {
            return reduceFn(previousValue, currentValue, currentIndex, promisesOrValues);
          });
        });
      }];
      if (initialValueSpecified) {
        reduceArguments.push(initialValue);
      }
      return Ext.Array.reduce.apply(Ext.Array, reduceArguments);
    });
  }, rejected:function(reason) {
    var deferred = new Ext.Deferred;
    deferred.reject(reason);
    return deferred.promise;
  }, resolved:function(value) {
    var deferred = new Ext.Deferred;
    deferred.resolve(value);
    return deferred.promise;
  }, sequence:function(fns, scope) {
    if (scope == null) {
      scope = null;
    }
    var args = Ext.Array.slice(arguments, 2);
    return Deferred.reduce(fns, function(results, fn) {
      if (!Ext.isFunction(fn)) {
        throw new Error('Invalid parameter: expected a function.');
      }
      return Deferred.resolved(fn.apply(scope, args)).then(function(result) {
        results.push(result);
        return results;
      });
    }, []);
  }, some:function(promisesOrValues, howMany) {
    if (!(Ext.isArray(promisesOrValues) || ExtPromise.is(promisesOrValues))) {
      Ext.raise('Invalid parameter: expected an Array or Promise of an Array.');
    }
    if (!Ext.isNumeric(howMany) || howMany <= 0) {
      Ext.raise('Invalid parameter: expected a positive integer.');
    }
    return Deferred.resolved(promisesOrValues).then(function(promisesOrValues) {
      var deferred, index, onReject, onResolve, promiseOrValue, remainingToReject, remainingToResolve, values, i, len;
      values = [];
      remainingToResolve = howMany;
      remainingToReject = promisesOrValues.length - remainingToResolve + 1;
      deferred = new Deferred;
      if (promisesOrValues.length < howMany) {
        deferred.reject(new Error('Too few Promises were resolved.'));
      } else {
        onResolve = function(value) {
          if (remainingToResolve > 0) {
            values.push(value);
          }
          remainingToResolve--;
          if (remainingToResolve === 0) {
            deferred.resolve(values);
          }
          return value;
        };
        onReject = function(reason) {
          remainingToReject--;
          if (remainingToReject === 0) {
            deferred.reject(new Error('Too few Promises were resolved.'));
          }
          return reason;
        };
        for (index = i = 0, len = promisesOrValues.length; i < len; index = ++i) {
          promiseOrValue = promisesOrValues[index];
          if (index in promisesOrValues) {
            Deferred.resolved(promiseOrValue).then(onResolve, onReject);
          }
        }
      }
      return deferred.promise;
    });
  }, timeout:function(promiseOrValue, milliseconds) {
    var deferred = new Deferred, timeoutId;
    timeoutId = setTimeout(function() {
      if (timeoutId) {
        deferred.reject(new Error('Promise timed out.'));
      }
    }, milliseconds);
    Deferred.resolved(promiseOrValue).then(function(value) {
      clearTimeout(timeoutId);
      timeoutId = null;
      deferred.resolve(value);
    }, function(reason) {
      clearTimeout(timeoutId);
      timeoutId = null;
      deferred.reject(reason);
    });
    return deferred.promise;
  }}};
}, function(Deferred) {
  Deferred._ready();
});
Ext.Factory = function(type) {
  var me = this;
  me.aliasPrefix = type + '.';
  me.cache = {};
  me.name = type.replace(me.fixNameRe, me.fixNameFn);
  me.type = type;
};
Ext.Factory.prototype = {defaultProperty:'type', instanceProp:'isInstance', create:function(config, defaultType) {
  var me = this, Manager = Ext.ClassManager, cache = me.cache, alias, className, klass, suffix;
  if (config) {
    if (config[me.instanceProp]) {
      return config;
    }
    if (typeof config === 'string') {
      suffix = config;
      config = {};
      config[me.defaultProperty] = suffix;
    }
    className = config.xclass;
    suffix = config.type;
  }
  if (className) {
    if (!(klass = Manager.get(className))) {
      return Manager.instantiate(className, config);
    }
  } else {
    if (!(suffix = suffix || defaultType || me.defaultType)) {
      klass = me.defaultClass;
    }
    if (!suffix && !klass) {
      Ext.raise('No type specified for ' + me.type + '.create');
    }
    if (!klass && !(klass = cache[suffix])) {
      alias = me.aliasPrefix + suffix;
      className = Manager.getNameByAlias(alias);
      if (!(klass = className && Manager.get(className))) {
        return Manager.instantiateByAlias(alias, config);
      }
      cache[suffix] = klass;
    }
  }
  return klass.isInstance ? klass : new klass(config);
}, fixNameRe:/\.[a-z]/ig, fixNameFn:function(match) {
  return match.substring(1).toUpperCase();
}, clearCache:function() {
  this.cache = {};
}};
Ext.Factory.define = function(type, config) {
  var Factory = Ext.Factory, defaultClass, factory, fn;
  if (type.constructor === Object) {
    Ext.Object.each(type, Factory.define, Factory);
  } else {
    factory = new Ext.Factory(type);
    if (config) {
      if (config.constructor === Object) {
        Ext.apply(factory, config);
        if (typeof(defaultClass = factory.xclass) === 'string') {
          factory.defaultClass = Ext.ClassManager.get(defaultClass);
        }
      } else {
        factory.defaultType = config;
      }
    }
    Factory[factory.name] = fn = factory.create.bind(factory);
    fn.instance = factory;
  }
  return fn;
};
Ext.define('Ext.mixin.Factoryable', {mixinId:'factoryable', onClassMixedIn:function(targetClass) {
  var proto = targetClass.prototype, factoryConfig = proto.factoryConfig, alias = proto.alias, config = {}, dot, createFn;
  alias = alias && alias.length && alias[0];
  if (alias && (dot = alias.lastIndexOf('.')) > 0) {
    config.type = alias.substring(0, dot);
    config.defaultType = alias.substring(dot + 1);
  }
  if (factoryConfig) {
    delete proto.factoryConfig;
    Ext.apply(config, factoryConfig);
  }
  createFn = Ext.Factory.define(config.type, config);
  if (targetClass.create === Ext.Base.create) {
    targetClass.create = createFn;
  }
}});
Ext.define('Ext.data.request.Base', {mixins:[Ext.mixin.Factoryable], factoryConfig:{type:'request', defaultType:'ajax'}, result:null, success:null, timer:null, constructor:function(config) {
  var me = this;
  Ext.apply(me, config.options || {}, config.ownerConfig);
  me.id = ++Ext.data.Connection.requestId;
  me.owner = config.owner;
  me.options = config.options;
  me.requestOptions = config.requestOptions;
}, start:function() {
  var me = this, timeout = me.getTimeout();
  if (timeout && me.async) {
    me.timer = Ext.defer(me.onTimeout, timeout, me);
  }
}, abort:function() {
  var me = this;
  me.clearTimer();
  if (!me.timedout) {
    me.aborted = true;
  }
  me.abort = Ext.emptyFn;
}, createDeferred:function() {
  return this.deferred = new Ext.Deferred;
}, getDeferred:function() {
  return this.deferred || this.createDeferred();
}, getPromise:function() {
  return this.getDeferred().promise;
}, then:function() {
  var promise = this.getPromise();
  return promise.then.apply(promise, arguments);
}, onComplete:function() {
  var me = this, deferred = me.deferred, result = me.result;
  me.clearTimer();
  if (deferred) {
    if (me.success) {
      deferred.resolve(result);
    } else {
      deferred.reject(result);
    }
  }
}, onTimeout:function() {
  var me = this;
  me.timedout = true;
  me.timer = null;
  me.abort(true);
}, getTimeout:function() {
  return this.timeout;
}, clearTimer:function() {
  var timer = this.timer;
  if (timer) {
    clearTimeout(timer);
    this.timer = null;
  }
}, destroy:function() {
  var me = this;
  me.abort();
  me.owner = me.options = me.requestOptions = me.result = null;
  me.callParent();
}, privates:{createException:function() {
  var me = this, result;
  result = {request:me, requestId:me.id, status:me.aborted ? -1 : 0, statusText:me.aborted ? 'transaction aborted' : 'communication failure', getResponseHeader:me._getHeader, getAllResponseHeaders:me._getHeaders};
  if (me.aborted) {
    result.aborted = true;
  }
  if (me.timedout) {
    result.timedout = true;
  }
  return result;
}, _getHeader:function(name) {
  var headers = this.headers;
  return headers && headers[name.toLowerCase()];
}, _getHeaders:function() {
  return this.headers;
}}});
Ext.define('Ext.data.flash.BinaryXhr', {statics:{flashPluginActivated:function() {
  Ext.data.flash.BinaryXhr.flashPluginActive = true;
  Ext.data.flash.BinaryXhr.flashPlugin = document.getElementById('ext-flash-polyfill');
  Ext.GlobalEvents.fireEvent('flashready');
}, flashPluginActive:false, flashPluginInjected:false, connectionIndex:1, liveConnections:{}, flashPlugin:null, onFlashStateChange:function(javascriptId, state, data) {
  var connection;
  connection = this.liveConnections[Number(javascriptId)];
  if (connection) {
    connection.onFlashStateChange(state, data);
  } else {
    Ext.warn.log('onFlashStateChange for unknown connection ID: ' + javascriptId);
  }
}, registerConnection:function(conn) {
  var i = this.connectionIndex;
  this.conectionIndex = this.connectionIndex + 1;
  this.liveConnections[i] = conn;
  return i;
}, injectFlashPlugin:function() {
  var me = this, flashLoaderPath, flashObjectPath;
  me.flashPolyfillEl = Ext.getBody().appendChild({id:'ext-flash-polyfill', cn:[{tag:'p', html:'To view this page ensure that Adobe Flash Player version 11.1.0 or greater is installed.'}, {tag:'a', href:'http://www.adobe.com/go/getflashplayer', cn:[{tag:'img', src:window.location.protocol + '//www.adobe.com/images/shared/download_buttons/get_flash_player.gif', alt:'Get Adobe Flash player'}]}]});
  flashLoaderPath = [Ext.Loader.getPath('Ext.data.Connection'), '../../../plugins/flash/swfobject.js'].join('/');
  flashObjectPath = '/plugins/flash/FlashPlugin.swf';
  flashObjectPath = [Ext.Loader.getPath('Ext.data.Connection'), '../../plugins/flash/FlashPlugin.swf'].join('/');
  if (Ext.flashPluginPath) {
    flashObjectPath = Ext.flashPluginPath;
  }
  Ext.Loader.loadScript({url:flashLoaderPath, onLoad:function() {
    var swfVersionStr = '11.4.0';
    var xiSwfUrlStr = 'playerProductInstall.swf';
    var flashvars = {};
    var params = {};
    params.quality = 'high';
    params.bgcolor = '#ffffff';
    params.allowscriptaccess = 'sameDomain';
    params.allowfullscreen = 'true';
    var attributes = {};
    attributes.id = 'ext-flash-polyfill';
    attributes.name = 'polyfill';
    attributes.align = 'middle';
    swfobject.embedSWF(flashObjectPath, 'ext-flash-polyfill', '0', '0', swfVersionStr, xiSwfUrlStr, flashvars, params, attributes);
  }, onError:function() {
    Ext.raise('Could not load flash-loader file swfobject.js from ' + flashLoader);
  }, scope:me});
  Ext.data.flash.BinaryXhr.flashPluginInjected = true;
}}, readyState:0, status:0, statusText:'', responseBytes:null, javascriptId:null, constructor:function(config) {
  if (!Ext.data.flash.BinaryXhr.flashPluginInjected) {
    Ext.data.flash.BinaryXhr.injectFlashPlugin();
  }
  var me = this;
  Ext.apply(me, config);
  me.requestHeaders = {};
}, abort:function() {
  var me = this;
  if (me.readyState == 4) {
    Ext.warn.log("Aborting a connection that's completed its transfer: " + this.url);
    return;
  }
  me.aborted = true;
  if (!Ext.data.flash.BinaryXhr.flashPluginActive) {
    Ext.GlobalEvents.removeListener('flashready', me.onFlashReady, me);
    return;
  }
  Ext.data.flash.BinaryXhr.flashPlugin.abortRequest(me.javascriptId);
  delete Ext.data.flash.BinaryXhr.liveConnections[me.javascriptId];
}, getAllResponseHeaders:function() {
  var headers = [];
  Ext.Object.each(this.responseHeaders, function(name, value) {
    headers.push(name + ': ' + value);
  });
  return headers.join('\r\n');
}, getResponseHeader:function(header) {
  var headers = this.responseHeaders;
  return headers && headers[header] || null;
}, open:function(method, url, async, user, password) {
  var me = this;
  me.method = method;
  me.url = url;
  me.async = async !== false;
  me.user = user;
  me.password = password;
  if (!me.async) {
    Ext.raise('Binary posts are only supported in async mode: ' + url);
  }
  if (me.method != 'POST') {
    Ext.log.warn('Binary data can only be sent as a POST request: ' + url);
  }
}, overrideMimeType:function(mimeType) {
  this.mimeType = mimeType;
}, send:function(body) {
  var me = this;
  me.body = body;
  if (!Ext.data.flash.BinaryXhr.flashPluginActive) {
    Ext.GlobalEvents.addListener('flashready', me.onFlashReady, me);
  } else {
    this.onFlashReady();
  }
}, onFlashReady:function() {
  var me = this, req, status;
  me.javascriptId = Ext.data.flash.BinaryXhr.registerConnection(me);
  req = {method:me.method, url:me.url, user:me.user, password:me.password, mimeType:me.mimeType, requestHeaders:me.requestHeaders, body:me.body, javascriptId:me.javascriptId};
  status = Ext.data.flash.BinaryXhr.flashPlugin.postBinary(req);
}, setReadyState:function(state) {
  var me = this;
  if (me.readyState != state) {
    me.readyState = state;
    me.onreadystatechange();
  }
}, setRequestHeader:function(header, value) {
  this.requestHeaders[header] = value;
}, onreadystatechange:Ext.emptyFn, parseData:function(data) {
  var me = this;
  this.status = data.status || 0;
  me.responseHeaders = {};
  if (me.mimeType) {
    me.responseHeaders['content-type'] = me.mimeType;
  }
  if (data.reason == 'complete') {
    this.responseBytes = data.data;
    me.responseHeaders['content-length'] = data.data.length;
  } else {
    if (data.reason == 'error' || data.reason == 'securityError') {
      this.statusText = data.text;
      me.responseHeaders['content-length'] = 0;
    } else {
      Ext.raise('Unkown reason code in data: ' + data.reason);
    }
  }
}, onFlashStateChange:function(state, data) {
  var me = this;
  if (state == 4) {
    me.parseData(data);
    delete Ext.data.flash.BinaryXhr.liveConnections[me.javascriptId];
  }
  me.setReadyState(state);
}});
Ext.define('Ext.data.request.Ajax', {extend:Ext.data.request.Base, alias:'request.ajax', statics:{parseStatus:function(status) {
  status = status == 1223 ? 204 : status;
  var success = status >= 200 && status < 300 || status == 304, isException = false;
  if (!success) {
    switch(status) {
      case 12002:
      case 12029:
      case 12030:
      case 12031:
      case 12152:
      case 13030:
        isException = true;
        break;
    }
  }
  return {success:success, isException:isException};
}}, start:function(data) {
  var me = this, options = me.options, requestOptions = me.requestOptions, isXdr = me.isXdr, xhr, headers;
  xhr = me.xhr = me.openRequest(options, requestOptions, me.async, me.username, me.password);
  if (!isXdr) {
    headers = me.setupHeaders(xhr, options, requestOptions.data, requestOptions.params);
  }
  if (me.async) {
    if (!isXdr) {
      xhr.onreadystatechange = Ext.Function.bind(me.onStateChange, me);
    }
  }
  if (isXdr) {
    me.processXdrRequest(me, xhr);
  }
  me.callParent([data]);
  xhr.send(data);
  if (!me.async) {
    return me.onComplete();
  }
  return me;
}, abort:function(force) {
  var me = this, xhr = me.xhr;
  if (force || me.isLoading()) {
    try {
      xhr.onreadystatechange = null;
    } catch (e$11) {
      xhr.onreadystatechange = Ext.emptyFn;
    }
    xhr.abort();
    me.callParent([force]);
    me.onComplete();
    me.cleanup();
  }
}, cleanup:function() {
  this.xhr = null;
  delete this.xhr;
}, isLoading:function() {
  var me = this, xhr = me.xhr, state = xhr && xhr.readyState, C = Ext.data.flash && Ext.data.flash.BinaryXhr;
  if (!xhr || me.aborted || me.timedout) {
    return false;
  }
  if (C && xhr instanceof C) {
    return state !== 4;
  }
  return state !== 0 && state !== 4;
}, openRequest:function(options, requestOptions, async, username, password) {
  var me = this, xhr = me.newRequest(options);
  if (username) {
    xhr.open(requestOptions.method, requestOptions.url, async, username, password);
  } else {
    if (me.isXdr) {
      xhr.open(requestOptions.method, requestOptions.url);
    } else {
      xhr.open(requestOptions.method, requestOptions.url, async);
    }
  }
  if (options.binary || me.binary) {
    if (window.Uint8Array) {
      xhr.responseType = 'arraybuffer';
    } else {
      if (xhr.overrideMimeType) {
        xhr.overrideMimeType('text/plain; charset\x3dx-user-defined');
      } else {
        if (!Ext.isIE) {
          Ext.log.warn('Your browser does not support loading binary data using Ajax.');
        }
      }
    }
  }
  if (options.withCredentials || me.withCredentials) {
    xhr.withCredentials = true;
  }
  return xhr;
}, newRequest:function(options) {
  var me = this, xhr;
  if (options.binaryData) {
    if (window.Uint8Array) {
      xhr = me.getXhrInstance();
    } else {
      xhr = new Ext.data.flash.BinaryXhr;
    }
  } else {
    if (me.cors && Ext.isIE9m) {
      xhr = me.getXdrInstance();
      me.isXdr = true;
    } else {
      xhr = me.getXhrInstance();
      me.isXdr = false;
    }
  }
  return xhr;
}, setupHeaders:function(xhr, options, data, params) {
  var me = this, headers = Ext.apply({}, options.headers || {}, me.defaultHeaders), contentType = me.defaultPostHeader, jsonData = options.jsonData, xmlData = options.xmlData, type = 'Content-Type', useHeader = me.useDefaultXhrHeader, key, header;
  if (!headers.hasOwnProperty(type) && (data || params)) {
    if (data) {
      if (options.rawData) {
        contentType = 'text/plain';
      } else {
        if (xmlData && Ext.isDefined(xmlData)) {
          contentType = 'text/xml';
        } else {
          if (jsonData && Ext.isDefined(jsonData)) {
            contentType = 'application/json';
          }
        }
      }
    }
    headers[type] = contentType;
  }
  if (useHeader && !headers['X-Requested-With']) {
    headers['X-Requested-With'] = me.defaultXhrHeader;
  }
  if (headers[type] === undefined || headers[type] === null) {
    delete headers[type];
  }
  try {
    for (key in headers) {
      if (headers.hasOwnProperty(key)) {
        header = headers[key];
        xhr.setRequestHeader(key, header);
      }
    }
  } catch (e$12) {
    me.owner.fireEvent('exception', key, header);
  }
  return headers;
}, getXdrInstance:function() {
  var xdr;
  if (Ext.ieVersion >= 8) {
    xdr = new XDomainRequest;
  } else {
    Ext.raise({msg:'Your browser does not support CORS'});
  }
  return xdr;
}, getXhrInstance:function() {
  var options = [function() {
    return new XMLHttpRequest;
  }, function() {
    return new ActiveXObject('MSXML2.XMLHTTP.3.0');
  }, function() {
    return new ActiveXObject('MSXML2.XMLHTTP');
  }, function() {
    return new ActiveXObject('Microsoft.XMLHTTP');
  }], i = 0, len = options.length, xhr;
  for (; i < len; ++i) {
    try {
      xhr = options[i];
      xhr();
      break;
    } catch (e$13) {
    }
  }
  return xhr;
}(), processXdrRequest:function(request, xhr) {
  var me = this;
  delete request.headers;
  request.contentType = request.options.contentType || me.defaultXdrContentType;
  xhr.onload = Ext.Function.bind(me.onStateChange, me, [true]);
  xhr.onerror = xhr.ontimeout = Ext.Function.bind(me.onStateChange, me, [false]);
}, processXdrResponse:function(response, xhr) {
  response.getAllResponseHeaders = function() {
    return [];
  };
  response.getResponseHeader = function() {
    return '';
  };
  response.contentType = xhr.contentType || this.defaultXdrContentType;
}, onStateChange:function(xdrResult) {
  var me = this, xhr = me.xhr, globalEvents = Ext.GlobalEvents;
  if (xhr && xhr.readyState == 4 || me.isXdr) {
    me.clearTimer();
    me.onComplete(xdrResult);
    me.cleanup();
    if (globalEvents.hasListeners.idle) {
      globalEvents.fireEvent('idle');
    }
  }
}, onComplete:function(xdrResult) {
  var me = this, owner = me.owner, options = me.options, xhr = me.xhr, failure = {success:false, isException:false}, result, success, response;
  if (!xhr || me.destroyed) {
    return me.result = failure;
  }
  try {
    result = Ext.data.request.Ajax.parseStatus(xhr.status);
    if (result.success) {
      result.success = xhr.readyState === 4;
    }
  } catch (e$14) {
    result = failure;
  }
  success = me.success = me.isXdr ? xdrResult : result.success;
  if (success) {
    response = me.createResponse(xhr);
    owner.fireEvent('requestcomplete', owner, response, options);
    Ext.callback(options.success, options.scope, [response, options]);
  } else {
    if (result.isException || me.aborted || me.timedout) {
      response = me.createException(xhr);
    } else {
      response = me.createResponse(xhr);
    }
    owner.fireEvent('requestexception', owner, response, options);
    Ext.callback(options.failure, options.scope, [response, options]);
  }
  me.result = response;
  Ext.callback(options.callback, options.scope, [options, success, response]);
  owner.onRequestComplete(me);
  me.callParent([xdrResult]);
  return response;
}, createResponse:function(xhr) {
  var me = this, isXdr = me.isXdr, headers = {}, lines = isXdr ? [] : xhr.getAllResponseHeaders().replace(/\r\n/g, '\n').split('\n'), count = lines.length, line, index, key, response, byteArray;
  while (count--) {
    line = lines[count];
    index = line.indexOf(':');
    if (index >= 0) {
      key = line.substr(0, index).toLowerCase();
      if (line.charAt(index + 1) == ' ') {
        ++index;
      }
      headers[key] = line.substr(index + 1);
    }
  }
  response = {request:me, requestId:me.id, status:xhr.status, statusText:xhr.statusText, getResponseHeader:function(header) {
    return headers[header.toLowerCase()];
  }, getAllResponseHeaders:function() {
    return headers;
  }};
  if (isXdr) {
    me.processXdrResponse(response, xhr);
  }
  if (me.binary) {
    response.responseBytes = me.getByteArray(xhr);
  } else {
    response.responseText = xhr.responseText;
    response.responseXML = xhr.responseXML;
  }
  return response;
}, destroy:function() {
  this.xhr = null;
  this.callParent();
}, privates:{getByteArray:function(xhr) {
  var response = xhr.response, responseBody = xhr.responseBody, Cls = Ext.data.flash && Ext.data.flash.BinaryXhr, byteArray, responseText, len, i;
  if (xhr instanceof Cls) {
    byteArray = xhr.responseBytes;
  } else {
    if (window.Uint8Array) {
      byteArray = response ? new Uint8Array(response) : [];
    } else {
      if (Ext.isIE9p) {
        try {
          byteArray = (new VBArray(responseBody)).toArray();
        } catch (e$15) {
          byteArray = [];
        }
      } else {
        if (Ext.isIE) {
          if (!this.self.vbScriptInjected) {
            this.injectVBScript();
          }
          getIEByteArray(xhr.responseBody, byteArray = []);
        } else {
          byteArray = [];
          responseText = xhr.responseText;
          len = responseText.length;
          for (i = 0; i < len; i++) {
            byteArray.push(responseText.charCodeAt(i) & 255);
          }
        }
      }
    }
  }
  return byteArray;
}, injectVBScript:function() {
  var scriptTag = document.createElement('script');
  scriptTag.type = 'text/vbscript';
  scriptTag.text = ['Function getIEByteArray(byteArray, out)', 'Dim len, i', 'len \x3d LenB(byteArray)', 'For i \x3d 1 to len', 'out.push(AscB(MidB(byteArray, i, 1)))', 'Next', 'End Function'].join('\n');
  Ext.getHead().dom.appendChild(scriptTag);
  this.self.vbScriptInjected = true;
}}});
Ext.define('Ext.data.request.Form', {extend:Ext.data.request.Base, alias:'request.form', start:function(data) {
  var me = this, options = me.options, requestOptions = me.requestOptions;
  me.callParent([data]);
  me.form = me.upload(options.form, requestOptions.url, requestOptions.data, options);
  return me;
}, abort:function(force) {
  var me = this, frame;
  if (me.isLoading()) {
    try {
      frame = me.frame.dom;
      if (frame.stop) {
        frame.stop();
      } else {
        frame.document.execCommand('Stop');
      }
    } catch (e$16) {
    }
  }
  me.callParent([force]);
  me.onComplete();
  me.cleanup();
}, cleanup:function() {
  var me = this, frame = me.frame;
  if (frame) {
    frame.un('load', me.onComplete, me);
    Ext.removeNode(frame);
  }
  me.frame = me.form = null;
}, isLoading:function() {
  return !!this.frame;
}, upload:function(form, url, params, options) {
  form = Ext.getDom(form);
  options = options || {};
  var frameDom = document.createElement('iframe'), frame = Ext.get(frameDom), id = frame.id, hiddens = [], encoding = 'multipart/form-data', buf = {target:form.target, method:form.method, encoding:form.encoding, enctype:form.enctype, action:form.action}, addField = function(name, value) {
    hiddenItem = document.createElement('input');
    Ext.fly(hiddenItem).set({type:'hidden', value:value, name:name});
    form.appendChild(hiddenItem);
    hiddens.push(hiddenItem);
  }, hiddenItem, obj, value, name, vLen, v, hLen, h, request;
  frame.set({name:id, cls:Ext.baseCSSPrefix + 'hidden-display', src:Ext.SSL_SECURE_URL, tabIndex:-1});
  document.body.appendChild(frameDom);
  if (document.frames) {
    document.frames[id].name = id;
  }
  Ext.fly(form).set({target:id, method:'POST', enctype:encoding, encoding:encoding, action:url || buf.action});
  if (params) {
    obj = Ext.Object.fromQueryString(params) || {};
    for (name in obj) {
      if (obj.hasOwnProperty(name)) {
        value = obj[name];
        if (Ext.isArray(value)) {
          vLen = value.length;
          for (v = 0; v < vLen; v++) {
            addField(name, value[v]);
          }
        } else {
          addField(name, value);
        }
      }
    }
  }
  this.frame = frame;
  frame.on({load:this.onComplete, scope:this, single:!Ext.isOpera});
  form.submit();
  Ext.fly(form).set(buf);
  for (hLen = hiddens.length, h = 0; h < hLen; h++) {
    Ext.removeNode(hiddens[h]);
  }
  return form;
}, getDoc:function() {
  var frame = this.frame.dom;
  return frame && (frame.contentWindow.document || frame.contentDocument) || (window.frames[frame.id] || {}).document;
}, getTimeout:function() {
  return this.options.timeout;
}, onComplete:function() {
  var me = this, frame = me.frame, owner = me.owner, options = me.options, callback, doc, success, contentNode, response;
  if (!frame) {
    return;
  }
  if (me.aborted || me.timedout) {
    me.result = response = me.createException();
    response.responseXML = null;
    response.responseText = '{success:false,message:"' + Ext.String.trim(response.statusText) + '"}';
    callback = options.failure;
    success = false;
  } else {
    try {
      doc = me.getDoc();
      me.result = response = {responseText:'', responseXML:null};
      if (doc) {
        if (Ext.isOpera && doc.location == Ext.SSL_SECURE_URL) {
          return;
        }
        if (doc.body) {
          if ((contentNode = doc.body.firstChild) && /pre/i.test(contentNode.tagName)) {
            response.responseText = contentNode.textContent || contentNode.innerText;
          } else {
            if (contentNode = doc.getElementsByTagName('textarea')[0]) {
              response.responseText = contentNode.value;
            } else {
              response.responseText = doc.body.textContent || doc.body.innerText;
            }
          }
        }
        response.responseXML = doc.XMLDocument || doc;
        callback = options.success;
        success = true;
        response.status = 200;
      } else {
        Ext.raise('Could not acquire a suitable connection for the file upload service.');
      }
    } catch (e$17) {
      me.result = response = me.createException();
      response.status = 400;
      response.statusText = (e$17.message || e$17.description) + '';
      response.responseText = '{success:false,message:"' + Ext.String.trim(response.statusText) + '"}';
      response.responseXML = null;
      callback = options.failure;
      success = false;
    }
  }
  me.frame = null;
  me.success = success;
  owner.fireEvent(success ? 'requestcomplete' : 'requestexception', owner, response, options);
  Ext.callback(callback, options.scope, [response, options]);
  Ext.callback(options.callback, options.scope, [options, success, response]);
  owner.onRequestComplete(me);
  Ext.asap(frame.destroy, frame);
  me.callParent();
}, destroy:function() {
  this.cleanup();
  this.callParent();
}});
Ext.define('Ext.data.Connection', {mixins:{observable:Ext.mixin.Observable}, statics:{requestId:0}, enctypeRe:/multipart\/form-data/i, config:{url:null, async:true, username:'', password:'', disableCaching:true, withCredentials:false, binary:false, cors:false, isXdr:false, defaultXdrContentType:'text/plain', disableCachingParam:'_dc', timeout:30000, extraParams:null, autoAbort:false, method:null, defaultHeaders:null, defaultPostHeader:'application/x-www-form-urlencoded; charset\x3dUTF-8', useDefaultXhrHeader:true, 
defaultXhrHeader:'XMLHttpRequest'}, constructor:function(config) {
  this.mixins.observable.constructor.call(this, config);
  this.requests = {};
}, request:function(options) {
  options = options || {};
  var me = this, requestOptions, request;
  if (me.fireEvent('beforerequest', me, options) !== false) {
    requestOptions = me.setOptions(options, options.scope || Ext.global);
    request = me.createRequest(options, requestOptions);
    return request.start(requestOptions.data);
  }
  Ext.callback(options.callback, options.scope, [options, undefined, undefined]);
  return Ext.Deferred.rejected([options, undefined, undefined]);
}, createRequest:function(options, requestOptions) {
  var me = this, type = options.type || requestOptions.type, request;
  if (!type) {
    type = me.isFormUpload(options) ? 'form' : 'ajax';
  }
  if (options.autoAbort || me.getAutoAbort()) {
    me.abort();
  }
  request = Ext.Factory.request({type:type, owner:me, options:options, requestOptions:requestOptions, ownerConfig:me.getConfig()});
  me.requests[request.id] = request;
  me.latestId = request.id;
  return request;
}, isFormUpload:function(options) {
  var form = this.getForm(options);
  if (form) {
    return options.isUpload || this.enctypeRe.test(form.getAttribute('enctype'));
  }
  return false;
}, getForm:function(options) {
  return Ext.getDom(options.form);
}, setOptions:function(options, scope) {
  var me = this, params = options.params || {}, extraParams = me.getExtraParams(), urlParams = options.urlParams, url = options.url || me.getUrl(), cors = options.cors, jsonData = options.jsonData, method, disableCache, data;
  if (cors !== undefined) {
    me.setCors(cors);
  }
  if (Ext.isFunction(params)) {
    params = params.call(scope, options);
  }
  if (Ext.isFunction(url)) {
    url = url.call(scope, options);
  }
  url = this.setupUrl(options, url);
  if (!url) {
    Ext.raise({options:options, msg:'No URL specified'});
  }
  data = options.rawData || options.binaryData || options.xmlData || jsonData || null;
  if (jsonData && !Ext.isPrimitive(jsonData)) {
    data = Ext.encode(data);
  }
  if (options.binaryData) {
    if (!Ext.isArray(options.binaryData)) {
      Ext.log.warn('Binary submission data must be an array of byte values! Instead got ' + typeof options.binaryData);
    }
    if (me.nativeBinaryPostSupport()) {
      data = new Uint8Array(options.binaryData);
      if (Ext.isChrome && Ext.chromeVersion < 22 || Ext.isSafari || Ext.isGecko) {
        data = data.buffer;
      }
    }
  }
  if (Ext.isObject(params)) {
    params = Ext.Object.toQueryString(params);
  }
  if (Ext.isObject(extraParams)) {
    extraParams = Ext.Object.toQueryString(extraParams);
  }
  params = params + (extraParams ? (params ? '\x26' : '') + extraParams : '');
  urlParams = Ext.isObject(urlParams) ? Ext.Object.toQueryString(urlParams) : urlParams;
  params = this.setupParams(options, params);
  method = (options.method || me.getMethod() || (params || data ? 'POST' : 'GET')).toUpperCase();
  this.setupMethod(options, method);
  disableCache = options.disableCaching !== false ? options.disableCaching || me.getDisableCaching() : false;
  if (method === 'GET' && disableCache) {
    url = Ext.urlAppend(url, (options.disableCachingParam || me.getDisableCachingParam()) + '\x3d' + (new Date).getTime());
  }
  if ((method == 'GET' || data) && params) {
    url = Ext.urlAppend(url, params);
    params = null;
  }
  if (urlParams) {
    url = Ext.urlAppend(url, urlParams);
  }
  return {url:url, method:method, data:data || params || null};
}, setupUrl:function(options, url) {
  var form = this.getForm(options);
  if (form) {
    url = url || form.action;
  }
  return url;
}, setupParams:function(options, params) {
  var form = this.getForm(options), serializedForm;
  if (form && !this.isFormUpload(options)) {
    serializedForm = Ext.Element.serializeForm(form);
    params = params ? params + '\x26' + serializedForm : serializedForm;
  }
  return params;
}, setupMethod:function(options, method) {
  if (this.isFormUpload(options)) {
    return 'POST';
  }
  return method;
}, isLoading:function(request) {
  if (!request) {
    request = this.getLatest();
  }
  return request ? request.isLoading() : false;
}, abort:function(request) {
  if (!request) {
    request = this.getLatest();
  }
  if (request && request.isLoading()) {
    request.abort();
  }
}, abortAll:function() {
  var requests = this.requests, id;
  for (id in requests) {
    this.abort(requests[id]);
  }
}, getLatest:function() {
  var id = this.latestId, request;
  if (id) {
    request = this.requests[id];
  }
  return request || null;
}, clearTimeout:function(request) {
  if (!request) {
    request = this.getLatest();
  }
  if (request) {
    request.clearTimer();
  }
}, onRequestComplete:function(request) {
  delete this.requests[request.id];
}, nativeBinaryPostSupport:function() {
  return Ext.isChrome || Ext.isSafari && Ext.isDefined(window.Uint8Array) || Ext.isGecko && Ext.isDefined(window.Uint8Array);
}});
Ext.define('MobileJudge.override.Connection', {override:'Ext.data.Connection', constructor:function(config) {
  this.callParent(config);
  this.on('requestcomplete', this.refreshToken, this);
  this.on('requestexception', this.handle401Error, this);
}, handle401Error:function(conn, response) {
  Ext.GlobalEvents.fireEvent('requestError', conn, response);
}, refreshToken:function(conn, response) {
  if (response && response.getResponseHeader) {
    var refreshToken = response.getResponseHeader('X-AUTH-TOKEN');
    if (refreshToken) {
      localStorage.setItem('token', refreshToken);
    }
  }
}, request:function(options) {
  options = options || {};
  var token = localStorage.getItem('token');
  if (token) {
    options.headers = {Authorization:'Bearer ' + token};
  }
  this.callParent([options]);
}});
Ext.define('Ext.Ajax', {extend:Ext.data.Connection, singleton:true, autoAbort:false});
Ext.define('Ext.AnimationQueue', {singleton:true, constructor:function() {
  var me = this;
  me.queue = [];
  me.taskQueue = [];
  me.runningQueue = [];
  me.idleQueue = [];
  me.isRunning = false;
  me.isIdle = true;
  me.run = Ext.Function.bind(me.run, me);
  if (Ext.os.is.iOS) {
    Ext.interval(me.watch, 500, me);
  }
}, start:function(fn, scope, args) {
  var me = this;
  me.queue.push(arguments);
  if (!me.isRunning) {
    if (me.hasOwnProperty('idleTimer')) {
      clearTimeout(me.idleTimer);
      delete me.idleTimer;
    }
    if (me.hasOwnProperty('idleQueueTimer')) {
      clearTimeout(me.idleQueueTimer);
      delete me.idleQueueTimer;
    }
    me.isIdle = false;
    me.isRunning = true;
    me.startCountTime = Ext.now();
    me.count = 0;
    me.doStart();
  }
}, watch:function() {
  if (this.isRunning && Ext.now() - this.lastRunTime >= 500) {
    this.run();
  }
}, run:function() {
  var me = this;
  if (!me.isRunning) {
    return;
  }
  var queue = me.runningQueue, now = Ext.now(), i, ln;
  me.lastRunTime = now;
  me.frameStartTime = now;
  queue.push.apply(queue, me.queue);
  for (i = 0, ln = queue.length; i < ln; i++) {
    me.invoke(queue[i]);
  }
  queue.length = 0;
  var elapse = me.frameStartTime - me.startCountTime, count = ++me.count;
  if (elapse >= 200) {
    me.onFpsChanged(count * 1000 / elapse, count, elapse);
    me.startCountTime = me.frameStartTime;
    me.count = 0;
  }
  me.doIterate();
}, onFpsChanged:Ext.emptyFn, onStop:Ext.emptyFn, doStart:function() {
  this.animationFrameId = Ext.Function.requestAnimationFrame(this.run);
  this.lastRunTime = Ext.now();
}, doIterate:function() {
  this.animationFrameId = Ext.Function.requestAnimationFrame(this.run);
}, doStop:function() {
  Ext.Function.cancelAnimationFrame(this.animationFrameId);
}, stop:function(fn, scope, args) {
  var me = this;
  if (!me.isRunning) {
    return;
  }
  var queue = me.queue, ln = queue.length, i, item;
  for (i = 0; i < ln; i++) {
    item = queue[i];
    if (item[0] === fn && item[1] === scope && item[2] === args) {
      queue.splice(i, 1);
      i--;
      ln--;
    }
  }
  if (ln === 0) {
    me.doStop();
    me.onStop();
    me.isRunning = false;
    me.idleTimer = Ext.defer(me.whenIdle, 100, me);
  }
}, onIdle:function(fn, scope, args) {
  var listeners = this.idleQueue, i, ln, listener;
  for (i = 0, ln = listeners.length; i < ln; i++) {
    listener = listeners[i];
    if (fn === listener[0] && scope === listener[1] && args === listener[2]) {
      return;
    }
  }
  listeners.push(arguments);
  if (this.isIdle) {
    this.processIdleQueue();
  }
}, unIdle:function(fn, scope, args) {
  var listeners = this.idleQueue, i, ln, listener;
  for (i = 0, ln = listeners.length; i < ln; i++) {
    listener = listeners[i];
    if (fn === listener[0] && scope === listener[1] && args === listener[2]) {
      listeners.splice(i, 1);
      return true;
    }
  }
  return false;
}, queueTask:function(fn, scope, args) {
  this.taskQueue.push(arguments);
  this.processTaskQueue();
}, dequeueTask:function(fn, scope, args) {
  var listeners = this.taskQueue, i, ln, listener;
  for (i = 0, ln = listeners.length; i < ln; i++) {
    listener = listeners[i];
    if (fn === listener[0] && scope === listener[1] && args === listener[2]) {
      listeners.splice(i, 1);
      i--;
      ln--;
    }
  }
}, invoke:function(listener) {
  var fn = listener[0], scope = listener[1], args = listener[2];
  fn = typeof fn == 'string' ? scope[fn] : fn;
  if (Ext.isArray(args)) {
    fn.apply(scope, args);
  } else {
    fn.call(scope, args);
  }
}, whenIdle:function() {
  this.isIdle = true;
  this.processIdleQueue();
}, processIdleQueue:function() {
  if (!this.hasOwnProperty('idleQueueTimer')) {
    this.idleQueueTimer = Ext.defer(this.processIdleQueueItem, 1, this);
  }
}, processIdleQueueItem:function() {
  delete this.idleQueueTimer;
  if (!this.isIdle) {
    return;
  }
  var listeners = this.idleQueue, listener;
  if (listeners.length > 0) {
    listener = listeners.shift();
    this.invoke(listener);
    this.processIdleQueue();
  }
}, processTaskQueue:function() {
  if (!this.hasOwnProperty('taskQueueTimer')) {
    this.taskQueueTimer = Ext.defer(this.processTaskQueueItem, 15, this);
  }
}, processTaskQueueItem:function() {
  delete this.taskQueueTimer;
  var listeners = this.taskQueue, listener;
  if (listeners.length > 0) {
    listener = listeners.shift();
    this.invoke(listener);
    this.processTaskQueue();
  }
}, showFps:function() {
  var styleTpl = {color:'white', 'background-color':'black', 'text-align':'center', 'font-family':'sans-serif', 'font-size':'8px', 'font-weight':'normal', 'font-style':'normal', 'line-height':'20px', '-webkit-font-smoothing':'antialiased', 'zIndex':100000, position:'absolute'};
  Ext.getBody().append([{style:Ext.applyIf({bottom:'50px', left:0, width:'50px', height:'20px'}, styleTpl), html:'Average'}, {style:Ext.applyIf({'background-color':'red', 'font-size':'18px', 'line-height':'50px', bottom:0, left:0, width:'50px', height:'50px'}, styleTpl), id:'__averageFps', html:'0'}, {style:Ext.applyIf({bottom:'50px', left:'50px', width:'50px', height:'20px'}, styleTpl), html:'Min (Last 1k)'}, {style:Ext.applyIf({'background-color':'orange', 'font-size':'18px', 'line-height':'50px', 
  bottom:0, left:'50px', width:'50px', height:'50px'}, styleTpl), id:'__minFps', html:'0'}, {style:Ext.applyIf({bottom:'50px', left:'100px', width:'50px', height:'20px'}, styleTpl), html:'Max (Last 1k)'}, {style:Ext.applyIf({'background-color':'maroon', 'font-size':'18px', 'line-height':'50px', bottom:0, left:'100px', width:'50px', height:'50px'}, styleTpl), id:'__maxFps', html:'0'}, {style:Ext.applyIf({bottom:'50px', left:'150px', width:'50px', height:'20px'}, styleTpl), html:'Current'}, {style:Ext.applyIf({'background-color':'green', 
  'font-size':'18px', 'line-height':'50px', bottom:0, left:'150px', width:'50px', height:'50px'}, styleTpl), id:'__currentFps', html:'0'}]);
  Ext.AnimationQueue.resetFps();
}, resetFps:function() {
  var currentFps = Ext.get('__currentFps'), averageFps = Ext.get('__averageFps'), minFps = Ext.get('__minFps'), maxFps = Ext.get('__maxFps'), min = 1000, max = 0, count = 0, sum = 0;
  if (!currentFps) {
    return;
  }
  Ext.AnimationQueue.onFpsChanged = function(fps) {
    count++;
    if (!(count % 10)) {
      min = 1000;
      max = 0;
    }
    sum += fps;
    min = Math.min(min, fps);
    max = Math.max(max, fps);
    currentFps.setHtml(Math.round(fps));
    averageFps.setHtml(Math.round(sum / count));
    minFps.setHtml(Math.round(min));
    maxFps.setHtml(Math.round(max));
  };
}}, function() {
  var paramsString = window.location.search.substr(1), paramsArray = paramsString.split('\x26');
  if (Ext.Array.contains(paramsArray, 'showfps')) {
    Ext.onReady(Ext.Function.bind(this.showFps, this));
  }
});
Ext.define('Ext.ComponentManager', {alternateClassName:'Ext.ComponentMgr', singleton:true, count:0, typeName:'xtype', constructor:function(config) {
  var me = this;
  Ext.apply(me, config || {});
  me.all = {};
  me.references = {};
  me.onAvailableCallbacks = {};
}, create:function(config, defaultType) {
  if (typeof config === 'string') {
    return Ext.widget(config);
  }
  if (config.isComponent) {
    return config;
  }
  if ('xclass' in config) {
    return Ext.create(config.xclass, config);
  }
  return Ext.widget(config.xtype || defaultType, config);
}, get:function(id) {
  return this.all[id];
}, register:function(component) {
  var me = this, all = me.all, key = component.getId(), onAvailableCallbacks = me.onAvailableCallbacks;
  if (key === undefined) {
    Ext.raise('Component id is undefined. Please ensure the component has an id.');
  }
  if (key in all) {
    Ext.raise('Registering duplicate component id "' + key + '"');
  }
  all[key] = component;
  if (component.getReference && component.getReference()) {
    me.references[key] = component;
  }
  ++me.count;
  if (!me.hasFocusListener) {
    Ext.on('focus', me.onGlobalFocus, me);
    me.hasFocusListener = true;
  }
  onAvailableCallbacks = onAvailableCallbacks && onAvailableCallbacks[key];
  if (onAvailableCallbacks && onAvailableCallbacks.length) {
    me.notifyAvailable(component);
  }
}, unregister:function(component) {
  var id = component.getId();
  if (component.getReference && component.getReference()) {
    this.references[id] = null;
    delete this.references[id];
  }
  this.all[id] = null;
  delete this.all[id];
  this.count--;
}, markReferencesDirty:function() {
  this.referencesDirty = true;
}, fixReferences:function() {
  var me = this, references = me.references, key;
  if (me.referencesDirty) {
    for (key in references) {
      if (references.hasOwnProperty(key)) {
        references[key].fixReference();
      }
    }
    me.referencesDirty = false;
  }
}, onAvailable:function(id, fn, scope) {
  var me = this, callbacks = me.onAvailableCallbacks, all = me.all, item;
  if (id in all) {
    item = all[id];
    fn.call(scope || item, item);
  } else {
    if (id) {
      if (!Ext.isArray(callbacks[id])) {
        callbacks[id] = [];
      }
      callbacks[id].push(function(item) {
        fn.call(scope || item, item);
      });
    }
  }
}, notifyAvailable:function(item) {
  var callbacks = this.onAvailableCallbacks[item && item.getId()] || [];
  while (callbacks.length) {
    callbacks.shift()(item);
  }
}, each:function(fn, scope) {
  return Ext.Object.each(this.all, fn, scope);
}, getCount:function() {
  return this.count;
}, getAll:function() {
  return Ext.Object.getValues(this.all);
}, getActiveComponent:function() {
  return Ext.Component.fromElement(Ext.dom.Element.getActiveElement());
}, onGlobalFocus:function(e) {
  var me = this, toElement = e.toElement, fromElement = e.fromElement, toComponent = Ext.Component.fromElement(toElement), fromComponent = Ext.Component.fromElement(fromElement), commonAncestor, targetComponent;
  if (toComponent === fromComponent) {
    return;
  }
  commonAncestor = me.getCommonAncestor(fromComponent, toComponent);
  if (fromComponent && !(fromComponent.destroyed || fromComponent.destroying)) {
    if (fromComponent.handleBlurEvent) {
      fromComponent.handleBlurEvent(e);
    }
    for (targetComponent = fromComponent; targetComponent && targetComponent !== commonAncestor; targetComponent = targetComponent.getRefOwner()) {
      if (!(targetComponent.destroyed || targetComponent.destroying)) {
        targetComponent.onFocusLeave({event:e.event, type:'focusleave', target:fromElement, relatedTarget:toElement, fromComponent:fromComponent, toComponent:toComponent});
      }
    }
  }
  if (toComponent && !toComponent.destroyed) {
    if (toComponent.handleFocusEvent) {
      toComponent.handleFocusEvent(e);
    }
    for (targetComponent = toComponent; targetComponent && targetComponent !== commonAncestor; targetComponent = targetComponent.getRefOwner()) {
      targetComponent.onFocusEnter({event:e.event, type:'focusenter', relatedTarget:fromElement, target:toElement, fromComponent:fromComponent, toComponent:toComponent});
    }
  }
}, getCommonAncestor:function(compA, compB) {
  if (compA === compB) {
    return compA;
  }
  while (compA && !(compA.isAncestor(compB) || compA === compB)) {
    compA = compA.getRefOwner();
  }
  return compA;
}, privates:{clearAll:function() {
  this.all = {};
  this.references = {};
  this.onAvailableCallbacks = {};
}, fromElement:function(node, limit, selector) {
  var target = Ext.getDom(node), cache = this.all, depth = 0, topmost, cmpId, cmp;
  if (typeof limit !== 'number') {
    topmost = Ext.getDom(limit);
    limit = Number.MAX_VALUE;
  }
  while (target && target.nodeType === 1 && depth < limit && target !== topmost) {
    cmpId = target.getAttribute('data-componentid') || target.id;
    if (cmpId) {
      cmp = cache[cmpId];
      if (cmp && (!selector || Ext.ComponentQuery.is(cmp, selector))) {
        return cmp;
      }
      depth++;
    }
    target = target.parentNode;
  }
  return null;
}}, deprecated:{5:{methods:{isRegistered:null, registerType:null}}}}, function() {
  Ext.getCmp = function(id) {
    return Ext.ComponentManager.get(id);
  };
});
Ext.ns('Ext.util').Operators = {'\x3d':function(a, v) {
  return a == v;
}, '!\x3d':function(a, v) {
  return a != v;
}, '^\x3d':function(a, v) {
  return a && a.substr(0, v.length) == v;
}, '$\x3d':function(a, v) {
  return a && a.substr(a.length - v.length) == v;
}, '*\x3d':function(a, v) {
  return a && a.indexOf(v) !== -1;
}, '%\x3d':function(a, v) {
  return a % v === 0;
}, '|\x3d':function(a, v) {
  return a && (a == v || a.substr(0, v.length + 1) == v + '-');
}, '~\x3d':function(a, v) {
  return a && (' ' + a + ' ').indexOf(' ' + v + ' ') != -1;
}};
Ext.define('Ext.util.LruCache', {extend:Ext.util.HashMap, config:{maxSize:null}, add:function(key, newValue) {
  var me = this, entry, last;
  me.removeAtKey(key);
  last = me.last;
  entry = {prev:last, next:null, key:key, value:newValue};
  if (last) {
    last.next = entry;
  } else {
    me.first = entry;
  }
  me.last = entry;
  me.callParent([key, entry]);
  me.prune();
  return newValue;
}, insertBefore:function(key, newValue, sibling) {
  var me = this, existingKey, entry;
  if (sibling = this.map[this.findKey(sibling)]) {
    existingKey = me.findKey(newValue);
    if (existingKey) {
      me.unlinkEntry(entry = me.map[existingKey]);
    } else {
      entry = {prev:sibling.prev, next:sibling, key:key, value:newValue};
    }
    if (sibling.prev) {
      entry.prev.next = entry;
    } else {
      me.first = entry;
    }
    entry.next = sibling;
    sibling.prev = entry;
    me.prune();
    return newValue;
  } else {
    return me.add(key, newValue);
  }
}, get:function(key) {
  var entry = this.map[key];
  if (entry) {
    if (entry.next) {
      this.moveToEnd(entry);
    }
    return entry.value;
  }
}, removeAtKey:function(key) {
  this.unlinkEntry(this.map[key]);
  return this.callParent(arguments);
}, clear:function(initial) {
  this.first = this.last = null;
  return this.callParent([initial]);
}, unlinkEntry:function(entry) {
  if (entry) {
    if (entry.next) {
      entry.next.prev = entry.prev;
    } else {
      this.last = entry.prev;
    }
    if (entry.prev) {
      entry.prev.next = entry.next;
    } else {
      this.first = entry.next;
    }
    entry.prev = entry.next = null;
  }
}, moveToEnd:function(entry) {
  this.unlinkEntry(entry);
  if (entry.prev = this.last) {
    this.last.next = entry;
  } else {
    this.first = entry;
  }
  this.last = entry;
}, getArray:function(isKey) {
  var arr = [], entry = this.first;
  while (entry) {
    arr.push(isKey ? entry.key : entry.value);
    entry = entry.next;
  }
  return arr;
}, each:function(fn, scope, reverse) {
  var me = this, entry = reverse ? me.last : me.first, length = me.length;
  scope = scope || me;
  while (entry) {
    if (fn.call(scope, entry.key, entry.value, length) === false) {
      break;
    }
    entry = reverse ? entry.prev : entry.next;
  }
  return me;
}, findKey:function(value) {
  var key, map = this.map;
  for (key in map) {
    if (map.hasOwnProperty(key) && map[key].value === value) {
      return key;
    }
  }
  return undefined;
}, clone:function() {
  var newCache = new this.self(this.initialConfig), map = this.map, key;
  newCache.suspendEvents();
  for (key in map) {
    if (map.hasOwnProperty(key)) {
      newCache.add(key, map[key].value);
    }
  }
  newCache.resumeEvents();
  return newCache;
}, prune:function() {
  var me = this, max = me.getMaxSize(), purgeCount = max ? me.length - max : 0;
  if (purgeCount > 0) {
    for (; me.first && purgeCount; purgeCount--) {
      me.removeAtKey(me.first.key);
    }
  }
}, destroy:function() {
  this.first = this.last = null;
  this.callParent();
}});
Ext.define('Ext.ComponentQuery', {singleton:true}, function() {
  var cq = this, queryOperators = Ext.util.Operators, nthRe = /(\d*)n\+?(\d*)/, nthRe2 = /\D/, stripLeadingSpaceRe = /^(\s)+/, unescapeRe = /\\(.)/g, regexCache = new Ext.util.LruCache({maxSize:100}), filterFnPattern = ['var r \x3d [],', 'i \x3d 0,', 'it \x3d items,', 'l \x3d it.length,', 'c;', 'for (; i \x3c l; i++) {', 'c \x3d it[i];', 'if (c.{0}) {', 'r.push(c);', '}', '}', 'return r;'].join(''), filterItems = function(items, operation) {
    return operation.method.apply(this, [items].concat(operation.args));
  }, getItems = function(items, mode) {
    var result = [], i = 0, length = items.length, candidate, deep = mode !== '\x3e';
    for (; i < length; i++) {
      candidate = items[i];
      if (candidate.getRefItems) {
        result = result.concat(candidate.getRefItems(deep));
      }
    }
    return result;
  }, getAncestors = function(items) {
    var result = [], i = 0, length = items.length, candidate;
    for (; i < length; i++) {
      candidate = items[i];
      while (!!(candidate = candidate.getRefOwner())) {
        result.push(candidate);
      }
    }
    return result;
  }, filterByXType = function(items, xtype, shallow) {
    if (xtype === '*') {
      return items.slice();
    } else {
      var result = [], i = 0, length = items.length, candidate;
      for (; i < length; i++) {
        candidate = items[i];
        if (candidate.isXType(xtype, shallow)) {
          result.push(candidate);
        }
      }
      return result;
    }
  }, filterByAttribute = function(items, property, operator, compareTo) {
    var result = [], i = 0, length = items.length, mustBeOwnProperty, presenceOnly, candidate, propValue, j, propLen, config;
    if (property.charAt(0) === '@') {
      mustBeOwnProperty = true;
      property = property.substr(1);
    }
    if (property.charAt(0) === '?') {
      mustBeOwnProperty = true;
      presenceOnly = true;
      property = property.substr(1);
    }
    for (; i < length; i++) {
      candidate = items[i];
      config = candidate.getConfigurator && candidate.self.$config.configs[property];
      if (config) {
        propValue = candidate[config.names.get]();
      } else {
        if (mustBeOwnProperty && !candidate.hasOwnProperty(property)) {
          continue;
        } else {
          propValue = candidate[property];
        }
      }
      if (presenceOnly) {
        result.push(candidate);
      } else {
        if (operator === '~\x3d') {
          if (propValue) {
            if (!Ext.isArray(propValue)) {
              propValue = propValue.split(' ');
            }
            for (j = 0, propLen = propValue.length; j < propLen; j++) {
              if (queryOperators[operator](Ext.coerce(propValue[j], compareTo), compareTo)) {
                result.push(candidate);
                break;
              }
            }
          }
        } else {
          if (operator === '/\x3d') {
            if (propValue != null && compareTo.test(propValue)) {
              result.push(candidate);
            }
          } else {
            if (!compareTo ? !!candidate[property] : queryOperators[operator](Ext.coerce(propValue, compareTo), compareTo)) {
              result.push(candidate);
            }
          }
        }
      }
    }
    return result;
  }, filterById = function(items, id) {
    var result = [], i = 0, length = items.length, candidate;
    for (; i < length; i++) {
      candidate = items[i];
      if (candidate.getItemId() === id) {
        result.push(candidate);
      }
    }
    return result;
  }, filterByPseudo = function(items, name, value) {
    return cq.pseudos[name](items, value);
  }, modeRe = /^(\s?([>\^])\s?|\s|$)/, tokenRe = /^(#)?((?:\\\.|[\w\-])+|\*)(?:\((true|false)\))?/, matchers = [{re:/^\.((?:\\\.|[\w\-])+)(?:\((true|false)\))?/, method:filterByXType, argTransform:function(args) {
    var selector = args[0];
    Ext.log.warn('"' + selector + '" ComponentQuery selector style is deprecated,' + ' use "' + selector.replace(/^\./, '') + '" without the leading dot instead');
    if (args[1] !== undefined) {
      args[1] = args[1].replace(unescapeRe, '$1');
    }
    return args.slice(1);
  }}, {re:/^(?:\[((?:[@?$])?[\w\-]*)\s*(?:([\^$*~%!\/]?=)\s*(['"])?((?:\\\]|.)*?)\3)?(?!\\)\])/, method:filterByAttribute, argTransform:function(args) {
    var selector = args[0], property = args[1], operator = args[2], compareTo = args[4], compareRe;
    if (compareTo !== undefined) {
      compareTo = compareTo.replace(unescapeRe, '$1');
      var format = Ext.String.format, msg = "ComponentQuery selector '{0}' has an unescaped ({1}) character at the {2} " + 'of the attribute value pattern. Usually that indicates an error ' + 'where the opening quote is not followed by the closing quote. ' + 'If you need to match a ({1}) character at the {2} of the attribute ' + 'value, escape the quote character in your pattern: (\\{1})', match;
      if (match = /^(['"]).*?[^'"]$/.exec(compareTo)) {
        Ext.log.warn(format(msg, selector, match[1], 'beginning'));
      } else {
        if (match = /^[^'"].*?(['"])$/.exec(compareTo)) {
          Ext.log.warn(format(msg, selector, match[1], 'end'));
        }
      }
    }
    if (operator === '/\x3d') {
      compareRe = regexCache.get(compareTo);
      if (compareRe) {
        compareTo = compareRe;
      } else {
        compareTo = regexCache.add(compareTo, new RegExp(compareTo));
      }
    }
    return [property, operator, compareTo];
  }}, {re:/^#((?:\\\.|[\w\-])+)/, method:filterById}, {re:/^\:([\w\-]+)(?:\(((?:\{[^\}]+\})|(?:(?!\{)[^\s>\/]*?(?!\})))\))?/, method:filterByPseudo, argTransform:function(args) {
    if (args[2] !== undefined) {
      args[2] = args[2].replace(unescapeRe, '$1');
    }
    return args.slice(1);
  }}, {re:/^(?:\{([^\}]+)\})/, method:filterFnPattern}];
  cq.Query = Ext.extend(Object, {constructor:function(cfg) {
    cfg = cfg || {};
    Ext.apply(this, cfg);
  }, execute:function(root) {
    var operations = this.operations, result = [], op, i, len;
    for (i = 0, len = operations.length; i < len; i++) {
      op = operations[i];
      result = result.concat(this._execute(root, op));
    }
    return result;
  }, _execute:function(root, operations) {
    var i = 0, length = operations.length, operation, workingItems;
    if (!root) {
      workingItems = Ext.ComponentManager.getAll();
    } else {
      if (Ext.isIterable(root)) {
        workingItems = root;
      } else {
        if (root.isMixedCollection) {
          workingItems = root.items;
        }
      }
    }
    for (; i < length; i++) {
      operation = operations[i];
      if (operation.mode === '^') {
        workingItems = getAncestors(workingItems || [root]);
      } else {
        if (operation.mode) {
          workingItems = getItems(workingItems || [root], operation.mode);
        } else {
          workingItems = filterItems(workingItems || getItems([root]), operation);
        }
      }
      if (i === length - 1) {
        return workingItems;
      }
    }
    return [];
  }, is:function(component) {
    var operations = this.operations, result = false, len = operations.length, op, i;
    if (len === 0) {
      return true;
    }
    for (i = 0; i < len; i++) {
      op = operations[i];
      result = this._is(component, op);
      if (result) {
        return result;
      }
    }
    return false;
  }, _is:function(component, operations) {
    var len = operations.length, active = [component], operation, i, j, mode, items, item;
    for (i = len - 1; i >= 0; --i) {
      operation = operations[i];
      mode = operation.mode;
      if (mode) {
        if (mode === '^') {
          active = getItems(active, ' ');
        } else {
          if (mode === '\x3e') {
            items = [];
            for (j = 0, len = active.length; j < len; ++j) {
              item = active[j].getRefOwner();
              if (item) {
                items.push(item);
              }
            }
            active = items;
          } else {
            active = getAncestors(active);
          }
        }
        if (active.length === 0) {
          return false;
        }
      } else {
        active = filterItems(active, operation);
        if (active.length === 0) {
          return false;
        }
      }
    }
    return true;
  }, getMatches:function(components, operations) {
    var len = operations.length, i;
    for (i = 0; i < len; ++i) {
      components = filterItems(components, operations[i]);
      if (components.length === 0) {
        break;
      }
    }
    return components;
  }, isMultiMatch:function() {
    return this.operations.length > 1;
  }});
  Ext.apply(cq, {cache:new Ext.util.LruCache({maxSize:100}), pseudos:{not:function(components, selector) {
    var i = 0, length = components.length, results = [], index = -1, component;
    for (; i < length; ++i) {
      component = components[i];
      if (!cq.is(component, selector)) {
        results[++index] = component;
      }
    }
    return results;
  }, first:function(components) {
    var ret = [];
    if (components.length > 0) {
      ret.push(components[0]);
    }
    return ret;
  }, last:function(components) {
    var len = components.length, ret = [];
    if (len > 0) {
      ret.push(components[len - 1]);
    }
    return ret;
  }, focusable:function(cmps) {
    var len = cmps.length, results = [], i = 0, c;
    for (; i < len; i++) {
      c = cmps[i];
      if (c.isFocusable && c.isFocusable()) {
        results.push(c);
      }
    }
    return results;
  }, 'nth-child':function(c, a) {
    var result = [], m = nthRe.exec(a === 'even' && '2n' || a === 'odd' && '2n+1' || !nthRe2.test(a) && 'n+' + a || a), f = (m[1] || 1) - 0, len = m[2] - 0, i, n, nodeIndex;
    for (i = 0; n = c[i]; i++) {
      nodeIndex = i + 1;
      if (f === 1) {
        if (len === 0 || nodeIndex === len) {
          result.push(n);
        }
      } else {
        if ((nodeIndex + len) % f === 0) {
          result.push(n);
        }
      }
    }
    return result;
  }, scrollable:function(cmps) {
    var len = cmps.length, results = [], i = 0, c;
    for (; i < len; i++) {
      c = cmps[i];
      if (c.scrollable || c._scrollable) {
        results.push(c);
      }
    }
    return results;
  }}, query:function(selector, root) {
    if (!selector) {
      return Ext.ComponentManager.all.getArray();
    }
    var results = [], noDupResults = [], dupMatcher = {}, query = cq.cache.get(selector), resultsLn, cmp, i;
    if (!query) {
      query = cq.cache.add(selector, cq.parse(selector));
    }
    results = query.execute(root);
    if (query.isMultiMatch()) {
      resultsLn = results.length;
      for (i = 0; i < resultsLn; i++) {
        cmp = results[i];
        if (!dupMatcher[cmp.id]) {
          noDupResults.push(cmp);
          dupMatcher[cmp.id] = true;
        }
      }
      results = noDupResults;
    }
    return results;
  }, visitPreOrder:function(selector, root, fn, scope, extraArgs) {
    cq._visit(true, selector, root, fn, scope, extraArgs);
  }, visitPostOrder:function(selector, root, fn, scope, extraArgs) {
    cq._visit(false, selector, root, fn, scope, extraArgs);
  }, _visit:function(preOrder, selector, root, fn, scope, extraArgs) {
    var query = cq.cache.get(selector), callArgs = [root], children, len = 0, i, rootMatch;
    if (!query) {
      query = cq.cache.add(selector, cq.parse(selector));
    }
    rootMatch = query.is(root);
    if (root.getRefItems) {
      children = root.getRefItems();
      len = children.length;
    }
    if (extraArgs) {
      Ext.Array.push(callArgs, extraArgs);
    }
    if (preOrder) {
      if (rootMatch) {
        if (fn.apply(scope || root, callArgs) === false) {
          return false;
        }
      }
    }
    for (i = 0; i < len; i++) {
      if (cq._visit.call(cq, preOrder, selector, children[i], fn, scope, extraArgs) === false) {
        return false;
      }
    }
    if (!preOrder) {
      if (rootMatch) {
        if (fn.apply(scope || root, callArgs) === false) {
          return false;
        }
      }
    }
  }, is:function(component, selector) {
    if (!selector) {
      return true;
    }
    var query = cq.cache.get(selector);
    if (!query) {
      query = cq.cache.add(selector, cq.parse(selector));
    }
    return query.is(component);
  }, parse:function(selector) {
    var operations = [], selectors, sel, i, len;
    selectors = Ext.splitAndUnescape(selector, ',');
    for (i = 0, len = selectors.length; i < len; i++) {
      sel = Ext.String.trim(selectors[i]);
      if (sel === '') {
        Ext.raise('Invalid ComponentQuery selector: ""');
      }
      operations.push(cq._parse(sel));
    }
    return new cq.Query({operations:operations});
  }, _parse:function(selector) {
    var operations = [], trim = Ext.String.trim, length = matchers.length, lastSelector, tokenMatch, token, matchedChar, modeMatch, selectorMatch, transform, i, matcher, method, args;
    while (selector && lastSelector !== selector) {
      lastSelector = selector;
      tokenMatch = selector.match(tokenRe);
      if (tokenMatch) {
        matchedChar = tokenMatch[1];
        token = trim(tokenMatch[2]).replace(unescapeRe, '$1');
        if (matchedChar === '#') {
          operations.push({method:filterById, args:[token]});
        } else {
          operations.push({method:filterByXType, args:[token, Boolean(tokenMatch[3])]});
        }
        selector = selector.replace(tokenMatch[0], '').replace(stripLeadingSpaceRe, '$1');
      }
      while (!(modeMatch = selector.match(modeRe))) {
        for (i = 0; selector && i < length; i++) {
          matcher = matchers[i];
          selectorMatch = selector.match(matcher.re);
          method = matcher.method;
          transform = matcher.argTransform;
          if (selectorMatch) {
            if (transform) {
              args = transform(selectorMatch);
            } else {
              args = selectorMatch.slice(1);
            }
            operations.push({method:Ext.isString(matcher.method) ? Ext.functionFactory('items', Ext.String.format.apply(Ext.String, [method].concat(selectorMatch.slice(1)))) : matcher.method, args:args});
            selector = selector.replace(selectorMatch[0], '').replace(stripLeadingSpaceRe, '$1');
            break;
          }
          if (i === length - 1) {
            Ext.raise('Invalid ComponentQuery selector: "' + arguments[0] + '"');
          }
        }
      }
      if (modeMatch[1]) {
        operations.push({mode:modeMatch[2] || modeMatch[1]});
        selector = selector.replace(modeMatch[0], '').replace(stripLeadingSpaceRe, '');
      }
    }
    return operations;
  }});
  Ext.all = function() {
    return cq.query.apply(cq, arguments);
  };
  Ext.first = function() {
    var matches = cq.query.apply(cq, arguments);
    return matches && matches[0] || null;
  };
});
Ext.define('Ext.Evented', {alternateClassName:'Ext.EventedBase', mixins:[Ext.mixin.Observable], initialized:false, constructor:function(config) {
  this.mixins.observable.constructor.call(this, config);
  this.initialized = true;
}, onClassExtended:function(cls, data) {
  if (!data.hasOwnProperty('eventedConfig')) {
    return;
  }
  var config = data.config, eventedConfig = data.eventedConfig, name, cfg;
  if (config) {
    Ext.applyIf(config, eventedConfig);
  } else {
    cls.addConfig(eventedConfig);
  }
  for (name in eventedConfig) {
    if (eventedConfig.hasOwnProperty(name)) {
      cfg = Ext.Config.get(name);
      data[cfg.names.set] = cfg.eventedSetter || cfg.getEventedSetter();
    }
  }
}});
Ext.define('Ext.util.Positionable', {mixinId:'positionable', _positionTopLeft:['position', 'top', 'left'], _alignRe:/^([a-z]+)-([a-z]+)([?!])?$/, afterSetPosition:Ext.emptyFn, getAnchorToXY:function() {
  Ext.raise('getAnchorToXY is not implemented in ' + this.$className);
}, getBorderPadding:function() {
  Ext.raise('getBorderPadding is not implemented in ' + this.$className);
}, getLocalX:function() {
  Ext.raise('getLocalX is not implemented in ' + this.$className);
}, getLocalXY:function() {
  Ext.raise('getLocalXY is not implemented in ' + this.$className);
}, getLocalY:function() {
  Ext.raise('getLocalY is not implemented in ' + this.$className);
}, getX:function() {
  Ext.raise('getX is not implemented in ' + this.$className);
}, getXY:function() {
  Ext.raise('getXY is not implemented in ' + this.$className);
}, getY:function() {
  Ext.raise('getY is not implemented in ' + this.$className);
}, setLocalX:function() {
  Ext.raise('setLocalX is not implemented in ' + this.$className);
}, setLocalXY:function() {
  Ext.raise('setLocalXY is not implemented in ' + this.$className);
}, setLocalY:function() {
  Ext.raise('setLocalY is not implemented in ' + this.$className);
}, setX:function() {
  Ext.raise('setX is not implemented in ' + this.$className);
}, setXY:function() {
  Ext.raise('setXY is not implemented in ' + this.$className);
}, setY:function() {
  Ext.raise('setY is not implemented in ' + this.$className);
}, adjustForConstraints:function(xy, parent) {
  var vector = this.getConstrainVector(parent, xy);
  if (vector) {
    xy[0] += vector[0];
    xy[1] += vector[1];
  }
  return xy;
}, alignTo:function(element, position, offsets, animate) {
  var me = this, el = me.el;
  return me.setXY(me.getAlignToXY(element, position, offsets), el.anim && !!animate ? el.anim(animate) : false);
}, calculateAnchorXY:function(anchor, extraX, extraY, mySize) {
  var me = this, el = me.el, doc = document, isViewport = el.dom === doc.body || el.dom === doc, round = Math.round, xy, myWidth, myHeight;
  anchor = (anchor || 'tl').toLowerCase();
  mySize = mySize || {};
  myWidth = mySize.width || (isViewport ? Ext.Element.getViewportWidth() : me.getWidth());
  myHeight = mySize.height || (isViewport ? Ext.Element.getViewportHeight() : me.getHeight());
  switch(anchor) {
    case 'tl':
      xy = [0, 0];
      break;
    case 'bl':
      xy = [0, myHeight];
      break;
    case 'tr':
      xy = [myWidth, 0];
      break;
    case 'c':
      xy = [round(myWidth * 0.5), round(myHeight * 0.5)];
      break;
    case 't':
      xy = [round(myWidth * 0.5), 0];
      break;
    case 'l':
      xy = [0, round(myHeight * 0.5)];
      break;
    case 'r':
      xy = [myWidth, round(myHeight * 0.5)];
      break;
    case 'b':
      xy = [round(myWidth * 0.5), myHeight];
      break;
    case 'tc':
      xy = [round(myWidth * 0.5), 0];
      break;
    case 'bc':
      xy = [round(myWidth * 0.5), myHeight];
      break;
    case 'br':
      xy = [myWidth, myHeight];
  }
  return [xy[0] + extraX, xy[1] + extraY];
}, convertPositionSpec:Ext.identityFn, getAlignToXY:function(alignToEl, posSpec, offset) {
  var me = this, constrainToEl, constrainTo, alignMatch, myPosition, alignToElPosition, myWidth, myHeight, alignToElRegion, swapY, swapX, constrain, align1, align2, p1y, p1x, p2y, p2x, x, y;
  alignToEl = Ext.get(alignToEl.el || alignToEl);
  if (!alignToEl || !alignToEl.dom) {
    Ext.raise({sourceClass:'Ext.util.Positionable', sourceMethod:'getAlignToXY', msg:"Attempted to align an element that doesn't exist"});
  }
  offset = offset || [0, 0];
  posSpec = (!posSpec || posSpec === '?' ? 'tl-bl?' : !/-/.test(posSpec) && posSpec !== '' ? 'tl-' + posSpec : posSpec || 'tl-bl').toLowerCase();
  posSpec = me.convertPositionSpec(posSpec);
  alignMatch = posSpec.match(me._alignRe);
  if (!alignMatch) {
    Ext.raise({sourceClass:'Ext.util.Positionable', sourceMethod:'getAlignToXY', el:alignToEl, position:posSpec, offset:offset, msg:'Attemmpted to align an element with an invalid position: "' + posSpec + '"'});
  }
  align1 = alignMatch[1];
  align2 = alignMatch[2];
  constrain = !!alignMatch[3];
  myPosition = me.getAnchorXY(align1, true);
  alignToElPosition = me.getAnchorToXY(alignToEl, align2, false);
  x = alignToElPosition[0] - myPosition[0] + offset[0];
  y = alignToElPosition[1] - myPosition[1] + offset[1];
  if (constrain) {
    if (alignMatch[3] === '!') {
      constrainToEl = alignToEl;
    } else {
      constrainToEl = me.constrainTo || me.container || me.el.parent();
    }
    constrainToEl = Ext.get(constrainToEl.el || constrainToEl);
    constrainTo = constrainToEl.getConstrainRegion();
    constrainTo.right = constrainTo.left + constrainToEl.el.dom.clientWidth;
    myWidth = me.getWidth();
    myHeight = me.getHeight();
    alignToElRegion = alignToEl.getRegion();
    p1y = align1.charAt(0);
    p1x = align1.charAt(align1.length - 1);
    p2y = align2.charAt(0);
    p2x = align2.charAt(align2.length - 1);
    swapY = x < alignToElRegion.right && x + myWidth >= alignToElRegion.left && (p1y == 't' && p2y == 'b' || p1y == 'b' && p2y == 't');
    swapX = y < alignToElRegion.bottom && y + myHeight >= alignToElRegion.top && (p1x == 'r' && p2x == 'l' || p1x == 'l' && p2x == 'r');
    if (x + myWidth > constrainTo.right) {
      if (swapX) {
        x = alignToElRegion.left - myWidth;
        swapX = false;
      } else {
        x = constrainTo.right - myWidth;
      }
    }
    if (x < constrainTo.left) {
      x = swapX ? alignToElRegion.right : constrainTo.left;
    }
    if (y + myHeight > constrainTo.bottom) {
      if (swapY) {
        y = alignToElRegion.top - myHeight;
        swapY = false;
      } else {
        y = constrainTo.bottom - myHeight;
      }
    }
    if (y < constrainTo.top) {
      y = swapY ? alignToElRegion.bottom : constrainTo.top;
    }
  }
  return [x, y];
}, getAnchorXY:function(anchor, local, mySize) {
  var me = this, myPos = me.getXY(), el = me.el, doc = document, isViewport = el.dom == doc.body || el.dom == doc, scroll = el.getScroll(), extraX = isViewport ? scroll.left : local ? 0 : myPos[0], extraY = isViewport ? scroll.top : local ? 0 : myPos[1];
  return me.calculateAnchorXY(anchor, extraX, extraY, mySize);
}, getBox:function(contentBox, local) {
  var me = this, xy = local ? me.getLocalXY() : me.getXY(), x = xy[0], y = xy[1], w = me.getWidth(), h = me.getHeight(), borderPadding, beforeX, beforeY;
  if (contentBox) {
    borderPadding = me.getBorderPadding();
    beforeX = borderPadding.beforeX;
    beforeY = borderPadding.beforeY;
    x += beforeX;
    y += beforeY;
    w -= beforeX + borderPadding.afterX;
    h -= beforeY + borderPadding.afterY;
  }
  return {x:x, left:x, 0:x, y:y, top:y, 1:y, width:w, height:h, right:x + w, bottom:y + h};
}, calculateConstrainedPosition:function(constrainTo, proposedPosition, local, proposedSize) {
  var me = this, vector, fp = me.floatParent, parentNode = fp ? fp.getTargetEl() : null, parentOffset, borderPadding, proposedConstrainPosition, xy = false, localXY;
  if (local && fp) {
    parentOffset = parentNode.getXY();
    borderPadding = parentNode.getBorderPadding();
    parentOffset[0] += borderPadding.beforeX;
    parentOffset[1] += borderPadding.beforeY;
    if (proposedPosition) {
      proposedConstrainPosition = [proposedPosition[0] + parentOffset[0], proposedPosition[1] + parentOffset[1]];
    }
  } else {
    proposedConstrainPosition = proposedPosition;
  }
  constrainTo = constrainTo || me.constrainTo || parentNode || me.container || me.el.parent();
  if (local && proposedConstrainPosition) {
    proposedConstrainPosition = me.reverseTranslateXY(proposedConstrainPosition);
  }
  vector = (me.constrainHeader && me.header.rendered ? me.header : me).getConstrainVector(constrainTo, proposedConstrainPosition, proposedSize);
  if (vector) {
    xy = proposedPosition || me.getPosition(local);
    xy[0] += vector[0];
    xy[1] += vector[1];
  }
  return xy;
}, getConstrainRegion:function() {
  var me = this, el = me.el, isBody = el.dom.nodeName === 'BODY', dom = el.dom, borders = el.getBorders(), pos = el.getXY(), left = pos[0] + borders.beforeX, top = pos[1] + borders.beforeY, scroll, width, height;
  if (isBody) {
    scroll = el.getScroll();
    left = scroll.left;
    top = scroll.top;
    width = Ext.Element.getViewportWidth();
    height = Ext.Element.getViewportHeight();
  } else {
    width = dom.clientWidth;
    height = dom.clientHeight;
  }
  return new Ext.util.Region(top, left + width, top + height, left);
}, getConstrainVector:function(constrainTo, proposedPosition, proposedSize) {
  var thisRegion = this.getRegion(), vector = [0, 0], shadowSize = this.shadow && this.constrainShadow && !this.shadowDisabled ? this.shadow.getShadowSize() : undefined, overflowed = false, constrainSize, constraintInsets = this.constraintInsets;
  if (!(constrainTo instanceof Ext.util.Region)) {
    constrainTo = Ext.get(constrainTo.el || constrainTo);
    constrainSize = constrainTo.getViewSize();
    constrainTo = constrainTo.getConstrainRegion();
    constrainTo.right = constrainTo.left + constrainSize.width;
    constrainTo.bottom = constrainTo.top + constrainSize.height;
  }
  if (constraintInsets) {
    constraintInsets = Ext.isObject(constraintInsets) ? constraintInsets : Ext.Element.parseBox(constraintInsets);
    constrainTo.adjust(constraintInsets.top, constraintInsets.right, constraintInsets.bottom, constraintInsets.left);
  }
  if (proposedPosition) {
    thisRegion.translateBy(proposedPosition[0] - thisRegion.x, proposedPosition[1] - thisRegion.y);
  }
  if (proposedSize) {
    thisRegion.right = thisRegion.left + proposedSize[0];
    thisRegion.bottom = thisRegion.top + proposedSize[1];
  }
  if (shadowSize) {
    constrainTo.adjust(shadowSize[0], -shadowSize[1], -shadowSize[2], shadowSize[3]);
  }
  if (thisRegion.right > constrainTo.right) {
    overflowed = true;
    vector[0] = constrainTo.right - thisRegion.right;
  }
  if (thisRegion.left + vector[0] < constrainTo.left) {
    overflowed = true;
    vector[0] = constrainTo.left - thisRegion.left;
  }
  if (thisRegion.bottom > constrainTo.bottom) {
    overflowed = true;
    vector[1] = constrainTo.bottom - thisRegion.bottom;
  }
  if (thisRegion.top + vector[1] < constrainTo.top) {
    overflowed = true;
    vector[1] = constrainTo.top - thisRegion.top;
  }
  return overflowed ? vector : false;
}, getOffsetsTo:function(offsetsTo) {
  var o = this.getXY(), e = Ext.fly(offsetsTo.el || offsetsTo).getXY();
  return [o[0] - e[0], o[1] - e[1]];
}, getRegion:function() {
  var box = this.getBox();
  return new Ext.util.Region(box.top, box.right, box.bottom, box.left);
}, getClientRegion:function() {
  var me = this, scrollbarSize, viewContentBox = me.getBox(), myDom = me.dom;
  scrollbarSize = myDom.offsetWidth - myDom.clientWidth;
  if (scrollbarSize) {
    if (me.getStyle('direction') === 'rtl') {
      viewContentBox.left += scrollbarSize;
    } else {
      viewContentBox.right -= scrollbarSize;
    }
  }
  scrollbarSize = myDom.offsetHeight - myDom.clientHeight;
  if (scrollbarSize) {
    viewContentBox.bottom -= scrollbarSize;
  }
  return new Ext.util.Region(viewContentBox.top, viewContentBox.right, viewContentBox.bottom, viewContentBox.left);
}, getViewRegion:function() {
  var me = this, el = me.el, isBody = el.dom.nodeName === 'BODY', borderPadding, scroll, pos, top, left, width, height;
  if (isBody) {
    scroll = el.getScroll();
    left = scroll.left;
    top = scroll.top;
    width = Ext.Element.getViewportWidth();
    height = Ext.Element.getViewportHeight();
  } else {
    borderPadding = me.getBorderPadding();
    pos = me.getXY();
    left = pos[0] + borderPadding.beforeX;
    top = pos[1] + borderPadding.beforeY;
    width = me.getWidth(true);
    height = me.getHeight(true);
  }
  return new Ext.util.Region(top, left + width, top + height, left);
}, move:function(direction, distance, animate) {
  var me = this, xy = me.getXY(), x = xy[0], y = xy[1], left = [x - distance, y], right = [x + distance, y], top = [x, y - distance], bottom = [x, y + distance], hash = {l:left, left:left, r:right, right:right, t:top, top:top, up:top, b:bottom, bottom:bottom, down:bottom};
  direction = direction.toLowerCase();
  me.setXY([hash[direction][0], hash[direction][1]], animate);
}, setBox:function(box) {
  var me = this, x, y;
  if (box.isRegion) {
    box = {x:box.left, y:box.top, width:box.right - box.left, height:box.bottom - box.top};
  }
  me.constrainBox(box);
  x = box.x;
  y = box.y;
  me.setXY([x, y]);
  me.setSize(box.width, box.height);
  me.afterSetPosition(x, y);
  return me;
}, constrainBox:function(box) {
  var me = this, constrainedPos, x, y;
  if (me.constrain || me.constrainHeader) {
    x = 'x' in box ? box.x : box.left;
    y = 'y' in box ? box.y : box.top;
    constrainedPos = me.calculateConstrainedPosition(null, [x, y], false, [box.width, box.height]);
    if (constrainedPos) {
      box.x = constrainedPos[0];
      box.y = constrainedPos[1];
    }
  }
}, translatePoints:function(x, y) {
  var pos = this.translateXY(x, y);
  return {left:pos.x, top:pos.y};
}, translateXY:function(x, y) {
  var me = this, el = me.el, styles = el.getStyle(me._positionTopLeft), relative = styles.position === 'relative', left = parseFloat(styles.left), top = parseFloat(styles.top), xy = me.getXY();
  if (Ext.isArray(x)) {
    y = x[1];
    x = x[0];
  }
  if (isNaN(left)) {
    left = relative ? 0 : el.dom.offsetLeft;
  }
  if (isNaN(top)) {
    top = relative ? 0 : el.dom.offsetTop;
  }
  left = typeof x === 'number' ? x - xy[0] + left : undefined;
  top = typeof y === 'number' ? y - xy[1] + top : undefined;
  return {x:left, y:top};
}, reverseTranslateXY:function(xy) {
  var coords = xy, el = this.el, translatedXY = [], dom = el.dom, offsetParent = dom.offsetParent, relative, offsetParentXY, x, y;
  if (offsetParent) {
    relative = el.isStyle('position', 'relative'), offsetParentXY = Ext.fly(offsetParent).getXY(), x = xy[0] + offsetParentXY[0] + offsetParent.clientLeft;
    y = xy[1] + offsetParentXY[1] + offsetParent.clientTop;
    if (relative) {
      x += el.getPadding('l');
      y += el.getPadding('t');
    }
    coords = [x, y];
  }
  return coords;
}});
Ext.define('Ext.dom.UnderlayPool', {constructor:function(elementConfig) {
  this.elementConfig = elementConfig;
  this.cache = [];
}, checkOut:function() {
  var el = this.cache.shift();
  if (!el) {
    el = Ext.Element.create(this.elementConfig);
    el.setVisibilityMode(2);
    el.dom.setAttribute('data-sticky', true);
  }
  return el;
}, checkIn:function(el) {
  this.cache.push(el);
}, reset:function() {
  var cache = this.cache, i = cache.length;
  while (i--) {
    cache[i].destroy();
  }
  this.cache = [];
}});
Ext.define('Ext.dom.Underlay', {constructor:function(config) {
  Ext.apply(this, config);
}, beforeShow:Ext.emptyFn, getInsertionTarget:function() {
  return this.target;
}, getPool:function() {
  return this.pool || (this.self.prototype.pool = new Ext.dom.UnderlayPool(this.elementConfig));
}, hide:function() {
  var me = this, el = me.el;
  if (el) {
    el.hide();
    me.getPool().checkIn(el);
    me.el = null;
    me.hidden = true;
  }
}, realign:function(x, y, width, height) {
  var me = this, el = me.el, target = me.target, offsets = me.offsets, max = Math.max;
  if (el) {
    if (x == null) {
      x = target.getX();
    }
    if (y == null) {
      y = target.getY();
    }
    if (width == null) {
      width = target.getWidth();
    }
    if (height == null) {
      height = target.getHeight();
    }
    if (offsets) {
      x = x + offsets.x;
      y = y + offsets.y;
      width = max(width + offsets.w, 0);
      height = max(height + offsets.h, 0);
    }
    el.setXY([x, y]);
    el.setSize(width, height);
  }
}, setZIndex:function(zIndex) {
  this.zIndex = zIndex;
  if (this.el) {
    this.el.setStyle('z-index', zIndex);
  }
}, show:function() {
  var me = this, target = me.target, zIndex = me.zIndex, el = me.el, insertionTarget = me.getInsertionTarget().dom, dom;
  if (!el) {
    el = me.el = me.getPool().checkOut();
  }
  me.beforeShow();
  if (zIndex == null) {
    zIndex = parseInt(target.getStyle('z-index'), 10);
  }
  if (zIndex) {
    el.setStyle('z-index', zIndex);
  }
  el.setStyle('position', me.fixed ? 'fixed' : '');
  dom = el.dom;
  if (dom.nextSibling !== insertionTarget) {
    target.dom.parentNode.insertBefore(dom, insertionTarget);
  }
  el.show();
  me.realign();
  me.hidden = false;
}});
Ext.define('Ext.dom.Shadow', {extend:Ext.dom.Underlay, alternateClassName:'Ext.Shadow', mode:'drop', offset:4, cls:Ext.baseCSSPrefix + (!Ext.supports.CSS3BoxShadow ? 'ie' : 'css') + '-shadow', constructor:function(config) {
  var me = this, outerOffsets, offsets, offset, rad;
  me.callParent([config]);
  me.elementConfig = {cls:me.cls, role:'presentation'};
  offset = me.offset;
  rad = Math.floor(offset / 2);
  me.opacity = 50;
  switch(me.mode.toLowerCase()) {
    case 'drop':
      outerOffsets = {x:0, y:0, w:offset, h:offset};
      if (Ext.supports.CSS3BoxShadow) {
        offsets = {x:offset, y:offset, h:-offset, w:-offset};
      } else {
        offsets = {x:-rad, y:-rad, h:-rad, w:-rad};
      }
      break;
    case 'sides':
      outerOffsets = {x:-offset, y:0, w:offset * 2, h:offset};
      if (Ext.supports.CSS3BoxShadow) {
        offsets = {x:0, y:offset, h:-offset, w:0};
      } else {
        offsets = {x:1 + rad - 2 * offset, y:-(1 + rad), h:-1, w:rad - 1};
      }
      break;
    case 'frame':
      outerOffsets = {x:-offset, y:-offset, w:offset * 2, h:offset * 2};
      if (Ext.supports.CSS3BoxShadow) {
        offsets = {x:0, y:0, h:0, w:0};
      } else {
        offsets = {x:1 + rad - 2 * offset, y:1 + rad - 2 * offset, h:offset - rad - 1, w:offset - rad - 1};
      }
      break;
    case 'bottom':
      outerOffsets = {x:-offset, y:0, w:offset * 2, h:offset};
      if (Ext.supports.CSS3BoxShadow) {
        offsets = {x:0, y:offset, h:-offset, w:0};
      } else {
        offsets = {x:0, y:offset, h:0, w:0};
      }
      break;
  }
  me.offsets = offsets;
  me.outerOffsets = outerOffsets;
}, getShadowSize:function() {
  var me = this, offset = me.el ? me.offset : 0, result = [offset, offset, offset, offset], mode = me.mode.toLowerCase();
  if (me.el && mode !== 'frame') {
    result[0] = 0;
    if (mode == 'drop') {
      result[3] = 0;
    }
  }
  return result;
}, boxShadowProperty:function() {
  var property = 'boxShadow', style = document.documentElement.style;
  if (!('boxShadow' in style)) {
    if ('WebkitBoxShadow' in style) {
      property = 'WebkitBoxShadow';
    } else {
      if ('MozBoxShadow' in style) {
        property = 'MozBoxShadow';
      }
    }
  }
  return property;
}(), beforeShow:function() {
  var me = this, style = me.el.dom.style, shim = me.shim;
  if (Ext.supports.CSS3BoxShadow) {
    style[me.boxShadowProperty] = '0 0 ' + (me.offset + 2) + 'px #888';
  } else {
    style.filter = 'progid:DXImageTransform.Microsoft.alpha(opacity\x3d' + me.opacity + ') progid:DXImageTransform.Microsoft.Blur(pixelradius\x3d' + me.offset + ')';
  }
  if (shim) {
    shim.realign();
  }
}, setOpacity:function(opacity) {
  var el = this.el;
  if (el) {
    if (Ext.isIE && !Ext.supports.CSS3BoxShadow) {
      opacity = Math.floor(opacity * 100 / 2) / 100;
    }
    this.opacity = opacity;
    el.setOpacity(opacity);
  }
}});
Ext.define('Ext.dom.Shim', {extend:Ext.dom.Underlay, cls:Ext.baseCSSPrefix + 'shim', constructor:function(config) {
  this.callParent([config]);
  this.elementConfig = {tag:'iframe', cls:this.cls, role:'presentation', frameBorder:'0', src:Ext.SSL_SECURE_URL, tabindex:'-1'};
}, getInsertionTarget:function() {
  var shadow = this.shadow;
  return shadow && shadow.el || this.target;
}});
Ext.define('Ext.dom.ElementEvent', {extend:Ext.util.Event, addListener:function(fn, scope, options, caller, manager) {
  var me = this, added = false, name = me.name, captures, directs, directCaptures;
  options = options || {};
  if (options.delegated === false || Ext.event.publisher.Dom.instance.directEvents[name]) {
    if (options.capture) {
      directCaptures = me.directCaptures || (me.directCaptures = new Ext.util.Event(me.observable, name));
      added = directCaptures.addListener(fn, scope, options, caller, manager);
    } else {
      directs = me.directs || (me.directs = new Ext.util.Event(me.observable, name));
      added = directs.addListener(fn, scope, options, caller, manager);
    }
  } else {
    if (options.capture) {
      captures = me.captures || (me.captures = new Ext.util.Event(me.observable, name));
      added = captures.addListener(fn, scope, options, caller, manager);
    } else {
      added = me.callParent([fn, scope, options, caller, manager]);
    }
  }
  return added;
}, removeListener:function(fn, scope) {
  var me = this, captures = me.captures, directs = me.directs, directCaptures = me.directCaptures, removed = false, index = me.findListener(fn, scope);
  if (index !== -1) {
    removed = me.callParent([fn, scope, index]);
  } else {
    if (directs) {
      index = directs.findListener(fn, scope);
    }
    if (index !== -1) {
      removed = directs.removeListener(fn, scope, index);
    } else {
      if (captures) {
        index = captures.findListener(fn, scope);
      }
      if (index !== -1) {
        removed = captures.removeListener(fn, scope, index);
      } else {
        if (directCaptures) {
          index = directCaptures.findListener(fn, scope);
          if (index !== -1) {
            removed = directCaptures.removeListener(fn, scope, index);
          }
        }
      }
    }
  }
  return removed;
}, clearListeners:function() {
  var me = this, directCaptures = me.directCaptures, directs = me.directs, captures = me.captures;
  if (directCaptures) {
    directCaptures.clearListeners();
  }
  if (directs) {
    directs.clearListeners();
  }
  if (captures) {
    captures.clearListeners();
  }
  me.callParent();
}, suspend:function() {
  var me = this, directCaptures = me.directCaptures, directs = me.directs, captures = me.captures;
  if (directCaptures) {
    directCaptures.suspend();
  }
  if (directs) {
    directs.suspend();
  }
  if (captures) {
    captures.suspend();
  }
  me.callParent();
}, resume:function() {
  var me = this, directCaptures = me.directCaptures, directs = me.directs, captures = me.captures;
  if (directCaptures) {
    directCaptures.resume();
  }
  if (directs) {
    directs.resume();
  }
  if (captures) {
    captures.resume();
  }
  me.callParent();
}});
Ext.define('Ext.event.publisher.Publisher', {handledEvents:[], statics:{publishers:{}, publishersByEvent:{}}, constructor:function() {
  var me = this, type = me.type;
  me.handles = {};
  if (!type) {
    Ext.raise("Event publisher '" + me.$className + "' defined without a 'type' property.");
  }
  if (me.self.instance) {
    Ext.raise("Cannot create multiple instances of '" + me.$className + "'. " + "Use '" + me.$className + ".instance' to retrieve the singleton instance.");
  }
  me.registerEvents();
  Ext.event.publisher.Publisher.publishers[type] = me;
}, registerEvents:function(events) {
  var me = this, publishersByEvent = Ext.event.publisher.Publisher.publishersByEvent, handledEvents = events || me.handledEvents, ln = handledEvents.length, eventName, i;
  for (i = 0; i < ln; i++) {
    eventName = handledEvents[i];
    me.handles[eventName] = 1;
    publishersByEvent[eventName] = me;
  }
}, subscribe:function() {
  Ext.raise("Ext.event.publisher.Publisher subclass '" + this.$className + '" has no subscribe method.');
}, unsubscribe:function() {
  Ext.raise("Ext.event.publisher.Publisher subclass '" + this.$className + '" has no unsubscribe method.');
}, fire:function(element, eventName, args) {
  var event;
  if (element.hasListeners[eventName]) {
    event = element.events[eventName];
    if (event) {
      event.fire.apply(event, args);
    }
  }
}});
Ext.define('Ext.util.Offset', {statics:{fromObject:function(obj) {
  return new this(obj.x, obj.y);
}}, constructor:function(x, y) {
  this.x = x != null && !isNaN(x) ? x : 0;
  this.y = y != null && !isNaN(y) ? y : 0;
  return this;
}, copy:function() {
  return new Ext.util.Offset(this.x, this.y);
}, copyFrom:function(p) {
  this.x = p.x;
  this.y = p.y;
}, toString:function() {
  return 'Offset[' + this.x + ',' + this.y + ']';
}, equals:function(offset) {
  if (!(offset instanceof this.statics())) {
    Ext.raise('Offset must be an instance of Ext.util.Offset');
  }
  return this.x == offset.x && this.y == offset.y;
}, round:function(to) {
  if (!isNaN(to)) {
    var factor = Math.pow(10, to);
    this.x = Math.round(this.x * factor) / factor;
    this.y = Math.round(this.y * factor) / factor;
  } else {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
  }
}, isZero:function() {
  return this.x == 0 && this.y == 0;
}});
Ext.define('Ext.util.Region', {isRegion:true, statics:{getRegion:function(el) {
  return Ext.fly(el).getRegion();
}, from:function(o) {
  return new this(o.top, o.right, o.bottom, o.left);
}}, constructor:function(top, right, bottom, left) {
  var me = this;
  me.y = me.top = me[1] = top;
  me.right = right;
  me.bottom = bottom;
  me.x = me.left = me[0] = left;
}, contains:function(region) {
  var me = this;
  return region.x >= me.x && region.right <= me.right && region.y >= me.y && region.bottom <= me.bottom;
}, intersect:function(region) {
  var me = this, t = Math.max(me.y, region.y), r = Math.min(me.right, region.right), b = Math.min(me.bottom, region.bottom), l = Math.max(me.x, region.x);
  if (b > t && r > l) {
    return new this.self(t, r, b, l);
  } else {
    return false;
  }
}, union:function(region) {
  var me = this, t = Math.min(me.y, region.y), r = Math.max(me.right, region.right), b = Math.max(me.bottom, region.bottom), l = Math.min(me.x, region.x);
  return new this.self(t, r, b, l);
}, constrainTo:function(r) {
  var me = this, constrain = Ext.Number.constrain;
  me.top = me.y = constrain(me.top, r.y, r.bottom);
  me.bottom = constrain(me.bottom, r.y, r.bottom);
  me.left = me.x = constrain(me.left, r.x, r.right);
  me.right = constrain(me.right, r.x, r.right);
  return me;
}, adjust:function(top, right, bottom, left) {
  var me = this;
  me.top = me.y += top;
  me.left = me.x += left;
  me.right += right;
  me.bottom += bottom;
  return me;
}, getOutOfBoundOffset:function(axis, p) {
  if (!Ext.isObject(axis)) {
    if (axis == 'x') {
      return this.getOutOfBoundOffsetX(p);
    } else {
      return this.getOutOfBoundOffsetY(p);
    }
  } else {
    p = axis;
    var d = new Ext.util.Offset;
    d.x = this.getOutOfBoundOffsetX(p.x);
    d.y = this.getOutOfBoundOffsetY(p.y);
    return d;
  }
}, getOutOfBoundOffsetX:function(p) {
  if (p <= this.x) {
    return this.x - p;
  } else {
    if (p >= this.right) {
      return this.right - p;
    }
  }
  return 0;
}, getOutOfBoundOffsetY:function(p) {
  if (p <= this.y) {
    return this.y - p;
  } else {
    if (p >= this.bottom) {
      return this.bottom - p;
    }
  }
  return 0;
}, isOutOfBound:function(axis, p) {
  if (!Ext.isObject(axis)) {
    if (axis == 'x') {
      return this.isOutOfBoundX(p);
    } else {
      return this.isOutOfBoundY(p);
    }
  } else {
    p = axis;
    return this.isOutOfBoundX(p.x) || this.isOutOfBoundY(p.y);
  }
}, isOutOfBoundX:function(p) {
  return p < this.x || p > this.right;
}, isOutOfBoundY:function(p) {
  return p < this.y || p > this.bottom;
}, restrict:function(axis, p, factor) {
  if (Ext.isObject(axis)) {
    var newP;
    factor = p;
    p = axis;
    if (p.copy) {
      newP = p.copy();
    } else {
      newP = {x:p.x, y:p.y};
    }
    newP.x = this.restrictX(p.x, factor);
    newP.y = this.restrictY(p.y, factor);
    return newP;
  } else {
    if (axis == 'x') {
      return this.restrictX(p, factor);
    } else {
      return this.restrictY(p, factor);
    }
  }
}, restrictX:function(p, factor) {
  if (!factor) {
    factor = 1;
  }
  if (p <= this.x) {
    p -= (p - this.x) * factor;
  } else {
    if (p >= this.right) {
      p -= (p - this.right) * factor;
    }
  }
  return p;
}, restrictY:function(p, factor) {
  if (!factor) {
    factor = 1;
  }
  if (p <= this.y) {
    p -= (p - this.y) * factor;
  } else {
    if (p >= this.bottom) {
      p -= (p - this.bottom) * factor;
    }
  }
  return p;
}, getSize:function() {
  return {width:this.right - this.x, height:this.bottom - this.y};
}, copy:function() {
  return new this.self(this.y, this.right, this.bottom, this.x);
}, copyFrom:function(p) {
  var me = this;
  me.top = me.y = me[1] = p.y;
  me.right = p.right;
  me.bottom = p.bottom;
  me.left = me.x = me[0] = p.x;
  return this;
}, toString:function() {
  return 'Region[' + this.top + ',' + this.right + ',' + this.bottom + ',' + this.left + ']';
}, translateBy:function(x, y) {
  if (arguments.length == 1) {
    y = x.y;
    x = x.x;
  }
  var me = this;
  me.top = me.y += y;
  me.right += x;
  me.bottom += y;
  me.left = me.x += x;
  return me;
}, round:function() {
  var me = this;
  me.top = me.y = Math.round(me.y);
  me.right = Math.round(me.right);
  me.bottom = Math.round(me.bottom);
  me.left = me.x = Math.round(me.x);
  return me;
}, equals:function(region) {
  return this.top === region.top && this.right === region.right && this.bottom === region.bottom && this.left === region.left;
}});
Ext.define('Ext.util.Point', {extend:Ext.util.Region, radianToDegreeConstant:180 / Math.PI, origin:{x:0, y:0}, statics:{fromEvent:function(e) {
  var changedTouches = e.changedTouches, touch = changedTouches && changedTouches.length > 0 ? changedTouches[0] : e;
  return this.fromTouch(touch);
}, fromTouch:function(touch) {
  return new this(touch.pageX, touch.pageY);
}, from:function(object) {
  if (!object) {
    return new this(0, 0);
  }
  if (!(object instanceof this)) {
    return new this(object.x, object.y);
  }
  return object;
}}, constructor:function(x, y) {
  if (x == null) {
    x = 0;
  }
  if (y == null) {
    y = 0;
  }
  this.callParent([y, x, y, x]);
}, clone:function() {
  return new this.self(this.x, this.y);
}, copy:function() {
  return this.clone.apply(this, arguments);
}, copyFrom:function(point) {
  this.x = point.x;
  this.y = point.y;
  return this;
}, toString:function() {
  return 'Point[' + this.x + ',' + this.y + ']';
}, equals:function(point) {
  return this.x === point.x && this.y === point.y;
}, isCloseTo:function(point, threshold) {
  if (typeof threshold == 'number') {
    return this.getDistanceTo(point) <= threshold;
  }
  var x = point.x, y = point.y, thresholdX = threshold.x, thresholdY = threshold.y;
  return this.x <= x + thresholdX && this.x >= x - thresholdX && this.y <= y + thresholdY && this.y >= y - thresholdY;
}, isWithin:function() {
  return this.isCloseTo.apply(this, arguments);
}, isContainedBy:function(region) {
  if (!(region instanceof Ext.util.Region)) {
    region = Ext.get(region.el || region).getRegion();
  }
  return region.contains(this);
}, roundedEquals:function(point) {
  if (!point || typeof point !== 'object') {
    point = this.origin;
  }
  return Math.round(this.x) === Math.round(point.x) && Math.round(this.y) === Math.round(point.y);
}, getDistanceTo:function(point) {
  if (!point || typeof point !== 'object') {
    point = this.origin;
  }
  var deltaX = this.x - point.x, deltaY = this.y - point.y;
  return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
}, getAngleTo:function(point) {
  if (!point || typeof point !== 'object') {
    point = this.origin;
  }
  var deltaX = this.x - point.x, deltaY = this.y - point.y;
  return Math.atan2(deltaY, deltaX) * this.radianToDegreeConstant;
}}, function() {
  this.prototype.translate = this.prototype.translateBy;
});
Ext.define('Ext.event.Event', {alternateClassName:'Ext.EventObjectImpl', isStopped:false, defaultPrevented:false, isEvent:true, statics:{resolveTextNode:function(node) {
  return node && node.nodeType === 3 ? node.parentNode : node;
}, pointerEvents:{pointerdown:1, pointermove:1, pointerup:1, pointercancel:1, pointerover:1, pointerout:1, pointerenter:1, pointerleave:1, MSPointerDown:1, MSPointerMove:1, MSPointerUp:1, MSPointerOver:1, MSPointerOut:1, MSPointerCancel:1, MSPointerEnter:1, MSPointerLeave:1}, mouseEvents:{mousedown:1, mousemove:1, mouseup:1, mouseover:1, mouseout:1, mouseenter:1, mouseleave:1}, clickEvents:{click:1, dblclick:1}, touchEvents:{touchstart:1, touchmove:1, touchend:1, touchcancel:1}, focusEvents:{focus:1, 
blur:1, focusin:1, focusout:1, focusenter:1, focusleave:1}, pointerTypes:{2:'touch', 3:'pen', 4:'mouse', touch:'touch', pen:'pen', mouse:'mouse'}}, constructor:function(event) {
  var me = this, self = me.self, resolveTextNode = me.self.resolveTextNode, changedTouches = event.changedTouches, coordinateOwner = changedTouches ? changedTouches[0] : event, type = event.type, pointerType, relatedTarget;
  me.pageX = coordinateOwner.pageX;
  me.pageY = coordinateOwner.pageY;
  me.target = me.delegatedTarget = resolveTextNode(event.target);
  relatedTarget = event.relatedTarget;
  if (relatedTarget) {
    me.relatedTarget = resolveTextNode(relatedTarget);
  }
  me.browserEvent = me.event = event;
  me.type = type;
  me.button = event.button || 0;
  me.shiftKey = event.shiftKey;
  me.ctrlKey = event.ctrlKey || event.metaKey || false;
  me.altKey = event.altKey;
  me.charCode = event.charCode;
  me.keyCode = event.keyCode;
  me.buttons = event.buttons;
  if (me.button === 0 && me.buttons === 0) {
    me.buttons = 1;
  }
  if (self.forwardTab !== undefined && self.focusEvents[type]) {
    me.forwardTab = self.forwardTab;
  }
  if (self.mouseEvents[type] || self.clickEvents[type]) {
    pointerType = 'mouse';
  } else {
    if (self.pointerEvents[type]) {
      pointerType = self.pointerTypes[event.pointerType];
    } else {
      if (self.touchEvents[type]) {
        pointerType = 'touch';
      }
    }
  }
  if (pointerType) {
    me.pointerType = pointerType;
  }
  me.timeStamp = me.time = +(event.timeStamp || new Date);
}, chain:function(props) {
  var e = Ext.Object.chain(this);
  e.parentEvent = this;
  return Ext.apply(e, props);
}, correctWheelDelta:function(delta) {
  var scale = this.WHEEL_SCALE, ret = Math.round(delta / scale);
  if (!ret && delta) {
    ret = delta < 0 ? -1 : 1;
  }
  return ret;
}, getCharCode:function() {
  return this.charCode || this.keyCode;
}, getKey:function() {
  return this.keyCode || this.charCode;
}, getKeyName:function() {
  return this.keyCodes[this.keyCode];
}, getPoint:function() {
  var xy = this.getXY();
  return new Ext.util.Point(xy[0], xy[1]);
}, getRelatedTarget:function(selector, maxDepth, returnEl) {
  var relatedTarget = this.relatedTarget, target = null;
  if (relatedTarget) {
    if (selector) {
      target = Ext.fly(relatedTarget).findParent(selector, maxDepth, returnEl);
    } else {
      target = returnEl ? Ext.get(relatedTarget) : relatedTarget;
    }
  }
  return target;
}, getTarget:function(selector, maxDepth, returnEl) {
  return selector ? Ext.fly(this.target).findParent(selector, maxDepth, returnEl) : returnEl ? Ext.get(this.target) : this.target;
}, getTime:function() {
  return this.time;
}, getWheelDelta:function() {
  var deltas = this.getWheelDeltas();
  return deltas.y;
}, getWheelDeltas:function() {
  var me = this, event = me.browserEvent, dx = 0, dy = 0;
  if (Ext.isDefined(event.wheelDeltaX)) {
    dx = event.wheelDeltaX;
    dy = event.wheelDeltaY;
  } else {
    if (event.wheelDelta) {
      dy = event.wheelDelta;
    } else {
      if (event.detail) {
        dy = -event.detail;
        if (dy > 100) {
          dy = 3;
        } else {
          if (dy < -100) {
            dy = -3;
          }
        }
        if (Ext.isDefined(event.axis) && event.axis === event.HORIZONTAL_AXIS) {
          dx = dy;
          dy = 0;
        }
      }
    }
  }
  return {x:me.correctWheelDelta(dx), y:me.correctWheelDelta(dy)};
}, getX:function() {
  return this.getXY()[0];
}, getXY:function() {
  var me = this, xy = me.xy;
  if (!xy) {
    xy = me.xy = [me.pageX, me.pageY];
    var x = xy[0], browserEvent, doc, docEl, body;
    if (!x && x !== 0) {
      browserEvent = me.browserEvent;
      doc = document;
      docEl = doc.documentElement;
      body = doc.body;
      xy[0] = browserEvent.clientX + (docEl && docEl.scrollLeft || body && body.scrollLeft || 0) - (docEl && docEl.clientLeft || body && body.clientLeft || 0);
      xy[1] = browserEvent.clientY + (docEl && docEl.scrollTop || body && body.scrollTop || 0) - (docEl && docEl.clientTop || body && body.clientTop || 0);
    }
  }
  return xy;
}, getY:function() {
  return this.getXY()[1];
}, hasModifier:function() {
  var me = this;
  return !!(me.ctrlKey || me.altKey || me.shiftKey || me.metaKey);
}, isNavKeyPress:function(scrollableOnly) {
  var me = this, k = me.keyCode, isKeyPress = me.type === 'keypress';
  return (!isKeyPress || Ext.isGecko) && k >= 33 && k <= 40 || !scrollableOnly && (k === me.RETURN || k === me.TAB || k === me.ESC);
}, isSpecialKey:function() {
  var me = this, k = me.keyCode, isGecko = Ext.isGecko, isKeyPress = me.type === 'keypress';
  return isGecko && isKeyPress && me.charCode === 0 || this.isNavKeyPress() || k === me.BACKSPACE || k === me.ENTER || k >= 16 && k <= 20 || (!isKeyPress || isGecko) && k >= 44 && k <= 46;
}, makeUnpreventable:function() {
  this.browserEvent.preventDefault = Ext.emptyFn;
}, preventDefault:function() {
  var me = this, parentEvent = me.parentEvent;
  me.defaultPrevented = true;
  if (parentEvent) {
    parentEvent.defaultPrevented = true;
  }
  me.browserEvent.preventDefault();
  return me;
}, setCurrentTarget:function(target) {
  this.currentTarget = this.delegatedTarget = target;
}, stopEvent:function() {
  return this.preventDefault().stopPropagation();
}, stopPropagation:function() {
  var me = this, browserEvent = me.browserEvent, parentEvent = me.parentEvent;
  me.isStopped = true;
  if (parentEvent) {
    parentEvent.isStopped = true;
  }
  if (!browserEvent.stopPropagation) {
    browserEvent.cancelBubble = true;
    return me;
  }
  browserEvent.stopPropagation();
  return me;
}, within:function(el, related, allowEl) {
  var t;
  if (el) {
    t = related ? this.getRelatedTarget() : this.getTarget();
  }
  return t ? Ext.fly(el).contains(t) || !!(allowEl && t === Ext.getDom(el)) : false;
}, deprecated:{'4.0':{methods:{getPageX:'getX', getPageY:'getY'}}}}, function(Event) {
  var prototype = Event.prototype, constants = {BACKSPACE:8, TAB:9, NUM_CENTER:12, ENTER:13, RETURN:13, SHIFT:16, CTRL:17, ALT:18, PAUSE:19, CAPS_LOCK:20, ESC:27, SPACE:32, PAGE_UP:33, PAGE_DOWN:34, END:35, HOME:36, LEFT:37, UP:38, RIGHT:39, DOWN:40, PRINT_SCREEN:44, INSERT:45, DELETE:46, ZERO:48, ONE:49, TWO:50, THREE:51, FOUR:52, FIVE:53, SIX:54, SEVEN:55, EIGHT:56, NINE:57, A:65, B:66, C:67, D:68, E:69, F:70, G:71, H:72, I:73, J:74, K:75, L:76, M:77, N:78, O:79, P:80, Q:81, R:82, S:83, T:84, U:85, 
  V:86, W:87, X:88, Y:89, Z:90, CONTEXT_MENU:93, NUM_ZERO:96, NUM_ONE:97, NUM_TWO:98, NUM_THREE:99, NUM_FOUR:100, NUM_FIVE:101, NUM_SIX:102, NUM_SEVEN:103, NUM_EIGHT:104, NUM_NINE:105, NUM_MULTIPLY:106, NUM_PLUS:107, NUM_MINUS:109, NUM_PERIOD:110, NUM_DIVISION:111, F1:112, F2:113, F3:114, F4:115, F5:116, F6:117, F7:118, F8:119, F9:120, F10:121, F11:122, F12:123, WHEEL_SCALE:function() {
    var scale;
    if (Ext.isGecko) {
      scale = 3;
    } else {
      if (Ext.isMac) {
        if (Ext.isSafari && Ext.webKitVersion >= 532) {
          scale = 120;
        } else {
          scale = 12;
        }
        scale *= 3;
      } else {
        scale = 120;
      }
    }
    return scale;
  }()}, keyCodes = {}, keyName, keyCode;
  Ext.apply(Event, constants);
  Ext.apply(prototype, constants);
  delete constants.WHEEL_SCALE;
  delete constants.RETURN;
  for (keyName in constants) {
    keyCode = constants[keyName];
    keyCodes[keyCode] = keyName;
  }
  prototype.keyCodes = keyCodes;
  prototype.getTrueXY = prototype.getXY;
});
Ext.define('Ext.event.publisher.Dom', {extend:Ext.event.publisher.Publisher, type:'dom', handledDomEvents:[], reEnterCount:0, captureEvents:{animationstart:1, animationend:1, resize:1, focus:1, blur:1, scroll:1}, directEvents:{mouseenter:1, mouseleave:1, pointerenter:1, pointerleave:1, MSPointerEnter:1, MSPointerLeave:1, load:1, unload:1, beforeunload:1, error:1, DOMContentLoaded:1, DOMFrameContentLoaded:1, hashchange:1}, blockedPointerEvents:{pointerover:1, pointerout:1, pointerenter:1, pointerleave:1, 
MSPointerOver:1, MSPointerOut:1, MSPointerEnter:1, MSPointerLeave:1}, blockedCompatibilityMouseEvents:{mouseenter:1, mouseleave:1}, constructor:function() {
  var me = this;
  me.bubbleSubscribers = {};
  me.captureSubscribers = {};
  me.directSubscribers = {};
  me.directCaptureSubscribers = {};
  me.delegatedListeners = {};
  me.initHandlers();
  Ext.onInternalReady(me.onReady, me);
  me.callParent();
}, registerEvents:function() {
  var me = this, publishersByEvent = Ext.event.publisher.Publisher.publishersByEvent, domEvents = me.handledDomEvents, ln = domEvents.length, i = 0, eventName;
  for (; i < ln; i++) {
    eventName = domEvents[i];
    me.handles[eventName] = 1;
    publishersByEvent[eventName] = me;
  }
  this.callParent();
}, onReady:function() {
  var me = this, domEvents = me.handledDomEvents, ln, i;
  if (domEvents) {
    for (i = 0, ln = domEvents.length; i < ln; i++) {
      me.addDelegatedListener(domEvents[i]);
    }
  }
  Ext.getWin().on('unload', me.destroy, me);
}, initHandlers:function() {
  var me = this;
  me.onDelegatedEvent = Ext.bind(me.onDelegatedEvent, me);
  me.onDirectEvent = Ext.bind(me.onDirectEvent, me);
  me.onDirectCaptureEvent = Ext.bind(me.onDirectCaptureEvent, me);
}, addDelegatedListener:function(eventName) {
  this.delegatedListeners[eventName] = 1;
  this.target.addEventListener(eventName, this.onDelegatedEvent, !!this.captureEvents[eventName]);
}, removeDelegatedListener:function(eventName) {
  delete this.delegatedListeners[eventName];
  this.target.removeEventListener(eventName, this.onDelegatedEvent, !!this.captureEvents[eventName]);
}, addDirectListener:function(eventName, element, capture) {
  element.dom.addEventListener(eventName, capture ? this.onDirectCaptureEvent : this.onDirectEvent, capture);
}, removeDirectListener:function(eventName, element, capture) {
  element.dom.removeEventListener(eventName, capture ? this.onDirectCaptureEvent : this.onDirectEvent, capture);
}, subscribe:function(element, eventName, delegated, capture) {
  var me = this, subscribers, id;
  if (delegated && !me.directEvents[eventName]) {
    subscribers = capture ? me.captureSubscribers : me.bubbleSubscribers;
    if (!me.handles[eventName] && !me.delegatedListeners[eventName]) {
      me.addDelegatedListener(eventName);
    }
    if (subscribers[eventName]) {
      ++subscribers[eventName];
    } else {
      subscribers[eventName] = 1;
    }
  } else {
    subscribers = capture ? me.directCaptureSubscribers : me.directSubscribers;
    id = element.id;
    subscribers = subscribers[eventName] || (subscribers[eventName] = {});
    if (subscribers[id]) {
      ++subscribers[id];
    } else {
      subscribers[id] = 1;
      me.addDirectListener(eventName, element, capture);
    }
  }
}, unsubscribe:function(element, eventName, delegated, capture) {
  var me = this, captureSubscribers, bubbleSubscribers, subscribers, id;
  if (delegated && !me.directEvents[eventName]) {
    captureSubscribers = me.captureSubscribers;
    bubbleSubscribers = me.bubbleSubscribers;
    subscribers = capture ? captureSubscribers : bubbleSubscribers;
    if (subscribers[eventName]) {
      --subscribers[eventName];
    }
    if (!me.handles[eventName] && !bubbleSubscribers[eventName] && !captureSubscribers[eventName]) {
      this.removeDelegatedListener(eventName);
    }
  } else {
    subscribers = capture ? me.directCaptureSubscribers : me.directSubscribers;
    id = element.id;
    subscribers = subscribers[eventName];
    if (subscribers[id]) {
      --subscribers[id];
    }
    if (!subscribers[id]) {
      delete subscribers[id];
      me.removeDirectListener(eventName, element, capture);
    }
  }
}, getPropagatingTargets:function(target) {
  var currentNode = target, targets = [], parentNode;
  while (currentNode) {
    targets.push(currentNode);
    parentNode = currentNode.parentNode;
    if (!parentNode) {
      parentNode = currentNode.defaultView;
    }
    currentNode = parentNode;
  }
  return targets;
}, publish:function(eventName, target, e) {
  var me = this, targets, el, i, ln;
  if (Ext.isArray(target)) {
    targets = target;
  } else {
    if (me.captureEvents[eventName]) {
      el = Ext.cache[target.id];
      targets = el ? [el] : [];
    } else {
      targets = me.getPropagatingTargets(target);
    }
  }
  ln = targets.length;
  if (me.captureSubscribers[eventName]) {
    for (i = ln; i--;) {
      el = Ext.cache[targets[i].id];
      if (el) {
        me.fire(el, eventName, e, false, true);
        if (e.isStopped) {
          break;
        }
      }
    }
  }
  if (!e.isStopped && me.bubbleSubscribers[eventName]) {
    for (i = 0; i < ln; i++) {
      el = Ext.cache[targets[i].id];
      if (el) {
        me.fire(el, eventName, e, false, false);
        if (e.isStopped) {
          break;
        }
      }
    }
  }
}, fire:function(element, eventName, e, direct, capture) {
  var event;
  if (element.hasListeners[eventName]) {
    event = element.events[eventName];
    if (event) {
      if (capture && direct) {
        event = event.directCaptures;
      } else {
        if (capture) {
          event = event.captures;
        } else {
          if (direct) {
            event = event.directs;
          }
        }
      }
      if (event) {
        e.setCurrentTarget(element.dom);
        event.fire(e, e.target);
      }
    }
  }
}, onDelegatedEvent:function(e) {
  if (Ext.elevateFunction) {
    Ext.elevateFunction(this.doDelegatedEvent, this, [e]);
  } else {
    this.doDelegatedEvent(e);
  }
}, doDelegatedEvent:function(e, invokeAfter) {
  var me = this, timeStamp = e.timeStamp;
  e = new Ext.event.Event(e);
  if (me.isEventBlocked(e)) {
    return false;
  }
  me.beforeEvent(e);
  Ext.frameStartTime = timeStamp;
  me.reEnterCount++;
  me.publish(e.type, e.target, e);
  me.reEnterCount--;
  if (invokeAfter !== false) {
    me.afterEvent(e);
  }
  return e;
}, onDirectEvent:function(e) {
  if (Ext.elevateFunction) {
    Ext.elevateFunction(this.doDirectEvent, this, [e, false]);
  } else {
    this.doDirectEvent(e, false);
  }
}, onDirectCaptureEvent:function(e) {
  if (Ext.elevateFunction) {
    Ext.elevateFunction(this.doDirectEvent, this, [e, true]);
  } else {
    this.doDirectEvent(e, true);
  }
}, doDirectEvent:function(e, capture) {
  var me = this, currentTarget = e.currentTarget, timeStamp = e.timeStamp, el;
  e = new Ext.event.Event(e);
  if (me.isEventBlocked(e)) {
    return;
  }
  me.beforeEvent(e);
  Ext.frameStartTime = timeStamp;
  el = Ext.cache[currentTarget.id];
  if (el) {
    me.reEnterCount++;
    me.fire(el, e.type, e, true, capture);
    me.reEnterCount--;
  }
  me.afterEvent(e);
}, beforeEvent:function(e) {
  var browserEvent = e.browserEvent, self = Ext.event.publisher.Dom, touches, touch;
  if (browserEvent.type === 'touchstart') {
    touches = browserEvent.touches;
    if (touches.length === 1) {
      touch = touches[0];
      self.lastTouchStartX = touch.pageX;
      self.lastTouchStartY = touch.pageY;
    }
  }
}, afterEvent:function(e) {
  var browserEvent = e.browserEvent, type = browserEvent.type, self = Ext.event.publisher.Dom, GlobalEvents = Ext.GlobalEvents;
  if (e.self.pointerEvents[type] && e.pointerType !== 'mouse') {
    self.lastScreenPointerEventTime = Ext.now();
  }
  if (type === 'touchend') {
    self.lastTouchEndTime = Ext.now();
  }
  if (!this.reEnterCount && GlobalEvents.hasListeners.idle && !GlobalEvents.idleEventMask[type]) {
    GlobalEvents.fireEvent('idle');
  }
}, isEventBlocked:function(e) {
  var me = this, type = e.type, self = Ext.event.publisher.Dom, now = Ext.now();
  if (Ext.isGecko && e.type === 'click' && e.button === 2) {
    return true;
  }
  return me.blockedPointerEvents[type] && e.pointerType !== 'mouse' || me.blockedCompatibilityMouseEvents[type] && now - self.lastScreenPointerEventTime < 1000 || Ext.supports.TouchEvents && e.self.mouseEvents[e.type] && Math.abs(e.pageX - self.lastTouchStartX) < 15 && Math.abs(e.pageY - self.lastTouchStartY) < 15 && Ext.now() - self.lastTouchEndTime < 1000;
}, destroy:function() {
  var eventName;
  for (eventName in this.delegatedListeners) {
    this.removeDelegatedListener(eventName);
  }
  this.callParent();
}, reset:function() {
  var self = Ext.event.publisher.Dom;
  self.lastScreenPointerEventTime = self.lastTouchEndTime = self.lastTouchStartX = self.lastTouchStartY = undefined;
}}, function(Dom) {
  var doc = document, defaultView = doc.defaultView, prototype = Dom.prototype;
  if (Ext.os.is.iOS && Ext.os.version.getMajor() < 5 || Ext.browser.is.AndroidStock || !(defaultView && defaultView.addEventListener)) {
    prototype.target = doc;
  } else {
    prototype.target = defaultView;
  }
  Dom.instance = new Dom;
});
Ext.define('Ext.event.publisher.Gesture', {extend:Ext.event.publisher.Dom, type:'gesture', config:{async:true}, isCancelEvent:{touchcancel:1, pointercancel:1, MSPointerCancel:1}, handledEvents:[], handledDomEvents:[], constructor:function(config) {
  var me = this, handledDomEvents = me.handledDomEvents, supports = Ext.supports, supportsTouchEvents = supports.TouchEvents, Fn = Ext.Function, onTouchStart = me.onTouchStart, onTouchMove = me.onTouchMove, onTouchEnd = me.onTouchEnd, asyncTouchStart = Fn.createAnimationFrame(me.onTouchStart, me, null, 1), asyncTouchMove = Fn.createAnimationFrame(me.onTouchMove, me), asyncTouchEnd = Fn.createAnimationFrame(me.onTouchEnd, me, null, 1);
  me._handlers = {touchstart:onTouchStart, touchmove:onTouchMove, touchend:onTouchEnd, touchcancel:onTouchEnd, pointerdown:onTouchStart, pointermove:onTouchMove, pointerup:onTouchEnd, pointercancel:onTouchEnd, MSPointerDown:onTouchStart, MSPointerMove:onTouchMove, MSPointerUp:onTouchEnd, MSPointerCancel:onTouchEnd, mousedown:onTouchStart, mousemove:onTouchMove, mouseup:onTouchEnd};
  me._asyncHandlers = {touchstart:asyncTouchStart, touchmove:asyncTouchMove, touchend:asyncTouchEnd, touchcancel:asyncTouchEnd, pointerdown:asyncTouchStart, pointermove:asyncTouchMove, pointerup:asyncTouchEnd, pointercancel:asyncTouchEnd, MSPointerDown:asyncTouchStart, MSPointerMove:asyncTouchMove, MSPointerUp:asyncTouchEnd, MSPointerCancel:asyncTouchEnd, mousedown:asyncTouchStart, mousemove:asyncTouchMove, mouseup:asyncTouchEnd};
  me.activeTouchesMap = {};
  me.activeTouches = [];
  me.changedTouches = [];
  me.recognizers = [];
  if (supportsTouchEvents) {
    me.onTargetTouchMove = me.onTargetTouchMove.bind(me);
    me.onTargetTouchEnd = me.onTargetTouchEnd.bind(me);
  }
  if (supports.PointerEvents) {
    handledDomEvents.push('pointerdown', 'pointermove', 'pointerup', 'pointercancel');
    me.mousePointerType = 'mouse';
  } else {
    if (supports.MSPointerEvents) {
      handledDomEvents.push('MSPointerDown', 'MSPointerMove', 'MSPointerUp', 'MSPointerCancel');
      me.mousePointerType = 4;
    } else {
      if (supportsTouchEvents) {
        handledDomEvents.push('touchstart', 'touchmove', 'touchend', 'touchcancel');
      }
    }
  }
  if (!handledDomEvents.length || supportsTouchEvents && Ext.isWebKit && Ext.os.is.Desktop) {
    handledDomEvents.push('mousedown', 'mousemove', 'mouseup');
  }
  me.initConfig(config);
  return me.callParent();
}, onReady:function() {
  this.callParent();
  Ext.Array.sort(this.recognizers, function(recognizerA, recognizerB) {
    var a = recognizerA.priority, b = recognizerB.priority;
    return a > b ? 1 : a < b ? -1 : 0;
  });
}, registerRecognizer:function(recognizer) {
  var me = this, handledEvents = recognizer.handledEvents, ln = handledEvents.length, i;
  recognizer.setOnRecognized(me.onRecognized);
  recognizer.setCallbackScope(me);
  for (i = 0; i < ln; i++) {
    me.handledEvents.push(handledEvents[i]);
  }
  me.registerEvents(handledEvents);
  me.recognizers.push(recognizer);
}, onRecognized:function(eventName, e, info) {
  var me = this, changedTouches = e.changedTouches, ln = changedTouches.length, targetGroups, targets, i, touch;
  info = info || {};
  info.type = eventName;
  info.target = changedTouches[0].target;
  info.isStopped = false;
  e = e.chain(info);
  if (ln > 1) {
    targetGroups = [];
    for (i = 0; i < ln; i++) {
      touch = changedTouches[i];
      targetGroups.push(touch.targets);
    }
    targets = me.getCommonTargets(targetGroups);
  } else {
    targets = changedTouches[0].targets;
  }
  me.publish(eventName, targets, e);
}, getCommonTargets:function(targetGroups) {
  var firstTargetGroup = targetGroups[0], ln = targetGroups.length;
  if (ln === 1) {
    return firstTargetGroup;
  }
  var commonTargets = [], i = 1, target, targets, j;
  while (true) {
    target = firstTargetGroup[firstTargetGroup.length - i];
    if (!target) {
      return commonTargets;
    }
    for (j = 1; j < ln; j++) {
      targets = targetGroups[j];
      if (targets[targets.length - i] !== target) {
        return commonTargets;
      }
    }
    commonTargets.unshift(target);
    i++;
  }
  return commonTargets;
}, invokeRecognizers:function(methodName, e) {
  var recognizers = this.recognizers, ln = recognizers.length, i, recognizer;
  if (methodName === 'onStart') {
    for (i = 0; i < ln; i++) {
      recognizers[i].isActive = true;
    }
  }
  for (i = 0; i < ln; i++) {
    recognizer = recognizers[i];
    if (recognizer.isActive && recognizer[methodName].call(recognizer, e) === false) {
      recognizer.isActive = false;
    }
  }
}, updateTouches:function(e, isEnd) {
  var me = this, browserEvent = e.browserEvent, touchSources = browserEvent.changedTouches || [browserEvent], activeTouches = me.activeTouches, activeTouchesMap = me.activeTouchesMap, changedTouches = [], touchSource, identifier, touch, target, i, ln, x, y;
  for (i = 0, ln = touchSources.length; i < ln; i++) {
    touchSource = touchSources[i];
    if ('identifier' in touchSource) {
      identifier = touchSource.identifier;
    } else {
      if ('pointerId' in touchSource) {
        identifier = touchSource.pointerId;
      } else {
        identifier = 1;
      }
    }
    touch = activeTouchesMap[identifier];
    if (!touch) {
      target = Ext.event.Event.resolveTextNode(touchSource.target);
      touch = activeTouchesMap[identifier] = {identifier:identifier, target:target, targets:me.getPropagatingTargets(target)};
      activeTouches.push(touch);
    }
    if (isEnd) {
      delete activeTouchesMap[identifier];
      Ext.Array.remove(activeTouches, touch);
    }
    x = touchSource.pageX;
    y = touchSource.pageY;
    touch.pageX = x;
    touch.pageY = y;
    touch.point = new Ext.util.Point(x, y);
    changedTouches.push(touch);
  }
  e.touches = Ext.Array.clone(activeTouches);
  e.changedTouches = changedTouches;
}, doDelegatedEvent:function(e) {
  var me = this;
  e = me.callParent([e, false]);
  if (e) {
    if (!e.button || e.button < 1) {
      me.handlers[e.type].call(me, e);
    }
    me.afterEvent(e);
  }
}, onTouchStart:function(e) {
  var me = this, target = e.target, touches = e.browserEvent.touches;
  if (e.browserEvent.type === 'touchstart') {
    target.addEventListener('touchmove', me.onTargetTouchMove);
    target.addEventListener('touchend', me.onTargetTouchEnd);
    target.addEventListener('touchcancel', me.onTargetTouchEnd);
  }
  if (touches && touches.length <= me.activeTouches.length) {
    me.removeGhostTouches(touches);
  }
  me.updateTouches(e);
  if (!me.isStarted) {
    me.isStarted = true;
    me.invokeRecognizers('onStart', e);
    if (Ext.enableGarbageCollector) {
      Ext.dom.GarbageCollector.pause();
    }
  }
  me.invokeRecognizers('onTouchStart', e);
}, onTouchMove:function(e) {
  var me = this, mousePointerType = me.mousePointerType;
  if (me.isStarted) {
    if (mousePointerType && e.browserEvent.pointerType === mousePointerType && e.buttons === 0) {
      e.type = Ext.dom.Element.prototype.eventMap.touchend;
      e.button = 0;
      me.onTouchEnd(e);
      return;
    }
    me.updateTouches(e);
    if (e.changedTouches.length > 0) {
      me.invokeRecognizers('onTouchMove', e);
    }
  }
}, onTouchEnd:function(e) {
  var me = this;
  if (!me.isStarted) {
    return;
  }
  me.updateTouches(e, true);
  me.invokeRecognizers(me.isCancelEvent[e.type] ? 'onTouchCancel' : 'onTouchEnd', e);
  if (!me.activeTouches.length) {
    me.isStarted = false;
    me.invokeRecognizers('onEnd', e);
    if (Ext.enableGarbageCollector) {
      Ext.dom.GarbageCollector.resume();
    }
  }
}, onTargetTouchMove:function(e) {
  if (Ext.elevateFunction) {
    Ext.elevateFunction(this.doTargetTouchMove, this, [e]);
  } else {
    this.doTargetTouchMove(e);
  }
}, doTargetTouchMove:function(e) {
  if (!Ext.getBody().contains(e.target)) {
    this.onTouchMove(new Ext.event.Event(e));
  }
}, onTargetTouchEnd:function(e) {
  if (Ext.elevateFunction) {
    Ext.elevateFunction(this.doTargetTouchEnd, this, [e]);
  } else {
    this.doTargetTouchEnd(e);
  }
}, doTargetTouchEnd:function(e) {
  var me = this, target = e.target;
  target.removeEventListener('touchmove', me.onTargetTouchMove);
  target.removeEventListener('touchend', me.onTargetTouchEnd);
  target.removeEventListener('touchcancel', me.onTargetTouchEnd);
  if (!Ext.getBody().contains(target)) {
    me.onTouchEnd(new Ext.event.Event(e));
  }
}, updateAsync:function(async) {
  this.handlers = async ? this._asyncHandlers : this._handlers;
}, reset:function() {
  var me = this, recognizers = me.recognizers, ln = recognizers.length, i, recognizer;
  me.activeTouchesMap = {};
  me.activeTouches = [];
  me.changedTouches = [];
  me.isStarted = false;
  for (i = 0; i < ln; i++) {
    recognizer = recognizers[i];
    recognizer.reset();
    recognizer.isActive = false;
  }
  this.callParent();
}, privates:{removeGhostTouches:function(touches) {
  var ids = {}, len = touches.length, activeTouches = this.activeTouches, map = this.activeTouchesMap, i, id, touch;
  for (i = 0; i < len; ++i) {
    ids[touches[i].identifier] = true;
  }
  i = activeTouches.length;
  while (i--) {
    touch = activeTouches[i];
    id = touch.identifier;
    if (!touches[id]) {
      Ext.Array.remove(activeTouches, touch);
      delete map[id];
    }
  }
}}}, function(Gesture) {
  Gesture.instance = new Gesture;
});
Ext.define('Ext.mixin.Templatable', {extend:Ext.Mixin, mixinConfig:{id:'templatable'}, referenceAttributeName:'reference', referenceSelector:'[reference]', getElementConfig:function() {
  return {reference:'element'};
}, getElementTemplate:function() {
  var elementTemplate = document.createDocumentFragment();
  elementTemplate.appendChild(Ext.Element.create(this.getElementConfig(), true));
  return elementTemplate;
}, initElement:function() {
  var prototype = this.self.prototype;
  prototype.elementTemplate = this.getElementTemplate();
  prototype.initElement = prototype.doInitElement;
  this.initElement.apply(this, arguments);
}, linkElement:function(reference, node) {
  this.link(reference, node);
}, doInitElement:function() {
  var referenceAttributeName = this.referenceAttributeName, renderElement, referenceNodes, i, ln, referenceNode, reference;
  renderElement = this.elementTemplate.cloneNode(true);
  referenceNodes = renderElement.querySelectorAll(this.referenceSelector);
  for (i = 0, ln = referenceNodes.length; i < ln; i++) {
    referenceNode = referenceNodes[i];
    reference = referenceNode.getAttribute(referenceAttributeName);
    referenceNode.removeAttribute(referenceAttributeName);
    this.linkElement(reference, referenceNode);
  }
}});
Ext.define('Ext.TaskQueue', {singleton:true, pending:false, mode:true, constructor:function() {
  this.readQueue = [];
  this.writeQueue = [];
  this.run = Ext.Function.bind(this.run, this);
  if (Ext.os.is.iOS) {
    Ext.interval(this.watch, 500, this);
  }
}, requestRead:function(fn, scope, args) {
  this.request(true);
  this.readQueue.push(arguments);
}, requestWrite:function(fn, scope, args) {
  this.request(false);
  this.writeQueue.push(arguments);
}, request:function(mode) {
  if (!this.pending) {
    this.pendingTime = Date.now();
    this.pending = true;
    this.mode = mode;
    if (mode) {
      Ext.defer(this.run, 1, this);
    } else {
      Ext.Function.requestAnimationFrame(this.run);
    }
  }
}, watch:function() {
  if (this.pending && Date.now() - this.pendingTime >= 500) {
    this.run();
  }
}, run:function() {
  this.pending = false;
  var readQueue = this.readQueue, writeQueue = this.writeQueue, request = null, queue;
  if (this.mode) {
    queue = readQueue;
    if (writeQueue.length > 0) {
      request = false;
    }
  } else {
    queue = writeQueue;
    if (readQueue.length > 0) {
      request = true;
    }
  }
  var tasks = queue.slice(), i, ln, task, fn, scope;
  queue.length = 0;
  for (i = 0, ln = tasks.length; i < ln; i++) {
    task = tasks[i];
    fn = task[0];
    scope = task[1];
    if (typeof fn === 'string') {
      fn = scope[fn];
    }
    if (task.length > 2) {
      fn.apply(scope, task[2]);
    } else {
      fn.call(scope);
    }
  }
  tasks.length = 0;
  if (request !== null) {
    this.request(request);
  }
}, privates:{flush:function() {
  while (this.readQueue.length || this.writeQueue.length) {
    this.run();
  }
}}});
Ext.define('Ext.util.sizemonitor.Abstract', {mixins:[Ext.mixin.Templatable], config:{element:null, callback:Ext.emptyFn, scope:null, args:[]}, width:0, height:0, contentWidth:0, contentHeight:0, constructor:function(config) {
  this.refresh = Ext.Function.bind(this.refresh, this);
  this.info = {width:0, height:0, contentWidth:0, contentHeight:0, flag:0};
  this.initElement();
  this.initConfig(config);
  this.bindListeners(true);
}, bindListeners:Ext.emptyFn, applyElement:function(element) {
  if (element) {
    return Ext.get(element);
  }
}, updateElement:function(element) {
  element.append(this.detectorsContainer);
  element.addCls(Ext.baseCSSPrefix + 'size-monitored');
}, applyArgs:function(args) {
  return args.concat([this.info]);
}, refreshMonitors:Ext.emptyFn, forceRefresh:function() {
  Ext.TaskQueue.requestRead('refresh', this);
}, getContentBounds:function() {
  return this.detectorsContainer.getBoundingClientRect();
}, getContentWidth:function() {
  return this.detectorsContainer.offsetWidth;
}, getContentHeight:function() {
  return this.detectorsContainer.offsetHeight;
}, refreshSize:function() {
  var element = this.getElement();
  if (!element || element.destroyed) {
    return false;
  }
  var width = element.getWidth(), height = element.getHeight(), contentWidth = this.getContentWidth(), contentHeight = this.getContentHeight(), currentContentWidth = this.contentWidth, currentContentHeight = this.contentHeight, info = this.info, resized = false, flag;
  this.width = width;
  this.height = height;
  this.contentWidth = contentWidth;
  this.contentHeight = contentHeight;
  flag = (currentContentWidth !== contentWidth ? 1 : 0) + (currentContentHeight !== contentHeight ? 2 : 0);
  if (flag > 0) {
    info.width = width;
    info.height = height;
    info.contentWidth = contentWidth;
    info.contentHeight = contentHeight;
    info.flag = flag;
    resized = true;
    this.getCallback().apply(this.getScope(), this.getArgs());
  }
  return resized;
}, refresh:function(force) {
  if (this.refreshSize() || force) {
    Ext.TaskQueue.requestWrite('refreshMonitors', this);
  }
}, destroy:function() {
  var me = this, element = me.getElement();
  me.bindListeners(false);
  if (element && !element.destroyed) {
    element.removeCls(Ext.baseCSSPrefix + 'size-monitored');
  }
  delete me._element;
  me.callParent();
}});
Ext.define('Ext.util.sizemonitor.Scroll', {extend:Ext.util.sizemonitor.Abstract, getElementConfig:function() {
  return {reference:'detectorsContainer', classList:[Ext.baseCSSPrefix + 'size-monitors', 'scroll'], children:[{reference:'expandMonitor', className:'expand'}, {reference:'shrinkMonitor', className:'shrink'}]};
}, constructor:function(config) {
  this.onScroll = Ext.Function.bind(this.onScroll, this);
  this.callParent(arguments);
}, bindListeners:function(bind) {
  var method = bind ? 'addEventListener' : 'removeEventListener';
  this.expandMonitor[method]('scroll', this.onScroll, true);
  this.shrinkMonitor[method]('scroll', this.onScroll, true);
}, forceRefresh:function() {
  Ext.TaskQueue.requestRead('refresh', this, [true]);
}, onScroll:function() {
  Ext.TaskQueue.requestRead('refresh', this);
}, refreshMonitors:function() {
  var expandMonitor = this.expandMonitor, shrinkMonitor = this.shrinkMonitor, end = 1000000;
  if (expandMonitor && !expandMonitor.destroyed) {
    expandMonitor.scrollLeft = end;
    expandMonitor.scrollTop = end;
  }
  if (shrinkMonitor && !shrinkMonitor.destroyed) {
    shrinkMonitor.scrollLeft = end;
    shrinkMonitor.scrollTop = end;
  }
}});
Ext.define('Ext.util.sizemonitor.OverflowChange', {extend:Ext.util.sizemonitor.Abstract, constructor:function(config) {
  this.onExpand = Ext.Function.bind(this.onExpand, this);
  this.onShrink = Ext.Function.bind(this.onShrink, this);
  this.callParent(arguments);
}, getElementConfig:function() {
  return {reference:'detectorsContainer', classList:[Ext.baseCSSPrefix + 'size-monitors', 'overflowchanged'], children:[{reference:'expandMonitor', className:'expand', children:[{reference:'expandHelper'}]}, {reference:'shrinkMonitor', className:'shrink', children:[{reference:'shrinkHelper'}]}]};
}, bindListeners:function(bind) {
  var method = bind ? 'addEventListener' : 'removeEventListener';
  this.expandMonitor[method](Ext.browser.is.Firefox ? 'underflow' : 'overflowchanged', this.onExpand, true);
  this.shrinkMonitor[method](Ext.browser.is.Firefox ? 'overflow' : 'overflowchanged', this.onShrink, true);
}, onExpand:function(e) {
  if (Ext.browser.is.Webkit && e.horizontalOverflow && e.verticalOverflow) {
    return;
  }
  Ext.TaskQueue.requestRead('refresh', this);
}, onShrink:function(e) {
  if (Ext.browser.is.Webkit && !e.horizontalOverflow && !e.verticalOverflow) {
    return;
  }
  Ext.TaskQueue.requestRead('refresh', this);
}, refreshMonitors:function() {
  if (this.destroyed) {
    return;
  }
  var expandHelper = this.expandHelper, shrinkHelper = this.shrinkHelper, contentBounds = this.getContentBounds(), width = contentBounds.width, height = contentBounds.height, style;
  if (expandHelper && !expandHelper.destroyed) {
    style = expandHelper.style;
    style.width = width + 1 + 'px';
    style.height = height + 1 + 'px';
  }
  if (shrinkHelper && !shrinkHelper.destroyed) {
    style = shrinkHelper.style;
    style.width = width + 'px';
    style.height = height + 'px';
  }
  Ext.TaskQueue.requestRead('refresh', this);
}});
Ext.define('Ext.util.SizeMonitor', {constructor:function(config) {
  var namespace = Ext.util.sizemonitor;
  if (Ext.browser.is.Firefox) {
    return new namespace.OverflowChange(config);
  } else {
    return new namespace.Scroll(config);
  }
}});
Ext.define('Ext.event.publisher.ElementSize', {extend:Ext.event.publisher.Publisher, type:'size', handledEvents:['resize'], constructor:function() {
  this.monitors = {};
  this.subscribers = {};
  this.callParent(arguments);
}, subscribe:function(element) {
  var id = element.id, subscribers = this.subscribers, monitors = this.monitors;
  if (subscribers[id]) {
    ++subscribers[id];
  } else {
    subscribers[id] = 1;
    monitors[id] = new Ext.util.SizeMonitor({element:element, callback:this.onElementResize, scope:this, args:[element]});
  }
  element.on('painted', 'forceRefresh', monitors[id]);
  return true;
}, unsubscribe:function(element) {
  var id = element.id, subscribers = this.subscribers, monitors = this.monitors, sizeMonitor;
  if (subscribers[id] && !--subscribers[id]) {
    delete subscribers[id];
    sizeMonitor = monitors[id];
    element.un('painted', 'forceRefresh', sizeMonitor);
    sizeMonitor.destroy();
    delete monitors[id];
  }
}, onElementResize:function(element, info) {
  Ext.TaskQueue.requestRead('fire', this, [element, 'resize', [element, info]]);
}, privates:{syncRefresh:function(elements) {
  elements = Ext.Array.from(elements);
  var len = elements.length, i = 0, el, monitor;
  for (i = 0; i < len; ++i) {
    el = elements[i];
    if (typeof el !== 'string') {
      el = el.id;
    }
    monitor = this.monitors[el];
    if (monitor) {
      monitor.forceRefresh();
    }
  }
  Ext.TaskQueue.flush();
}}}, function(ElementSize) {
  ElementSize.instance = new ElementSize;
});
Ext.define('Ext.util.paintmonitor.Abstract', {config:{element:null, callback:Ext.emptyFn, scope:null, args:[]}, eventName:'', monitorClass:'', constructor:function(config) {
  this.onElementPainted = Ext.Function.bind(this.onElementPainted, this);
  this.initConfig(config);
}, bindListeners:function(bind) {
  this.monitorElement[bind ? 'addEventListener' : 'removeEventListener'](this.eventName, this.onElementPainted, true);
}, applyElement:function(element) {
  if (element) {
    return Ext.get(element);
  }
}, updateElement:function(element) {
  this.monitorElement = Ext.Element.create({classList:[Ext.baseCSSPrefix + 'paint-monitor', this.monitorClass]}, true);
  element.appendChild(this.monitorElement);
  element.addCls(Ext.baseCSSPrefix + 'paint-monitored');
  this.bindListeners(true);
}, onElementPainted:function() {
}, destroy:function() {
  var me = this, monitorElement = me.monitorElement, parentNode = monitorElement.parentNode, element = me.getElement();
  me.bindListeners(false);
  delete me.monitorElement;
  if (element && !element.destroyed) {
    element.removeCls(Ext.baseCSSPrefix + 'paint-monitored');
    delete me._element;
  }
  if (parentNode) {
    parentNode.removeChild(monitorElement);
  }
  me.callParent();
}});
Ext.define('Ext.util.paintmonitor.CssAnimation', {extend:Ext.util.paintmonitor.Abstract, eventName:Ext.browser.is.WebKit ? 'webkitAnimationEnd' : 'animationend', monitorClass:'cssanimation', onElementPainted:function(e) {
  if (e.animationName === Ext.baseCSSPrefix + 'paint-monitor-helper') {
    this.getCallback().apply(this.getScope(), this.getArgs());
  }
}});
Ext.define('Ext.util.PaintMonitor', {constructor:function(config) {
  return new Ext.util.paintmonitor.CssAnimation(config);
}});
Ext.define('Ext.event.publisher.ElementPaint', {extend:Ext.event.publisher.Publisher, type:'paint', handledEvents:['painted'], constructor:function() {
  this.monitors = {};
  this.subscribers = {};
  this.callParent(arguments);
}, subscribe:function(element) {
  var me = this, id = element.id, subscribers = me.subscribers;
  if (subscribers[id]) {
    ++subscribers[id];
  } else {
    subscribers[id] = 1;
    me.monitors[id] = new Ext.util.PaintMonitor({element:element, callback:me.onElementPainted, scope:me, args:[element]});
  }
}, unsubscribe:function(element) {
  var id = element.id, subscribers = this.subscribers, monitors = this.monitors;
  if (subscribers[id] && !--subscribers[id]) {
    delete subscribers[id];
    monitors[id].destroy();
    delete monitors[id];
  }
}, onElementPainted:function(element) {
  Ext.TaskQueue.requestRead('fire', this, [element, 'painted', [element]]);
}}, function(ElementPaint) {
  ElementPaint.instance = new ElementPaint;
});
Ext.define('Ext.dom.Element', function(Element) {
  var WIN = window, DOC = document, windowId = 'ext-window', documentId = 'ext-document', WIDTH = 'width', HEIGHT = 'height', MIN_WIDTH = 'min-width', MIN_HEIGHT = 'min-height', MAX_WIDTH = 'max-width', MAX_HEIGHT = 'max-height', TOP = 'top', RIGHT = 'right', BOTTOM = 'bottom', LEFT = 'left', VISIBILITY = 'visibility', HIDDEN = 'hidden', DISPLAY = 'display', NONE = 'none', ZINDEX = 'z-index', POSITION = 'position', RELATIVE = 'relative', STATIC = 'static', SEPARATOR = '-', wordsRe = /\w/g, spacesRe = 
  /\s+/, classNameSplitRegex = /[\s]+/, transparentRe = /^(?:transparent|(?:rgba[(](?:\s*\d+\s*[,]){3}\s*0\s*[)]))$/i, adjustDirect2DTableRe = /table-row|table-.*-group/, topRe = /top/i, borders = {t:'border-top-width', r:'border-right-width', b:'border-bottom-width', l:'border-left-width'}, paddings = {t:'padding-top', r:'padding-right', b:'padding-bottom', l:'padding-left'}, margins = {t:'margin-top', r:'margin-right', b:'margin-bottom', l:'margin-left'}, paddingsTLRB = [paddings.l, paddings.r, 
  paddings.t, paddings.b], bordersTLRB = [borders.l, borders.r, borders.t, borders.b], numberRe = /\d+$/, unitRe = /\d+(px|em|%|en|ex|pt|in|cm|mm|pc)$/i, defaultUnit = 'px', camelRe = /(-[a-z])/gi, cssRe = /([a-z0-9\-]+)\s*:\s*([^;\s]+(?:\s*[^;\s]+)*);?/gi, pxRe = /^\d+(?:\.\d*)?px$/i, propertyCache = {}, ORIGINALDISPLAY = 'originalDisplay', camelReplaceFn = function(m, a) {
    return a.charAt(1).toUpperCase();
  }, clearData = function(node, deep) {
    var childNodes, i, len;
    if (node.nodeType === 1) {
      node._extData = null;
      if (deep) {
        childNodes = node.childNodes;
        for (i = 0, len = childNodes.length; i < len; ++i) {
          clearData(childNodes[i], deep);
        }
      }
    }
  }, visibilityCls = Ext.baseCSSPrefix + 'hidden-visibility', displayCls = Ext.baseCSSPrefix + 'hidden-display', offsetsCls = Ext.baseCSSPrefix + 'hidden-offsets', clipCls = Ext.baseCSSPrefix + 'hidden-clip', sizedCls = Ext.baseCSSPrefix + 'sized', unsizedCls = Ext.baseCSSPrefix + 'unsized', stretchedCls = Ext.baseCSSPrefix + 'stretched', noTouchScrollCls = Ext.baseCSSPrefix + 'no-touch-scroll', CREATE_ATTRIBUTES = {style:'style', className:'className', cls:'cls', classList:'classList', text:'text', 
  hidden:'hidden', html:'html', children:'children'}, lastFocusChange = 0, lastKeyboardClose = 0, editableHasFocus = false, isVirtualKeyboardOpen = false, visFly, scrollFly, caFly;
  return {alternateClassName:['Ext.Element'], mixins:[Ext.util.Positionable, Ext.mixin.Observable], observableType:'element', isElement:true, skipGarbageCollection:true, $applyConfigs:true, identifiablePrefix:'ext-element-', styleHooks:{}, validIdRe:Ext.validIdRe, blockedEvents:Ext.supports.EmulatedMouseOver ? {mouseover:1} : {}, longpressEvents:{longpress:1, taphold:1}, constructor:function(dom) {
    var me = this, id;
    if (typeof dom === 'string') {
      dom = DOC.getElementById(dom);
    }
    if (!dom) {
      Ext.raise('Invalid domNode reference or an id of an existing domNode: ' + dom);
      return null;
    }
    if (Ext.cache[dom.id]) {
      Ext.raise("Element cache already contains an entry for id '" + dom.id + "'.  Use Ext.get() to create or retrieve Element instances.");
    }
    me.dom = dom;
    id = dom.id;
    if (id) {
      me.id = id;
    } else {
      id = dom.id = me.getUniqueId();
    }
    if (!me.validIdRe.test(me.id)) {
      Ext.raise('Invalid Element "id": "' + me.id + '"');
    }
    me.el = me;
    Ext.cache[id] = me;
    me.mixins.observable.constructor.call(me);
  }, inheritableStatics:{cache:Ext.cache = {}, editableSelector:'input,textarea,[contenteditable\x3d"true"]', VISIBILITY:1, DISPLAY:2, OFFSETS:3, CLIP:4, minKeyboardHeight:100, unitRe:unitRe, useDelegatedEvents:true, validNodeTypes:{1:1, 9:1}, addUnits:function(size, units) {
    if (typeof size === 'number') {
      return size + (units || defaultUnit);
    }
    if (size === '' || size === 'auto' || size == null) {
      return size || '';
    }
    if (numberRe.test(size)) {
      return size + (units || defaultUnit);
    }
    if (!unitRe.test(size)) {
      Ext.Logger.warn('Warning, size detected (' + size + ') not a valid property value on Element.addUnits.');
      return size || '';
    }
    return size;
  }, create:function(attributes, domNode) {
    var me = this, hidden = CREATE_ATTRIBUTES.hidden, element, elementStyle, tag, value, name, i, ln, className;
    if (!attributes) {
      attributes = {};
    }
    if (attributes.isElement) {
      return domNode ? attributes.dom : attributes;
    } else {
      if ('nodeType' in attributes) {
        return domNode ? attributes : Ext.get(attributes);
      }
    }
    if (typeof attributes === 'string') {
      return DOC.createTextNode(attributes);
    }
    tag = attributes.tag;
    if (!tag) {
      tag = 'div';
    }
    if (attributes.namespace) {
      element = DOC.createElementNS(attributes.namespace, tag);
    } else {
      element = DOC.createElement(tag);
    }
    elementStyle = element.style;
    if (attributes[hidden]) {
      className = attributes.className;
      className = className == null ? '' : className + ' ';
      attributes.className = className + displayCls;
      delete attributes[hidden];
    }
    for (name in attributes) {
      if (name !== 'tag') {
        value = attributes[name];
        switch(name) {
          case CREATE_ATTRIBUTES.style:
            if (typeof value === 'string') {
              element.setAttribute(name, value);
            } else {
              for (i in value) {
                if (value.hasOwnProperty(i)) {
                  elementStyle[i] = value[i];
                }
              }
            }
            break;
          case CREATE_ATTRIBUTES.className:
          case CREATE_ATTRIBUTES.cls:
            element.className = value;
            break;
          case CREATE_ATTRIBUTES.classList:
            element.className = value.join(' ');
            break;
          case CREATE_ATTRIBUTES.text:
            element.textContent = value;
            break;
          case CREATE_ATTRIBUTES.html:
            element.innerHTML = value;
            break;
          case CREATE_ATTRIBUTES.children:
            for (i = 0, ln = value.length; i < ln; i++) {
              element.appendChild(me.create(value[i], true));
            }
            break;
          default:
            if (value != null) {
              element.setAttribute(name, value);
            }
        }
      }
    }
    if (domNode) {
      return element;
    } else {
      return me.get(element);
    }
  }, detach:function() {
    var dom = this.dom;
    if (dom && dom.parentNode && dom.tagName !== 'BODY') {
      dom.parentNode.removeChild(dom);
    }
    return this;
  }, fly:function(dom, named) {
    return Ext.fly(dom, named);
  }, fromPoint:function(x, y) {
    return Ext.get(DOC.elementFromPoint(x, y));
  }, get:function(el) {
    var me = this, cache = Ext.cache, nodeType, dom, id, entry, isDoc, isWin, isValidNodeType;
    if (!el) {
      return null;
    }
    function warnDuplicate(id) {
      Ext.raise('DOM element with id ' + id + ' in Element cache is not the same as element in the DOM. ' + 'Make sure to clean up Element instances using destroy()');
    }
    if (el.isFly) {
      el = el.dom;
    }
    if (typeof el === 'string') {
      id = el;
      if (cache.hasOwnProperty(id)) {
        entry = cache[id];
        if (entry.skipGarbageCollection || !Ext.isGarbage(entry.dom)) {
          dom = Ext.getElementById ? Ext.getElementById(id) : DOC.getElementById(id);
          if (dom && dom !== entry.dom) {
            warnDuplicate(id);
          }
          return entry;
        } else {
          entry.destroy();
        }
      }
      if (id === windowId) {
        return Element.get(WIN);
      } else {
        if (id === documentId) {
          return Element.get(DOC);
        }
      }
      dom = Ext.getElementById ? Ext.getElementById(id) : DOC.getElementById(id);
      if (dom) {
        return new Element(dom);
      }
    }
    nodeType = el.nodeType;
    if (nodeType) {
      isDoc = nodeType === 9;
      isValidNodeType = me.validNodeTypes[nodeType];
    } else {
      isWin = el.window == el;
    }
    if (isValidNodeType || isWin) {
      id = el.id;
      if (cache.hasOwnProperty(id)) {
        entry = cache[id];
        if (entry.skipGarbageCollection || el === entry.dom || !Ext.isGarbage(entry.dom)) {
          if (el !== entry.dom) {
            warnDuplicate(id);
          }
          return entry;
        } else {
          entry.destroy();
        }
      }
      if (el === DOC) {
        el.id = documentId;
      }
      if (el == WIN) {
        el.id = windowId;
      }
      el = new Element(el);
      if (isWin || isDoc) {
        el.skipGarbageCollection = true;
      }
      return el;
    }
    if (el.isElement) {
      return el;
    }
    if (el.isComposite) {
      return el;
    }
    if (Ext.isIterable(el)) {
      return me.select(el);
    }
    return null;
  }, getActiveElement:function(asElement) {
    var active = DOC.activeElement;
    if (!active || !active.focus) {
      active = DOC.body;
    }
    return asElement ? Ext.get(active) : active;
  }, getDocumentHeight:function() {
    return Math.max(!Ext.isStrict ? DOC.body.scrollHeight : DOC.documentElement.scrollHeight, this.getViewportHeight());
  }, getDocumentWidth:function() {
    return Math.max(!Ext.isStrict ? DOC.body.scrollWidth : DOC.documentElement.scrollWidth, this.getViewportWidth());
  }, getOrientation:function() {
    if (Ext.supports.OrientationChange) {
      return WIN.orientation == 0 ? 'portrait' : 'landscape';
    }
    return WIN.innerHeight > WIN.innerWidth ? 'portrait' : 'landscape';
  }, getViewportHeight:function() {
    var viewportHeight = Element._viewportHeight;
    if (Ext.isIE9m) {
      return DOC.documentElement.clientHeight;
    }
    return viewportHeight != null ? viewportHeight : WIN.innerHeight;
  }, getViewportWidth:function() {
    var viewportWidth = Element._viewportWidth;
    if (Ext.isIE9m) {
      return DOC.documentElement.clientWidth;
    }
    return viewportWidth != null ? viewportWidth : WIN.innerWidth;
  }, getViewSize:function() {
    return {width:Element.getViewportWidth(), height:Element.getViewportHeight()};
  }, normalize:function(prop) {
    return propertyCache[prop] || (propertyCache[prop] = prop.replace(camelRe, camelReplaceFn));
  }, _onWindowFocusChange:function(e) {
    if (Ext.fly(e.target).is(Element.editableSelector)) {
      lastFocusChange = new Date;
      editableHasFocus = e.type === 'focusin' || e.type === 'pointerup';
    }
  }, _onWindowResize:function() {
    var windowWidth = window.innerWidth, windowHeight = window.innerHeight, now = new Date, threshold = 1000, deltaX, deltaY;
    deltaX = windowWidth - Element._windowWidth;
    deltaY = windowHeight - Element._windowHeight;
    Element._windowWidth = windowWidth;
    Element._windowHeight = windowHeight;
    if (now - lastFocusChange < threshold || now - lastKeyboardClose < threshold) {
      if (deltaX === 0 && (editableHasFocus && deltaY <= -Element.minKeyboardHeight)) {
        isVirtualKeyboardOpen = true;
        return;
      }
    }
    if (isVirtualKeyboardOpen && deltaX === 0 && deltaY >= Element.minKeyboardHeight) {
      isVirtualKeyboardOpen = false;
      lastKeyboardClose = new Date;
    }
    if (isVirtualKeyboardOpen) {
      return;
    }
    Element._viewportWidth = windowWidth;
    Element._viewportHeight = windowHeight;
  }, parseBox:function(box) {
    box = box || 0;
    var type = typeof box, parts, ln;
    if (type === 'number') {
      return {top:box, right:box, bottom:box, left:box};
    } else {
      if (type !== 'string') {
        return box;
      }
    }
    parts = box.split(' ');
    ln = parts.length;
    if (ln === 1) {
      parts[1] = parts[2] = parts[3] = parts[0];
    } else {
      if (ln === 2) {
        parts[2] = parts[0];
        parts[3] = parts[1];
      } else {
        if (ln === 3) {
          parts[3] = parts[1];
        }
      }
    }
    return {top:parseFloat(parts[0]) || 0, right:parseFloat(parts[1]) || 0, bottom:parseFloat(parts[2]) || 0, left:parseFloat(parts[3]) || 0};
  }, parseStyles:function(styles) {
    var out = {}, matches;
    if (styles) {
      cssRe.lastIndex = 0;
      while (matches = cssRe.exec(styles)) {
        out[matches[1]] = matches[2] || '';
      }
    }
    return out;
  }, select:function(selector, composite, root) {
    return Ext.fly(root || DOC).select(selector, composite);
  }, query:function(selector, asDom, root) {
    return Ext.fly(root || DOC).query(selector, asDom);
  }, unitizeBox:function(box, units) {
    var me = this;
    box = me.parseBox(box);
    return me.addUnits(box.top, units) + ' ' + me.addUnits(box.right, units) + ' ' + me.addUnits(box.bottom, units) + ' ' + me.addUnits(box.left, units);
  }, serializeForm:function(form) {
    var fElements = form.elements || (DOC.forms[form] || Ext.getDom(form)).elements, hasSubmit = false, encoder = encodeURIComponent, data = '', eLen = fElements.length, element, name, type, options, hasValue, e, o, oLen, opt;
    for (e = 0; e < eLen; e++) {
      element = fElements[e];
      name = element.name;
      type = element.type;
      options = element.options;
      if (!element.disabled && name) {
        if (/select-(one|multiple)/i.test(type)) {
          oLen = options.length;
          for (o = 0; o < oLen; o++) {
            opt = options[o];
            if (opt.selected) {
              hasValue = opt.hasAttribute('value');
              data += Ext.String.format('{0}\x3d{1}\x26', encoder(name), encoder(hasValue ? opt.value : opt.text));
            }
          }
        } else {
          if (!/file|undefined|reset|button/i.test(type)) {
            if (!(/radio|checkbox/i.test(type) && !element.checked) && !(type == 'submit' && hasSubmit)) {
              data += encoder(name) + '\x3d' + encoder(element.value) + '\x26';
              hasSubmit = /submit/i.test(type);
            }
          }
        }
      }
    }
    return data.substr(0, data.length - 1);
  }, getCommonAncestor:function(nodeA, nodeB, returnDom) {
    caFly = caFly || new Ext.dom.Fly;
    caFly.attach(Ext.getDom(nodeA));
    while (!caFly.isAncestor(nodeB)) {
      if (caFly.dom.parentNode) {
        caFly.attach(caFly.dom.parentNode);
      } else {
        caFly.attach(document.body);
        break;
      }
    }
    return returnDom ? caFly.dom : Ext.get(caFly);
  }}, addCls:function(names, prefix, suffix) {
    var me = this, elementData = me.getData(), hasNewCls, dom, map, classList, i, ln, name;
    if (!names) {
      return me;
    }
    if (!elementData.isSynchronized) {
      me.synchronize();
    }
    dom = me.dom;
    map = elementData.classMap;
    classList = elementData.classList;
    prefix = prefix ? prefix + SEPARATOR : '';
    suffix = suffix ? SEPARATOR + suffix : '';
    if (typeof names === 'string') {
      names = names.split(spacesRe);
    }
    for (i = 0, ln = names.length; i < ln; i++) {
      name = names[i];
      if (name) {
        name = prefix + name + suffix;
        if (!map[name]) {
          map[name] = true;
          classList.push(name);
          hasNewCls = true;
        }
      }
    }
    if (hasNewCls) {
      dom.className = classList.join(' ');
    }
    return me;
  }, addStyles:function(sides, styles) {
    var totalSize = 0, sidesArr = (sides || '').match(wordsRe), i, len = sidesArr.length, side, styleSides = [];
    if (len === 1) {
      totalSize = Math.abs(parseFloat(this.getStyle(styles[sidesArr[0]])) || 0);
    } else {
      if (len) {
        for (i = 0; i < len; i++) {
          side = sidesArr[i];
          styleSides.push(styles[side]);
        }
        styleSides = this.getStyle(styleSides);
        for (i = 0; i < len; i++) {
          side = sidesArr[i];
          totalSize += parseFloat(styleSides[styles[side]]) || 0;
        }
      }
    }
    return totalSize;
  }, addUnits:function(size, units) {
    return Element.addUnits(size, units);
  }, adjustDirect2DDimension:function(dimension) {
    var me = this, dom = me.dom, display = me.getStyle('display'), inlineDisplay = dom.style.display, inlinePosition = dom.style.position, originIndex = dimension === WIDTH ? 0 : 1, currentStyle = dom.currentStyle, floating;
    if (display === 'inline') {
      dom.style.display = 'inline-block';
    }
    dom.style.position = display.match(adjustDirect2DTableRe) ? 'absolute' : 'static';
    floating = (parseFloat(currentStyle[dimension]) || parseFloat(currentStyle.msTransformOrigin.split(' ')[originIndex]) * 2) % 1;
    dom.style.position = inlinePosition;
    if (display === 'inline') {
      dom.style.display = inlineDisplay;
    }
    return floating;
  }, animate:function(animation) {
    animation = new Ext.fx.Animation(animation);
    animation.setElement(this);
    this._activeAnimation = animation;
    animation.on({animationend:this._onAnimationEnd});
    Ext.Animator.run(animation);
    return animation;
  }, _onAnimationEnd:function() {
    this._activeAnimation = null;
  }, getActiveAnimation:function() {
    return this._activeAnimation;
  }, append:function() {
    this.appendChild.apply(this, arguments);
  }, appendChild:function(el, returnDom) {
    var me = this, insertEl, eLen, e;
    if (el.nodeType || el.dom || typeof el === 'string') {
      el = Ext.getDom(el);
      me.dom.appendChild(el);
      return !returnDom ? Ext.get(el) : el;
    } else {
      if (el.length) {
        insertEl = Ext.fly(document.createDocumentFragment());
        eLen = el.length;
        for (e = 0; e < eLen; e++) {
          insertEl.appendChild(el[e], returnDom);
        }
        me.dom.appendChild(insertEl.dom);
        return returnDom ? insertEl.dom : insertEl;
      } else {
        return me.createChild(el, null, returnDom);
      }
    }
  }, appendTo:function(el) {
    Ext.getDom(el).appendChild(this.dom);
    return this;
  }, applyStyles:function(styles) {
    if (styles) {
      if (typeof styles === 'function') {
        styles = styles.call();
      }
      if (typeof styles === 'string') {
        styles = Element.parseStyles(styles);
      }
      if (typeof styles === 'object') {
        this.setStyle(styles);
      }
    }
    return this;
  }, blur:function() {
    var me = this, dom = me.dom;
    if (dom !== DOC.body) {
      try {
        dom.blur();
      } catch (e$18) {
      }
      return me;
    } else {
      return me.focus(undefined, dom);
    }
  }, cacheScrollValues:function() {
    var me = this, scrollValues = [], scrolledDescendants = [], descendants, descendant, i, len;
    scrollFly = scrollFly || new Ext.dom.Fly;
    descendants = me.query('*');
    for (i = 0, len = descendants.length; i < len; i++) {
      descendant = descendants[i];
      if (descendant.scrollTop > 0 || descendant.scrollLeft !== 0) {
        scrolledDescendants.push(descendant);
        scrollValues.push(scrollFly.attach(descendant).getScroll());
      }
    }
    return function() {
      var scroll, i, len;
      for (i = 0, len = scrolledDescendants.length; i < len; i++) {
        scroll = scrollValues[i];
        scrollFly.attach(scrolledDescendants[i]);
        scrollFly.setScrollLeft(scroll.left);
        scrollFly.setScrollTop(scroll.top);
      }
    };
  }, center:function(centerIn) {
    return this.alignTo(centerIn || DOC, 'c-c');
  }, child:function(selector, returnDom) {
    var me = this, id = Ext.get(me).id;
    return me.selectNode(Ext.makeIdSelector(id) + ' \x3e ' + selector, !!returnDom);
  }, clone:function(deep, returnDom) {
    var clone = this.dom.cloneNode(deep);
    if (Ext.supports.CloneNodeCopiesExpando) {
      clearData(clone, deep);
    }
    return returnDom ? clone : Ext.get(clone);
  }, constrainScrollLeft:function(left) {
    var dom = this.dom;
    return Math.max(Math.min(left, dom.scrollWidth - dom.clientWidth), 0);
  }, constrainScrollTop:function(top) {
    var dom = this.dom;
    return Math.max(Math.min(top, dom.scrollHeight - dom.clientHeight), 0);
  }, createChild:function(config, insertBefore, returnDom) {
    config = config || {tag:'div'};
    if (insertBefore) {
      return Ext.DomHelper.insertBefore(insertBefore, config, returnDom !== true);
    } else {
      return Ext.DomHelper.append(this.dom, config, returnDom !== true);
    }
  }, contains:function(element) {
    if (!element) {
      return false;
    }
    var me = this, dom = Ext.getDom(element);
    return dom === me.dom || me.isAncestor(dom);
  }, destroy:function() {
    var me = this, dom = me.dom;
    if (me.destroyed) {
      Ext.Logger.warn('Cannot destroy Element "' + me.id + '". Already destroyed.');
      return;
    }
    if (dom) {
      if (dom === DOC.body) {
        Ext.raise('Cannot destroy body element.');
      } else {
        if (dom === DOC) {
          Ext.raise('Cannot destroy document object.');
        } else {
          if (dom === WIN) {
            Ext.raise('Cannot destroy window object');
          }
        }
      }
    }
    if (dom && dom.parentNode) {
      dom.parentNode.removeChild(dom);
    }
    me.collect();
    if (!me.isFly) {
      me.callParent();
    }
  }, detach:function() {
    var dom = this.dom;
    if (dom && dom.parentNode && dom.tagName !== 'BODY') {
      dom.parentNode.removeChild(dom);
    }
    return this;
  }, disableShadow:function() {
    var shadow = this.shadow;
    if (shadow) {
      shadow.hide();
      shadow.disabled = true;
    }
  }, disableShim:function() {
    var shim = this.shim;
    if (shim) {
      shim.hide();
      shim.disabled = true;
    }
  }, disableTouchContextMenu:function() {
    this._contextMenuListenerRemover = this.on({MSHoldVisual:function(e) {
      e.preventDefault();
    }, destroyable:true, delegated:false});
  }, disableTouchScroll:function() {
    this.addCls(noTouchScrollCls);
    this.on({touchmove:function(e) {
      e.preventDefault();
    }, translate:false});
  }, doReplaceWith:function(element) {
    var dom = this.dom;
    dom.parentNode.replaceChild(Ext.getDom(element), dom);
  }, doScrollIntoView:function(container, hscroll, animate, highlight, getScrollX, scrollTo) {
    scrollFly = scrollFly || new Ext.dom.Fly;
    var me = this, dom = me.dom, scrollX = scrollFly.attach(container)[getScrollX](), scrollY = container.scrollTop, position = me.getScrollIntoViewXY(container, scrollX, scrollY), newScrollX = position.x, newScrollY = position.y;
    if (highlight) {
      if (animate) {
        animate = Ext.apply({listeners:{afteranimate:function() {
          scrollFly.attach(dom).highlight();
        }}}, animate);
      } else {
        scrollFly.attach(dom).highlight();
      }
    }
    if (newScrollY !== scrollY) {
      scrollFly.attach(container).scrollTo('top', newScrollY, animate);
    }
    if (hscroll !== false && newScrollX !== scrollX) {
      scrollFly.attach(container)[scrollTo]('left', newScrollX, animate);
    }
    return me;
  }, down:function(selector, returnDom) {
    return this.selectNode(selector, !!returnDom);
  }, enableShadow:function(options, isVisible) {
    var me = this, shadow = me.shadow || (me.shadow = new Ext.dom.Shadow(Ext.apply({target:me}, options))), shim = me.shim;
    if (shim) {
      shim.offsets = shadow.outerOffsets;
      shim.shadow = shadow;
      shadow.shim = shim;
    }
    if (isVisible === true || isVisible !== false && me.isVisible()) {
      shadow.show();
    } else {
      shadow.hide();
    }
    shadow.disabled = false;
  }, enableShim:function(options, isVisible) {
    var me = this, shim = me.shim || (me.shim = new Ext.dom.Shim(Ext.apply({target:me}, options))), shadow = me.shadow;
    if (shadow) {
      shim.offsets = shadow.outerOffsets;
      shim.shadow = shadow;
      shadow.shim = shim;
    }
    if (isVisible === true || isVisible !== false && me.isVisible()) {
      shim.show();
    } else {
      shim.hide();
    }
    shim.disabled = false;
  }, findParent:function(simpleSelector, limit, returnEl) {
    var me = this, target = me.dom, topmost = DOC.documentElement, depth = 0;
    if (limit || limit === 0) {
      if (typeof limit !== 'number') {
        topmost = Ext.getDom(limit);
        limit = Number.MAX_VALUE;
      }
    } else {
      limit = 50;
    }
    while (target && target.nodeType === 1 && depth < limit && target !== topmost) {
      if (Ext.fly(target).is(simpleSelector)) {
        return returnEl ? Ext.get(target) : target;
      }
      depth++;
      target = target.parentNode;
    }
    return null;
  }, findParentNode:function(simpleSelector, limit, returnEl) {
    var p = Ext.fly(this.dom.parentNode);
    return p ? p.findParent(simpleSelector, limit, returnEl) : null;
  }, first:function(selector, returnDom) {
    return this.matchNode('nextSibling', 'firstChild', selector, returnDom);
  }, focus:function(defer, dom) {
    var me = this;
    dom = dom || me.dom;
    if (Number(defer)) {
      Ext.defer(me.focus, defer, me, [null, dom]);
    } else {
      Ext.GlobalEvents.fireEvent('beforefocus', dom);
      dom.focus();
    }
    return me;
  }, collect:function() {
    var me = this, dom = me.dom, shadow = me.shadow, shim = me.shim;
    if (!me.isFly) {
      me.mixins.observable.destroy.call(me);
      delete Ext.cache[me.id];
      me.destroyed = true;
      me.el = null;
    }
    if (dom) {
      dom._extData = me.dom = null;
    }
    if (shadow) {
      shadow.hide();
      me.shadow = null;
    }
    if (shim) {
      shim.hide();
      me.shim = null;
    }
  }, getAnchorToXY:function(el, anchor, local, mySize) {
    return el.getAnchorXY(anchor, local, mySize);
  }, getAttribute:function(name, namespace) {
    var dom = this.dom;
    return namespace ? dom.getAttributeNS(namespace, name) || dom.getAttribute(namespace + ':' + name) : dom.getAttribute(name) || dom[name] || null;
  }, getAttributes:function() {
    var attributes = this.dom.attributes, result = {}, attr, i, len;
    for (i = 0, len = attributes.length; i < len; i++) {
      attr = attributes[i];
      result[attr.name] = attr.value;
    }
    return result;
  }, getBottom:function(local) {
    return (local ? this.getLocalY() : this.getY()) + this.getHeight();
  }, getById:function(id, asDom) {
    var dom = DOC.getElementById(id) || this.dom.querySelector(Ext.makeIdSelector(id));
    return asDom ? dom : dom ? Ext.get(dom) : null;
  }, getBorderPadding:function() {
    var paddingWidth = this.getStyle(paddingsTLRB), bordersWidth = this.getStyle(bordersTLRB);
    return {beforeX:(parseFloat(bordersWidth[borders.l]) || 0) + (parseFloat(paddingWidth[paddings.l]) || 0), afterX:(parseFloat(bordersWidth[borders.r]) || 0) + (parseFloat(paddingWidth[paddings.r]) || 0), beforeY:(parseFloat(bordersWidth[borders.t]) || 0) + (parseFloat(paddingWidth[paddings.t]) || 0), afterY:(parseFloat(bordersWidth[borders.b]) || 0) + (parseFloat(paddingWidth[paddings.b]) || 0)};
  }, getBorders:function() {
    var bordersWidth = this.getStyle(bordersTLRB);
    return {beforeX:parseFloat(bordersWidth[borders.l]) || 0, afterX:parseFloat(bordersWidth[borders.r]) || 0, beforeY:parseFloat(bordersWidth[borders.t]) || 0, afterY:parseFloat(bordersWidth[borders.b]) || 0};
  }, getBorderWidth:function(side) {
    return this.addStyles(side, borders);
  }, getData:function(preventCreate) {
    var dom = this.dom, data;
    if (dom) {
      data = dom._extData;
      if (!data && !preventCreate) {
        dom._extData = data = {};
      }
    }
    return data;
  }, getFirstChild:function() {
    return Ext.get(this.dom.firstElementChild);
  }, getHeight:function(contentHeight, preciseHeight) {
    var me = this, hidden = me.isStyle('display', 'none'), height, floating;
    if (hidden) {
      return 0;
    }
    height = me.dom.offsetHeight;
    if (Ext.supports.Direct2DBug) {
      floating = me.adjustDirect2DDimension(HEIGHT);
      if (preciseHeight) {
        height += floating;
      } else {
        if (floating > 0 && floating < 0.5) {
          height++;
        }
      }
    }
    if (contentHeight) {
      height -= me.getBorderWidth('tb') + me.getPadding('tb');
    }
    return height < 0 ? 0 : height;
  }, getHtml:function() {
    return this.dom ? this.dom.innerHTML : '';
  }, getLeft:function(local) {
    return local ? this.getLocalX() : this.getX();
  }, getLocalX:function() {
    var me = this, offsetParent, x = me.getStyle('left');
    if (!x || x === 'auto') {
      x = 0;
    } else {
      if (pxRe.test(x)) {
        x = parseFloat(x);
      } else {
        x = me.getX();
        offsetParent = me.dom.offsetParent;
        if (offsetParent) {
          x -= Ext.fly(offsetParent).getX();
        }
      }
    }
    return x;
  }, getLocalXY:function() {
    var me = this, offsetParent, style = me.getStyle(['left', 'top']), x = style.left, y = style.top;
    if (!x || x === 'auto') {
      x = 0;
    } else {
      if (pxRe.test(x)) {
        x = parseFloat(x);
      } else {
        x = me.getX();
        offsetParent = me.dom.offsetParent;
        if (offsetParent) {
          x -= Ext.fly(offsetParent).getX();
        }
      }
    }
    if (!y || y === 'auto') {
      y = 0;
    } else {
      if (pxRe.test(y)) {
        y = parseFloat(y);
      } else {
        y = me.getY();
        offsetParent = me.dom.offsetParent;
        if (offsetParent) {
          y -= Ext.fly(offsetParent).getY();
        }
      }
    }
    return [x, y];
  }, getLocalY:function() {
    var me = this, offsetParent, y = me.getStyle('top');
    if (!y || y === 'auto') {
      y = 0;
    } else {
      if (pxRe.test(y)) {
        y = parseFloat(y);
      } else {
        y = me.getY();
        offsetParent = me.dom.offsetParent;
        if (offsetParent) {
          y -= Ext.fly(offsetParent).getY();
        }
      }
    }
    return y;
  }, getMargin:function() {
    var hash = {t:'top', l:'left', r:'right', b:'bottom'}, allMargins = ['margin-top', 'margin-left', 'margin-right', 'margin-bottom'];
    return function(side) {
      var me = this, style, key, o;
      if (!side) {
        style = me.getStyle(allMargins);
        o = {};
        if (style && typeof style === 'object') {
          o = {};
          for (key in margins) {
            o[key] = o[hash[key]] = parseFloat(style[margins[key]]) || 0;
          }
        }
      } else {
        o = me.addStyles(side, margins);
      }
      return o;
    };
  }(), getPadding:function(side) {
    return this.addStyles(side, paddings);
  }, getParent:function() {
    return Ext.get(this.dom.parentNode);
  }, getRight:function(local) {
    return (local ? this.getLocalX() : this.getX()) + this.getWidth();
  }, getScroll:function() {
    var me = this, dom = me.dom, docElement = DOC.documentElement, left, top, body = document.body;
    if (dom === DOC || dom === body) {
      left = docElement.scrollLeft || (body ? body.scrollLeft : 0);
      top = docElement.scrollTop || (body ? body.scrollTop : 0);
    } else {
      left = dom.scrollLeft;
      top = dom.scrollTop;
    }
    return {left:left, top:top};
  }, getScrollIntoViewXY:function(container, scrollX, scrollY) {
    var dom = this.dom, ct = Ext.getDom(container), offsets = this.getOffsetsTo(ct), width = dom.offsetWidth, height = dom.offsetHeight, left = offsets[0] + scrollX, top = offsets[1] + scrollY, bottom = top + height, right = left + width, viewHeight = ct.clientHeight, viewWidth = ct.clientWidth, viewLeft = scrollX, viewTop = scrollY, viewBottom = viewTop + viewHeight, viewRight = viewLeft + viewWidth;
    if (height > viewHeight || top < viewTop) {
      scrollY = top;
    } else {
      if (bottom > viewBottom) {
        scrollY = bottom - viewHeight;
      }
    }
    if (width > viewWidth || left < viewLeft) {
      scrollX = left;
    } else {
      if (right > viewRight) {
        scrollX = right - viewWidth;
      }
    }
    return {x:scrollX, y:scrollY};
  }, getScrollLeft:function() {
    var dom = this.dom;
    if (dom === DOC || dom === document.body) {
      return this.getScroll().left;
    } else {
      return dom.scrollLeft;
    }
  }, getScrollTop:function() {
    var dom = this.dom;
    if (dom === DOC || dom === document.body) {
      return this.getScroll().top;
    } else {
      return dom.scrollTop;
    }
  }, getSize:function(contentSize) {
    return {width:this.getWidth(contentSize), height:this.getHeight(contentSize)};
  }, getStyle:function(property, inline) {
    var me = this, dom = me.dom, multiple = typeof property !== 'string', hooks = me.styleHooks, prop = property, props = prop, len = 1, domStyle, camel, values, hook, out, style, i;
    if (multiple) {
      values = {};
      prop = props[0];
      i = 0;
      if (!(len = props.length)) {
        return values;
      }
    }
    if (!dom || dom.documentElement) {
      return values || '';
    }
    domStyle = dom.style;
    if (inline) {
      style = domStyle;
    } else {
      style = dom.ownerDocument.defaultView.getComputedStyle(dom, null);
      if (!style) {
        inline = true;
        style = domStyle;
      }
    }
    do {
      hook = hooks[prop];
      if (!hook) {
        hooks[prop] = hook = {name:Element.normalize(prop)};
      }
      if (hook.get) {
        out = hook.get(dom, me, inline, style);
      } else {
        camel = hook.name;
        out = style[camel];
      }
      if (!multiple) {
        return out;
      }
      values[prop] = out;
      prop = props[++i];
    } while (i < len);
    return values;
  }, getStyleValue:function(name) {
    return this.dom.style.getPropertyValue(name);
  }, getTop:function(local) {
    return local ? this.getLocalY() : this.getY();
  }, getValue:function(asNumber) {
    var value = this.dom.value;
    return asNumber ? parseInt(value, 10) : value;
  }, getViewSize:function() {
    var dom = this.dom;
    if (dom === DOC || dom === DOC.body) {
      return {width:Element.getViewportWidth(), height:Element.getViewportHeight()};
    } else {
      return {width:dom.clientWidth, height:dom.clientHeight};
    }
  }, getVisibilityMode:function() {
    var me = this, data = me.getData(), mode = data.visibilityMode;
    if (mode === undefined) {
      data.visibilityMode = mode = Element.DISPLAY;
    }
    return mode;
  }, getWidth:function(contentWidth, preciseWidth) {
    var me = this, dom = me.dom, hidden = me.isStyle('display', 'none'), rect, width, floating;
    if (hidden) {
      return 0;
    }
    if (Ext.supports.BoundingClientRect) {
      rect = dom.getBoundingClientRect();
      width = me.vertical && !Ext.supports.RotatedBoundingClientRect ? rect.bottom - rect.top : rect.right - rect.left;
      width = preciseWidth ? width : Math.ceil(width);
    } else {
      width = dom.offsetWidth;
    }
    if (Ext.supports.Direct2DBug && !me.vertical) {
      floating = me.adjustDirect2DDimension(WIDTH);
      if (preciseWidth) {
        width += floating;
      } else {
        if (floating > 0 && floating < 0.5) {
          width++;
        }
      }
    }
    if (contentWidth) {
      width -= me.getBorderWidth('lr') + me.getPadding('lr');
    }
    return width < 0 ? 0 : width;
  }, getX:function() {
    return this.getXY()[0];
  }, getXY:function() {
    var round = Math.round, dom = this.dom, x = 0, y = 0, box, scroll;
    if (dom !== DOC && dom !== DOC.body) {
      try {
        box = dom.getBoundingClientRect();
      } catch (ex) {
        box = {left:0, top:0};
      }
      x = round(box.left);
      y = round(box.top);
      scroll = Ext.getDoc().getScroll();
      x += scroll.left;
      y += scroll.top;
    }
    return [x, y];
  }, getY:function() {
    return this.getXY()[1];
  }, getZIndex:function() {
    return parseInt(this.getStyle('z-index'), 10);
  }, hasCls:function(name) {
    var elementData = this.getData();
    if (!elementData.isSynchronized) {
      this.synchronize();
    }
    return elementData.classMap.hasOwnProperty(name);
  }, hide:function() {
    this.setVisible(false);
    return this;
  }, insertAfter:function(el) {
    el = Ext.getDom(el);
    el.parentNode.insertBefore(this.dom, el.nextSibling);
    return this;
  }, insertBefore:function(el) {
    el = Ext.getDom(el);
    el.parentNode.insertBefore(this.dom, el);
    return this;
  }, insertFirst:function(el, returnDom) {
    el = el || {};
    if (el.nodeType || el.dom || typeof el === 'string') {
      el = Ext.getDom(el);
      this.dom.insertBefore(el, this.dom.firstChild);
      return !returnDom ? Ext.get(el) : el;
    } else {
      return this.createChild(el, this.dom.firstChild, returnDom);
    }
  }, insertHtml:function(where, html, returnEl) {
    var el = Ext.DomHelper.insertHtml(where, this.dom, html);
    return returnEl ? Ext.get(el) : el;
  }, insertSibling:function(el, where, returnDom) {
    var me = this, DomHelper = Ext.DomHelper, isAfter = (where || 'before').toLowerCase() === 'after', rt, insertEl, eLen, e;
    if (Ext.isIterable(el)) {
      eLen = el.length;
      insertEl = Ext.fly(document.createDocumentFragment());
      if (Ext.isArray(el)) {
        for (e = 0; e < eLen; e++) {
          rt = insertEl.appendChild(el[e], returnDom);
        }
      } else {
        for (e = 0; e < eLen; e++) {
          insertEl.dom.appendChild(rt = el[0]);
        }
        if (returnDom === false) {
          rt = Ext.get(rt);
        }
      }
      me.dom.parentNode.insertBefore(insertEl.dom, isAfter ? me.dom.nextSibling : me.dom);
      return rt;
    }
    el = el || {};
    if (el.nodeType || el.dom) {
      rt = me.dom.parentNode.insertBefore(Ext.getDom(el), isAfter ? me.dom.nextSibling : me.dom);
      if (!returnDom) {
        rt = Ext.get(rt);
      }
    } else {
      if (isAfter && !me.dom.nextSibling) {
        rt = DomHelper.append(me.dom.parentNode, el, !returnDom);
      } else {
        rt = DomHelper[isAfter ? 'insertAfter' : 'insertBefore'](me.dom, el, !returnDom);
      }
    }
    return rt;
  }, is:function(selector) {
    var dom = this.dom, is;
    if (!selector) {
      is = true;
    } else {
      if (!dom.tagName) {
        is = false;
      } else {
        if (Ext.isFunction(selector)) {
          is = selector(dom);
        } else {
          is = dom[Ext.supports.matchesSelector](selector);
        }
      }
    }
    return is;
  }, isAncestor:function(el) {
    var ret = false, dom = this.dom, child = Ext.getDom(el);
    if (dom && child) {
      if (dom.contains) {
        return dom.contains(child);
      } else {
        if (dom.compareDocumentPosition) {
          return !!(dom.compareDocumentPosition(child) & 16);
        } else {
          while (child = child.parentNode) {
            ret = child === dom || ret;
          }
        }
      }
    }
    return ret;
  }, isPainted:function() {
    return !Ext.browser.is.IE ? function() {
      var dom = this.dom;
      return Boolean(dom && dom.offsetParent);
    } : function() {
      var dom = this.dom;
      return Boolean(dom && (dom.offsetHeight !== 0 && dom.offsetWidth !== 0));
    };
  }(), isScrollable:function() {
    var dom = this.dom;
    return dom.scrollHeight > dom.clientHeight || dom.scrollWidth > dom.clientWidth;
  }, isStyle:function(style, val) {
    return this.getStyle(style) === val;
  }, isVisible:function(deep) {
    var dom = this.dom, end;
    if (!dom) {
      return false;
    }
    if (!visFly) {
      visFly = new Ext.dom.Fly;
    }
    for (end = dom.ownerDocument.documentElement; dom !== end; dom = dom.parentNode) {
      if (!dom || dom.nodeType === 11 || visFly.attach(dom).isStyle(VISIBILITY, HIDDEN) || visFly.isStyle(DISPLAY, NONE)) {
        return false;
      }
      if (!deep) {
        break;
      }
    }
    return true;
  }, last:function(selector, returnDom) {
    return this.matchNode('previousSibling', 'lastChild', selector, returnDom);
  }, maskIframes:function() {
    var iframes = document.getElementsByTagName('iframe');
    Ext.each(iframes, function(iframe) {
      var iframeParent = Ext.fly(iframe.parentNode), myMask = iframeParent.mask();
      myMask.setStyle('background-color', 'transparent');
    });
  }, matchNode:function(dir, start, selector, returnDom) {
    var dom = this.dom, n;
    if (!dom) {
      return null;
    }
    n = dom[start];
    while (n) {
      if (n.nodeType === 1 && (!selector || Ext.fly(n, '_matchNode').is(selector))) {
        return !returnDom ? Ext.get(n) : n;
      }
      n = n[dir];
    }
    return null;
  }, next:function(selector, returnDom) {
    return this.matchNode('nextSibling', 'nextSibling', selector, returnDom);
  }, parent:function(selector, returnDom) {
    return this.matchNode('parentNode', 'parentNode', selector, returnDom);
  }, position:function(pos, zIndex, x, y) {
    var me = this;
    if (me.dom.tagName !== 'BODY') {
      if (!pos && me.isStyle(POSITION, STATIC)) {
        me.setStyle(POSITION, RELATIVE);
      } else {
        if (pos) {
          me.setStyle(POSITION, pos);
        }
      }
      if (zIndex) {
        me.setStyle(ZINDEX, zIndex);
      }
      if (x || y) {
        me.setXY([x || false, y || false]);
      }
    }
  }, prev:function(selector, returnDom) {
    return this.matchNode('previousSibling', 'previousSibling', selector, returnDom);
  }, query:function(selector, asDom, single) {
    var dom = this.dom, results, len, nlen, node, nodes, i, j;
    if (!dom) {
      return null;
    }
    asDom = asDom !== false;
    selector = selector.split(',');
    if (!single) {
      results = [];
    }
    for (i = 0, len = selector.length; i < len; i++) {
      if (typeof selector[i] === 'string') {
        if (single) {
          node = dom.querySelector(selector[i]);
          return asDom ? node : Ext.get(node);
        }
        nodes = dom.querySelectorAll(selector[i]);
        for (j = 0, nlen = nodes.length; j < nlen; j++) {
          results.push(asDom ? nodes[j] : Ext.get(nodes[j]));
        }
      }
    }
    return results;
  }, radioCls:function(className) {
    var cn = this.dom.parentNode.childNodes, v;
    className = Ext.isArray(className) ? className : [className];
    for (var i = 0, len = cn.length; i < len; i++) {
      v = cn[i];
      if (v && v.nodeType === 1) {
        Ext.fly(v).removeCls(className);
      }
    }
    return this.addCls(className);
  }, redraw:function() {
    var dom = this.dom, domStyle = dom.style;
    domStyle.display = 'none';
    dom.offsetHeight;
    domStyle.display = '';
  }, remove:function() {
    this.destroy();
  }, removeChild:function(element) {
    this.dom.removeChild(Ext.getDom(element));
    return this;
  }, removeCls:function(names, prefix, suffix) {
    var me = this, elementData = me.getData(), hasNewCls, dom, map, classList, i, ln, name;
    if (!names) {
      return me;
    }
    if (!elementData.isSynchronized) {
      me.synchronize();
    }
    dom = me.dom;
    map = elementData.classMap;
    classList = elementData.classList;
    prefix = prefix ? prefix + SEPARATOR : '';
    suffix = suffix ? SEPARATOR + suffix : '';
    if (typeof names === 'string') {
      names = names.split(spacesRe);
    }
    for (i = 0, ln = names.length; i < ln; i++) {
      name = names[i];
      if (name) {
        name = prefix + name + suffix;
        if (map[name]) {
          delete map[name];
          Ext.Array.remove(classList, name);
          hasNewCls = true;
        }
      }
    }
    if (hasNewCls) {
      dom.className = classList.join(' ');
    }
    return me;
  }, repaint:function() {
    var me = this;
    me.addCls(Ext.baseCSSPrefix + 'repaint');
    Ext.defer(function() {
      if (me.dom) {
        Ext.fly(me.dom).removeCls(Ext.baseCSSPrefix + 'repaint');
      }
    }, 1);
    return me;
  }, replace:function(el, destroy) {
    el = Ext.getDom(el);
    var parentNode = el.parentNode, id = el.id, dom = this.dom;
    if (!parentNode) {
      Ext.raise('Cannot replace element "' + id + '". It is not attached to a parent node.');
    }
    if (destroy !== false && id && Ext.cache[id]) {
      parentNode.insertBefore(dom, el);
      Ext.get(el).destroy();
    } else {
      parentNode.replaceChild(dom, el);
    }
    return this;
  }, replaceCls:function(oldName, newName, prefix, suffix) {
    var me = this, dom, map, classList, i, ln, name, elementData = me.getData(), change;
    if (!oldName && !newName) {
      return me;
    }
    oldName = oldName || [];
    newName = newName || [];
    if (!elementData.isSynchronized) {
      me.synchronize();
    }
    if (!suffix) {
      suffix = '';
    }
    dom = me.dom;
    map = elementData.classMap;
    classList = elementData.classList;
    prefix = prefix ? prefix + SEPARATOR : '';
    suffix = suffix ? SEPARATOR + suffix : '';
    if (typeof oldName === 'string') {
      oldName = oldName.split(spacesRe);
    }
    if (typeof newName === 'string') {
      newName = newName.split(spacesRe);
    }
    for (i = 0, ln = oldName.length; i < ln; i++) {
      name = prefix + oldName[i] + suffix;
      if (map[name]) {
        delete map[name];
        change = true;
      }
    }
    for (i = 0, ln = newName.length; i < ln; i++) {
      name = prefix + newName[i] + suffix;
      if (!map[name]) {
        map[name] = true;
        change = true;
      }
    }
    if (change) {
      elementData.classList = classList = Ext.Object.getKeys(map);
      dom.className = classList.join(' ');
    }
    return me;
  }, replaceWith:function(el) {
    var me = this, dom = me.dom, parent = dom.parentNode, cache = Ext.cache, newDom;
    me.clearListeners();
    if (el.nodeType || el.dom || typeof el === 'string') {
      el = Ext.get(el);
      newDom = parent.insertBefore(el.dom, dom);
    } else {
      newDom = Ext.DomHelper.insertBefore(dom, el);
    }
    parent.removeChild(dom);
    me.dom = newDom;
    if (!me.isFly) {
      delete cache[me.id];
      cache[me.id = Ext.id(newDom)] = me;
    }
    return me;
  }, resolveListenerScope:function(defaultScope) {
    var component = this.component;
    return component ? component.resolveListenerScope(defaultScope) : this;
  }, scroll:function(direction, distance, animate) {
    if (!this.isScrollable()) {
      return false;
    }
    direction = direction.charAt(0);
    var me = this, dom = me.dom, side = direction === 'r' || direction === 'l' ? 'left' : 'top', scrolled = false, currentScroll, constrainedScroll;
    if (direction === 'l' || direction === 't' || direction === 'u') {
      distance = -distance;
    }
    if (side === 'left') {
      currentScroll = dom.scrollLeft;
      constrainedScroll = me.constrainScrollLeft(currentScroll + distance);
    } else {
      currentScroll = dom.scrollTop;
      constrainedScroll = me.constrainScrollTop(currentScroll + distance);
    }
    if (constrainedScroll !== currentScroll) {
      this.scrollTo(side, constrainedScroll, animate);
      scrolled = true;
    }
    return scrolled;
  }, scrollBy:function(deltaX, deltaY, animate) {
    var me = this, dom = me.dom;
    if (deltaX.length) {
      animate = deltaY;
      deltaY = deltaX[1];
      deltaX = deltaX[0];
    } else {
      if (typeof deltaX != 'number') {
        animate = deltaY;
        deltaY = deltaX.y;
        deltaX = deltaX.x;
      }
    }
    if (deltaX) {
      me.scrollTo('left', me.constrainScrollLeft(dom.scrollLeft + deltaX), animate);
    }
    if (deltaY) {
      me.scrollTo('top', me.constrainScrollTop(dom.scrollTop + deltaY), animate);
    }
    return me;
  }, scrollChildIntoView:function(child, hscroll) {
    Ext.fly(child).scrollIntoView(this, hscroll);
  }, scrollIntoView:function(container, hscroll, animate, highlight) {
    container = Ext.getDom(container) || Ext.getBody().dom;
    return this.doScrollIntoView(container, hscroll, animate, highlight, 'getScrollLeft', 'scrollTo');
  }, scrollTo:function(side, value, animate) {
    var top = topRe.test(side), me = this, prop = top ? 'scrollTop' : 'scrollLeft', dom = me.dom, animCfg;
    if (!animate || !me.anim) {
      dom[prop] = value;
      dom[prop] = value;
    } else {
      animCfg = {to:{}};
      animCfg.to[prop] = value;
      if (Ext.isObject(animate)) {
        Ext.applyIf(animCfg, animate);
      }
      me.animate(animCfg);
    }
    return me;
  }, select:function(selector, composite) {
    var isElementArray, elements;
    if (typeof selector === 'string') {
      elements = this.query(selector, !composite);
    } else {
      if (selector.length === undefined) {
        Ext.raise('Invalid selector specified: ' + selector);
      } else {
        elements = selector;
        isElementArray = true;
      }
    }
    return composite ? new Ext.CompositeElement(elements, !isElementArray) : new Ext.CompositeElementLite(elements, true);
  }, selectNode:function(selector, asDom) {
    return this.query(selector, asDom, true);
  }, set:function(attributes, useSet) {
    var me = this, dom = me.dom, attribute, value;
    for (attribute in attributes) {
      if (attributes.hasOwnProperty(attribute)) {
        value = attributes[attribute];
        if (attribute === 'style') {
          me.applyStyles(value);
        } else {
          if (attribute === 'cls') {
            dom.className = value;
          } else {
            if (useSet !== false) {
              if (value === undefined) {
                dom.removeAttribute(attribute);
              } else {
                dom.setAttribute(attribute, value);
              }
            } else {
              dom[attribute] = value;
            }
          }
        }
      }
    }
    return me;
  }, setBottom:function(bottom) {
    this.dom.style[BOTTOM] = Element.addUnits(bottom);
    return this;
  }, setCls:function(className) {
    var me = this, elementData = me.getData(), i, ln, name, map, classList;
    if (!elementData.isSynchronized) {
      me.synchronize();
    }
    if (typeof className === 'string') {
      className = className.split(spacesRe);
    }
    elementData.classList = classList = className.slice();
    elementData.classMap = map = {};
    for (i = 0, ln = classList.length; i < ln; i++) {
      map[classList[i]] = true;
    }
    me.dom.className = classList.join(' ');
  }, setDisplayed:function(value) {
    var me = this;
    if (typeof value === 'boolean') {
      value = value ? me._getDisplay() : NONE;
    }
    me.setStyle(DISPLAY, value);
    if (me.shadow || me.shim) {
      me.setUnderlaysVisible(value !== NONE);
    }
    return me;
  }, setHeight:function(height) {
    var me = this;
    me.dom.style[HEIGHT] = Element.addUnits(height);
    if (me.shadow || me.shim) {
      me.syncUnderlays();
    }
    return me;
  }, setHtml:function(html) {
    if (this.dom) {
      this.dom.innerHTML = html;
    }
    return this;
  }, setId:function(id) {
    var me = this, currentId = me.id, cache = Ext.cache;
    if (currentId) {
      delete cache[currentId];
    }
    me.dom.id = id;
    me.id = id;
    cache[id] = me;
    return me;
  }, setLeft:function(left) {
    var me = this;
    me.dom.style[LEFT] = Element.addUnits(left);
    if (me.shadow || me.shim) {
      me.syncUnderlays();
    }
    return me;
  }, setLocalX:function(x) {
    var me = this, style = me.dom.style;
    style.right = 'auto';
    style.left = x === null ? 'auto' : x + 'px';
    if (me.shadow || me.shim) {
      me.syncUnderlays();
    }
    return me;
  }, setLocalXY:function(x, y) {
    var me = this, style = me.dom.style;
    style.right = 'auto';
    if (x && x.length) {
      y = x[1];
      x = x[0];
    }
    if (x === null) {
      style.left = 'auto';
    } else {
      if (x !== undefined) {
        style.left = x + 'px';
      }
    }
    if (y === null) {
      style.top = 'auto';
    } else {
      if (y !== undefined) {
        style.top = y + 'px';
      }
    }
    if (me.shadow || me.shim) {
      me.syncUnderlays();
    }
    return me;
  }, setLocalY:function(y) {
    var me = this;
    me.dom.style.top = y === null ? 'auto' : y + 'px';
    if (me.shadow || me.shim) {
      me.syncUnderlays();
    }
    return me;
  }, setMargin:function(margin) {
    var me = this, domStyle = me.dom.style;
    if (margin || margin === 0) {
      margin = me.self.unitizeBox(margin === true ? 5 : margin);
      domStyle.setProperty('margin', margin, 'important');
    } else {
      domStyle.removeProperty('margin-top');
      domStyle.removeProperty('margin-right');
      domStyle.removeProperty('margin-bottom');
      domStyle.removeProperty('margin-left');
    }
  }, setMaxHeight:function(height) {
    this.dom.style[MAX_HEIGHT] = Element.addUnits(height);
    return this;
  }, setMaxWidth:function(width) {
    this.dom.style[MAX_WIDTH] = Element.addUnits(width);
    return this;
  }, setMinHeight:function(height) {
    this.dom.style[MIN_HEIGHT] = Element.addUnits(height);
    return this;
  }, setMinWidth:function(width) {
    this.dom.style[MIN_WIDTH] = Element.addUnits(width);
    return this;
  }, setOpacity:function(opacity) {
    var me = this;
    if (me.dom) {
      me.setStyle('opacity', opacity);
    }
    return me;
  }, setPadding:function(padding) {
    var me = this, domStyle = me.dom.style;
    if (padding || padding === 0) {
      padding = me.self.unitizeBox(padding === true ? 5 : padding);
      domStyle.setProperty('padding', padding, 'important');
    } else {
      domStyle.removeProperty('padding-top');
      domStyle.removeProperty('padding-right');
      domStyle.removeProperty('padding-bottom');
      domStyle.removeProperty('padding-left');
    }
  }, setRight:function(right) {
    this.dom.style[RIGHT] = Element.addUnits(right);
    return this;
  }, setScrollLeft:function(left) {
    this.dom.scrollLeft = left;
    return this;
  }, setScrollTop:function(top) {
    this.dom.scrollTop = top;
    return this;
  }, setSize:function(width, height) {
    var me = this, style = me.dom.style;
    if (Ext.isObject(width)) {
      height = width.height;
      width = width.width;
    }
    style.width = Element.addUnits(width);
    style.height = Element.addUnits(height);
    if (me.shadow || me.shim) {
      me.syncUnderlays();
    }
    return me;
  }, setSizeState:function(state) {
    var me = this, add, remove;
    if (state === true) {
      add = sizedCls;
      remove = [unsizedCls, stretchedCls];
    } else {
      if (state === false) {
        add = unsizedCls;
        remove = [sizedCls, stretchedCls];
      } else {
        if (state === null) {
          add = stretchedCls;
          remove = [sizedCls, unsizedCls];
        } else {
          remove = [sizedCls, unsizedCls, stretchedCls];
        }
      }
    }
    if (add) {
      me.addCls(add);
    }
    me.removeCls(remove);
    return me;
  }, setStyle:function(prop, value) {
    var me = this, dom = me.dom, hooks = me.styleHooks, style = dom.style, name = prop, hook;
    if (typeof name === 'string') {
      hook = hooks[name];
      if (!hook) {
        hooks[name] = hook = {name:Element.normalize(name)};
      }
      value = value == null ? '' : value;
      if (hook.set) {
        hook.set(dom, value, me);
      } else {
        style[hook.name] = value;
      }
      if (hook.afterSet) {
        hook.afterSet(dom, value, me);
      }
    } else {
      for (name in prop) {
        if (prop.hasOwnProperty(name)) {
          hook = hooks[name];
          if (!hook) {
            hooks[name] = hook = {name:Element.normalize(name)};
          }
          value = prop[name];
          value = value == null ? '' : value;
          if (hook.set) {
            hook.set(dom, value, me);
          } else {
            style[hook.name] = value;
          }
          if (hook.afterSet) {
            hook.afterSet(dom, value, me);
          }
        }
      }
    }
    return me;
  }, setText:function(text) {
    this.dom.textContent = text;
  }, setTop:function(top) {
    var me = this;
    me.dom.style[TOP] = Element.addUnits(top);
    if (me.shadow || me.shim) {
      me.syncUnderlays();
    }
    return me;
  }, setUnderlaysVisible:function(visible) {
    var shadow = this.shadow, shim = this.shim;
    if (shadow && !shadow.disabled) {
      if (visible) {
        shadow.show();
      } else {
        shadow.hide();
      }
    }
    if (shim && !shim.disabled) {
      if (visible) {
        shim.show();
      } else {
        shim.hide();
      }
    }
  }, setVisibility:function(isVisible) {
    var domStyle = this.dom.style;
    if (isVisible) {
      domStyle.removeProperty('visibility');
    } else {
      domStyle.setProperty('visibility', 'hidden', 'important');
    }
  }, setVisibilityMode:function(mode) {
    if (mode !== 1 && mode !== 2 && mode !== 3 && mode !== 4) {
      Ext.raise('visibilityMode must be one of the following: ' + 'Ext.Element.DISPLAY, Ext.Element.VISIBILITY, Ext.Element.OFFSETS, ' + 'or Ext.Element.CLIP');
    }
    this.getData().visibilityMode = mode;
    return this;
  }, setVisible:function(visible) {
    var me = this, mode = me.getVisibilityMode(), addOrRemove = visible ? 'removeCls' : 'addCls';
    switch(mode) {
      case Element.DISPLAY:
        me.removeCls([visibilityCls, offsetsCls, clipCls]);
        me[addOrRemove](displayCls);
        break;
      case Element.VISIBILITY:
        me.removeCls([displayCls, offsetsCls, clipCls]);
        me[addOrRemove](visibilityCls);
        break;
      case Element.OFFSETS:
        me.removeCls([visibilityCls, displayCls, clipCls]);
        me[addOrRemove](offsetsCls);
        break;
      case Element.CLIP:
        me.removeCls([visibilityCls, displayCls, offsetsCls]);
        me[addOrRemove](clipCls);
        break;
    }
    if (me.shadow || me.shim) {
      me.setUnderlaysVisible(visible);
    }
    return me;
  }, setWidth:function(width) {
    var me = this;
    me.dom.style[WIDTH] = Element.addUnits(width);
    if (me.shadow || me.shim) {
      me.syncUnderlays();
    }
    return me;
  }, setX:function(x) {
    return this.setXY([x, false]);
  }, setXY:function(xy) {
    var me = this, pts = me.translatePoints(xy), style = me.dom.style, pos;
    me.position();
    style.right = 'auto';
    for (pos in pts) {
      if (!isNaN(pts[pos])) {
        style[pos] = pts[pos] + 'px';
      }
    }
    if (me.shadow || me.shim) {
      me.syncUnderlays();
    }
    return me;
  }, setY:function(y) {
    return this.setXY([false, y]);
  }, setZIndex:function(zindex) {
    var me = this;
    if (me.shadow) {
      me.shadow.setZIndex(zindex);
    }
    if (me.shim) {
      me.shim.setZIndex(zindex);
    }
    return me.setStyle('z-index', zindex);
  }, show:function() {
    this.setVisible(true);
    return this;
  }, swapCls:function(firstClass, secondClass, flag, prefix) {
    if (flag === undefined) {
      flag = true;
    }
    var me = this, addedClass = flag ? firstClass : secondClass, removedClass = flag ? secondClass : firstClass;
    if (removedClass) {
      me.removeCls(prefix ? prefix + '-' + removedClass : removedClass);
    }
    if (addedClass) {
      me.addCls(prefix ? prefix + '-' + addedClass : addedClass);
    }
    return me;
  }, synchronize:function() {
    var me = this, dom = me.dom, hasClassMap = {}, className = dom.className, classList, i, ln, name, elementData = me.getData();
    if (className && className.length > 0) {
      classList = dom.className.split(classNameSplitRegex);
      for (i = 0, ln = classList.length; i < ln; i++) {
        name = classList[i];
        hasClassMap[name] = true;
      }
    } else {
      classList = [];
    }
    elementData.classList = classList;
    elementData.classMap = hasClassMap;
    elementData.isSynchronized = true;
    return me;
  }, syncUnderlays:function() {
    var me = this, shadow = me.shadow, shim = me.shim, dom = me.dom, xy, x, y, w, h;
    if (me.isVisible()) {
      xy = me.getXY();
      x = xy[0];
      y = xy[1];
      w = dom.offsetWidth;
      h = dom.offsetHeight;
      if (shadow && !shadow.hidden) {
        shadow.realign(x, y, w, h);
      }
      if (shim && !shim.hidden) {
        shim.realign(x, y, w, h);
      }
    }
  }, toggleCls:function(className, state) {
    if (typeof state !== 'boolean') {
      state = !this.hasCls(className);
    }
    return state ? this.addCls(className) : this.removeCls(className);
  }, toggle:function() {
    this.setVisible(!this.isVisible());
    return this;
  }, translate:function() {
    var transformStyleName = 'webkitTransform' in DOC.createElement('div').style ? 'webkitTransform' : 'transform';
    return function(x, y, z) {
      this.dom.style[transformStyleName] = 'translate3d(' + (x || 0) + 'px, ' + (y || 0) + 'px, ' + (z || 0) + 'px)';
    };
  }(), unmaskIframes:function() {
    var iframes = document.getElementsByTagName('iframe');
    Ext.each(iframes, function(iframe) {
      var iframeParent = Ext.fly(iframe.parentNode);
      iframeParent.unmask();
    });
  }, unwrap:function() {
    var dom = this.dom, parentNode = dom.parentNode, grandparentNode, activeElement = Ext.fly(Ext.Element.getActiveElement()), cached, resumeFocus, grannyFly, tabIndex;
    cached = Ext.cache[activeElement.id];
    if (cached) {
      activeElement = cached;
    }
    if (this.contains(activeElement)) {
      if (cached) {
        cached.suspendFocusEvents();
      }
      resumeFocus = true;
    }
    if (parentNode) {
      grandparentNode = parentNode.parentNode;
      if (resumeFocus) {
        tabIndex = grandparentNode.getAttribute('tabIndex');
        grannyFly = Ext.fly(grandparentNode);
        grannyFly.set({tabIndex:-1});
        grannyFly.suspendFocusEvents();
        grannyFly.focus();
      }
      grandparentNode.insertBefore(dom, parentNode);
      grandparentNode.removeChild(parentNode);
    } else {
      grandparentNode = document.createDocumentFragment();
      grandparentNode.appendChild(dom);
    }
    if (resumeFocus) {
      if (cached) {
        cached.focus();
        cached.resumeFocusEvents();
      } else {
        Ext.fly(activeElement).focus();
      }
      if (grannyFly) {
        grannyFly.resumeFocusEvents();
        grannyFly.set({tabIndex:tabIndex});
      }
    }
    return this;
  }, up:function(simpleSelector, limit, returnDom) {
    return this.findParentNode(simpleSelector, limit, !returnDom);
  }, update:function(html) {
    return this.setHtml(html);
  }, wrap:function(config, returnDom, selector) {
    var me = this, dom = me.dom, newEl = Ext.DomHelper.insertBefore(dom, config || {tag:'div'}, !returnDom), target = newEl, activeElement = Ext.Element.getActiveElement(), cached, resumeFocus, tabIndex;
    cached = Ext.cache[activeElement.id];
    if (cached) {
      activeElement = cached;
    }
    if (selector) {
      target = newEl.selectNode(selector, returnDom);
    }
    if (me.contains(activeElement)) {
      if (cached) {
        cached.suspendFocusEvents();
      }
      tabIndex = newEl.dom.getAttribute('tabIndex');
      newEl.set({tabIndex:-1});
      newEl.suspendFocusEvents();
      newEl.focus();
      resumeFocus = true;
    }
    target.appendChild(dom);
    if (resumeFocus) {
      if (cached) {
        cached.focus();
        cached.resumeFocusEvents();
      } else {
        Ext.fly(activeElement).focus();
      }
      newEl.resumeFocusEvents();
      newEl.set({tabIndex:tabIndex});
    }
    return newEl;
  }, privates:{doAddListener:function(eventName, fn, scope, options, order, caller, manager) {
    var me = this, observableDoAddListener, additiveEventName, translatedEventName;
    eventName = Ext.canonicalEventName(eventName);
    if (!me.blockedEvents[eventName]) {
      observableDoAddListener = me.mixins.observable.doAddListener;
      options = options || {};
      if (me.longpressEvents[eventName]) {
        me.disableTouchContextMenu();
      }
      if (Element.useDelegatedEvents === false) {
        options.delegated = options.delegated || false;
      }
      if (options.translate !== false) {
        additiveEventName = me.additiveEvents[eventName];
        if (additiveEventName) {
          options.type = eventName;
          eventName = additiveEventName;
          observableDoAddListener.call(me, eventName, fn, scope, options, order, caller, manager);
        }
        translatedEventName = me.eventMap[eventName];
        if (translatedEventName) {
          options.type = options.type || eventName;
          eventName = translatedEventName;
        }
      }
      observableDoAddListener.call(me, eventName, fn, scope, options, order, caller, manager);
      delete options.type;
    }
  }, doRemoveListener:function(eventName, fn, scope) {
    var me = this, observableDoRemoveListener, translatedEventName, additiveEventName, contextMenuListenerRemover;
    if (!me.blockedEvents[eventName]) {
      observableDoRemoveListener = me.mixins.observable.doRemoveListener;
      if (me.longpressEvents[eventName]) {
        contextMenuListenerRemover = this._contextMenuListenerRemover;
        if (contextMenuListenerRemover) {
          contextMenuListenerRemover.destroy();
        }
      }
      additiveEventName = me.additiveEvents[eventName];
      if (additiveEventName) {
        eventName = additiveEventName;
        observableDoRemoveListener.call(me, eventName, fn, scope);
      }
      translatedEventName = me.eventMap[eventName];
      if (translatedEventName) {
        observableDoRemoveListener.call(me, translatedEventName, fn, scope);
      }
      observableDoRemoveListener.call(me, eventName, fn, scope);
    }
  }, _initEvent:function(eventName) {
    return this.events[eventName] = new Ext.dom.ElementEvent(this, eventName);
  }, _getDisplay:function() {
    var data = this.getData(), display = data[ORIGINALDISPLAY];
    if (display === undefined) {
      data[ORIGINALDISPLAY] = display = '';
    }
    return display;
  }, _getPublisher:function(eventName) {
    var Publisher = Ext.event.publisher.Publisher, publisher = Publisher.publishersByEvent[eventName];
    if (!publisher || this.dom === window && eventName === 'resize') {
      publisher = Publisher.publishers.dom;
    }
    return publisher;
  }, isFocusSuspended:function() {
    return !!this.getData().suspendFocusEvents;
  }, suspendFocusEvents:function() {
    if (!this.isFly) {
      this.suspendEvent('focus', 'blur');
    }
    this.getData().suspendFocusEvents = true;
  }, resumeFocusEvents:function() {
    function resumeFn() {
      var data;
      if (!this.destroyed) {
        data = this.getData();
        if (data) {
          data.suspendFocusEvents = false;
        }
        if (!this.isFly) {
          this.resumeEvent('focus', 'blur');
        }
      }
    }
    if (!this.destroyed && this.getData().suspendFocusEvents) {
      if (Ext.isIE) {
        Ext.asap(resumeFn, this);
      } else {
        resumeFn.call(this);
      }
    }
  }}, deprecated:{'5.0':{methods:{cssTranslate:null, getHTML:'getHtml', getOuterHeight:null, getOuterWidth:null, getPageBox:function(getRegion) {
    var me = this, dom = me.dom, isDoc = dom.nodeName === 'BODY', w = isDoc ? Element.getViewportWidth() : dom.offsetWidth, h = isDoc ? Element.getViewportHeight() : dom.offsetHeight, xy = me.getXY(), t = xy[1], r = xy[0] + w, b = xy[1] + h, l = xy[0];
    if (getRegion) {
      return new Ext.util.Region(t, r, b, l);
    } else {
      return {left:l, top:t, width:w, height:h, right:r, bottom:b};
    }
  }, getScrollParent:null, isDescendent:null, isTransparent:function(prop) {
    var value = this.getStyle(prop);
    return value ? transparentRe.test(value) : false;
  }, purgeAllListeners:'clearListeners', removeAllListeners:'clearListeners', setHTML:'setHtml', setTopLeft:null}}}};
}, function(Element) {
  var DOC = document, prototype = Element.prototype, supports = Ext.supports, pointerdown = 'pointerdown', pointermove = 'pointermove', pointerup = 'pointerup', pointercancel = 'pointercancel', MSPointerDown = 'MSPointerDown', MSPointerMove = 'MSPointerMove', MSPointerUp = 'MSPointerUp', MSPointerCancel = 'MSPointerCancel', mousedown = 'mousedown', mousemove = 'mousemove', mouseup = 'mouseup', mouseover = 'mouseover', mouseout = 'mouseout', mouseenter = 'mouseenter', mouseleave = 'mouseleave', touchstart = 
  'touchstart', touchmove = 'touchmove', touchend = 'touchend', touchcancel = 'touchcancel', click = 'click', dblclick = 'dblclick', tap = 'tap', doubletap = 'doubletap', eventMap = prototype.eventMap = {}, additiveEvents = prototype.additiveEvents = {}, oldId = Ext.id, eventOptions;
  Ext.id = function(obj, prefix) {
    var el = Ext.getDom(obj, true), sandboxPrefix, id;
    if (!el) {
      id = oldId(obj, prefix);
    } else {
      if (!(id = el.id)) {
        id = oldId(null, prefix || Element.prototype.identifiablePrefix);
        if (Ext.isSandboxed) {
          sandboxPrefix = Ext.sandboxPrefix || (Ext.sandboxPrefix = Ext.sandboxName.toLowerCase() + '-');
          id = sandboxPrefix + id;
        }
        el.id = id;
      }
    }
    return id;
  };
  if (supports.PointerEvents) {
    eventMap[mousedown] = pointerdown;
    eventMap[mousemove] = pointermove;
    eventMap[mouseup] = pointerup;
    eventMap[touchstart] = pointerdown;
    eventMap[touchmove] = pointermove;
    eventMap[touchend] = pointerup;
    eventMap[touchcancel] = pointercancel;
    eventMap[click] = tap;
    eventMap[dblclick] = doubletap;
    eventMap[mouseover] = 'pointerover';
    eventMap[mouseout] = 'pointerout';
    eventMap[mouseenter] = 'pointerenter';
    eventMap[mouseleave] = 'pointerleave';
  } else {
    if (supports.MSPointerEvents) {
      eventMap[pointerdown] = MSPointerDown;
      eventMap[pointermove] = MSPointerMove;
      eventMap[pointerup] = MSPointerUp;
      eventMap[pointercancel] = MSPointerCancel;
      eventMap[mousedown] = MSPointerDown;
      eventMap[mousemove] = MSPointerMove;
      eventMap[mouseup] = MSPointerUp;
      eventMap[touchstart] = MSPointerDown;
      eventMap[touchmove] = MSPointerMove;
      eventMap[touchend] = MSPointerUp;
      eventMap[touchcancel] = MSPointerCancel;
      eventMap[click] = tap;
      eventMap[dblclick] = doubletap;
      eventMap[mouseover] = 'MSPointerOver';
      eventMap[mouseout] = 'MSPointerOut';
    } else {
      if (supports.TouchEvents) {
        eventMap[pointerdown] = touchstart;
        eventMap[pointermove] = touchmove;
        eventMap[pointerup] = touchend;
        eventMap[pointercancel] = touchcancel;
        eventMap[mousedown] = touchstart;
        eventMap[mousemove] = touchmove;
        eventMap[mouseup] = touchend;
        eventMap[click] = tap;
        eventMap[dblclick] = doubletap;
        if (Ext.isWebKit && Ext.os.is.Desktop) {
          eventMap[touchstart] = mousedown;
          eventMap[touchmove] = mousemove;
          eventMap[touchend] = mouseup;
          eventMap[touchcancel] = mouseup;
          additiveEvents[mousedown] = mousedown;
          additiveEvents[mousemove] = mousemove;
          additiveEvents[mouseup] = mouseup;
          additiveEvents[touchstart] = touchstart;
          additiveEvents[touchmove] = touchmove;
          additiveEvents[touchend] = touchend;
          additiveEvents[touchcancel] = touchcancel;
          additiveEvents[pointerdown] = mousedown;
          additiveEvents[pointermove] = mousemove;
          additiveEvents[pointerup] = mouseup;
          additiveEvents[pointercancel] = mouseup;
        }
      } else {
        eventMap[pointerdown] = mousedown;
        eventMap[pointermove] = mousemove;
        eventMap[pointerup] = mouseup;
        eventMap[pointercancel] = mouseup;
        eventMap[touchstart] = mousedown;
        eventMap[touchmove] = mousemove;
        eventMap[touchend] = mouseup;
        eventMap[touchcancel] = mouseup;
      }
    }
  }
  if (Ext.isWebKit) {
    eventMap.transitionend = Ext.browser.getVendorProperyName('transitionEnd');
    eventMap.animationstart = Ext.browser.getVendorProperyName('animationStart');
    eventMap.animationend = Ext.browser.getVendorProperyName('animationEnd');
  }
  if (!Ext.supports.MouseWheel && !Ext.isOpera) {
    eventMap.mousewheel = 'DOMMouseScroll';
  }
  eventOptions = prototype.$eventOptions = Ext.Object.chain(prototype.$eventOptions);
  eventOptions.translate = eventOptions.capture = eventOptions.delegate = eventOptions.delegated = eventOptions.stopEvent = eventOptions.preventDefault = eventOptions.stopPropagation = eventOptions.element = 1;
  prototype.styleHooks.opacity = {name:'opacity', afterSet:function(dom, value, el) {
    var shadow = el.shadow;
    if (shadow) {
      shadow.setOpacity(value);
    }
  }};
  prototype.getTrueXY = prototype.getXY;
  Ext.select = Element.select;
  Ext.query = Element.query;
  Ext.apply(Ext, {get:function(element) {
    return Element.get(element);
  }, getDom:function(el) {
    if (!el || !DOC) {
      return null;
    }
    return typeof el === 'string' ? Ext.getElementById(el) : 'dom' in el ? el.dom : el;
  }, getBody:function() {
    if (!Ext._bodyEl) {
      if (!DOC.body) {
        throw new Error('[Ext.getBody] document.body does not yet exist');
      }
      Ext._bodyEl = Ext.get(DOC.body);
    }
    return Ext._bodyEl;
  }, getHead:function() {
    if (!Ext._headEl) {
      Ext._headEl = Ext.get(DOC.head || DOC.getElementsByTagName('head')[0]);
    }
    return Ext._headEl;
  }, getDoc:function() {
    if (!Ext._docEl) {
      Ext._docEl = Ext.get(DOC);
    }
    return Ext._docEl;
  }, getWin:function() {
    if (!Ext._winEl) {
      Ext._winEl = Ext.get(window);
    }
    return Ext._winEl;
  }, removeNode:function(node) {
    node = node.dom || node;
    var id = node && node.id, el = Ext.cache[id], parent;
    if (el) {
      el.destroy();
    } else {
      if (node && (node.nodeType === 3 || node.tagName.toUpperCase() !== 'BODY')) {
        parent = node.parentNode;
        if (parent) {
          parent.removeChild(node);
        }
      }
    }
  }});
  Ext.isGarbage = function(dom) {
    return dom && dom.nodeType === 1 && dom.tagName !== 'BODY' && dom.tagName !== 'HTML' && (!dom.parentNode || !dom.offsetParent && (Ext.isIE8 ? DOC.all[dom.id] : DOC.getElementById(dom.id)) !== dom && !(Ext.detachedBodyEl && Ext.detachedBodyEl.isAncestor(dom)));
  };
  if (Ext.os.is.Android || Ext.os.is.Windows && Ext.supports.Touch) {
    Ext.onReady(function() {
      var win = Ext.getWin();
      Element._windowWidth = Element._viewportWidth = window.innerWidth;
      Element._windowHeight = Element._viewportHeight = window.innerHeight;
      win.on({focusin:'_onWindowFocusChange', focusout:'_onWindowFocusChange', pointerup:'_onWindowFocusChange', capture:true, delegated:false, delay:1, scope:Element});
      win.on({resize:'_onWindowResize', priority:2000, scope:Element});
    });
  }
});
Ext.define('Ext.GlobalEvents', {extend:Ext.mixin.Observable, alternateClassName:'Ext.globalEvents', observableType:'global', singleton:true, resizeBuffer:100, idleEventMask:{mousemove:1, touchmove:1, pointermove:1, MSPointerMove:1, unload:1}, constructor:function() {
  var me = this;
  me.callParent();
  Ext.onInternalReady(function() {
    me.attachListeners();
  });
}, attachListeners:function() {
  Ext.get(window).on('resize', this.fireResize, this, {buffer:this.resizeBuffer});
  Ext.getDoc().on('mousedown', this.fireMouseDown, this);
}, fireMouseDown:function(e) {
  this.fireEvent('mousedown', e);
}, fireResize:function() {
  var me = this, Element = Ext.Element, w = Element.getViewportWidth(), h = Element.getViewportHeight();
  if (me.curHeight !== h || me.curWidth !== w) {
    me.curHeight = h;
    me.curWidth = w;
    me.fireEvent('resize', w, h);
  }
}}, function(GlobalEvents) {
  Ext.on = function() {
    return GlobalEvents.addListener.apply(GlobalEvents, arguments);
  };
  Ext.un = function() {
    return GlobalEvents.removeListener.apply(GlobalEvents, arguments);
  };
});
Ext.USE_NATIVE_JSON = false;
Ext.JSON = new function() {
  var me = this, hasNative = window.JSON && JSON.toString() === '[object JSON]', useHasOwn = !!{}.hasOwnProperty, pad = function(n) {
    return n < 10 ? '0' + n : n;
  }, doDecode = function(json) {
    return eval('(' + json + ')');
  }, doEncode = function(o, newline) {
    if (o === null || o === undefined) {
      return 'null';
    } else {
      if (Ext.isDate(o)) {
        return me.encodeDate(o);
      } else {
        if (Ext.isString(o)) {
          if (Ext.isMSDate(o)) {
            return me.encodeMSDate(o);
          } else {
            return me.encodeString(o);
          }
        } else {
          if (typeof o === 'number') {
            return isFinite(o) ? String(o) : 'null';
          } else {
            if (Ext.isBoolean(o)) {
              return String(o);
            } else {
              if (o.toJSON) {
                return o.toJSON();
              } else {
                if (Ext.isArray(o)) {
                  return encodeArray(o, newline);
                } else {
                  if (Ext.isObject(o)) {
                    return encodeObject(o, newline);
                  } else {
                    if (typeof o === 'function') {
                      return 'null';
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    return 'undefined';
  }, m = {'\b':'\\b', '\t':'\\t', '\n':'\\n', '\f':'\\f', '\r':'\\r', '"':'\\"', '\\':'\\\\', '\x0B':'\\u000b'}, charToReplace = /[\\\"\x00-\x1f\x7f-\uffff]/g, encodeString = function(s) {
    return '"' + s.replace(charToReplace, function(a) {
      var c = m[a];
      return typeof c === 'string' ? c : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    }) + '"';
  }, encodeMSDate = function(o) {
    return '"' + o + '"';
  }, encodeArrayPretty = function(o, newline) {
    var len = o.length, cnewline = newline + '   ', sep = ',' + cnewline, a = ['[', cnewline], i;
    for (i = 0; i < len; i += 1) {
      a.push(me.encodeValue(o[i], cnewline), sep);
    }
    a[a.length - 1] = newline + ']';
    return a.join('');
  }, encodeObjectPretty = function(o, newline) {
    var cnewline = newline + '   ', sep = ',' + cnewline, a = ['{', cnewline], i, val;
    for (i in o) {
      val = o[i];
      if (!useHasOwn || o.hasOwnProperty(i)) {
        if (typeof val === 'function' || val === undefined) {
          continue;
        }
        a.push(me.encodeValue(i) + ': ' + me.encodeValue(val, cnewline), sep);
      }
    }
    a[a.length - 1] = newline + '}';
    return a.join('');
  }, encodeArray = function(o, newline) {
    if (newline) {
      return encodeArrayPretty(o, newline);
    }
    var a = ['[', ''], len = o.length, i;
    for (i = 0; i < len; i += 1) {
      a.push(me.encodeValue(o[i]), ',');
    }
    a[a.length - 1] = ']';
    return a.join('');
  }, encodeObject = function(o, newline) {
    if (newline) {
      return encodeObjectPretty(o, newline);
    }
    var a = ['{', ''], i, val;
    for (i in o) {
      val = o[i];
      if (!useHasOwn || o.hasOwnProperty(i)) {
        if (typeof val === 'function' || val === undefined) {
          continue;
        }
        a.push(me.encodeValue(i), ':', me.encodeValue(val), ',');
      }
    }
    a[a.length - 1] = '}';
    return a.join('');
  };
  me.encodeString = encodeString;
  me.encodeValue = doEncode;
  me.encodeDate = function(o) {
    return '"' + o.getFullYear() + '-' + pad(o.getMonth() + 1) + '-' + pad(o.getDate()) + 'T' + pad(o.getHours()) + ':' + pad(o.getMinutes()) + ':' + pad(o.getSeconds()) + '"';
  };
  me.encode = function(o) {
    if (hasNative && Ext.USE_NATIVE_JSON) {
      return JSON.stringify(o);
    }
    return me.encodeValue(o);
  };
  me.decode = function(json, safe) {
    try {
      if (hasNative && Ext.USE_NATIVE_JSON) {
        return JSON.parse(json);
      }
      return doDecode(json);
    } catch (e$19) {
      if (safe) {
        return null;
      }
      Ext.raise({sourceClass:'Ext.JSON', sourceMethod:'decode', msg:"You're trying to decode an invalid JSON String: " + json});
    }
  };
  me.encodeMSDate = encodeMSDate;
  if (!Ext.util) {
    Ext.util = {};
  }
  Ext.util.JSON = me;
  Ext.encode = me.encode;
  Ext.decode = me.decode;
};
Ext.define('Ext.mixin.Inheritable', {extend:Ext.Mixin, mixinConfig:{id:'inheritable'}, getInherited:function(inner) {
  var me = this, inheritedState = inner && me.inheritedStateInner || me.inheritedState, ownerCt = me.getRefOwner(), isContainer = me.isContainer, parent, inheritedStateInner, getInner, ownerLayout;
  if (!inheritedState || inheritedState.invalid) {
    parent = me.getRefOwner();
    ownerLayout = me.ownerLayout;
    if (ownerCt) {
      getInner = ownerLayout ? ownerLayout === ownerCt.layout : true;
    }
    me.inheritedState = inheritedState = Ext.Object.chain(parent ? parent.getInherited(getInner) : Ext.rootInheritedState);
    if (isContainer) {
      me.inheritedStateInner = inheritedStateInner = Ext.Object.chain(inheritedState);
    }
    me.initInheritedState(inheritedState, inheritedStateInner);
    inheritedState = isContainer && inner ? me.inheritedStateInner : me.inheritedState;
  }
  return inheritedState;
}, getInheritedConfig:function(property, skipThis) {
  var state = this.inheritedState, old, ret;
  if (!state || state.invalid) {
    state = this.getInherited();
  }
  ret = state[property];
  if (skipThis && state.hasOwnProperty(property)) {
    old = ret;
    delete state[property];
    ret = state[property];
    state[property] = old;
  }
  return ret;
}, resolveListenerScope:function(defaultScope, skipThis) {
  var me = this, hasSkipThis = typeof skipThis === 'boolean', namedScope = Ext._namedScopes[defaultScope], ret;
  if (!namedScope) {
    ret = me.getInheritedConfig('defaultListenerScope', hasSkipThis ? skipThis : true) || defaultScope || me;
  } else {
    if (namedScope.isController) {
      ret = me.getInheritedConfig('controller', hasSkipThis ? skipThis : !namedScope.isSelf);
    } else {
      if (namedScope.isSelf) {
        ret = me.getInheritedConfig('defaultListenerScope', hasSkipThis && skipThis) || me;
      } else {
        if (namedScope.isThis) {
          ret = me;
        }
      }
    }
  }
  return ret || null;
}, resolveSatelliteListenerScope:function(satellite, defaultScope) {
  var me = this, namedScope = Ext._namedScopes[defaultScope], ret;
  if (!namedScope) {
    ret = me.getInheritedConfig('defaultListenerScope') || defaultScope || me;
  } else {
    if (namedScope.isController) {
      ret = me.getInheritedConfig('controller');
    } else {
      if (namedScope.isSelf) {
        ret = me.getInheritedConfig('defaultListenerScope') || satellite;
      } else {
        if (namedScope.isThis) {
          ret = satellite;
        }
      }
    }
  }
  return ret || null;
}, lookupReferenceHolder:function(skipThis) {
  return this.getInheritedConfig('referenceHolder', skipThis !== false) || null;
}, getRefOwner:function() {
  var me = this;
  return me.ownerCt || me.parent || me.$initParent || me.ownerCmp || me.floatParent;
}, invalidateInheritedState:function() {
  var inheritedState = this.inheritedState;
  if (inheritedState) {
    inheritedState.invalid = true;
    delete this.inheritedState;
  }
}, privates:{fixReference:function() {
  var me = this, refHolder;
  if (me.getReference()) {
    refHolder = me.lookupReferenceHolder();
    if (refHolder) {
      refHolder.attachReference(me);
    }
  }
}, onInheritedAdd:function(parent, instanced) {
  var me = this;
  if (me.inheritedState && instanced) {
    me.invalidateInheritedState();
  }
  if (me.getReference()) {
    Ext.ComponentManager.markReferencesDirty();
  }
}, onInheritedRemove:function(destroying) {
  var me = this, refHolder;
  if (me.getReference()) {
    refHolder = me.lookupReferenceHolder();
    if (refHolder) {
      refHolder.clearReference(me);
    }
  }
  if (me.inheritedState && !destroying) {
    me.invalidateInheritedState();
  }
}}}, function() {
  Ext.rootInheritedState = {};
});
Ext.define('Ext.mixin.Bindable', {mixinId:'bindable', config:{bind:{$value:null, lazy:true}, controller:null, defaultListenerScope:false, publishes:{$value:null, lazy:true, merge:function(newValue, oldValue) {
  return this.mergeSets(newValue, oldValue);
}}, reference:null, session:{$value:null, lazy:true}, twoWayBindable:{$value:null, lazy:true, merge:function(newValue, oldValue) {
  return this.mergeSets(newValue, oldValue);
}}, viewModel:{$value:null, lazy:true}}, defaultBindProperty:null, validRefRe:/^[a-z_][a-z0-9_]*$/i, initInheritedState:function(inheritedState) {
  var me = this, reference = me.getReference(), controller = me.getController(), viewModel = me.getConfig('viewModel', true), session = me.getConfig('session', true), defaultListenerScope = me.getDefaultListenerScope();
  if (controller) {
    inheritedState.controller = controller;
  }
  if (defaultListenerScope) {
    inheritedState.defaultListenerScope = me;
  } else {
    if (controller) {
      inheritedState.defaultListenerScope = controller;
    }
  }
  if (viewModel) {
    if (!viewModel.isViewModel) {
      viewModel = me;
    }
    inheritedState.viewModel = viewModel;
  }
  if (session) {
    if (!session.isSession) {
      session = me;
    }
    inheritedState.session = session;
  }
  if (reference) {
    me.referenceKey = (inheritedState.referencePath || '') + reference;
    me.viewModelKey = (inheritedState.viewModelPath || '') + reference;
  }
}, lookupController:function(skipThis) {
  return this.getInheritedConfig('controller', skipThis) || null;
}, lookupSession:function(skipThis) {
  var ret = skipThis ? null : this.getSession();
  if (!ret) {
    ret = this.getInheritedConfig('session', skipThis);
    if (ret && !ret.isSession) {
      ret = ret.getInherited().session = ret.getSession();
    }
  }
  return ret || null;
}, lookupViewModel:function(skipThis) {
  var ret = skipThis ? null : this.getViewModel();
  if (!ret) {
    ret = this.getInheritedConfig('viewModel', skipThis);
    if (ret && !ret.isViewModel) {
      ret = ret.getInherited().viewModel = ret.getViewModel();
    }
  }
  return ret || null;
}, publishState:function(property, value) {
  var me = this, state = me.publishedState, binds = me.getBind(), binding = binds && property && binds[property], count = 0, name, publishes, vm, path;
  if (binding && !binding.syncing && !binding.isReadOnly()) {
    if (!(binding.calls === 0 && (value == null || value === me.getInitialConfig()[property]))) {
      binding.setValue(value);
    }
  }
  if (!(publishes = me.getPublishes())) {
    return;
  }
  if (!(vm = me.lookupViewModel())) {
    return;
  }
  if (!(path = me.viewModelKey)) {
    return;
  }
  if (property && state) {
    if (!publishes[property]) {
      return;
    }
    if (!(value && value.constructor === Object) && !(value instanceof Array)) {
      if (state[property] === value) {
        return;
      }
    }
    path += '.';
    path += property;
  } else {
    state = state || (me.publishedState = {});
    for (name in publishes) {
      ++count;
      if (name === property) {
        state[name] = value;
      } else {
        state[name] = me[name];
      }
    }
    if (!count) {
      return;
    }
    value = state;
  }
  vm.set(path, value);
}, privates:{addBindableUpdater:function(property) {
  var me = this, configs = me.self.$config.configs, cfg = configs[property], updateName;
  if (cfg && !me.hasOwnProperty(updateName = cfg.names.update)) {
    me[updateName] = cfg.bindableUpdater || (cfg.root.bindableUpdater = me.makeBindableUpdater(cfg));
  }
}, applyBind:function(binds, currentBindings) {
  if (!binds) {
    return binds;
  }
  var me = this, viewModel = me.lookupViewModel(), twoWayable = me.getTwoWayBindable(), getBindTemplateScope = me._getBindTemplateScope, b, property, descriptor;
  if (!currentBindings || typeof currentBindings === 'string') {
    currentBindings = {};
  }
  if (!viewModel) {
    Ext.raise('Cannot use bind config without a viewModel');
  }
  if (Ext.isString(binds)) {
    if (!me.defaultBindProperty) {
      Ext.raise(me.$className + ' has no defaultBindProperty - ' + 'Please specify a bind object');
    }
    b = binds;
    binds = {};
    binds[me.defaultBindProperty] = b;
  }
  for (property in binds) {
    descriptor = binds[property];
    b = currentBindings[property];
    if (b && typeof b !== 'string') {
      b.destroy();
      b = null;
    }
    if (descriptor) {
      b = viewModel.bind(descriptor, me.onBindNotify, me);
      b._config = Ext.Config.get(property);
      b.getTemplateScope = getBindTemplateScope;
      if (!me[b._config.names.set]) {
        Ext.raise('Cannot bind ' + property + ' on ' + me.$className + ' - missing a ' + b._config.names.set + ' method.');
      }
    }
    currentBindings[property] = b;
    if (twoWayable && twoWayable[property] && !b.isReadOnly()) {
      me.addBindableUpdater(property);
    }
  }
  return currentBindings;
}, applyController:function(controller) {
  if (controller) {
    controller = Ext.Factory.controller(controller);
    controller.setView(this);
  }
  return controller;
}, applyPublishes:function(all) {
  if (this.lookupViewModel()) {
    for (var property in all) {
      this.addBindableUpdater(property);
    }
  }
  return all;
}, applyReference:function(reference) {
  var validIdRe = this.validRefRe || Ext.validIdRe;
  if (reference && !validIdRe.test(reference)) {
    Ext.raise('Invalid reference "' + reference + '" for ' + this.getId() + ' - not a valid identifier');
  }
  return reference;
}, applySession:function(session) {
  if (!session) {
    return null;
  }
  if (!session.isSession) {
    var parentSession = this.lookupSession(true), config = session === true ? {} : session;
    if (parentSession) {
      session = parentSession.spawn(config);
    } else {
      session = new Ext.data['Session'](config);
    }
  }
  return session;
}, applyViewModel:function(viewModel) {
  var me = this, config, session;
  if (!viewModel) {
    return null;
  }
  if (!viewModel.isViewModel) {
    config = {parent:me.lookupViewModel(true)};
    config.session = me.getSession();
    if (!session && !config.parent) {
      config.session = me.lookupSession();
    }
    if (viewModel) {
      if (viewModel.constructor === Object) {
        Ext.apply(config, viewModel);
      } else {
        if (typeof viewModel === 'string') {
          config.type = viewModel;
        }
      }
    }
    viewModel = Ext.Factory.viewModel(config);
  }
  return viewModel;
}, _getBindTemplateScope:function() {
  return this.scope.resolveListenerScope();
}, destroyBindable:function() {
  var me = this, viewModel = me.getConfig('viewModel', true), session = me.getConfig('session', true), controller = me.getController();
  if (viewModel && viewModel.isViewModel) {
    viewModel.destroy();
    me.setViewModel(null);
  }
  if (session && session.isSession) {
    if (session.getAutoDestroy()) {
      session.destroy();
    }
    me.setSession(null);
  }
  if (controller) {
    me.setController(null);
    controller.destroy();
  }
}, initBindable:function() {
  this.initBindable = Ext.emptyFn;
  this.getBind();
  this.getPublishes();
}, makeBindableUpdater:function(cfg) {
  var updateName = cfg.names.update;
  return function(newValue, oldValue) {
    var me = this, updater = me.self.prototype[updateName];
    if (updater) {
      updater.call(me, newValue, oldValue);
    }
    me.publishState(cfg.name, newValue);
  };
}, isSyncing:function(name) {
  var bindings = this.getBind(), ret = false, binding;
  if (bindings) {
    binding = bindings[name];
    if (binding) {
      ret = binding.syncing > 0;
    }
  }
  return ret;
}, onBindNotify:function(value, oldValue, binding) {
  binding.syncing = binding.syncing + 1 || 1;
  this[binding._config.names.set](value);
  --binding.syncing;
}, removeBindings:function() {
  var me = this, bindings, key, binding;
  if (!me.destroying) {
    bindings = me.getBind();
    if (bindings && typeof bindings !== 'string') {
      for (key in bindings) {
        binding = bindings[key];
        binding.destroy();
        binding._config = binding.getTemplateScope = null;
      }
    }
  }
  me.setBind(null);
}, updateSession:function(session) {
  var state = this.getInherited();
  if (session) {
    state.session = session;
  } else {
    delete state.session;
  }
}, updateViewModel:function(viewModel) {
  var state = this.getInherited(), controller = this.getController();
  if (viewModel) {
    state.viewModel = viewModel;
    viewModel.setView(this);
    if (controller) {
      controller.initViewModel(viewModel);
    }
  } else {
    delete state.viewModel;
  }
}}});
Ext.define('Ext.mixin.ComponentDelegation', {extend:Ext.Mixin, mixinConfig:{id:'componentDelegation'}, privates:{addDelegatedListener:function(eventName, fn, scope, options, order, caller, manager) {
  var me = this, delegatedEvents, event, priority;
  order = order || options.order;
  if (order) {
    priority = options && options.priority;
    if (!priority) {
      options = options ? Ext.Object.chain(options) : {};
      options.priority = me.$orderToPriority[order];
    }
  }
  if (options.target) {
    Ext.raise("Cannot add '" + eventName + "' listener to component: '" + me.id + "' - 'delegate' and 'target' event options are incompatible.");
  }
  delegatedEvents = me.$delegatedEvents || (me.$delegatedEvents = {});
  event = delegatedEvents[eventName] || (delegatedEvents[eventName] = new Ext.util.Event(me, eventName));
  if (event.addListener(fn, scope, options, caller, manager)) {
    me.$hasDelegatedListeners._incr_(eventName);
  }
}, clearDelegatedListeners:function() {
  var me = this, delegatedEvents = me.$delegatedEvents, eventName, event, listenerCount;
  if (delegatedEvents) {
    for (eventName in delegatedEvents) {
      event = delegatedEvents[eventName];
      listenerCount = event.listeners.length;
      event.clearListeners();
      me.$hasDelegatedListeners._decr_(eventName, listenerCount);
      delete delegatedEvents[eventName];
    }
  }
}, doFireDelegatedEvent:function(eventName, args) {
  var me = this, ret = true, owner, delegatedEvents, event;
  if (me.$hasDelegatedListeners[eventName]) {
    owner = me.getRefOwner();
    while (owner) {
      delegatedEvents = owner.$delegatedEvents;
      if (delegatedEvents) {
        event = delegatedEvents[eventName];
        if (event) {
          ret = event.fireDelegated(me, args);
          if (ret === false) {
            break;
          }
        }
      }
      owner = owner.getRefOwner();
    }
  }
  return ret;
}, removeDelegatedListener:function(eventName, fn, scope) {
  var me = this, delegatedEvents = me.$delegatedEvents, event;
  if (delegatedEvents) {
    event = delegatedEvents[eventName];
    if (event && event.removeListener(fn, scope)) {
      me.$hasDelegatedListeners._decr_(eventName);
      if (event.listeners.length === 0) {
        delete delegatedEvents[eventName];
      }
    }
  }
}}, onClassMixedIn:function(T) {
  function HasListeners() {
  }
  T.prototype.HasListeners = T.HasListeners = HasListeners;
  HasListeners.prototype = T.hasListeners = new Ext.mixin.ComponentDelegation.HasDelegatedListeners;
}}, function(ComponentDelegation) {
  function HasDelegatedListeners() {
  }
  ComponentDelegation.HasDelegatedListeners = HasDelegatedListeners;
  HasDelegatedListeners.prototype = ComponentDelegation.prototype.$hasDelegatedListeners = new Ext.mixin.Observable.HasListeners;
});
Ext.define('Ext.Widget', {extend:Ext.Evented, xtype:'widget', mixins:[Ext.mixin.Inheritable, Ext.mixin.Bindable, Ext.mixin.ComponentDelegation], isWidget:true, element:{reference:'element'}, observableType:'component', cachedConfig:{style:null}, config:{userCls:null}, eventedConfig:{width:null, height:null}, template:[], constructor:function(config) {
  var me = this, controller;
  me.initId(config);
  me.initElement();
  me.mixins.observable.constructor.call(me, config);
  Ext.ComponentManager.register(me);
  controller = me.getController();
  if (controller) {
    controller.init(me);
  }
}, afterCachedConfig:function() {
  var me = this, prototype = me.self.prototype, referenceList = me.referenceList, renderElement = me.renderElement, renderTemplate, element, i, ln, reference, elements;
  prototype.renderTemplate = renderTemplate = document.createDocumentFragment();
  renderTemplate.appendChild(renderElement.clone(true, true));
  elements = renderTemplate.querySelectorAll('[id]');
  for (i = 0, ln = elements.length; i < ln; i++) {
    element = elements[i];
    element.removeAttribute('id');
  }
  for (i = 0, ln = referenceList.length; i < ln; i++) {
    reference = referenceList[i];
    me[reference].dom.removeAttribute('reference');
  }
}, addCls:function(cls) {
  this.el.addCls(cls);
}, applyWidth:function(width) {
  return this.filterLengthValue(width);
}, applyHeight:function(height) {
  return this.filterLengthValue(height);
}, clearListeners:function() {
  var me = this;
  me.mixins.observable.clearListeners.call(me);
  me.mixins.componentDelegation.clearDelegatedListeners.call(me);
}, destroy:function() {
  var me = this, referenceList = me.referenceList, i, ln, reference;
  for (i = 0, ln = referenceList.length; i < ln; i++) {
    reference = referenceList[i];
    if (me.hasOwnProperty(reference)) {
      me[reference].destroy();
      me[reference] = null;
    }
  }
  me.destroyBindable();
  me.callParent();
  Ext.ComponentManager.unregister(me);
}, doFireEvent:function(eventName, args, bubbles) {
  var me = this, ret = me.mixins.observable.doFireEvent.call(me, eventName, args, bubbles);
  if (ret !== false) {
    ret = me.mixins.componentDelegation.doFireDelegatedEvent.call(me, eventName, args);
  }
  return ret;
}, getElementConfig:function() {
  var me = this, el = me.element;
  if (!('children' in el)) {
    el = Ext.apply({children:me.getTemplate()}, el);
  }
  return el;
}, getSize:function() {
  return {width:this.getWidth(), height:this.getHeight()};
}, getTemplate:function() {
  return this.template;
}, initElement:function() {
  var me = this, prototype = me.self.prototype, id = me.getId(), referenceList = me.referenceList = me.referenceList = [], cleanAttributes = true, renderTemplate, renderElement, element, referenceNodes, i, ln, referenceNode, reference;
  if (prototype.hasOwnProperty('renderTemplate')) {
    renderTemplate = me.renderTemplate.cloneNode(true);
    renderElement = renderTemplate.firstChild;
  } else {
    cleanAttributes = false;
    renderTemplate = document.createDocumentFragment();
    renderElement = Ext.Element.create(me.processElementConfig.call(prototype), true);
    renderTemplate.appendChild(renderElement);
  }
  referenceNodes = renderTemplate.querySelectorAll('[reference]');
  for (i = 0, ln = referenceNodes.length; i < ln; i++) {
    referenceNode = referenceNodes[i];
    reference = referenceNode.getAttribute('reference');
    if (cleanAttributes) {
      referenceNode.removeAttribute('reference');
    }
    if (reference === 'element') {
      if (element) {
        Ext.raise("Duplicate 'element' reference detected in '" + me.$className + "' template.");
      }
      referenceNode.id = id;
      element = me.el = me.addElementReference(reference, referenceNode);
      element.dom.setAttribute('data-componentid', id);
    } else {
      me.addElementReferenceOnDemand(reference, referenceNode);
    }
    referenceList.push(reference);
  }
  if (!element) {
    Ext.raise("No 'element' reference found in '" + me.$className + "' template.");
  }
  if (renderElement === element.dom) {
    me.renderElement = element;
  } else {
    me.addElementReferenceOnDemand('renderElement', renderElement);
  }
}, is:function(selector) {
  return Ext.ComponentQuery.is(this, selector);
}, isXType:function(xtype, shallow) {
  return shallow ? Ext.Array.indexOf(this.xtypes, xtype) !== -1 : !!this.xtypesMap[xtype];
}, removeCls:function(cls) {
  this.el.removeCls(cls);
}, toggleCls:function(cls, state) {
  this.element.toggleCls(cls, state);
}, resolveListenerScope:function(defaultScope, skipThis) {
  return this.mixins.inheritable.resolveListenerScope.call(this, defaultScope, skipThis);
}, setSize:function(width, height) {
  if (width !== undefined) {
    this.setWidth(width);
  }
  if (height !== undefined) {
    this.setHeight(height);
  }
}, applyStyle:function(style, oldStyle) {
  if (oldStyle && style === oldStyle && Ext.isObject(oldStyle)) {
    style = Ext.apply({}, style);
  }
  return style;
}, updateStyle:function(style) {
  this.element.applyStyles(style);
}, updateWidth:function(width) {
  this.element.setWidth(width);
}, updateHeight:function(height) {
  this.element.setHeight(height);
}, onFocusEnter:Ext.emptyFn, onFocusLeave:Ext.emptyFn, isAncestor:function() {
  return false;
}, privates:{addElementReferenceOnDemand:function(name, domNode) {
  if (this._elementListeners[name]) {
    this.addElementReference(name, domNode);
  } else {
    Ext.Object.defineProperty(this, name, {get:function() {
      delete this[name];
      return this.addElementReference(name, domNode);
    }, configurable:true});
  }
}, addElementReference:function(name, domNode) {
  var me = this, referenceEl = me[name] = Ext.get(domNode), listeners = me._elementListeners[name], eventName, listener;
  referenceEl.skipGarbageCollection = true;
  referenceEl.component = me;
  if (listeners) {
    listeners = Ext.clone(listeners);
    for (eventName in listeners) {
      listener = listeners[eventName];
      if (typeof listener === 'object') {
        listener.scope = me;
      }
    }
    listeners.scope = me;
    referenceEl.on(listeners);
  }
  return referenceEl;
}, detachFromBody:function() {
  Ext.getDetachedBody().appendChild(this.element);
  this.isDetached = true;
}, doAddListener:function(name, fn, scope, options, order, caller, manager) {
  var me = this, delegate;
  if (options && 'element' in options) {
    if (me.referenceList.indexOf(options.element) === -1) {
      Ext.Logger.error("Adding event listener with an invalid element reference of '" + options.element + "' for this component. Available values are: '" + me.referenceList.join("', '") + "'", me);
    }
    me[options.element].doAddListener(name, fn, scope || me, options, order);
  }
  if (options) {
    delegate = options.delegate;
    if (delegate) {
      me.mixins.componentDelegation.addDelegatedListener.call(me, name, fn, scope, options, order, caller, manager);
      return;
    }
  }
  me.callParent([name, fn, scope, options, order, caller, manager]);
}, doRemoveListener:function(eventName, fn, scope) {
  var me = this;
  me.mixins.observable.doRemoveListener.call(me, eventName, fn, scope);
  me.mixins.componentDelegation.removeDelegatedListener.call(me, eventName, fn, scope);
}, filterLengthValue:function(value) {
  if (value === 'auto' || !value && value !== 0) {
    return null;
  }
  return value;
}, getFocusEl:function() {
  return this.element;
}, initElementListeners:function(elementConfig) {
  var prototype = this, superPrototype = prototype.self.superclass, superElementListeners = superPrototype._elementListeners, reference = elementConfig.reference, children = elementConfig.children, elementListeners, listeners, superListeners, ln, i;
  if (prototype.hasOwnProperty('_elementListeners')) {
    elementListeners = prototype._elementListeners;
  } else {
    elementListeners = prototype._elementListeners = superElementListeners ? Ext.Object.chain(superElementListeners) : {};
  }
  if (reference) {
    listeners = elementConfig.listeners;
    if (listeners) {
      if (superElementListeners) {
        superListeners = superElementListeners[reference];
        if (superListeners) {
          listeners = Ext.Object.chain(superListeners);
          Ext.apply(listeners, elementConfig.listeners);
        }
      }
      elementListeners[reference] = listeners;
      elementConfig.listeners = null;
    }
  }
  if (children) {
    for (i = 0, ln = children.length; i < ln; i++) {
      prototype.initElementListeners(children[i]);
    }
  }
}, initId:function(config) {
  var me = this, defaultConfig = me.config, id = config && config.id || defaultConfig && defaultConfig.id;
  if (id) {
    me.setId(id);
    me.id = id;
  } else {
    me.getId();
  }
}, processElementConfig:function() {
  var prototype = this, superPrototype = prototype.self.superclass, elementConfig;
  if (prototype.hasOwnProperty('_elementConfig')) {
    elementConfig = prototype._elementConfig;
  } else {
    elementConfig = prototype._elementConfig = prototype.getElementConfig();
    if (superPrototype.isWidget) {
      prototype.processElementConfig.call(superPrototype);
    }
    prototype.initElementListeners(elementConfig);
  }
  return elementConfig;
}, reattachToBody:function() {
  this.isDetached = false;
}, updateUserCls:function(newCls, oldCls) {
  this.element.replaceCls(oldCls, newCls);
}}}, function(Widget) {
  var prototype = Widget.prototype;
  (prototype.$elementEventOptions = Ext.Object.chain(Ext.Element.prototype.$eventOptions)).element = 1;
  (prototype.$eventOptions = Ext.Object.chain(prototype.$eventOptions)).delegate = 1;
});
Ext.define('Ext.mixin.Traversable', {extend:Ext.Mixin, mixinConfig:{id:'traversable'}, setParent:function(parent) {
  this.parent = parent;
  return this;
}, hasParent:function() {
  return Boolean(this.parent);
}, getParent:function() {
  return this.parent;
}, getAncestors:function() {
  var ancestors = [], parent = this.getParent();
  while (parent) {
    ancestors.push(parent);
    parent = parent.getParent();
  }
  return ancestors;
}, getAncestorIds:function() {
  var ancestorIds = [], parent = this.getParent();
  while (parent) {
    ancestorIds.push(parent.getId());
    parent = parent.getParent();
  }
  return ancestorIds;
}});
Ext.define('Ext.overrides.Widget', {override:'Ext.Widget', mixins:[Ext.mixin.Traversable], config:{flex:{evented:true, $value:null}, itemId:undefined}, constructor:function(config) {
  this.callParent([config]);
  this.initBindable();
}, applyFlex:function(flex) {
  if (flex) {
    flex = Number(flex);
    if (isNaN(flex)) {
      flex = null;
    }
  } else {
    flex = null;
  }
  return flex;
}, applyItemId:function(itemId) {
  return itemId || this.getId();
}, render:function(container, insertBeforeElement) {
  this.renderTo(container, insertBeforeElement);
}, renderTo:function(container, insertBeforeElement) {
  var dom = this.renderElement.dom, containerDom = Ext.getDom(container), insertBeforeChildDom;
  if (Ext.isNumber(insertBeforeChildDom)) {
    insertBeforeElement = containerDom.childNodes[insertBeforeElement];
  }
  insertBeforeChildDom = Ext.getDom(insertBeforeElement);
  if (containerDom) {
    if (insertBeforeChildDom) {
      containerDom.insertBefore(dom, insertBeforeChildDom);
    } else {
      containerDom.appendChild(dom);
    }
    this.setRendered(Boolean(dom.offsetParent));
  }
}, destroy:function() {
  var me = this, parent = me.getParent();
  if (parent && parent.remove) {
    parent.remove(me, false);
  }
  me.callParent();
}, isInnerItem:function() {
  return true;
}, isCentered:function() {
  return false;
}, isDocked:function() {
  return Boolean(this.getDocked());
}, isFloating:function() {
  return false;
}, getDocked:function() {
  return this._docked;
}, onAdded:function(parent, instanced) {
  var me = this, inheritedState = me.inheritedState, currentParent = me.parent;
  if (currentParent && currentParent !== parent) {
    currentParent.remove(me, false);
  }
  me.parent = parent;
  me.onInheritedAdd(parent, instanced);
}, onRemoved:function(destroying) {
  if (!destroying) {
    this.removeBindings();
  }
  this.onInheritedRemove(destroying);
  this.parent = null;
}, setLayoutSizeFlags:Ext.emptyFn, setRendered:function(rendered) {
  var wasRendered = this.rendered;
  if (rendered !== wasRendered) {
    this.rendered = rendered;
    return true;
  }
  return false;
}, updateLayout:function() {
  var parent = this.getParent(), scrollable;
  if (parent) {
    scrollable = parent.getScrollable();
    if (scrollable) {
      scrollable.refresh();
    }
  }
}});
Ext.define('Ext.util.Format', function() {
  var me;
  return {singleton:true, defaultDateFormat:'m/d/Y', thousandSeparator:',', decimalSeparator:'.', currencyPrecision:2, currencySign:'$', percentSign:'%', currencyAtEnd:false, stripTagsRe:/<\/?[^>]+>/gi, stripScriptsRe:/(?:<script.*?>)((\n|\r|.)*?)(?:<\/script>)/ig, nl2brRe:/\r?\n/g, hashRe:/#+$/, allHashes:/^#+$/, formatPattern:/[\d,\.#]+/, formatCleanRe:/[^\d\.#]/g, I18NFormatCleanRe:null, formatFns:{}, constructor:function() {
    me = this;
  }, undef:function(value) {
    return value !== undefined ? value : '';
  }, defaultValue:function(value, defaultValue) {
    return value !== undefined && value !== '' ? value : defaultValue;
  }, substr:'ab'.substr(-1) != 'b' ? function(value, start, length) {
    var str = String(value);
    return start < 0 ? str.substr(Math.max(str.length + start, 0), length) : str.substr(start, length);
  } : function(value, start, length) {
    return String(value).substr(start, length);
  }, lowercase:function(value) {
    return String(value).toLowerCase();
  }, uppercase:function(value) {
    return String(value).toUpperCase();
  }, usMoney:function(v) {
    return me.currency(v, '$', 2);
  }, currency:function(v, currencySign, decimals, end) {
    var negativeSign = '', format = ',0', i = 0;
    v = v - 0;
    if (v < 0) {
      v = -v;
      negativeSign = '-';
    }
    decimals = Ext.isDefined(decimals) ? decimals : me.currencyPrecision;
    format += decimals > 0 ? '.' : '';
    for (; i < decimals; i++) {
      format += '0';
    }
    v = me.number(v, format);
    if ((end || me.currencyAtEnd) === true) {
      return Ext.String.format('{0}{1}{2}', negativeSign, v, currencySign || me.currencySign);
    } else {
      return Ext.String.format('{0}{1}{2}', negativeSign, currencySign || me.currencySign, v);
    }
  }, date:function(v, format) {
    if (!v) {
      return '';
    }
    if (!Ext.isDate(v)) {
      v = new Date(Date.parse(v));
    }
    return Ext.Date.dateFormat(v, format || Ext.Date.defaultFormat);
  }, dateRenderer:function(format) {
    return function(v) {
      return me.date(v, format);
    };
  }, hex:function(value, digits) {
    var s = parseInt(value || 0, 10).toString(16);
    if (digits) {
      if (digits < 0) {
        digits = -digits;
        if (s.length > digits) {
          s = s.substring(s.length - digits);
        }
      }
      while (s.length < digits) {
        s = '0' + s;
      }
    }
    return s;
  }, or:function(value, orValue) {
    return value || orValue;
  }, pick:function(value, firstValue, secondValue) {
    if (Ext.isNumber(value)) {
      var ret = arguments[value + 1];
      if (ret) {
        return ret;
      }
    }
    return value ? secondValue : firstValue;
  }, stripTags:function(v) {
    return !v ? v : String(v).replace(me.stripTagsRe, '');
  }, stripScripts:function(v) {
    return !v ? v : String(v).replace(me.stripScriptsRe, '');
  }, fileSize:function() {
    var byteLimit = 1024, kbLimit = 1048576, mbLimit = 1073741824;
    return function(size) {
      var out;
      if (size < byteLimit) {
        if (size === 1) {
          out = '1 byte';
        } else {
          out = size + ' bytes';
        }
      } else {
        if (size < kbLimit) {
          out = Math.round(size * 10 / byteLimit) / 10 + ' KB';
        } else {
          if (size < mbLimit) {
            out = Math.round(size * 10 / kbLimit) / 10 + ' MB';
          } else {
            out = Math.round(size * 10 / mbLimit) / 10 + ' GB';
          }
        }
      }
      return out;
    };
  }(), math:function() {
    var fns = {};
    return function(v, a) {
      if (!fns[a]) {
        fns[a] = Ext.functionFactory('v', 'return v ' + a + ';');
      }
      return fns[a](v);
    };
  }(), round:function(value, precision) {
    var result = Number(value);
    if (typeof precision === 'number') {
      precision = Math.pow(10, precision);
      result = Math.round(value * precision) / precision;
    } else {
      if (precision === undefined) {
        result = Math.round(result);
      }
    }
    return result;
  }, number:function(v, formatString) {
    if (!formatString) {
      return v;
    }
    if (isNaN(v)) {
      return '';
    }
    var formatFn = me.formatFns[formatString];
    if (!formatFn) {
      var originalFormatString = formatString, comma = me.thousandSeparator, decimalSeparator = me.decimalSeparator, precision = 0, trimPart = '', hasComma, splitFormat, extraChars, trimTrailingZeroes, code, len;
      if (formatString.substr(formatString.length - 2) === '/i') {
        if (!me.I18NFormatCleanRe || me.lastDecimalSeparator !== decimalSeparator) {
          me.I18NFormatCleanRe = new RegExp('[^\\d\\' + decimalSeparator + '#]', 'g');
          me.lastDecimalSeparator = decimalSeparator;
        }
        formatString = formatString.substr(0, formatString.length - 2);
        hasComma = formatString.indexOf(comma) !== -1;
        splitFormat = formatString.replace(me.I18NFormatCleanRe, '').split(decimalSeparator);
      } else {
        hasComma = formatString.indexOf(',') !== -1;
        splitFormat = formatString.replace(me.formatCleanRe, '').split('.');
      }
      extraChars = formatString.replace(me.formatPattern, '');
      if (splitFormat.length > 2) {
        Ext.raise({sourceClass:'Ext.util.Format', sourceMethod:'number', value:v, formatString:formatString, msg:'Invalid number format, should have no more than 1 decimal'});
      } else {
        if (splitFormat.length === 2) {
          precision = splitFormat[1].length;
          trimTrailingZeroes = splitFormat[1].match(me.hashRe);
          if (trimTrailingZeroes) {
            len = trimTrailingZeroes[0].length;
            trimPart = 'trailingZeroes\x3dnew RegExp(Ext.String.escapeRegex(utilFormat.decimalSeparator) + "*0{0,' + len + '}$")';
          }
        }
      }
      code = ['var utilFormat\x3dExt.util.Format,extNumber\x3dExt.Number,neg,absVal,fnum,parts' + (hasComma ? ',thousandSeparator,thousands\x3d[],j,n,i' : '') + (extraChars ? ',formatString\x3d"' + formatString + '",formatPattern\x3d/[\\d,\\.#]+/' : '') + ',trailingZeroes;' + 'return function(v){' + 'if(typeof v!\x3d\x3d"number"\x26\x26isNaN(v\x3dextNumber.from(v,NaN)))return"";' + 'neg\x3dv\x3c0;', 'absVal\x3dMath.abs(v);', 'fnum\x3dExt.Number.toFixed(absVal, ' + precision + ');', trimPart, ';'];
      if (hasComma) {
        if (precision) {
          code[code.length] = 'parts\x3dfnum.split(".");';
          code[code.length] = 'fnum\x3dparts[0];';
        }
        code[code.length] = 'if(absVal\x3e\x3d1000) {';
        code[code.length] = 'thousandSeparator\x3dutilFormat.thousandSeparator;' + 'thousands.length\x3d0;' + 'j\x3dfnum.length;' + 'n\x3dfnum.length%3||3;' + 'for(i\x3d0;i\x3cj;i+\x3dn){' + 'if(i!\x3d\x3d0){' + 'n\x3d3;' + '}' + 'thousands[thousands.length]\x3dfnum.substr(i,n);' + '}' + 'fnum\x3dthousands.join(thousandSeparator);' + '}';
        if (precision) {
          code[code.length] = 'fnum +\x3d utilFormat.decimalSeparator+parts[1];';
        }
      } else {
        if (precision) {
          code[code.length] = 'if(utilFormat.decimalSeparator!\x3d\x3d"."){' + 'parts\x3dfnum.split(".");' + 'fnum\x3dparts[0]+utilFormat.decimalSeparator+parts[1];' + '}';
        }
      }
      code[code.length] = 'if(neg\x26\x26fnum!\x3d\x3d"' + (precision ? '0.' + Ext.String.repeat('0', precision) : '0') + '") { fnum\x3d"-"+fnum; }';
      if (trimTrailingZeroes) {
        code[code.length] = 'fnum\x3dfnum.replace(trailingZeroes,"");';
      }
      code[code.length] = 'return ';
      if (extraChars) {
        code[code.length] = 'formatString.replace(formatPattern, fnum);';
      } else {
        code[code.length] = 'fnum;';
      }
      code[code.length] = '};';
      formatFn = me.formatFns[originalFormatString] = Ext.functionFactory('Ext', code.join(''))(Ext);
    }
    return formatFn(v);
  }, numberRenderer:function(format) {
    return function(v) {
      return me.number(v, format);
    };
  }, percent:function(value, formatString) {
    return me.number(value * 100, formatString || '0') + me.percentSign;
  }, attributes:function(attributes) {
    if (typeof attributes === 'object') {
      var result = [], name;
      for (name in attributes) {
        if (attributes.hasOwnProperty(name)) {
          result.push(name, '\x3d"', name === 'style' ? Ext.DomHelper.generateStyles(attributes[name], null, true) : Ext.htmlEncode(attributes[name]), '" ');
        }
      }
      attributes = result.join('');
    }
    return attributes || '';
  }, plural:function(v, s, p) {
    return v + ' ' + (v === 1 ? s : p ? p : s + 's');
  }, nl2br:function(v) {
    return Ext.isEmpty(v) ? '' : v.replace(me.nl2brRe, '\x3cbr/\x3e');
  }, capitalize:Ext.String.capitalize, uncapitalize:Ext.String.uncapitalize, ellipsis:Ext.String.ellipsis, escape:Ext.String.escape, escapeRegex:Ext.String.escapeRegex, htmlDecode:Ext.String.htmlDecode, htmlEncode:Ext.String.htmlEncode, leftPad:Ext.String.leftPad, toggle:Ext.String.toggle, trim:Ext.String.trim, parseBox:function(box) {
    box = box || 0;
    if (typeof box === 'number') {
      return {top:box, right:box, bottom:box, left:box};
    }
    var parts = box.split(' '), ln = parts.length;
    if (ln === 1) {
      parts[1] = parts[2] = parts[3] = parts[0];
    } else {
      if (ln === 2) {
        parts[2] = parts[0];
        parts[3] = parts[1];
      } else {
        if (ln === 3) {
          parts[3] = parts[1];
        }
      }
    }
    return {top:parseInt(parts[0], 10) || 0, right:parseInt(parts[1], 10) || 0, bottom:parseInt(parts[2], 10) || 0, left:parseInt(parts[3], 10) || 0};
  }};
});
Ext.define('Ext.Template', {inheritableStatics:{from:function(el, config) {
  el = Ext.getDom(el);
  return new this(el.value || el.innerHTML, config || '');
}}, useEval:Ext.isGecko, constructor:function(html) {
  var me = this, args = arguments, buffer = [], i, length = args.length, value;
  me.initialConfig = {};
  if (length === 1 && Ext.isArray(html)) {
    args = html;
    length = args.length;
  }
  if (length > 1) {
    for (i = 0; i < length; i++) {
      value = args[i];
      if (typeof value === 'object') {
        Ext.apply(me.initialConfig, value);
        Ext.apply(me, value);
      } else {
        buffer.push(value);
      }
    }
  } else {
    buffer.push(html);
  }
  me.html = buffer.join('');
}, isTemplate:true, disableFormats:false, tokenRe:/\{(?:(?:(\d+)|([a-z_][\w\-]*))(?::([a-z_\.]+)(?:\(([^\)]*?)?\))?)?)\}/gi, apply:function(values) {
  var me = this;
  if (me.compiled) {
    if (!me.fn) {
      me.compile();
    }
    return me.fn(values).join('');
  }
  return me.evaluate(values);
}, evaluate:function(values) {
  var me = this, useFormat = !me.disableFormats, fm = Ext.util.Format, tpl = me;
  function fn(match, index, name, formatFn, args) {
    if (name == null || name === '') {
      name = index;
    }
    if (formatFn && useFormat) {
      if (args) {
        args = [values[name]].concat(Ext.functionFactory('return [' + args + '];')());
      } else {
        args = [values[name]];
      }
      if (formatFn.substr(0, 5) === 'this.') {
        return tpl[formatFn.substr(5)].apply(tpl, args);
      } else {
        if (fm[formatFn]) {
          return fm[formatFn].apply(fm, args);
        } else {
          return match;
        }
      }
    } else {
      return values[name] !== undefined ? values[name] : '';
    }
  }
  return me.html.replace(me.tokenRe, fn);
}, applyOut:function(values, out) {
  var me = this;
  if (me.compiled) {
    if (!me.fn) {
      me.compile();
    }
    out.push.apply(out, me.fn(values));
  } else {
    out.push(me.apply(values));
  }
  return out;
}, applyTemplate:function() {
  return this.apply.apply(this, arguments);
}, set:function(html, compile) {
  var me = this;
  me.html = html;
  me.compiled = !!compile;
  me.fn = null;
  return me;
}, compileARe:/\\/g, compileBRe:/(\r\n|\n)/g, compileCRe:/'/g, compile:function() {
  var me = this, code;
  code = me.html.replace(me.compileARe, '\\\\').replace(me.compileBRe, '\\n').replace(me.compileCRe, "\\'").replace(me.tokenRe, me.regexReplaceFn.bind(me));
  code = (this.disableFormats !== true ? 'var fm\x3dExt.util.Format;' : '') + (me.useEval ? '$\x3d' : 'return') + " function(v){return ['" + code + "'];};";
  me.fn = me.useEval ? me.evalCompiled(code) : (new Function('Ext', code))(Ext);
  me.compiled = true;
  return me;
}, evalCompiled:function($) {
  eval($);
  return $;
}, regexReplaceFn:function(match, index, name, formatFn, args) {
  if (index == null || index === '') {
    index = '"' + name + '"';
  } else {
    if (this.stringFormat) {
      index = parseInt(index) + 1;
    }
  }
  if (formatFn && this.disableFormats !== true) {
    args = args ? ',' + args : '';
    if (formatFn.substr(0, 5) === 'this.') {
      formatFn = formatFn + '(';
    } else {
      if (Ext.util.Format[formatFn]) {
        formatFn = 'fm.' + formatFn + '(';
      } else {
        return match;
      }
    }
    return "'," + formatFn + 'v[' + index + ']' + args + "),'";
  } else {
    return "',v[" + index + "] \x3d\x3d undefined ? '' : v[" + index + "],'";
  }
}, insertFirst:function(el, values, returnElement) {
  return this.doInsert('afterBegin', el, values, returnElement);
}, insertBefore:function(el, values, returnElement) {
  return this.doInsert('beforeBegin', el, values, returnElement);
}, insertAfter:function(el, values, returnElement) {
  return this.doInsert('afterEnd', el, values, returnElement);
}, append:function(el, values, returnElement) {
  return this.doInsert('beforeEnd', el, values, returnElement);
}, doInsert:function(where, el, values, returnElement) {
  var newNode = Ext.DomHelper.insertHtml(where, Ext.getDom(el), this.apply(values));
  return returnElement ? Ext.get(newNode) : newNode;
}, overwrite:function(el, values, returnElement) {
  var newNode = Ext.DomHelper.overwrite(Ext.getDom(el), this.apply(values));
  return returnElement ? Ext.get(newNode) : newNode;
}}, function(Template) {
  var formatRe = /\{\d+\}/, generateFormatFn = function(format) {
    if (formatRe.test(format)) {
      format = new Template(format, formatTplConfig);
      return function() {
        return format.apply(arguments);
      };
    } else {
      return function() {
        return format;
      };
    }
  }, formatTplConfig = {useFormat:false, compiled:true, stringFormat:true}, formatFns = {};
  Ext.String.format = Ext.util.Format.format = function(format) {
    var formatFn = formatFns[format] || (formatFns[format] = generateFormatFn(format));
    return formatFn.apply(this, arguments);
  };
  Ext.String.formatEncode = function() {
    return Ext.String.htmlEncode(Ext.String.format.apply(this, arguments));
  };
});
Ext.define('Ext.util.XTemplateParser', {constructor:function(config) {
  Ext.apply(this, config);
}, doTpl:Ext.emptyFn, parse:function(str) {
  var me = this, len = str.length, aliases = {elseif:'elif'}, topRe = me.topRe, actionsRe = me.actionsRe, index, stack, s, m, t, prev, frame, subMatch, begin, end, actions, prop, expectTplNext;
  me.level = 0;
  me.stack = stack = [];
  for (index = 0; index < len; index = end) {
    topRe.lastIndex = index;
    m = topRe.exec(str);
    if (!m) {
      me.doText(str.substring(index, len));
      break;
    }
    begin = m.index;
    end = topRe.lastIndex;
    if (index < begin) {
      s = str.substring(index, begin);
      if (!(expectTplNext && Ext.String.trim(s) === '')) {
        me.doText(s);
      }
    }
    expectTplNext = false;
    if (m[1]) {
      end = str.indexOf('%}', begin + 2);
      me.doEval(str.substring(begin + 2, end));
      end += 2;
    } else {
      if (m[2]) {
        end = str.indexOf(']}', begin + 2);
        me.doExpr(str.substring(begin + 2, end));
        end += 2;
      } else {
        if (m[3]) {
          me.doTag(m[3]);
        } else {
          if (m[4]) {
            actions = null;
            while ((subMatch = actionsRe.exec(m[4])) !== null) {
              s = subMatch[2] || subMatch[3];
              if (s) {
                s = Ext.String.htmlDecode(s);
                t = subMatch[1];
                t = aliases[t] || t;
                actions = actions || {};
                prev = actions[t];
                if (typeof prev == 'string') {
                  actions[t] = [prev, s];
                } else {
                  if (prev) {
                    actions[t].push(s);
                  } else {
                    actions[t] = s;
                  }
                }
              }
            }
            if (!actions) {
              if (me.elseRe.test(m[4])) {
                me.doElse();
              } else {
                if (me.defaultRe.test(m[4])) {
                  me.doDefault();
                } else {
                  me.doTpl();
                  stack.push({type:'tpl'});
                }
              }
            } else {
              if (actions['if']) {
                me.doIf(actions['if'], actions);
                stack.push({type:'if'});
              } else {
                if (actions['switch']) {
                  me.doSwitch(actions['switch'], actions);
                  stack.push({type:'switch'});
                  expectTplNext = true;
                } else {
                  if (actions['case']) {
                    me.doCase(actions['case'], actions);
                  } else {
                    if (actions['elif']) {
                      me.doElseIf(actions['elif'], actions);
                    } else {
                      if (actions['for']) {
                        ++me.level;
                        if (prop = me.propRe.exec(m[4])) {
                          actions.propName = prop[1] || prop[2];
                        }
                        me.doFor(actions['for'], actions);
                        stack.push({type:'for', actions:actions});
                      } else {
                        if (actions['foreach']) {
                          ++me.level;
                          if (prop = me.propRe.exec(m[4])) {
                            actions.propName = prop[1] || prop[2];
                          }
                          me.doForEach(actions['foreach'], actions);
                          stack.push({type:'foreach', actions:actions});
                        } else {
                          if (actions.exec) {
                            me.doExec(actions.exec, actions);
                            stack.push({type:'exec', actions:actions});
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          } else {
            if (m[0].length === 5) {
              stack.push({type:'tpl'});
            } else {
              frame = stack.pop();
              me.doEnd(frame.type, frame.actions);
              if (frame.type == 'for' || frame.type == 'foreach') {
                --me.level;
              }
            }
          }
        }
      }
    }
  }
}, topRe:/(?:(\{\%)|(\{\[)|\{([^{}]+)\})|(?:<tpl([^>]*)\>)|(?:<\/tpl>)/g, actionsRe:/\s*(elif|elseif|if|for|foreach|exec|switch|case|eval|between)\s*\=\s*(?:(?:"([^"]*)")|(?:'([^']*)'))\s*/g, propRe:/prop=(?:(?:"([^"]*)")|(?:'([^']*)'))/, defaultRe:/^\s*default\s*$/, elseRe:/^\s*else\s*$/});
Ext.define('Ext.util.XTemplateCompiler', {extend:Ext.util.XTemplateParser, useEval:Ext.isGecko, useIndex:Ext.isIE8m, useFormat:true, propNameRe:/^[\w\d\$]*$/, compile:function(tpl) {
  var me = this, code = me.generate(tpl);
  return me.useEval ? me.evalTpl(code) : (new Function('Ext', code))(Ext);
}, generate:function(tpl) {
  var me = this, definitions = 'var fm\x3dExt.util.Format,ts\x3dObject.prototype.toString;', code;
  me.maxLevel = 0;
  me.body = ['var c0\x3dvalues, a0\x3d' + me.createArrayTest(0) + ', p0\x3dparent, n0\x3dxcount, i0\x3dxindex, k0, v;\n'];
  if (me.definitions) {
    if (typeof me.definitions === 'string') {
      me.definitions = [me.definitions, definitions];
    } else {
      me.definitions.push(definitions);
    }
  } else {
    me.definitions = [definitions];
  }
  me.switches = [];
  me.parse(tpl);
  me.definitions.push((me.useEval ? '$\x3d' : 'return') + ' function (' + me.fnArgs + ') {', me.body.join(''), '}');
  code = me.definitions.join('\n');
  me.definitions.length = me.body.length = me.switches.length = 0;
  delete me.definitions;
  delete me.body;
  delete me.switches;
  return code;
}, doText:function(text) {
  var me = this, out = me.body;
  text = text.replace(me.aposRe, "\\'").replace(me.newLineRe, '\\n');
  if (me.useIndex) {
    out.push("out[out.length]\x3d'", text, "'\n");
  } else {
    out.push("out.push('", text, "')\n");
  }
}, doExpr:function(expr) {
  var out = this.body;
  out.push('if ((v\x3d' + expr + ') !\x3d null) out');
  if (this.useIndex) {
    out.push("[out.length]\x3dv+''\n");
  } else {
    out.push(".push(v+'')\n");
  }
}, doTag:function(tag) {
  var expr = this.parseTag(tag);
  if (expr) {
    this.doExpr(expr);
  } else {
    this.doText('{' + tag + '}');
  }
}, doElse:function() {
  this.body.push('} else {\n');
}, doEval:function(text) {
  this.body.push(text, '\n');
}, doIf:function(action, actions) {
  var me = this;
  if (action === '.') {
    me.body.push('if (values) {\n');
  } else {
    if (me.propNameRe.test(action)) {
      me.body.push('if (', me.parseTag(action), ') {\n');
    } else {
      me.body.push('if (', me.addFn(action), me.callFn, ') {\n');
    }
  }
  if (actions.exec) {
    me.doExec(actions.exec);
  }
}, doElseIf:function(action, actions) {
  var me = this;
  if (action === '.') {
    me.body.push('else if (values) {\n');
  } else {
    if (me.propNameRe.test(action)) {
      me.body.push('} else if (', me.parseTag(action), ') {\n');
    } else {
      me.body.push('} else if (', me.addFn(action), me.callFn, ') {\n');
    }
  }
  if (actions.exec) {
    me.doExec(actions.exec);
  }
}, doSwitch:function(action) {
  var me = this, key;
  if (action === '.' || action === '#') {
    key = action === '.' ? 'values' : 'xindex';
    me.body.push('switch (', key, ') {\n');
  } else {
    if (me.propNameRe.test(action)) {
      me.body.push('switch (', me.parseTag(action), ') {\n');
    } else {
      me.body.push('switch (', me.addFn(action), me.callFn, ') {\n');
    }
  }
  me.switches.push(0);
}, doCase:function(action) {
  var me = this, cases = Ext.isArray(action) ? action : [action], n = me.switches.length - 1, match, i;
  if (me.switches[n]) {
    me.body.push('break;\n');
  } else {
    me.switches[n]++;
  }
  for (i = 0, n = cases.length; i < n; ++i) {
    match = me.intRe.exec(cases[i]);
    cases[i] = match ? match[1] : "'" + cases[i].replace(me.aposRe, "\\'") + "'";
  }
  me.body.push('case ', cases.join(': case '), ':\n');
}, doDefault:function() {
  var me = this, n = me.switches.length - 1;
  if (me.switches[n]) {
    me.body.push('break;\n');
  } else {
    me.switches[n]++;
  }
  me.body.push('default:\n');
}, doEnd:function(type, actions) {
  var me = this, L = me.level - 1;
  if (type == 'for' || type == 'foreach') {
    if (actions.exec) {
      me.doExec(actions.exec);
    }
    me.body.push('}\n');
    me.body.push('parent\x3dp', L, ';values\x3dr', L + 1, ';xcount\x3dn' + L + ';xindex\x3di', L, '+1;xkey\x3dk', L, ';\n');
  } else {
    if (type == 'if' || type == 'switch') {
      me.body.push('}\n');
    }
  }
}, doFor:function(action, actions) {
  var me = this, s, L = me.level, up = L - 1, parentAssignment;
  if (action === '.') {
    s = 'values';
  } else {
    if (me.propNameRe.test(action)) {
      s = me.parseTag(action);
    } else {
      s = me.addFn(action) + me.callFn;
    }
  }
  if (me.maxLevel < L) {
    me.maxLevel = L;
    me.body.push('var ');
  }
  if (action == '.') {
    parentAssignment = 'c' + L;
  } else {
    parentAssignment = 'a' + up + '?c' + up + '[i' + up + ']:c' + up;
  }
  me.body.push('i', L, '\x3d0,n', L, '\x3d0,c', L, '\x3d', s, ',a', L, '\x3d', me.createArrayTest(L), ',r', L, '\x3dvalues,p', L, ',k', L, ';\n', 'p', L, '\x3dparent\x3d', parentAssignment, '\n', 'if (c', L, '){if(a', L, '){n', L, '\x3dc', L, '.length;}else if (c', L, '.isMixedCollection){c', L, '\x3dc', L, '.items;n', L, '\x3dc', L, '.length;}else if(c', L, '.isStore){c', L, '\x3dc', L, '.data.items;n', L, '\x3dc', L, '.length;}else{c', L, '\x3d[c', L, '];n', L, '\x3d1;}}\n', 'for (xcount\x3dn', 
  L, ';i', L, '\x3cn' + L + ';++i', L, '){\n', 'values\x3dc', L, '[i', L, ']');
  if (actions.propName) {
    me.body.push('.', actions.propName);
  }
  me.body.push('\n', 'xindex\x3di', L, '+1\n');
  if (actions.between) {
    me.body.push('if(xindex\x3e1){ out.push("', actions.between, '"); } \n');
  }
}, doForEach:function(action, actions) {
  var me = this, s, L = me.level, up = L - 1, parentAssignment;
  if (action === '.') {
    s = 'values';
  } else {
    if (me.propNameRe.test(action)) {
      s = me.parseTag(action);
    } else {
      s = me.addFn(action) + me.callFn;
    }
  }
  if (me.maxLevel < L) {
    me.maxLevel = L;
    me.body.push('var ');
  }
  if (action == '.') {
    parentAssignment = 'c' + L;
  } else {
    parentAssignment = 'a' + up + '?c' + up + '[i' + up + ']:c' + up;
  }
  me.body.push('i', L, '\x3d-1,n', L, '\x3d0,c', L, '\x3d', s, ',a', L, '\x3d', me.createArrayTest(L), ',r', L, '\x3dvalues,p', L, ',k', L, ';\n', 'p', L, '\x3dparent\x3d', parentAssignment, '\n', 'for(k', L, ' in c', L, '){\n', 'xindex\x3d++i', L, '+1;\n', 'xkey\x3dk', L, ';\n', 'values\x3dc', L, '[k', L, '];');
  if (actions.propName) {
    me.body.push('.', actions.propName);
  }
  if (actions.between) {
    me.body.push('if(xindex\x3e1){ out.push("', actions.between, '"); } \n');
  }
}, createArrayTest:'isArray' in Array ? function(L) {
  return 'Array.isArray(c' + L + ')';
} : function(L) {
  return 'ts.call(c' + L + ')\x3d\x3d\x3d"[object Array]"';
}, doExec:function(action, actions) {
  var me = this, name = 'f' + me.definitions.length, guards = me.guards[me.strict ? 0 : 1];
  me.definitions.push('function ' + name + '(' + me.fnArgs + ') {', guards.doTry, ' var $v \x3d values; with($v) {', '  ' + action, ' }', guards.doCatch, '}');
  me.body.push(name + me.callFn + '\n');
}, guards:[{doTry:'', doCatch:''}, {doTry:'try { ', doCatch:' } catch(e) {\n' + 'Ext.log.warn("XTemplate evaluation exception: " + e.message);\n' + '}'}], addFn:function(body) {
  var me = this, name = 'f' + me.definitions.length, guards = me.guards[me.strict ? 0 : 1];
  if (body === '.') {
    me.definitions.push('function ' + name + '(' + me.fnArgs + ') {', ' return values', '}');
  } else {
    if (body === '..') {
      me.definitions.push('function ' + name + '(' + me.fnArgs + ') {', ' return parent', '}');
    } else {
      me.definitions.push('function ' + name + '(' + me.fnArgs + ') {', guards.doTry, ' var $v \x3d values; with($v) {', '  return(' + body + ')', ' }', guards.doCatch, '}');
    }
  }
  return name;
}, parseTag:function(tag) {
  var me = this, m = me.tagRe.exec(tag), name, format, args, math, v;
  if (!m) {
    return null;
  }
  name = m[1];
  format = m[2];
  args = m[3];
  math = m[4];
  if (name == '.') {
    if (!me.validTypes) {
      me.definitions.push('var validTypes\x3d{string:1,number:1,boolean:1};');
      me.validTypes = true;
    }
    v = 'validTypes[typeof values] || ts.call(values) \x3d\x3d\x3d "[object Date]" ? values : ""';
  } else {
    if (name == '#') {
      v = 'xindex';
    } else {
      if (name == '$') {
        v = 'xkey';
      } else {
        if (name.substr(0, 7) == 'parent.') {
          v = name;
        } else {
          if (isNaN(name) && name.indexOf('-') == -1 && name.indexOf('.') != -1) {
            v = 'values.' + name;
          } else {
            v = "values['" + name + "']";
          }
        }
      }
    }
  }
  if (math) {
    v = '(' + v + math + ')';
  }
  if (format && me.useFormat) {
    args = args ? ',' + args : '';
    if (format.substr(0, 5) != 'this.') {
      format = 'fm.' + format + '(';
    } else {
      format += '(';
    }
  } else {
    return v;
  }
  return format + v + args + ')';
}, evalTpl:function($) {
  eval($);
  return $;
}, newLineRe:/\r\n|\r|\n/g, aposRe:/[']/g, intRe:/^\s*(\d+)\s*$/, tagRe:/^([\w-\.\#\$]+)(?:\:([\w\.]*)(?:\((.*?)?\))?)?(\s?[\+\-\*\/]\s?[\d\.\+\-\*\/\(\)]+)?$/}, function() {
  var proto = this.prototype;
  proto.fnArgs = 'out,values,parent,xindex,xcount,xkey';
  proto.callFn = '.call(this,' + proto.fnArgs + ')';
});
Ext.define('Ext.XTemplate', {extend:Ext.Template, isXTemplate:true, emptyObj:{}, fn:null, strict:false, apply:function(values, parent, xindex, xcount) {
  return this.applyOut(values, [], parent, xindex, xcount).join('');
}, applyOut:function(values, out, parent, xindex, xcount) {
  var me = this, compiler;
  if (!me.fn) {
    compiler = new Ext.util.XTemplateCompiler({useFormat:me.disableFormats !== true, definitions:me.definitions, strict:me.strict});
    me.fn = compiler.compile(me.html);
  }
  xindex = xindex || 1;
  xcount = xcount || 1;
  if (me.strict) {
    me.fn(out, values, parent || me.emptyObj, xindex, xcount);
  } else {
    try {
      me.fn(out, values, parent || me.emptyObj, xindex, xcount);
    } catch (e$20) {
      Ext.log.warn('XTemplate evaluation exception: ' + e$20.message);
    }
  }
  return out;
}, compile:function() {
  return this;
}, statics:{getTpl:function(instance, name) {
  var tpl = instance[name], owner;
  if (tpl && !tpl.isTemplate) {
    tpl = Ext.ClassManager.dynInstantiate('Ext.XTemplate', tpl);
    if (instance.hasOwnProperty(name)) {
      owner = instance;
    } else {
      for (owner = instance.self.prototype; owner && !owner.hasOwnProperty(name); owner = owner.superclass) {
      }
    }
    owner[name] = tpl;
    tpl.owner = owner;
  }
  return tpl || null;
}}});
Ext.define('Ext.app.EventDomain', {statics:{instances:{}}, isEventDomain:true, isInstance:false, constructor:function() {
  var me = this;
  if (!me.isInstance) {
    Ext.app.EventDomain.instances[me.type] = me;
  }
  me.bus = {};
  me.monitoredClasses = [];
}, dispatch:function(target, ev, args) {
  ev = Ext.canonicalEventName(ev);
  var me = this, bus = me.bus, selectors = bus[ev], selector, controllers, id, info, events, len, i, event;
  if (!selectors) {
    return true;
  }
  for (selector in selectors) {
    if (selectors.hasOwnProperty(selector) && me.match(target, selector, me.controller)) {
      controllers = selectors[selector];
      for (id in controllers) {
        if (controllers.hasOwnProperty(id)) {
          info = controllers[id];
          if (info.controller.isActive()) {
            events = info.list;
            len = events.length;
            for (i = 0; i < len; i++) {
              event = events[i];
              if (event.fire.apply(event, args) === false) {
                return false;
              }
            }
          }
        }
      }
    }
  }
  return true;
}, listen:function(selectors, controller) {
  var me = this, bus = me.bus, idProperty = me.idProperty, monitoredClasses = me.monitoredClasses, monitoredClassesCount = monitoredClasses.length, controllerId = controller.getId(), isComponentDomain = me.type === 'component', refMap = isComponentDomain ? controller.getRefMap() : null, i, tree, info, selector, options, listener, scope, event, listeners, ev, classHasListeners;
  for (selector in selectors) {
    listeners = selectors[selector];
    if (isComponentDomain) {
      selector = refMap[selector] || selector;
    }
    if (listeners) {
      if (idProperty) {
        if (!/^[*#]/.test(selector)) {
          Ext.raise('Selectors containing id should begin with #');
        }
        selector = selector === '*' ? selector : selector.substring(1);
      }
      for (ev in listeners) {
        options = null;
        listener = listeners[ev];
        scope = controller;
        ev = Ext.canonicalEventName(ev);
        event = new Ext.util.Event(controller, ev);
        if (Ext.isObject(listener)) {
          options = listener;
          listener = options.fn;
          scope = options.scope || controller;
          delete options.fn;
          delete options.scope;
        }
        if ((!options || !options.scope) && typeof listener === 'string') {
          if (!scope[listener]) {
            Ext.raise('Cannot resolve "' + listener + '" on controller.');
          }
          scope = null;
        } else {
          if (typeof listener === 'string') {
            listener = scope[listener];
          }
        }
        event.addListener(listener, scope, options);
        for (i = 0; i < monitoredClassesCount; ++i) {
          classHasListeners = monitoredClasses[i].hasListeners;
          if (classHasListeners) {
            classHasListeners._incr_(ev);
          }
        }
        tree = bus[ev] || (bus[ev] = {});
        tree = tree[selector] || (tree[selector] = {});
        info = tree[controllerId] || (tree[controllerId] = {controller:controller, list:[]});
        info.list.push(event);
      }
    }
  }
}, match:function(target, selector) {
  var idProperty = this.idProperty;
  if (idProperty) {
    return selector === '*' || target[idProperty] === selector;
  }
  return false;
}, monitor:function(observable) {
  var domain = this, prototype = observable.isInstance ? observable : observable.prototype, doFireEvent = prototype.doFireEvent;
  domain.monitoredClasses.push(observable);
  prototype.doFireEvent = function(ev, args) {
    var ret = doFireEvent.apply(this, arguments);
    if (ret !== false && !this.isSuspended(ev)) {
      ret = domain.dispatch(this, ev, args);
    }
    return ret;
  };
}, unlisten:function(controllerId) {
  var bus = this.bus, id = controllerId, monitoredClasses = this.monitoredClasses, monitoredClassesCount = monitoredClasses.length, controllers, ev, events, len, item, selector, selectors, i, j, info, classHasListeners;
  if (controllerId.isController) {
    id = controllerId.getId();
  }
  for (ev in bus) {
    ev = Ext.canonicalEventName(ev);
    if (bus.hasOwnProperty(ev) && (selectors = bus[ev])) {
      for (selector in selectors) {
        controllers = selectors[selector];
        info = controllers[id];
        if (info) {
          events = info.list;
          if (events) {
            for (i = 0, len = events.length; i < len; ++i) {
              item = events[i];
              item.clearListeners();
              for (j = 0; j < monitoredClassesCount; ++j) {
                classHasListeners = monitoredClasses[j].hasListeners;
                if (classHasListeners) {
                  classHasListeners._decr_(item.name);
                }
              }
            }
            delete controllers[id];
          }
        }
      }
    }
  }
}, destroy:function() {
  this.monitoredClasses = this.bus = null;
  this.callParent();
}});
Ext.define('Ext.app.domain.Component', {extend:Ext.app.EventDomain, singleton:true, type:'component', constructor:function() {
  this.callParent();
  this.monitor(Ext.Widget);
}, dispatch:function(target, ev, args) {
  var controller = target.lookupController(false), domain, view;
  while (controller) {
    domain = controller.compDomain;
    if (domain) {
      if (domain.dispatch(target, ev, args) === false) {
        return false;
      }
    }
    view = controller.getView();
    controller = view ? view.lookupController(true) : null;
  }
  return this.callParent(arguments);
}, match:function(target, selector) {
  return target.is(selector);
}});
Ext.define('Ext.app.EventBus', {singleton:true, constructor:function() {
  var me = this, domains = Ext.app.EventDomain.instances;
  me.callParent();
  me.domains = domains;
  me.bus = domains.component.bus;
}, control:function(selectors, controller) {
  return this.domains.component.listen(selectors, controller);
}, listen:function(to, controller) {
  var domains = this.domains, domain;
  for (domain in to) {
    if (to.hasOwnProperty(domain)) {
      domains[domain].listen(to[domain], controller);
    }
  }
}, unlisten:function(controllerId) {
  var domains = Ext.app.EventDomain.instances, domain;
  for (domain in domains) {
    domains[domain].unlisten(controllerId);
  }
}});
Ext.define('Ext.app.domain.Global', {extend:Ext.app.EventDomain, singleton:true, type:'global', constructor:function() {
  var me = this;
  me.callParent();
  me.monitor(Ext.GlobalEvents);
}, listen:function(listeners, controller) {
  this.callParent([{global:listeners}, controller]);
}, match:Ext.returnTrue});
Ext.define('Ext.app.BaseController', {mixins:[Ext.mixin.Observable], isController:true, config:{id:null, control:null, listen:null, routes:null, before:null}, constructor:function(config) {
  var me = this;
  Ext.apply(me, config);
  delete me.control;
  delete me.listen;
  me.eventbus = Ext.app.EventBus;
  me.mixins.observable.constructor.call(me, config);
  me.ensureId();
}, applyListen:function(listen) {
  if (Ext.isObject(listen)) {
    listen = Ext.clone(listen);
  }
  return listen;
}, applyControl:function(control) {
  if (Ext.isObject(control)) {
    control = Ext.clone(control);
  }
  return control;
}, updateControl:function(control) {
  this.ensureId();
  if (control) {
    this.control(control);
  }
}, updateListen:function(listen) {
  this.ensureId();
  if (listen) {
    this.listen(listen);
  }
}, updateRoutes:function(routes) {
  if (routes) {
    var me = this, befores = me.getBefore() || {}, Router = Ext.app.route.Router, url, config, method;
    for (url in routes) {
      config = routes[url];
      if (Ext.isString(config)) {
        config = {action:config};
      }
      method = config.action;
      if (!config.before) {
        config.before = befores[method];
      } else {
        if (befores[method]) {
          Ext.log.warn('You have a before method configured on a route ("' + url + '") and in the before object property also in the "' + me.self.getName() + '" controller. Will use the before method in the route and disregard the one in the before property.');
        }
      }
      Router.connect(url, config, me);
    }
  }
}, isActive:function() {
  return true;
}, control:function(selectors, listeners, controller) {
  var me = this, ctrl = controller, obj;
  if (Ext.isString(selectors)) {
    obj = {};
    obj[selectors] = listeners;
  } else {
    obj = selectors;
    ctrl = listeners;
  }
  me.eventbus.control(obj, ctrl || me);
}, listen:function(to, controller) {
  this.eventbus.listen(to, controller || this);
}, destroy:function() {
  var me = this, bus = me.eventbus;
  Ext.app.route.Router.disconnectAll(me);
  if (bus) {
    bus.unlisten(me);
    me.eventbus = null;
  }
  me.callParent();
}, redirectTo:function(token, force) {
  if (token.isModel) {
    token = token.toUrl();
  }
  if (!force) {
    var currentToken = Ext.util.History.getToken();
    if (currentToken === token) {
      return false;
    }
  } else {
    Ext.app.route.Router.onStateChange(token);
  }
  Ext.util.History.add(token);
  return true;
}});
Ext.define('Ext.app.Util', {}, function() {
  Ext.apply(Ext.app, {namespaces:{Ext:{}}, addNamespaces:function(namespace) {
    var namespaces = Ext.app.namespaces, i, l;
    if (!Ext.isArray(namespace)) {
      namespace = [namespace];
    }
    for (i = 0, l = namespace.length; i < l; i++) {
      namespaces[namespace[i]] = true;
    }
  }, clearNamespaces:function() {
    Ext.app.namespaces = {};
  }, getNamespace:function(className) {
    var namespaces = Ext.apply({}, Ext.ClassManager.paths, Ext.app.namespaces), deepestPrefix = '', prefix;
    for (prefix in namespaces) {
      if (namespaces.hasOwnProperty(prefix) && prefix.length > deepestPrefix.length && prefix + '.' === className.substring(0, prefix.length + 1)) {
        deepestPrefix = prefix;
      }
    }
    return deepestPrefix === '' ? undefined : deepestPrefix;
  }, setupPaths:function(appName, appFolder, paths) {
    var manifestPaths = Ext.manifest, ns;
    if (appName && appFolder !== null) {
      manifestPaths = manifestPaths && manifestPaths.paths;
      if (!manifestPaths || appFolder !== undefined) {
        Ext.Loader.setPath(appName, appFolder === undefined ? 'app' : appFolder);
      }
    }
    if (paths) {
      for (ns in paths) {
        if (paths.hasOwnProperty(ns)) {
          Ext.Loader.setPath(ns, paths[ns]);
        }
      }
    }
  }});
  Ext.getNamespace = Ext.app.getNamespace;
});
Ext.define('Ext.util.Filter', {isFilter:true, config:{property:null, value:null, filterFn:null, id:null, anyMatch:false, exactMatch:false, caseSensitive:false, disabled:false, disableOnEmpty:false, operator:null, root:null, serializer:null, convert:null}, scope:null, $configStrict:false, statics:{createFilterFn:function(filters) {
  if (!filters) {
    return Ext.returnTrue;
  }
  return function(candidate) {
    var items = filters.isCollection ? filters.items : filters, length = items.length, match = true, i, filter;
    for (i = 0; match && i < length; i++) {
      filter = items[i];
      if (!filter.getDisabled()) {
        match = filter.filter(candidate);
      }
    }
    return match;
  };
}, isInvalid:function(cfg) {
  if (!cfg.filterFn) {
    if (!cfg.property) {
      return 'A Filter requires either a property or a filterFn to be set';
    }
    if (!cfg.hasOwnProperty('value') && !cfg.operator) {
      return 'A Filter requires either a property and value, or a filterFn to be set';
    }
  }
  return false;
}}, constructor:function(config) {
  var warn = Ext.util.Filter.isInvalid(config);
  if (warn) {
    Ext.log.warn(warn);
  }
  this.initConfig(config);
}, preventConvert:{'in':1, notin:1}, filter:function(item) {
  var me = this, filterFn = me._filterFn || me.getFilterFn(), convert = me.getConvert(), value = me._value;
  me._filterValue = value;
  me.isDateValue = Ext.isDate(value);
  if (me.isDateValue) {
    me.dateValue = value.getTime();
  }
  if (convert && !me.preventConvert[me.getOperator()]) {
    me._filterValue = convert.call(me.scope || me, value);
  }
  return filterFn.call(me.scope || me, item);
}, getId:function() {
  var id = this._id;
  if (!id) {
    id = this.getProperty();
    if (!id) {
      id = Ext.id(null, 'ext-filter-');
    }
    this._id = id;
  }
  return id;
}, getFilterFn:function() {
  var me = this, filterFn = me._filterFn, operator;
  if (!filterFn) {
    operator = me.getOperator();
    if (operator) {
      filterFn = me.operatorFns[operator];
    } else {
      filterFn = me.createRegexFilter();
    }
    me._filterFn = filterFn;
  }
  return filterFn;
}, createRegexFilter:function() {
  var me = this, anyMatch = !!me.getAnyMatch(), exact = !!me.getExactMatch(), value = me.getValue(), matcher = Ext.String.createRegex(value, !anyMatch, !anyMatch && exact, !me.getCaseSensitive());
  return function(item) {
    var val = me.getPropertyValue(item);
    return matcher ? matcher.test(val) : val == null;
  };
}, getPropertyValue:function(item) {
  var root = this._root, value = root == null ? item : item[root];
  return value[this._property];
}, getState:function() {
  var config = this.getInitialConfig(), result = {}, name;
  for (name in config) {
    if (config.hasOwnProperty(name)) {
      result[name] = config[name];
    }
  }
  delete result.root;
  result.value = this.getValue();
  return result;
}, getScope:function() {
  return this.scope;
}, serialize:function() {
  var result = this.getState(), serializer = this.getSerializer();
  delete result.id;
  delete result.serializer;
  if (serializer) {
    serializer.call(this, result);
  }
  return result;
}, updateOperator:function() {
  this._filterFn = null;
}, updateValue:function(value) {
  this._filterFn = null;
  if (this.getDisableOnEmpty()) {
    this.setDisabled(Ext.isEmpty(value));
  }
}, updateDisableOnEmpty:function(disableOnEmpty) {
  var disabled = false;
  if (disableOnEmpty) {
    disabled = Ext.isEmpty(this.getValue());
  }
  this.setDisabled(disabled);
}, privates:{getCandidateValue:function(candidate, v, preventCoerce) {
  var me = this, convert = me._convert, result = me.getPropertyValue(candidate);
  if (convert) {
    result = convert.call(me.scope || me, result);
  } else {
    if (!preventCoerce) {
      result = Ext.coerce(result, v);
    }
  }
  return result;
}}}, function() {
  var prototype = this.prototype, operatorFns = prototype.operatorFns = {'\x3c':function(candidate) {
    var v = this._filterValue;
    return this.getCandidateValue(candidate, v) < v;
  }, '\x3c\x3d':function(candidate) {
    var v = this._filterValue;
    return this.getCandidateValue(candidate, v) <= v;
  }, '\x3d':function(candidate) {
    var me = this, v = me._filterValue;
    candidate = me.getCandidateValue(candidate, v);
    if (me.isDateValue && candidate instanceof Date) {
      candidate = candidate.getTime();
      v = me.dateValue;
    }
    return candidate == v;
  }, '\x3d\x3d\x3d':function(candidate) {
    var me = this, v = me._filterValue;
    candidate = me.getCandidateValue(candidate, v, true);
    if (me.isDateValue && candidate instanceof Date) {
      candidate = candidate.getTime();
      v = me.dateValue;
    }
    return candidate === v;
  }, '\x3e\x3d':function(candidate) {
    var v = this._filterValue;
    return this.getCandidateValue(candidate, v) >= v;
  }, '\x3e':function(candidate) {
    var v = this._filterValue;
    return this.getCandidateValue(candidate, v) > v;
  }, '!\x3d':function(candidate) {
    var me = this, v = me._filterValue;
    candidate = me.getCandidateValue(candidate, v);
    if (me.isDateValue && candidate instanceof Date) {
      candidate = candidate.getTime();
      v = me.dateValue;
    }
    return candidate != v;
  }, '!\x3d\x3d':function(candidate) {
    var me = this, v = me._filterValue;
    candidate = me.getCandidateValue(candidate, v, true);
    if (me.isDateValue && candidate instanceof Date) {
      candidate = candidate.getTime();
      v = me.dateValue;
    }
    return candidate !== v;
  }, 'in':function(candidate) {
    var v = this._filterValue;
    return Ext.Array.contains(v, this.getCandidateValue(candidate, v));
  }, notin:function(candidate) {
    var v = this._filterValue;
    return !Ext.Array.contains(v, this.getCandidateValue(candidate, v));
  }, like:function(candidate) {
    var v = this._filterValue;
    return v && this.getCandidateValue(candidate, v).toLowerCase().indexOf(v.toLowerCase()) > -1;
  }};
  operatorFns['\x3d\x3d'] = operatorFns['\x3d'];
  operatorFns.gt = operatorFns['\x3e'];
  operatorFns.ge = operatorFns['\x3e\x3d'];
  operatorFns.lt = operatorFns['\x3c'];
  operatorFns.le = operatorFns['\x3c\x3d'];
  operatorFns.eq = operatorFns['\x3d'];
  operatorFns.ne = operatorFns['!\x3d'];
});
Ext.define('Ext.util.Observable', {extend:Ext.mixin.Observable, $applyConfigs:true}, function(Observable) {
  var Super = Ext.mixin.Observable;
  Observable.releaseCapture = Super.releaseCapture;
  Observable.capture = Super.capture;
  Observable.captureArgs = Super.captureArgs;
  Observable.observe = Observable.observeClass = Super.observe;
});
Ext.define('Ext.util.AbstractMixedCollection', {mixins:{observable:Ext.util.Observable}, isMixedCollection:true, generation:0, indexGeneration:0, constructor:function(allowFunctions, keyFn) {
  var me = this;
  if (arguments.length === 1 && Ext.isObject(allowFunctions)) {
    me.initialConfig = allowFunctions;
    Ext.apply(me, allowFunctions);
  } else {
    me.allowFunctions = allowFunctions === true;
    if (keyFn) {
      me.getKey = keyFn;
    }
    me.initialConfig = {allowFunctions:me.allowFunctions, getKey:me.getKey};
  }
  me.items = [];
  me.map = {};
  me.keys = [];
  me.indexMap = {};
  me.length = 0;
  me.mixins.observable.constructor.call(me);
}, destroy:function() {
  var me = this;
  me.items = me.map = me.keys = me.indexMap = null;
  me.callParent();
}, allowFunctions:false, add:function(key, obj) {
  var len = this.length, out;
  if (arguments.length === 1) {
    out = this.insert(len, key);
  } else {
    out = this.insert(len, key, obj);
  }
  return out;
}, getKey:function(o) {
  return o.id;
}, replace:function(key, o) {
  var me = this, old, index;
  if (arguments.length == 1) {
    o = arguments[0];
    key = me.getKey(o);
  }
  old = me.map[key];
  if (typeof key == 'undefined' || key === null || typeof old == 'undefined') {
    return me.add(key, o);
  }
  me.generation++;
  index = me.indexOfKey(key);
  me.items[index] = o;
  me.map[key] = o;
  if (me.hasListeners.replace) {
    me.fireEvent('replace', key, old, o);
  }
  return o;
}, reorder:function(mapping) {
  var me = this, items = me.items, index = 0, length = items.length, order = [], remaining = [], oldIndex;
  me.suspendEvents();
  for (oldIndex in mapping) {
    order[mapping[oldIndex]] = items[oldIndex];
  }
  for (index = 0; index < length; index++) {
    if (mapping[index] == undefined) {
      remaining.push(items[index]);
    }
  }
  for (index = 0; index < length; index++) {
    if (order[index] == undefined) {
      order[index] = remaining.shift();
    }
  }
  me.clear();
  me.addAll(order);
  me.resumeEvents();
}, updateKey:function(oldKey, newKey) {
  var me = this, map = me.map, index = me.indexOfKey(oldKey), indexMap = me.indexMap, item;
  if (index > -1) {
    item = map[oldKey];
    delete map[oldKey];
    delete indexMap[oldKey];
    map[newKey] = item;
    indexMap[newKey] = index;
    me.keys[index] = newKey;
    me.indexGeneration = ++me.generation;
  }
}, addAll:function(objs) {
  var me = this, key;
  if (arguments.length > 1 || Ext.isArray(objs)) {
    me.insert(me.length, arguments.length > 1 ? arguments : objs);
  } else {
    for (key in objs) {
      if (objs.hasOwnProperty(key)) {
        if (me.allowFunctions || typeof objs[key] != 'function') {
          me.add(key, objs[key]);
        }
      }
    }
  }
}, each:function(fn, scope) {
  var items = Ext.Array.push([], this.items), i = 0, len = items.length, item;
  for (; i < len; i++) {
    item = items[i];
    if (fn.call(scope || item, item, i, len) === false) {
      break;
    }
  }
}, eachKey:function(fn, scope) {
  var keys = this.keys, items = this.items, i = 0, len = keys.length;
  for (; i < len; i++) {
    fn.call(scope || window, keys[i], items[i], i, len);
  }
}, findBy:function(fn, scope) {
  var keys = this.keys, items = this.items, i = 0, len = items.length;
  for (; i < len; i++) {
    if (fn.call(scope || window, items[i], keys[i])) {
      return items[i];
    }
  }
  return null;
}, insert:function(index, key, obj) {
  var out;
  if (Ext.isIterable(key)) {
    out = this.doInsert(index, key, obj);
  } else {
    if (arguments.length > 2) {
      out = this.doInsert(index, [key], [obj]);
    } else {
      out = this.doInsert(index, [key]);
    }
    out = out[0];
  }
  return out;
}, doInsert:function(index, keys, objects) {
  var me = this, itemKey, removeIndex, i, len = keys.length, deDupedLen = len, fireAdd = me.hasListeners.add, syncIndices, newKeys = {}, passedDuplicates, oldKeys, oldObjects;
  if (objects != null) {
    me.useLinearSearch = true;
  } else {
    objects = keys;
    keys = new Array(len);
    for (i = 0; i < len; i++) {
      keys[i] = this.getKey(objects[i]);
    }
  }
  me.suspendEvents();
  for (i = 0; i < len; i++) {
    itemKey = keys[i];
    removeIndex = me.indexOfKey(itemKey);
    if (removeIndex !== -1) {
      if (removeIndex < index) {
        index--;
      }
      me.removeAt(removeIndex);
    }
    if (itemKey != null) {
      if (newKeys[itemKey] != null) {
        passedDuplicates = true;
        deDupedLen--;
      }
      newKeys[itemKey] = i;
    }
  }
  me.resumeEvents();
  if (passedDuplicates) {
    oldKeys = keys;
    oldObjects = objects;
    keys = new Array(deDupedLen);
    objects = new Array(deDupedLen);
    i = 0;
    for (itemKey in newKeys) {
      keys[i] = oldKeys[newKeys[itemKey]];
      objects[i] = oldObjects[newKeys[itemKey]];
      i++;
    }
    len = deDupedLen;
  }
  syncIndices = index === me.length && me.indexGeneration === me.generation;
  Ext.Array.insert(me.items, index, objects);
  Ext.Array.insert(me.keys, index, keys);
  me.length += len;
  me.generation++;
  if (syncIndices) {
    me.indexGeneration = me.generation;
  }
  for (i = 0; i < len; i++, index++) {
    itemKey = keys[i];
    if (itemKey != null) {
      me.map[itemKey] = objects[i];
      if (syncIndices) {
        me.indexMap[itemKey] = index;
      }
    }
    if (fireAdd) {
      me.fireEvent('add', index, objects[i], itemKey);
    }
  }
  return objects;
}, remove:function(o) {
  var me = this, removeKey, index;
  if (!me.useLinearSearch && (removeKey = me.getKey(o))) {
    index = me.indexOfKey(removeKey);
  } else {
    index = Ext.Array.indexOf(me.items, o);
  }
  return index === -1 ? false : me.removeAt(index);
}, removeAll:function(items) {
  var me = this, i;
  if (items || me.hasListeners.remove) {
    if (items) {
      for (i = items.length - 1; i >= 0; --i) {
        me.remove(items[i]);
      }
    } else {
      while (me.length) {
        me.removeAt(0);
      }
    }
  } else {
    me.length = me.items.length = me.keys.length = 0;
    me.map = {};
    me.indexMap = {};
    me.generation++;
    me.indexGeneration = me.generation;
  }
}, removeAt:function(index) {
  var me = this, o, key;
  if (index < me.length && index >= 0) {
    me.length--;
    o = me.items[index];
    Ext.Array.erase(me.items, index, 1);
    key = me.keys[index];
    if (typeof key != 'undefined') {
      delete me.map[key];
    }
    Ext.Array.erase(me.keys, index, 1);
    if (me.hasListeners.remove) {
      me.fireEvent('remove', o, key);
    }
    me.generation++;
    return o;
  }
  return false;
}, removeRange:function(index, removeCount) {
  var me = this, o, key, i, limit, syncIndices, trimming;
  if (index < me.length && index >= 0) {
    if (!removeCount) {
      removeCount = 1;
    }
    limit = Math.min(index + removeCount, me.length);
    removeCount = limit - index;
    trimming = limit === me.length;
    syncIndices = trimming && me.indexGeneration === me.generation;
    for (i = index; i < limit; i++) {
      key = me.keys[i];
      if (key != null) {
        delete me.map[key];
        if (syncIndices) {
          delete me.indexMap[key];
        }
      }
    }
    o = me.items[i - 1];
    me.length -= removeCount;
    me.generation++;
    if (syncIndices) {
      me.indexGeneration = me.generation;
    }
    if (trimming) {
      me.items.length = me.keys.length = me.length;
    } else {
      me.items.splice(index, removeCount);
      me.keys.splice(index, removeCount);
    }
    return o;
  }
  return false;
}, removeAtKey:function(key) {
  var me = this, keys = me.keys, i;
  if (key == null) {
    for (i = keys.length - 1; i >= 0; i--) {
      if (keys[i] == null) {
        me.removeAt(i);
      }
    }
  } else {
    return me.removeAt(me.indexOfKey(key));
  }
}, getCount:function() {
  return this.length;
}, indexOf:function(o) {
  var me = this, key;
  if (o != null) {
    if (!me.useLinearSearch && (key = me.getKey(o))) {
      return this.indexOfKey(key);
    }
    return Ext.Array.indexOf(me.items, o);
  }
  return -1;
}, indexOfKey:function(key) {
  if (!this.map.hasOwnProperty(key)) {
    return -1;
  }
  if (this.indexGeneration !== this.generation) {
    this.rebuildIndexMap();
  }
  return this.indexMap[key];
}, rebuildIndexMap:function() {
  var me = this, indexMap = me.indexMap = {}, keys = me.keys, len = keys.length, i;
  for (i = 0; i < len; i++) {
    indexMap[keys[i]] = i;
  }
  me.indexGeneration = me.generation;
}, get:function(key) {
  var me = this, mk = me.map[key], item = mk !== undefined ? mk : typeof key == 'number' ? me.items[key] : undefined;
  return typeof item != 'function' || me.allowFunctions ? item : null;
}, getAt:function(index) {
  return this.items[index];
}, getByKey:function(key) {
  return this.map[key];
}, contains:function(o) {
  var me = this, key;
  if (o != null) {
    if (!me.useLinearSearch && (key = me.getKey(o))) {
      return this.map[key] != null;
    }
    return Ext.Array.indexOf(this.items, o) !== -1;
  }
  return false;
}, containsKey:function(key) {
  return this.map.hasOwnProperty(key);
}, clear:function() {
  var me = this;
  if (me.generation) {
    me.length = 0;
    me.items = [];
    me.keys = [];
    me.map = {};
    me.indexMap = {};
    me.generation++;
    me.indexGeneration = me.generation;
  }
  if (me.hasListeners.clear) {
    me.fireEvent('clear');
  }
}, first:function() {
  return this.items[0];
}, last:function() {
  return this.items[this.length - 1];
}, sum:function(property, root, start, end) {
  var values = this.extractValues(property, root), length = values.length, sum = 0, i;
  start = start || 0;
  end = end || end === 0 ? end : length - 1;
  for (i = start; i <= end; i++) {
    sum += values[i];
  }
  return sum;
}, collect:function(property, root, allowNull) {
  var values = this.extractValues(property, root), length = values.length, hits = {}, unique = [], value, strValue, i;
  for (i = 0; i < length; i++) {
    value = values[i];
    strValue = String(value);
    if ((allowNull || !Ext.isEmpty(value)) && !hits[strValue]) {
      hits[strValue] = true;
      unique.push(value);
    }
  }
  return unique;
}, extractValues:function(property, root) {
  var values = this.items;
  if (root) {
    values = Ext.Array.pluck(values, root);
  }
  return Ext.Array.pluck(values, property);
}, hasRange:function(start, end) {
  return end < this.length;
}, getRange:function(start, end) {
  var me = this, items = me.items, range = [], len = items.length, tmp, reverse;
  if (len < 1) {
    return range;
  }
  if (start > end) {
    reverse = true;
    tmp = start;
    start = end;
    end = tmp;
  }
  if (start < 0) {
    start = 0;
  }
  if (end == null || end >= len) {
    end = len - 1;
  }
  range = items.slice(start, end + 1);
  if (reverse && range.length) {
    range.reverse();
  }
  return range;
}, filter:function(property, value, anyMatch, caseSensitive) {
  var filters = [];
  if (Ext.isString(property)) {
    filters.push(new Ext.util.Filter({property:property, value:value, anyMatch:anyMatch, caseSensitive:caseSensitive}));
  } else {
    if (Ext.isArray(property) || property instanceof Ext.util.Filter) {
      filters = filters.concat(property);
    }
  }
  return this.filterBy(Ext.util.Filter.createFilterFn(filters));
}, filterBy:function(fn, scope) {
  var me = this, newMC = new me.self(me.initialConfig), keys = me.keys, items = me.items, length = items.length, i;
  newMC.getKey = me.getKey;
  for (i = 0; i < length; i++) {
    if (fn.call(scope || me, items[i], keys[i])) {
      newMC.add(keys[i], items[i]);
    }
  }
  newMC.useLinearSearch = me.useLinearSearch;
  return newMC;
}, findIndex:function(property, value, start, anyMatch, caseSensitive) {
  if (Ext.isEmpty(value, false)) {
    return -1;
  }
  value = this.createValueMatcher(value, anyMatch, caseSensitive);
  return this.findIndexBy(function(o) {
    return o && value.test(o[property]);
  }, null, start);
}, findIndexBy:function(fn, scope, start) {
  var me = this, keys = me.keys, items = me.items, i = start || 0, len = items.length;
  for (; i < len; i++) {
    if (fn.call(scope || me, items[i], keys[i])) {
      return i;
    }
  }
  return -1;
}, createValueMatcher:function(value, anyMatch, caseSensitive, exactMatch) {
  if (!value.exec) {
    var er = Ext.String.escapeRegex;
    value = String(value);
    if (anyMatch === true) {
      value = er(value);
    } else {
      value = '^' + er(value);
      if (exactMatch === true) {
        value += '$';
      }
    }
    value = new RegExp(value, caseSensitive ? '' : 'i');
  }
  return value;
}, clone:function() {
  var me = this, copy = new me.self(me.initialConfig);
  copy.add(me.keys, me.items);
  copy.useLinearSearch = me.useLinearSearch;
  return copy;
}});
Ext.define('Ext.util.Sorter', {isSorter:true, config:{property:null, sorterFn:null, root:null, transform:null, direction:'ASC', id:undefined}, statics:{createComparator:function(sorters, nextFn) {
  nextFn = nextFn || 0;
  return function(lhs, rhs) {
    var items = sorters.isCollection ? sorters.items : sorters, n = items.length, comp, i;
    for (i = 0; i < n; ++i) {
      comp = items[i].sort(lhs, rhs);
      if (comp) {
        return comp;
      }
    }
    return nextFn && nextFn(lhs, rhs);
  };
}}, multiplier:1, constructor:function(config) {
  if (config && !this.isGrouper) {
    if (!config.property === !config.sorterFn) {
      Ext.raise('A Sorter requires either a property or a sorterFn.');
    }
  }
  this.initConfig(config);
}, getId:function() {
  var id = this._id;
  if (!id) {
    id = this.getProperty();
    if (!id) {
      id = Ext.id(null, 'ext-sorter-');
    }
    this._id = id;
  }
  return id;
}, sort:function(lhs, rhs) {
  return this.multiplier * this.sortFn(lhs, rhs);
}, sortFn:function(item1, item2) {
  var me = this, transform = me._transform, root = me._root, property = me._property, lhs, rhs;
  if (root) {
    item1 = item1[root];
    item2 = item2[root];
  }
  lhs = item1[property];
  rhs = item2[property];
  if (transform) {
    lhs = transform(lhs);
    rhs = transform(rhs);
  }
  return lhs > rhs ? 1 : lhs < rhs ? -1 : 0;
}, applyDirection:function(direction) {
  return direction ? direction : 'ASC';
}, updateDirection:function(direction) {
  this.multiplier = direction.toUpperCase() === 'DESC' ? -1 : 1;
}, updateProperty:function(property) {
  if (property) {
    delete this.sortFn;
  }
}, updateSorterFn:function(sorterFn) {
  this.sortFn = sorterFn;
}, toggle:function() {
  this.setDirection(Ext.String.toggle(this.getDirection(), 'ASC', 'DESC'));
}, getState:function() {
  var me = this, result = {root:me.getRoot(), property:me.getProperty(), direction:me.getDirection()};
  if (me._id) {
    result.id = me._id;
  }
  return result;
}, serialize:function() {
  return {property:this.getProperty(), direction:this.getDirection()};
}});
Ext.define('Ext.util.Sortable', {isSortable:true, $configPrefixed:false, $configStrict:false, config:{sorters:null}, defaultSortDirection:'ASC', multiSortLimit:3, statics:{createComparator:function(sorters) {
  return sorters && sorters.length ? function(r1, r2) {
    var result = sorters[0].sort(r1, r2), length = sorters.length, i = 1;
    for (; !result && i < length; i++) {
      result = sorters[i].sort.call(sorters[i], r1, r2);
    }
    return result;
  } : function() {
    return 0;
  };
}}, applySorters:function(sorters) {
  var me = this, sortersCollection = me.getSorters() || new Ext.util.MixedCollection(false, Ext.returnId);
  if (sorters) {
    sortersCollection.addAll(me.decodeSorters(sorters));
  }
  return sortersCollection;
}, sort:function(sorters, direction, insertionPosition, doSort) {
  var me = this, sorter, overFlow, currentSorters = me.getSorters();
  if (!currentSorters) {
    me.setSorters(null);
    currentSorters = me.getSorters();
  }
  if (Ext.isArray(sorters)) {
    doSort = insertionPosition;
    insertionPosition = direction;
  } else {
    if (Ext.isObject(sorters)) {
      sorters = [sorters];
      doSort = insertionPosition;
      insertionPosition = direction;
    } else {
      if (Ext.isString(sorters)) {
        sorter = currentSorters.get(sorters);
        if (!sorter) {
          sorter = {property:sorters, direction:direction};
        } else {
          if (direction == null) {
            sorter.toggle();
          } else {
            sorter.setDirection(direction);
          }
        }
        sorters = [sorter];
      }
    }
  }
  if (sorters && sorters.length) {
    sorters = me.decodeSorters(sorters);
    switch(insertionPosition) {
      case 'multi':
        currentSorters.insert(0, sorters[0]);
        overFlow = currentSorters.getCount() - me.multiSortLimit;
        if (overFlow > 0) {
          currentSorters.removeRange(me.multiSortLimit, overFlow);
        }
        break;
      case 'prepend':
        currentSorters.insert(0, sorters);
        break;
      case 'append':
        currentSorters.addAll(sorters);
        break;
      case undefined:
      case null:
      case 'replace':
        currentSorters.clear();
        currentSorters.addAll(sorters);
        break;
      default:
        Ext.raise('Sorter insertion point must be "multi", "prepend", "append" or "replace"');
    }
  }
  if (doSort !== false) {
    me.fireEvent('beforesort', me, sorters);
    me.onBeforeSort(sorters);
    if (me.getSorterCount()) {
      me.doSort(me.generateComparator());
    }
  }
  return sorters;
}, getSorterCount:function() {
  return this.getSorters().items.length;
}, generateComparator:function() {
  var sorters = this.getSorters().getRange();
  return sorters.length ? this.createComparator(sorters) : this.emptyComparator;
}, emptyComparator:function() {
  return 0;
}, onBeforeSort:Ext.emptyFn, decodeSorters:function(sorters) {
  if (!Ext.isArray(sorters)) {
    if (sorters === undefined) {
      sorters = [];
    } else {
      sorters = [sorters];
    }
  }
  var length = sorters.length, Sorter = Ext.util.Sorter, model = this.getModel ? this.getModel() : this.model, field, config, i;
  for (i = 0; i < length; i++) {
    config = sorters[i];
    if (!(config instanceof Sorter)) {
      if (Ext.isString(config)) {
        config = {property:config};
      }
      Ext.applyIf(config, {root:this.sortRoot, direction:'ASC'});
      if (config.fn) {
        config.sorterFn = config.fn;
      }
      if (typeof config == 'function') {
        config = {sorterFn:config};
      }
      if (model && !config.transform) {
        field = model.getField(config.property);
        config.transform = field && field.sortType !== Ext.identityFn ? field.sortType : undefined;
      }
      sorters[i] = new Ext.util.Sorter(config);
    }
  }
  return sorters;
}, getFirstSorter:function() {
  var sorters = this.getSorters().items, len = sorters.length, i = 0, sorter;
  for (; i < len; ++i) {
    sorter = sorters[i];
    if (!sorter.isGrouper) {
      return sorter;
    }
  }
  return null;
}}, function() {
  this.prototype.createComparator = this.createComparator;
});
Ext.define('Ext.util.MixedCollection', {extend:Ext.util.AbstractMixedCollection, mixins:{sortable:Ext.util.Sortable}, constructor:function() {
  this.initConfig();
  this.callParent(arguments);
}, doSort:function(sorterFn) {
  this.sortBy(sorterFn);
}, _sort:function(property, dir, fn) {
  var me = this, i, len, dsc = String(dir).toUpperCase() == 'DESC' ? -1 : 1, c = [], keys = me.keys, items = me.items, o;
  fn = fn || function(a, b) {
    return a - b;
  };
  for (i = 0, len = items.length; i < len; i++) {
    c[c.length] = {key:keys[i], value:items[i], index:i};
  }
  Ext.Array.sort(c, function(a, b) {
    return fn(a[property], b[property]) * dsc || (a.index < b.index ? -1 : 1);
  });
  for (i = 0, len = c.length; i < len; i++) {
    o = c[i];
    items[i] = o.value;
    keys[i] = o.key;
    me.indexMap[o.key] = i;
  }
  me.generation++;
  me.indexGeneration = me.generation;
  me.fireEvent('sort', me);
}, sortBy:function(sorterFn) {
  var me = this, items = me.items, item, keys = me.keys, key, length = items.length, i;
  for (i = 0; i < length; i++) {
    items[i].$extCollectionIndex = i;
  }
  Ext.Array.sort(items, function(a, b) {
    return sorterFn(a, b) || (a.$extCollectionIndex < b.$extCollectionIndex ? -1 : 1);
  });
  for (i = 0; i < length; i++) {
    item = items[i];
    key = me.getKey(item);
    keys[i] = key;
    me.indexMap[key] = i;
    delete items.$extCollectionIndex;
  }
  me.generation++;
  me.indexGeneration = me.generation;
  me.fireEvent('sort', me, items, keys);
}, findInsertionIndex:function(newItem, sorterFn) {
  var me = this, items = me.items, start = 0, end = items.length - 1, middle, comparison;
  if (!sorterFn) {
    sorterFn = me.generateComparator();
  }
  while (start <= end) {
    middle = start + end >> 1;
    comparison = sorterFn(newItem, items[middle]);
    if (comparison >= 0) {
      start = middle + 1;
    } else {
      if (comparison < 0) {
        end = middle - 1;
      }
    }
  }
  return start;
}, reorder:function(mapping) {
  this.callParent([mapping]);
  this.fireEvent('sort', this);
}, sortByKey:function(dir, fn) {
  this._sort('key', dir, fn || function(a, b) {
    var v1 = String(a).toUpperCase(), v2 = String(b).toUpperCase();
    return v1 > v2 ? 1 : v1 < v2 ? -1 : 0;
  });
}});
Ext.define('Ext.util.CollectionKey', {mixins:[Ext.mixin.Identifiable], isCollectionKey:true, observerPriority:-200, config:{collection:null, keyFn:null, property:null, rootProperty:null, unique:true}, generation:0, map:null, mapRebuilds:0, constructor:function(config) {
  this.initConfig(config);
  if (!Ext.isFunction(this.getKey)) {
    Ext.raise('CollectionKey requires a keyFn or property config');
  }
}, get:function(key) {
  var map = this.map || this.getMap();
  return map[key] || null;
}, clear:function() {
  this.map = null;
}, getRootProperty:function() {
  var me = this, root = this.callParent();
  return root !== null ? root : me.getCollection().getRootProperty();
}, indexOf:function(key, startAt) {
  var map = this.map || this.getMap(), item = map[key], collection = this.getCollection(), length = collection.length, i, index, items, n;
  if (!item) {
    return -1;
  }
  if (startAt === undefined) {
    startAt = -1;
  }
  if (item instanceof Array) {
    items = item;
    index = length;
    for (n = items.length; n-- > 0;) {
      i = collection.indexOf(items[n]);
      if (i < index && i > startAt) {
        index = i;
      }
    }
    if (index === length) {
      return -1;
    }
  } else {
    index = collection.indexOf(item);
  }
  return index > startAt ? index : -1;
}, updateKey:function(item, oldKey) {
  var me = this, map = me.map, bucket, index;
  if (map) {
    bucket = map[oldKey];
    if (bucket instanceof Array) {
      index = Ext.Array.indexOf(bucket, item);
      if (index >= 0) {
        if (bucket.length > 2) {
          bucket.splice(index, 1);
        } else {
          map[oldKey] = bucket[1 - index];
        }
      }
    } else {
      if (bucket) {
        if (me.getUnique() && bucket !== item) {
          Ext.raise('Incorrect oldKey "' + oldKey + '" for item with newKey "' + me.getKey(item) + '"');
        }
        delete map[oldKey];
      }
    }
    me.add([item]);
  }
}, onCollectionAdd:function(collection, add) {
  if (this.map) {
    this.add(add.items);
  }
}, onCollectionItemChange:function(collection, details) {
  this.map = null;
}, onCollectionRefresh:function() {
  this.map = null;
}, onCollectionRemove:function(collection, remove) {
  var me = this, map = me.map, items = remove.items, length = items.length, i, item, key;
  if (map) {
    if (me.getUnique() && length < collection.length / 2) {
      for (i = 0; i < length; ++i) {
        key = me.getKey(item = items[i]);
        delete map[key];
      }
    } else {
      me.map = null;
    }
  }
}, add:function(items) {
  var me = this, map = me.map, bucket, i, item, key, length, unique;
  length = items.length;
  unique = me.getUnique();
  for (i = 0; i < length; ++i) {
    key = me.getKey(item = items[i]);
    if (unique || !(key in map)) {
      map[key] = item;
    } else {
      if (!((bucket = map[key]) instanceof Array)) {
        map[key] = bucket = [bucket];
      }
      bucket.push(item);
    }
  }
}, applyKeyFn:function(keyFn) {
  if (Ext.isString(keyFn)) {
    this.getKey = function(item) {
      return item[keyFn]();
    };
  } else {
    this.getKey = keyFn;
  }
}, updateProperty:function(property) {
  var root = this.getRootProperty();
  this.getKey = function(item) {
    return (root ? item[root] : item)[property];
  };
}, getMap:function() {
  var me = this, map = me.map;
  if (!map) {
    me.map = map = {};
    me.keysByItemKey = {};
    ++me.mapRebuilds;
    me.add(me.getCollection().items);
  }
  return map;
}, updateCollection:function(collection) {
  collection.addObserver(this);
}, clone:function() {
  return new Ext.util.CollectionKey(this.getCurrentConfig());
}});
Ext.define('Ext.util.Grouper', {extend:Ext.util.Sorter, isGrouper:true, config:{groupFn:null, sortProperty:null}, constructor:function(config) {
  if (config) {
    if (config.getGroupString) {
      Ext.raise('Cannot set getGroupString - use groupFn instead');
    }
  }
  this.callParent(arguments);
}, getGroupString:function(item) {
  var group = this._groupFn(item);
  return group != null ? String(group) : '';
}, sortFn:function(item1, item2) {
  var me = this, lhs = me._groupFn(item1), rhs = me._groupFn(item2), property = me._sortProperty, root = me._root, sorterFn = me._sorterFn, transform = me._transform;
  if (lhs === rhs) {
    return 0;
  }
  if (property || sorterFn) {
    if (sorterFn) {
      return sorterFn.call(this, item1, item2);
    }
    if (root) {
      item1 = item1[root];
      item2 = item2[root];
    }
    lhs = item1[property];
    rhs = item2[property];
    if (transform) {
      lhs = transform(lhs);
      rhs = transform(rhs);
    }
  }
  return lhs > rhs ? 1 : lhs < rhs ? -1 : 0;
}, standardGroupFn:function(item) {
  var root = this._root;
  return (root ? item[root] : item)[this._property];
}, updateSorterFn:function() {
}, updateProperty:function() {
  if (!this.getGroupFn()) {
    this.setGroupFn(this.standardGroupFn);
  }
}});
Ext.define('Ext.util.Collection', {mixins:[Ext.mixin.Observable], isCollection:true, config:{autoFilter:true, autoSort:true, autoGroup:true, decoder:null, extraKeys:null, filters:null, grouper:null, groups:null, rootProperty:null, sorters:null, multiSortLimit:3, defaultSortDirection:'ASC', source:null, trackGroups:true}, generation:0, indices:null, indexRebuilds:0, updating:0, grouped:false, sorted:false, filtered:false, $endUpdatePriority:1001, constructor:function(config) {
  var me = this;
  me.items = [];
  me.map = {};
  me.length = 0;
  if (config && config.keyFn) {
    me.getKey = config.keyFn;
  }
  me.mixins.observable.constructor.call(me, config);
}, destroy:function() {
  var me = this, filters = me._filters, sorters = me._sorters, groups = me._groups;
  if (filters) {
    filters.destroy();
    me._filters = null;
  }
  if (sorters) {
    sorters.destroy();
    me._sorters = null;
  }
  if (groups) {
    groups.destroy();
    me._groups = null;
  }
  me.setSource(null);
  me.observers = me.items = me.map = null;
  me.callParent();
}, add:function(item) {
  var me = this, items = me.decodeItems(arguments, 0), ret = items;
  if (items.length) {
    me.requestedIndex = me.length;
    me.splice(me.length, 0, items);
    delete me.requestedIndex;
    ret = items.length === 1 ? items[0] : items;
  }
  return ret;
}, replaceAll:function() {
  var me = this, ret, items;
  items = me.decodeItems(arguments, 0);
  ret = items;
  if (items.length) {
    me.splice(0, me.length, items);
    ret = items.length === 1 ? items[0] : items;
  } else {
    me.removeAll();
  }
  return ret;
}, aggregate:function(property, operation, begin, end, scope) {
  var me = this, args = Ext.Array.slice(arguments);
  args.unshift(me.items);
  return me.aggregateItems.apply(me, args);
}, aggregateByGroup:function(property, operation, scope) {
  var groups = this.getGroups();
  return this.aggregateGroups(groups, property, operation, scope);
}, aggregateItems:function(items, property, operation, begin, end, scope) {
  var me = this, range = Ext.Number.clipIndices(items.length, [begin, end]), subsetRequested = begin !== 0 && end !== items.length, i, j, rangeLen, root, value, values, valueItems;
  begin = range[0];
  end = range[1];
  if (!Ext.isFunction(operation)) {
    operation = me._aggregators[operation];
    return operation.call(me, items, begin, end, property, me.getRootProperty());
  }
  root = me.getRootProperty();
  values = new Array(rangeLen);
  valueItems = subsetRequested ? new Array(rangeLen) : items;
  for (i = begin, j = 0; i < end; ++i, j++) {
    if (subsetRequested) {
      valueItems[j] = value = items[i];
    }
    values[j] = (root ? value[root] : value)[property];
  }
  return operation.call(scope || me, items, values, 0);
}, aggregateGroups:function(groups, property, operation, scope) {
  var items = groups.items, len = items.length, callDirect = !Ext.isFunction(operation), out = {}, i, group, result;
  for (i = 0; i < len; ++i) {
    group = items[i];
    if (!callDirect) {
      result = this.aggregateItems(group.items, property, operation, null, null, scope);
    } else {
      result = group[operation](property);
    }
    out[group.getGroupKey()] = result;
  }
  return out;
}, beginUpdate:function() {
  if (!this.updating++) {
    this.notify('beginupdate');
  }
}, clear:function() {
  var me = this, generation = me.generation, ret = generation ? me.items : [], extraKeys, indexName;
  if (generation) {
    me.items = [];
    me.length = 0;
    me.map = {};
    me.indices = {};
    me.generation++;
    extraKeys = me.getExtraKeys();
    if (extraKeys) {
      for (indexName in extraKeys) {
        extraKeys[indexName].clear();
      }
    }
  }
  return ret;
}, clone:function() {
  var me = this, copy = new me.self(me.initialConfig);
  copy.add(me.items);
  return copy;
}, collect:function(property, root, allowNull) {
  var items = this.items, length = items.length, map = {}, ret = [], i, strValue, value;
  for (i = 0; i < length; ++i) {
    value = items[i];
    value = (root ? value[root] : value)[property];
    strValue = String(value);
    if ((allowNull || !Ext.isEmpty(value)) && !map[strValue]) {
      map[strValue] = 1;
      ret.push(value);
    }
  }
  return ret;
}, contains:function(item) {
  var ret = false, key;
  if (item != null) {
    key = this.getKey(item);
    ret = this.map[key] === item;
  }
  return ret;
}, containsKey:function(key) {
  return key in this.map;
}, createFiltered:function(property, value, anyMatch, caseSensitive, exactMatch) {
  var me = this, ret = new me.self(me.initialConfig), root = me.getRootProperty(), items = me.items, length, i, filters, fn, scope;
  if (Ext.isFunction(property)) {
    fn = property;
    scope = value;
  } else {
    if (Ext.isString(property)) {
      filters = [new Ext.util.Filter({property:property, value:value, root:root, anyMatch:anyMatch, caseSensitive:caseSensitive, exactMatch:exactMatch})];
    } else {
      if (property instanceof Ext.util.Filter) {
        filters = [property];
        property.setRoot(root);
      } else {
        if (Ext.isArray(property)) {
          filters = property.slice(0);
          for (i = 0, length = filters.length; i < length; ++i) {
            filters[i].setRoot(root);
          }
        }
      }
    }
    fn = Ext.util.Filter.createFilterFn(filters);
  }
  scope = scope || me;
  for (i = 0, length = items.length; i < length; i++) {
    if (fn.call(scope, items[i])) {
      ret.add(items[i]);
    }
  }
  return ret;
}, filterBy:function(fn, scope) {
  return this.createFiltered(fn, scope);
}, each:function(fn, scope) {
  var items = this.items, len = items.length, i, ret;
  if (len) {
    scope = scope || this;
    items = items.slice(0);
    for (i = 0; i < len; i++) {
      ret = fn.call(scope, items[i], i, len);
      if (ret === false) {
        break;
      }
    }
  }
  return ret;
}, eachKey:function(fn, scope) {
  var me = this, items = me.items, len = items.length, i, item, key, ret;
  if (len) {
    scope = scope || me;
    items = items.slice(0);
    for (i = 0; i < len; i++) {
      key = me.getKey(item = items[i]);
      ret = fn.call(scope, key, item, i, len);
      if (ret === false) {
        break;
      }
    }
  }
  return ret;
}, endUpdate:function() {
  if (!--this.updating) {
    this.notify('endupdate');
  }
}, find:function(property, value, start, startsWith, endsWith, ignoreCase) {
  if (Ext.isEmpty(value, false)) {
    return null;
  }
  var regex = Ext.String.createRegex(value, startsWith, endsWith, ignoreCase), root = this.getRootProperty();
  return this.findBy(function(item) {
    return item && regex.test((root ? item[root] : item)[property]);
  }, null, start);
}, findBy:function(fn, scope, start) {
  var me = this, items = me.items, len = items.length, i, item, key;
  scope = scope || me;
  for (i = start || 0; i < len; i++) {
    key = me.getKey(item = items[i]);
    if (fn.call(scope, item, key)) {
      return items[i];
    }
  }
  return null;
}, findIndex:function(property, value, start, startsWith, endsWith, ignoreCase) {
  var item = this.find(property, value, start, startsWith, endsWith, ignoreCase);
  return item ? this.indexOf(item) : -1;
}, findIndexBy:function(fn, scope, start) {
  var item = this.findBy(fn, scope, start);
  return item ? this.indexOf(item) : -1;
}, first:function(grouped) {
  var groups = grouped ? this.getGroups() : undefined;
  return groups ? this.aggregateGroups(groups, null, 'first') : this.items[0];
}, last:function(grouped) {
  var groups = grouped ? this.getGroups() : undefined;
  return groups ? this.aggregateGroups(groups, null, 'last') : this.items[this.length - 1];
}, get:function(key) {
  return this.map[key];
}, getAt:function(index) {
  return this.items[index];
}, getByKey:function(key) {
  return this.map[key];
}, getCount:function() {
  return this.length;
}, getKey:function(item) {
  var id = item.id;
  return id === 0 || id ? id : (id = item._id) === 0 || id ? id : item.getId();
}, getRange:function(begin, end) {
  var items = this.items, length = items.length, range;
  if (begin > end) {
    Ext.raise('Inverted range passed to Collection.getRange: [' + begin + ',' + end + ']');
  }
  if (!length) {
    range = [];
  } else {
    range = Ext.Number.clipIndices(length, [begin, end]);
    range = items.slice(range[0], range[1]);
  }
  return range;
}, getValues:function(property, root, start, end) {
  var items = this.items, range = Ext.Number.clipIndices(items.length, [start, end]), ret = [], i, value;
  for (i = range[0], end = range[1]; i < end; ++i) {
    value = items[i];
    value = (root ? value[root] : value)[property];
    ret.push(value);
  }
  return ret;
}, indexOf:function(item) {
  if (!item) {
    return -1;
  }
  var key = this.getKey(item);
  return this.indexOfKey(key);
}, indexOfKey:function(key) {
  var me = this, indices = me.indices;
  if (key in me.map) {
    if (!indices) {
      indices = me.getIndices();
    }
    return indices[key];
  }
  return -1;
}, insert:function(index, item) {
  var me = this, items = me.decodeItems(arguments, 1), ret = items;
  if (items.length) {
    me.requestedIndex = index;
    me.splice(index, 0, items);
    delete me.requestedIndex;
    ret = items.length === 1 ? items[0] : items;
  }
  return ret;
}, itemChanged:function(item, modified, oldKey, meta) {
  var me = this, keyChanged = oldKey === 0 || !!oldKey, filtered = me.filtered && me.getAutoFilter(), filterChanged = false, itemMovement = 0, items = me.items, last = me.length - 1, sorted = me.sorted && last > 0 && me.getAutoSort(), source = me.getSource(), toRemove = 0, itemFiltered = false, wasFiltered = false, details, newKey, sortFn, toAdd, index, newIndex;
  if (source && !source.updating) {
    source.itemChanged(item, modified, oldKey, meta);
  } else {
    newKey = me.getKey(item);
    if (filtered) {
      index = me.indexOfKey(keyChanged ? oldKey : newKey);
      wasFiltered = index < 0;
      itemFiltered = me.isItemFiltered(item);
      filterChanged = wasFiltered !== itemFiltered;
    }
    if (filterChanged) {
      if (itemFiltered) {
        toRemove = [item];
        newIndex = -1;
      } else {
        toAdd = [item];
        newIndex = me.length;
      }
    } else {
      if (sorted && !itemFiltered) {
        if (!filtered) {
          index = me.indexOfKey(keyChanged ? oldKey : newKey);
        }
        sortFn = me.getSortFn();
        if (index !== -1) {
          if (index && sortFn(items[index - 1], items[index]) > 0) {
            itemMovement = -1;
            newIndex = Ext.Array.binarySearch(items, item, 0, index, sortFn);
          } else {
            if (index < last && sortFn(items[index], items[index + 1]) > 0) {
              itemMovement = 1;
              newIndex = Ext.Array.binarySearch(items, item, index + 1, sortFn);
            }
          }
          if (itemMovement) {
            toAdd = [item];
          }
        }
      }
    }
    details = {item:item, key:newKey, index:newIndex, filterChanged:filterChanged, keyChanged:keyChanged, indexChanged:!!itemMovement, filtered:itemFiltered, oldIndex:index, newIndex:newIndex, wasFiltered:wasFiltered, meta:meta};
    if (keyChanged) {
      details.oldKey = oldKey;
    }
    if (modified) {
      details.modified = modified;
    }
    me.beginUpdate();
    me.notify('beforeitemchange', [details]);
    if (keyChanged) {
      me.updateKey(item, oldKey);
    }
    if (toAdd || toRemove) {
      me.splice(newIndex, toRemove, toAdd);
    }
    if (itemMovement > 0) {
      details.newIndex--;
    } else {
      if (itemMovement < 0) {
        details.oldIndex++;
      }
    }
    me.notify(itemFiltered ? 'filtereditemchange' : 'itemchange', [details]);
    me.endUpdate();
  }
}, remove:function(item) {
  var me = this, items = me.decodeRemoveItems(arguments, 0), length = me.length;
  me.splice(0, items);
  return length - me.length;
}, removeAll:function() {
  var me = this, length = me.length;
  if (me.generation && length) {
    me.splice(0, length);
  }
  return me;
}, removeAt:function(index, count) {
  var me = this, length = me.length, Num = Ext.Number, range = Num.clipIndices(length, [index, count === undefined ? 1 : count], Num.Clip.COUNT), n = range[0], removeCount = range[1] - n, item = removeCount === 1 && me.getAt(n), removed;
  me.splice(n, removeCount);
  removed = me.length - length;
  return item && removed ? item : removed;
}, removeByKey:function(key) {
  var item = this.getByKey(key);
  if (!item || !this.remove(item)) {
    return false;
  }
  return item;
}, replace:function(item) {
  var index = this.indexOf(item);
  if (index === -1) {
    this.add(item);
  } else {
    this.insert(index, item);
  }
}, splice:function(index, toRemove, toAdd) {
  var me = this, autoSort = me.sorted && me.getAutoSort(), map = me.map, items = me.items, length = me.length, removeItems = toRemove instanceof Array ? me.decodeRemoveItems(toRemove) : null, isRemoveCount = !removeItems, Num = Ext.Number, range = Num.clipIndices(length, [index, isRemoveCount ? toRemove : 0], Num.Clip.COUNT), begin = range[0], end = range[1], removeCount = end - begin, newItems = me.decodeItems(arguments, 2), newCount = newItems ? newItems.length : 0, addItems, newItemsMap, removeMap, 
  insertAt = begin, indices = me.indices || (newCount || removeItems ? me.getIndices() : null), adds = null, removes = removeCount ? [begin] : null, newKeys = null, source = me.getSource(), chunk, chunkItems, chunks, i, item, itemIndex, k, key, keys, n, duplicates, sorters, end;
  if (source && !source.updating) {
    if (isRemoveCount) {
      removeItems = [];
      for (i = 0; i < removeCount; ++i) {
        removeItems.push(items[begin + i]);
      }
    }
    if (begin < length) {
      i = source.indexOf(items[begin]);
    } else {
      i = source.length;
    }
    source.splice(i, removeItems, newItems);
    return me;
  }
  if (newCount) {
    addItems = newItems;
    newKeys = [];
    newItemsMap = {};
    if (autoSort) {
      sorters = me.getSorters();
      if (newCount > 1) {
        if (!addItems.$cloned) {
          newItems = addItems = addItems.slice(0);
        }
        me.sortData(addItems);
      }
    }
    for (i = 0; i < newCount; ++i) {
      key = me.getKey(item = newItems[i]);
      if ((k = newItemsMap[key]) !== undefined) {
        (duplicates || (duplicates = {}))[k] = 1;
      } else {
        itemIndex = indices[key];
        if (itemIndex < begin || end <= itemIndex) {
          (removes || (removes = [])).push(itemIndex);
        }
      }
      newItemsMap[key] = i;
      newKeys.push(key);
    }
    if (duplicates) {
      keys = newKeys;
      addItems = [];
      newKeys = [];
      addItems.$cloned = true;
      for (i = 0; i < newCount; ++i) {
        if (!duplicates[i]) {
          item = newItems[i];
          addItems.push(item);
          newKeys.push(keys[i]);
        }
      }
      newCount = addItems.length;
    }
    adds = {items:addItems, keys:newKeys};
  }
  for (i = removeItems ? removeItems.length : 0; i-- > 0;) {
    key = me.getKey(removeItems[i]);
    if ((itemIndex = indices[key]) !== undefined) {
      (removes || (removes = [])).push(itemIndex);
    }
  }
  if (!adds && !removes) {
    return me;
  }
  me.beginUpdate();
  if (removes) {
    chunk = null;
    chunks = [];
    removeMap = {};
    if (removes.length > 1) {
      removes.sort(Ext.Array.numericSortFn);
    }
    for (i = 0, n = removes.length; i < n; ++i) {
      key = me.getKey(item = items[itemIndex = removes[i]]);
      if (!(key in map)) {
        continue;
      }
      delete map[key];
      if (!chunk || itemIndex > chunk.at + chunkItems.length) {
        chunks.push(chunk = {at:itemIndex, items:chunkItems = [], keys:keys = [], map:removeMap, next:chunk, replacement:adds});
        if (adds) {
          adds.replaced = chunk;
        }
      }
      chunkItems.push(removeMap[key] = item);
      keys.push(key);
      if (itemIndex < insertAt) {
        --insertAt;
      }
      if (removeCount > 1 && itemIndex === begin) {
        --removeCount;
        removes[i--] = ++begin;
      }
    }
    if (adds) {
      adds.at = insertAt;
    }
    for (k = chunks.length; k-- > 0;) {
      chunk = chunks[k];
      i = chunk.at;
      n = chunk.items.length;
      if (i + n < length) {
        me.indices = indices = null;
      }
      me.length = length -= n;
      items.splice(i, n);
      if (indices) {
        keys = chunk.keys;
        for (i = 0; i < n; ++i) {
          delete indices[keys[i]];
        }
      }
      ++me.generation;
      me.notify('remove', [chunk]);
    }
  }
  if (adds) {
    if (autoSort && newCount > 1 && length) {
      me.spliceMerge(addItems, newKeys);
    } else {
      if (autoSort) {
        if (newCount > 1) {
          insertAt = 0;
          me.indices = indices = null;
        } else {
          insertAt = sorters.findInsertionIndex(adds.items[0], items, me.getSortFn());
        }
      }
      if (insertAt === length) {
        end = insertAt;
        for (i = addItems.length - 1; i >= 0; --i) {
          items[end + i] = addItems[i];
        }
        indices = me.indices;
        if (indices) {
          for (i = 0; i < newCount; ++i) {
            indices[newKeys[i]] = insertAt + i;
          }
        }
      } else {
        me.indices = null;
        Ext.Array.insert(items, insertAt, addItems);
      }
      for (i = 0; i < newCount; ++i) {
        map[newKeys[i]] = addItems[i];
      }
      me.length += newCount;
      adds.at = insertAt;
      adds.atItem = insertAt === 0 ? null : items[insertAt - 1];
      ++me.generation;
      me.notify('add', [adds]);
    }
  }
  me.endUpdate();
  return me;
}, update:function(fn, scope) {
  var me = this;
  me.beginUpdate();
  try {
    return fn.call(scope || me, me);
  } catch (e$21) {
    Ext.log.error(this.$className + ': Unhandled Exception: ', e$21.description || e$21.message);
    throw e$21;
  } finally {
    me.endUpdate();
  }
}, updateKey:function(item, oldKey) {
  var me = this, map = me.map, indices = me.indices, source = me.getSource(), newKey;
  if (source && !source.updating) {
    source.updateKey(item, oldKey);
  } else {
    if ((newKey = me.getKey(item)) !== oldKey) {
      if (map[oldKey] === item && !(newKey in map)) {
        delete map[oldKey];
        me.updating++;
        me.generation++;
        map[newKey] = item;
        if (indices) {
          indices[newKey] = indices[oldKey];
          delete indices[oldKey];
        }
        me.notify('updatekey', [{item:item, newKey:newKey, oldKey:oldKey}]);
        me.updating--;
      } else {
        if (newKey in map && map[newKey] !== item) {
          Ext.raise('Duplicate newKey "' + newKey + '" for item with oldKey "' + oldKey + '"');
        }
        if (oldKey in map && map[oldKey] !== item) {
          Ext.raise('Incorrect oldKey "' + oldKey + '" for item with newKey "' + newKey + '"');
        }
      }
    }
  }
}, findInsertIndex:function(item) {
  var source = this.getSource(), sourceItems = source.items, i = source.indexOf(item) - 1, sourceItem, index;
  while (i > -1) {
    sourceItem = sourceItems[i];
    index = this.indexOf(sourceItem);
    if (index > -1) {
      return index + 1;
    }
    --i;
  }
  return 0;
}, onCollectionAdd:function(source, details) {
  var me = this, atItem = details.atItem, items = details.items, requestedIndex = me.requestedIndex, filtered, index, copy, i, item, n;
  if (!me.sorted) {
    if (requestedIndex !== undefined) {
      index = requestedIndex;
    } else {
      if (atItem) {
        index = me.indexOf(atItem);
        if (index === -1) {
          index = me.findInsertIndex(items[0]);
        } else {
          ++index;
        }
      } else {
        index = 0;
      }
    }
  }
  if (me.getAutoFilter() && me.filtered) {
    for (i = 0, n = items.length; i < n; ++i) {
      item = items[i];
      if (me.isItemFiltered(item)) {
        if (!copy) {
          copy = items.slice(0, i);
        }
        if (!filtered) {
          filtered = [];
        }
        filtered.push(item);
      } else {
        if (copy) {
          copy.push(item);
        }
      }
    }
  }
  me.splice(index < 0 ? me.length : index, 0, copy || items);
  if (filtered) {
    me.notify('filteradd', [filtered]);
  }
}, onCollectionBeforeItemChange:function(source, details) {
  this.onCollectionUpdateKey = null;
}, onCollectionBeginUpdate:function() {
  this.beginUpdate();
}, onCollectionEndUpdate:function() {
  this.endUpdate();
}, onCollectionItemChange:function(source, details) {
  delete this.onCollectionUpdateKey;
  this.itemChanged(details.item, details.modified, details.oldKey, details.meta);
}, onCollectionFilteredItemChange:null, onCollectionRefresh:function(source) {
  var me = this, map = {}, indices = {}, i, item, items, key, length;
  items = source.items;
  items = me.filtered && me.getAutoFilter() ? Ext.Array.filter(items, me.getFilterFn()) : items.slice(0);
  if (me.sorted) {
    me.sortData(items);
  }
  me.items = items;
  me.length = length = items.length;
  me.map = map;
  me.indices = indices;
  for (i = 0; i < length; ++i) {
    key = me.getKey(item = items[i]);
    map[key] = item;
    indices[key] = i;
  }
  me.notify('refresh');
}, onCollectionRemove:function(source, details) {
  this.splice(0, details.items);
}, onCollectionUpdateKey:function(source, details) {
  this.updateKey(details.item, details.oldKey);
}, _aggregators:{average:function(items, begin, end, property, root) {
  var n = end - begin;
  return n && this._aggregators.sum.call(this, items, begin, end, property, root) / n;
}, bounds:function(items, begin, end, property, root) {
  for (var value, max, min, i = begin; i < end; ++i) {
    value = items[i];
    value = (root ? value[root] : value)[property];
    if (!(value < max)) {
      max = value;
    }
    if (!(value > min)) {
      min = value;
    }
  }
  return [min, max];
}, count:function(items) {
  return items.length;
}, extremes:function(items, begin, end, property, root) {
  var most = null, least = null, i, item, max, min, value;
  for (i = begin; i < end; ++i) {
    item = items[i];
    value = (root ? item[root] : item)[property];
    if (!(value < max)) {
      max = value;
      most = item;
    }
    if (!(value > min)) {
      min = value;
      least = item;
    }
  }
  return [least, most];
}, max:function(items, begin, end, property, root) {
  var b = this._aggregators.bounds.call(this, items, begin, end, property, root);
  return b[1];
}, maxItem:function(items, begin, end, property, root) {
  var b = this._aggregators.extremes.call(this, items, begin, end, property, root);
  return b[1];
}, min:function(items, begin, end, property, root) {
  var b = this._aggregators.bounds.call(this, items, begin, end, property, root);
  return b[0];
}, minItem:function(items, begin, end, property, root) {
  var b = this._aggregators.extremes.call(this, items, begin, end, property, root);
  return b[0];
}, sum:function(items, begin, end, property, root) {
  for (var value, sum = 0, i = begin; i < end; ++i) {
    value = items[i];
    value = (root ? value[root] : value)[property];
    sum += value;
  }
  return sum;
}}, _eventToMethodMap:{add:'onCollectionAdd', beforeitemchange:'onCollectionBeforeItemChange', beginupdate:'onCollectionBeginUpdate', endupdate:'onCollectionEndUpdate', itemchange:'onCollectionItemChange', filtereditemchange:'onCollectionFilteredItemChange', refresh:'onCollectionRefresh', remove:'onCollectionRemove', beforesort:'beforeCollectionSort', sort:'onCollectionSort', filter:'onCollectionFilter', filteradd:'onCollectionFilterAdd', updatekey:'onCollectionUpdateKey'}, addObserver:function(observer) {
  var me = this, observers = me.observers;
  if (!observers) {
    me.observers = observers = [];
  }
  if (Ext.Array.contains(observers, observer)) {
    Ext.Error.raise('Observer already added');
  }
  observers.push(observer);
  if (observers.length > 1) {
    Ext.Array.sort(observers, me.prioritySortFn);
  }
}, prioritySortFn:function(o1, o2) {
  var a = o1.observerPriority || 0, b = o2.observerPriority || 0;
  return a - b;
}, applyExtraKeys:function(extraKeys, oldExtraKeys) {
  var me = this, ret = oldExtraKeys || {}, config, name, value;
  for (name in extraKeys) {
    value = extraKeys[name];
    if (!value.isCollectionKey) {
      config = {collection:me};
      if (Ext.isString(value)) {
        config.property = value;
      } else {
        config = Ext.apply(config, value);
      }
      value = new Ext.util.CollectionKey(config);
    } else {
      value.setCollection(me);
    }
    ret[name] = me[name] = value;
    value.name = name;
  }
  return ret;
}, applyGrouper:function(grouper) {
  if (grouper) {
    grouper = this.getSorters().decodeSorter(grouper, 'Ext.util.Grouper');
  }
  return grouper;
}, decodeItems:function(args, index) {
  var me = this, ret = index === undefined ? args : args[index], cloned, decoder, i;
  if (!ret || !ret.$cloned) {
    cloned = args.length > index + 1 || !Ext.isIterable(ret);
    if (cloned) {
      ret = Ext.Array.slice(args, index);
      if (ret.length === 1 && ret[0] === undefined) {
        ret.length = 0;
      }
    }
    decoder = me.getDecoder();
    if (decoder) {
      if (!cloned) {
        ret = ret.slice(0);
        cloned = true;
      }
      for (i = ret.length; i-- > 0;) {
        if ((ret[i] = decoder.call(me, ret[i])) === false) {
          ret.splice(i, 1);
        }
      }
    }
    if (cloned) {
      ret.$cloned = true;
    }
  }
  return ret;
}, getIndices:function() {
  var me = this, indices = me.indices, items = me.items, n = items.length, i, key;
  if (!indices) {
    me.indices = indices = {};
    ++me.indexRebuilds;
    for (i = 0; i < n; ++i) {
      key = me.getKey(items[i]);
      indices[key] = i;
    }
  }
  return indices;
}, notify:function(eventName, args) {
  var me = this, observers = me.observers, methodName = me._eventToMethodMap[eventName], added = 0, index, length, method, observer;
  args = args || [];
  if (observers && methodName) {
    for (index = 0, length = observers.length; index < length; ++index) {
      method = (observer = observers[index])[methodName];
      if (method) {
        if (!added++) {
          args.unshift(me);
        }
        method.apply(observer, args);
      }
    }
  }
  if (!me.hasListeners) {
    return;
  }
  if (me.hasListeners[eventName]) {
    if (!added) {
      args.unshift(me);
    }
    me.fireEventArgs(eventName, args);
  }
}, getFilterFn:function() {
  return this.getFilters().getFilterFn();
}, getFilters:function(autoCreate) {
  var ret = this._filters;
  if (!ret && autoCreate !== false) {
    ret = new Ext.util.FilterCollection;
    this.setFilters(ret);
  }
  return ret;
}, isItemFiltered:function(item) {
  return !this.getFilters().filterFn(item);
}, onFilterChange:function(filters) {
  var me = this, source = me.getSource(), extraKeys, newKeys, key;
  if (!source) {
    extraKeys = me.getExtraKeys();
    if (extraKeys) {
      newKeys = {};
      for (key in extraKeys) {
        newKeys[key] = extraKeys[key].clone(me);
      }
    }
    source = new Ext.util.Collection({keyFn:me.getKey, extraKeys:newKeys, rootProperty:me.getRootProperty()});
    if (me.length) {
      source.add(me.items);
    }
    me.setSource(source);
    me.autoSource = source;
  } else {
    if (source.length || me.length) {
      me.onCollectionRefresh(source);
    }
  }
  me.notify('filter');
}, applyFilters:function(filters, collection) {
  if (filters == null || filters && filters.isFilterCollection) {
    return filters;
  }
  if (filters) {
    if (!collection) {
      collection = this.getFilters();
    }
    collection.splice(0, collection.length, filters);
  }
  return collection;
}, updateFilters:function(newFilters, oldFilters) {
  var me = this;
  if (oldFilters) {
    oldFilters.un('endupdate', 'onEndUpdateFilters', me);
  }
  if (newFilters) {
    newFilters.on({endupdate:'onEndUpdateFilters', scope:me, priority:me.$endUpdatePriority});
    newFilters.$filterable = me;
  }
  me.onEndUpdateFilters(newFilters);
}, onEndUpdateFilters:function(filters) {
  var me = this, was = me.filtered, is = !!filters && filters.length > 0;
  if (was || is) {
    me.filtered = is;
    me.onFilterChange(filters);
  }
}, getSortFn:function() {
  return this._sortFn || this.createSortFn();
}, getSorters:function(autoCreate) {
  var ret = this._sorters;
  if (!ret && autoCreate !== false) {
    ret = new Ext.util.SorterCollection;
    this.setSorters(ret);
  }
  return ret;
}, onSortChange:function() {
  if (this.sorted) {
    this.sortItems();
  }
}, sort:function(property, direction, mode) {
  var sorters = this.getSorters();
  sorters.addSort.apply(sorters, arguments);
  return this;
}, sortData:function(data) {
  Ext.Array.sort(data, this.getSortFn());
  return data;
}, sortItems:function(sortFn) {
  var me = this;
  if (me.sorted) {
    if (sortFn) {
      Ext.raise('Collections with sorters cannot resorted');
    }
    sortFn = me.getSortFn();
  }
  me.indices = null;
  me.notify('beforesort', [me.getSorters(false)]);
  if (me.length) {
    Ext.Array.sort(me.items, sortFn);
  }
  me.notify('sort');
}, sortBy:function(sortFn) {
  return this.sortItems(sortFn);
}, findInsertionIndex:function(item, items, comparatorFn) {
  if (!items) {
    items = this.items;
  }
  if (!comparatorFn) {
    comparatorFn = this.getSortFn();
  }
  return Ext.Array.binarySearch(items, item, comparatorFn);
}, applySorters:function(sorters, collection) {
  if (sorters == null || sorters && sorters.isSorterCollection) {
    return sorters;
  }
  if (sorters) {
    if (!collection) {
      collection = this.getSorters();
    }
    collection.splice(0, collection.length, sorters);
  }
  return collection;
}, createSortFn:function() {
  var me = this, grouper = me.getGrouper(), sorters = me.getSorters(false), sorterFn = sorters ? sorters.getSortFn() : null;
  if (!grouper) {
    return sorterFn;
  }
  return function(lhs, rhs) {
    var ret = grouper.sort(lhs, rhs);
    if (!ret && sorterFn) {
      ret = sorterFn(lhs, rhs);
    }
    return ret;
  };
}, updateGrouper:function(grouper) {
  var me = this, groups = me.getGroups(), sorters = me.getSorters(), populate;
  me.onSorterChange();
  me.grouped = !!grouper;
  if (grouper) {
    if (me.getTrackGroups()) {
      if (!groups) {
        groups = new Ext.util.GroupCollection({itemRoot:me.getRootProperty()});
        groups.$groupable = me;
        me.setGroups(groups);
      }
      groups.setGrouper(grouper);
      populate = true;
    }
  } else {
    if (groups) {
      me.removeObserver(groups);
      groups.destroy();
    }
    me.setGroups(null);
  }
  if (!sorters.updating) {
    me.onEndUpdateSorters(sorters);
  }
  if (populate) {
    groups.onCollectionRefresh(me);
  }
}, updateSorters:function(newSorters, oldSorters) {
  var me = this;
  if (oldSorters) {
    oldSorters.un('endupdate', 'onEndUpdateSorters', me);
  }
  if (newSorters) {
    newSorters.on({endupdate:'onEndUpdateSorters', scope:me, priority:me.$endUpdatePriority});
    newSorters.$sortable = me;
  }
  me.onSorterChange();
  me.onEndUpdateSorters(newSorters);
}, onSorterChange:function() {
  this._sortFn = null;
}, onEndUpdateSorters:function(sorters) {
  var me = this, was = me.sorted, is = me.grouped && me.getAutoGroup() || sorters && sorters.length > 0;
  if (was || is) {
    me.sorted = !!is;
    me.onSortChange(sorters);
  }
}, removeObserver:function(observer) {
  var observers = this.observers;
  if (observers) {
    Ext.Array.remove(observers, observer);
  }
}, spliceMerge:function(newItems, newKeys) {
  var me = this, map = me.map, newLength = newItems.length, oldIndex = 0, oldItems = me.items, oldLength = oldItems.length, adds = [], count = 0, items = [], sortFn = me.getSortFn(), addItems, end, i, newItem, oldItem, newIndex;
  me.items = items;
  for (newIndex = 0; newIndex < newLength; newIndex = end) {
    newItem = newItems[newIndex];
    for (; oldIndex < oldLength; ++oldIndex) {
      if (sortFn(newItem, oldItem = oldItems[oldIndex]) < 0) {
        break;
      }
      items.push(oldItem);
    }
    if (oldIndex === oldLength) {
      adds[count++] = {at:items.length, itemAt:items[items.length - 1], items:addItems = []};
      if (count > 1) {
        adds[count - 2].next = adds[count - 1];
      }
      for (; newIndex < newLength; ++newIndex) {
        addItems.push(newItem = newItems[newIndex]);
        items.push(newItem);
      }
      break;
    }
    adds[count++] = {at:items.length, itemAt:items[items.length - 1], items:addItems = [newItem]};
    if (count > 1) {
      adds[count - 2].next = adds[count - 1];
    }
    items.push(newItem);
    for (end = newIndex + 1; end < newLength; ++end) {
      if (sortFn(newItem = newItems[end], oldItem) >= 0) {
        break;
      }
      items.push(newItem);
      addItems.push(newItem);
    }
  }
  for (; oldIndex < oldLength; ++oldIndex) {
    items.push(oldItems[oldIndex]);
  }
  for (i = 0; i < newLength; ++i) {
    map[newKeys[i]] = newItems[i];
  }
  me.length = items.length;
  ++me.generation;
  me.indices = null;
  for (i = 0; i < count; ++i) {
    me.notify('add', [adds[i]]);
  }
}, getGroups:function() {
  return this.callParent() || null;
}, updateAutoGroup:function(autoGroup) {
  var groups = this.getGroups();
  if (groups) {
    groups.setAutoGroup(autoGroup);
  }
  this.onEndUpdateSorters(this._sorters);
}, updateGroups:function(newGroups, oldGroups) {
  if (oldGroups) {
    this.removeObserver(oldGroups);
  }
  if (newGroups) {
    this.addObserver(newGroups);
  }
}, updateSource:function(newSource, oldSource) {
  var auto = this.autoSource;
  if (oldSource) {
    oldSource.removeObserver(this);
    if (oldSource === auto) {
      auto.destroy();
      this.autoSource = null;
    }
  }
  if (newSource) {
    newSource.addObserver(this);
    if (newSource.length || this.length) {
      this.onCollectionRefresh(newSource);
    }
  }
}}, function() {
  var prototype = this.prototype;
  prototype.removeAtKey = prototype.removeByKey;
  prototype.decodeRemoveItems = prototype.decodeItems;
  Ext.Object.each(prototype._aggregators, function(name) {
    prototype[name] = function(property, begin, end) {
      return this.aggregate(property, name, begin, end);
    };
    prototype[name + 'ByGroup'] = function(property) {
      return this.aggregateByGroup(property, name);
    };
  });
});
Ext.define('Ext.util.ObjectTemplate', {isObjectTemplate:true, excludeProperties:{}, valueRe:/^[{][a-z\.]+[}]$/i, statics:{create:function(template, options) {
  if (!Ext.isObject(template)) {
    Ext.raise('The template is not an Object');
  }
  return template.isObjectTemplate ? template : new Ext.util.ObjectTemplate(template, options);
}}, constructor:function(template, options) {
  Ext.apply(this, options);
  this.template = template;
}, apply:function(context) {
  var me = this;
  delete me.apply;
  me.apply = me.compile(me.template);
  return me.apply(context);
}, privates:{compile:function(template) {
  var me = this, exclude = me.excludeProperties, compiled, i, len, fn;
  if (Ext.isString(template)) {
    if (template.indexOf('{') < 0) {
      fn = function() {
        return template;
      };
    } else {
      if (me.valueRe.test(template)) {
        template = template.substring(1, template.length - 1).split('.');
        fn = function(context) {
          for (var v = context, i = 0; v && i < template.length; ++i) {
            v = v[template[i]];
          }
          return v;
        };
      } else {
        template = new Ext.XTemplate(template);
        fn = function(context) {
          return template.apply(context);
        };
      }
    }
  } else {
    if (!template || Ext.isPrimitive(template) || Ext.isFunction(template)) {
      fn = function() {
        return template;
      };
    } else {
      if (template instanceof Array) {
        compiled = [];
        for (i = 0, len = template.length; i < len; ++i) {
          compiled[i] = me.compile(template[i]);
        }
        fn = function(context) {
          var ret = [], i;
          for (i = 0; i < len; ++i) {
            ret[i] = compiled[i](context);
          }
          return ret;
        };
      } else {
        compiled = {};
        for (i in template) {
          if (!exclude[i]) {
            compiled[i] = me.compile(template[i]);
          }
        }
        fn = function(context) {
          var ret = {}, i, v;
          for (i in template) {
            v = exclude[i] ? template[i] : compiled[i](context);
            if (v !== undefined) {
              ret[i] = v;
            }
          }
          return ret;
        };
      }
    }
  }
  return fn;
}}});
Ext.define('Ext.data.schema.Role', {isRole:true, left:true, owner:false, side:'left', isMany:false, defaultReaderType:'json', _internalReadOptions:{recordsOnly:true, asRoot:true}, constructor:function(association, config) {
  var me = this, extra = config.extra;
  Ext.apply(me, config);
  if (extra) {
    delete extra.type;
    Ext.apply(me, extra);
    delete me.extra;
  }
  me.association = association;
  if (association.owner === me.side) {
    association.owner = me;
    me.owner = true;
  }
}, processUpdate:function() {
  Ext.raise('Only the "many" for an association may be processed. "' + this.role + '" is not valid.');
}, processLoad:function(store, associatedEntity, records, session) {
  return records;
}, checkMembership:Ext.emptyFn, adoptAssociated:function(record, session) {
  var other = this.getAssociatedItem(record);
  if (other) {
    session.adopt(other);
  }
}, createAssociationStore:function(session, from, records, isComplete) {
  var me = this, association = me.association, foreignKeyName = association.getFieldName(), isMany = association.isManyToMany, storeConfig = me.storeConfig, id = from.getId(), config = {asynchronousLoad:false, model:me.cls, role:me, session:session, associatedEntity:from, disableMetaChangeEvent:true, pageSize:null, remoteFilter:true, trackRemoved:!session}, store;
  if (isMany) {
    config.filters = [{property:me.inverse.field, value:id, exactMatch:true}];
  } else {
    if (foreignKeyName) {
      config.filters = [{property:foreignKeyName, value:id, exactMatch:true}];
      config.foreignKeyName = foreignKeyName;
    }
  }
  if (storeConfig) {
    Ext.apply(config, storeConfig);
  }
  store = Ext.Factory.store(config);
  me.onStoreCreate(store, session, id);
  if (foreignKeyName || isMany && session) {
    store.on({scope:me, add:'onAddToMany', remove:'onRemoveFromMany', clear:'onRemoveFromMany'});
  }
  if (records) {
    store.loadData(records);
    store.complete = !!isComplete;
  }
  return store;
}, onStoreCreate:Ext.emptyFn, getAssociatedStore:function(inverseRecord, options, scope, records, allowInfer) {
  var me = this, storeName = me.getStoreName(), store = inverseRecord[storeName], session = inverseRecord.session, load = options && options.reload, source = inverseRecord.$source, isComplete = false, hadSource, args, i, len, raw, rec, sourceStore, hadRecords;
  if (!store) {
    if (session) {
      if (!records && source) {
        source = source[storeName];
        if (source && !source.isLoading()) {
          sourceStore = source;
          records = [];
          raw = source.getData().items;
          for (i = 0, len = raw.length; i < len; ++i) {
            rec = raw[i];
            records.push(session.getRecord(rec.self, rec.id));
          }
          isComplete = !!source.complete;
          hadSource = true;
        }
      }
      if (!hadSource) {
        hadRecords = !!records;
        records = me.findRecords(session, inverseRecord, records, allowInfer);
        if (!hadRecords && (!records || !records.length)) {
          records = null;
        }
        isComplete = hadRecords;
      }
    } else {
      isComplete = !!(records && records.length > 0);
    }
    store = me.createAssociationStore(session, inverseRecord, records, isComplete);
    store.$source = sourceStore;
    if (!records && (me.autoLoad || options)) {
      load = true;
    }
    inverseRecord[storeName] = store;
  }
  if (options) {
    if (load || store.isLoading()) {
      store.on('load', function(store, records, success, operation) {
        args = [store, operation];
        scope = scope || options.scope || inverseRecord;
        if (success) {
          Ext.callback(options.success, scope, args);
        } else {
          Ext.callback(options.failure, scope, args);
        }
        args.push(success);
        Ext.callback(options, scope, args);
        Ext.callback(options.callback, scope, args);
      }, null, {single:true});
    } else {
      args = [store, null];
      scope = scope || options.scope || inverseRecord;
      Ext.callback(options.success, scope, args);
      args.push(true);
      Ext.callback(options, scope, args);
      Ext.callback(options.callback, scope, args);
    }
  }
  if (load && !store.isLoading()) {
    store.load();
  }
  return store;
}, getAssociatedItem:function(rec) {
  var key = this.isMany ? this.getStoreName() : this.getInstanceName();
  return rec[key] || null;
}, onDrop:Ext.emptyFn, getReaderRoot:function() {
  var me = this;
  return me.associationKey || (me.associationKey = me.association.schema.getNamer().readerRoot(me.role));
}, getReader:function() {
  var me = this, reader = me.reader, Model = me.cls, useSimpleAccessors = !me.associationKey, root = this.getReaderRoot();
  if (reader && !reader.isReader) {
    if (Ext.isString(reader)) {
      reader = {type:reader};
    }
    Ext.applyIf(reader, {model:Model, rootProperty:root, useSimpleAccessors:useSimpleAccessors, type:me.defaultReaderType});
    reader = me.reader = Ext.createByAlias('reader.' + reader.type, reader);
  }
  return reader;
}, getInstanceName:function() {
  var me = this;
  return me.instanceName || (me.instanceName = me.association.schema.getNamer().instanceName(me.role));
}, getOldInstanceName:function() {
  return this.oldInstanceName || (this.oldInstanceName = '$old' + this.getInstanceName());
}, getStoreName:function() {
  var me = this;
  return me.storeName || (me.storeName = me.association.schema.getNamer().storeName(me.role));
}, constructReader:function(fromReader) {
  var me = this, reader = me.getReader(), Model = me.cls, useSimpleAccessors = !me.associationKey, root = me.getReaderRoot(), proxyReader, proxy;
  if (!reader) {
    proxy = Model.getProxy();
    if (proxy) {
      proxyReader = proxy.getReader();
      reader = new proxyReader.self;
      reader.copyFrom(proxyReader);
      reader.setRootProperty(root);
    } else {
      reader = new fromReader.self({model:Model, useSimpleAccessors:useSimpleAccessors, rootProperty:root});
    }
    me.reader = reader;
  }
  return reader;
}, read:function(record, data, fromReader, readOptions) {
  var reader = this.constructReader(fromReader), root = reader.getRoot(data);
  if (root) {
    return reader.readRecords(root, readOptions, this._internalReadOptions);
  }
}, getCallbackOptions:function(options, scope, defaultScope) {
  if (typeof options === 'function') {
    options = {callback:options, scope:scope || defaultScope};
  } else {
    if (options) {
      options = Ext.apply({}, options);
      options.scope = scope || options.scope || defaultScope;
    }
  }
  return options;
}, doGetFK:function(leftRecord, options, scope) {
  var me = this, cls = me.cls, foreignKey = me.association.getFieldName(), instanceName = me.getInstanceName(), rightRecord = leftRecord[instanceName], reload = options && options.reload, done = rightRecord !== undefined && !reload, session = leftRecord.session, foreignKeyId, args;
  if (!done) {
    if (session) {
      foreignKeyId = leftRecord.get(foreignKey);
      if (foreignKeyId || foreignKeyId === 0) {
        done = session.peekRecord(cls, foreignKeyId, true) && !reload;
        rightRecord = session.getRecord(cls, foreignKeyId, false);
      } else {
        done = true;
        leftRecord[instanceName] = rightRecord = null;
      }
    } else {
      if (foreignKey) {
        foreignKeyId = leftRecord.get(foreignKey);
        if (!foreignKeyId && foreignKeyId !== 0) {
          done = true;
          leftRecord[instanceName] = rightRecord = null;
        } else {
          if (!rightRecord) {
            rightRecord = cls.createWithId(foreignKeyId);
          }
        }
      } else {
        done = true;
      }
    }
  } else {
    if (rightRecord) {
      done = !rightRecord.isLoading();
    }
  }
  if (done) {
    if (options) {
      args = [rightRecord, null];
      scope = scope || options.scope || leftRecord;
      Ext.callback(options.success, scope, args);
      args.push(true);
      Ext.callback(options, scope, args);
      Ext.callback(options.callback, scope, args);
    }
  } else {
    leftRecord[instanceName] = rightRecord;
    options = me.getCallbackOptions(options, scope, leftRecord);
    rightRecord.load(options);
  }
  return rightRecord;
}, doSetFK:function(leftRecord, rightRecord, options, scope) {
  var me = this, foreignKey = me.association.getFieldName(), instanceName = me.getInstanceName(), current = leftRecord[instanceName], inverse = me.inverse, inverseSetter = inverse.setterName, session = leftRecord.session, modified, oldInstanceName;
  if (rightRecord && rightRecord.isEntity) {
    if (current !== rightRecord) {
      oldInstanceName = me.getOldInstanceName();
      leftRecord[oldInstanceName] = current;
      leftRecord[instanceName] = rightRecord;
      if (current && current.isEntity) {
        current[inverse.getInstanceName()] = undefined;
      }
      if (foreignKey) {
        leftRecord.set(foreignKey, rightRecord.getId());
      }
      delete leftRecord[oldInstanceName];
      if (inverseSetter) {
        rightRecord[inverseSetter](leftRecord);
      }
    }
  } else {
    if (!foreignKey) {
      Ext.raise('No foreignKey specified for "' + me.association.left.role + '" by ' + leftRecord.$className);
    }
    modified = leftRecord.changingKey && !inverse.isMany || leftRecord.set(foreignKey, rightRecord);
    if (modified && current && current.isEntity && !current.isEqual(current.getId(), rightRecord)) {
      leftRecord[instanceName] = undefined;
      if (!inverse.isMany) {
        current[inverse.getInstanceName()] = undefined;
      }
    }
  }
  if (options) {
    if (Ext.isFunction(options)) {
      options = {callback:options, scope:scope || leftRecord};
    }
    return leftRecord.save(options);
  }
}});
Ext.define('Ext.data.schema.Association', {isOneToOne:false, isManyToOne:false, isManyToMany:false, owner:null, field:null, constructor:function(config) {
  var me = this, left, right;
  Ext.apply(me, config);
  me.left = left = new me.Left(me, me.left);
  me.right = right = new me.Right(me, me.right);
  left.inverse = right;
  right.inverse = left;
}, hasField:function() {
  return !!this.field;
}, getFieldName:function() {
  var field = this.field;
  return field ? field.name : '';
}});
Ext.define('Ext.data.schema.OneToOne', {extend:Ext.data.schema.Association, isOneToOne:true, isToOne:true, kind:'one-to-one', Left:Ext.define(null, {extend:'Ext.data.schema.Role', onDrop:function(rightRecord, session) {
  var leftRecord = this.getAssociatedItem(rightRecord);
  rightRecord[this.getInstanceName()] = null;
  if (leftRecord) {
    leftRecord[this.inverse.getInstanceName()] = null;
  }
}, createGetter:function() {
  var me = this;
  return function() {
    return me.doGet(this);
  };
}, createSetter:function() {
  var me = this;
  return function(value) {
    return me.doSet(this, value);
  };
}, doGet:function(rightRecord) {
  var instanceName = this.getInstanceName(), ret = rightRecord[instanceName], session = rightRecord.session;
  if (!ret && session) {
  }
  return ret || null;
}, doSet:function(rightRecord, leftRecord) {
  var instanceName = this.getInstanceName(), ret = rightRecord[instanceName], inverseSetter = this.inverse.setterName;
  if (ret !== leftRecord) {
    rightRecord[instanceName] = leftRecord;
    if (inverseSetter) {
      leftRecord[inverseSetter](rightRecord);
    }
  }
  return ret;
}, read:function(rightRecord, node, fromReader, readOptions) {
  var me = this, leftRecords = me.callParent([rightRecord, node, fromReader, readOptions]), leftRecord;
  if (leftRecords) {
    leftRecord = leftRecords[0];
    if (leftRecord) {
      leftRecord[me.inverse.getInstanceName()] = rightRecord;
      rightRecord[me.getInstanceName()] = leftRecord;
      delete rightRecord.data[me.role];
    }
  }
}}), Right:Ext.define(null, {extend:'Ext.data.schema.Role', left:false, side:'right', createGetter:function() {
  var me = this;
  return function(options, scope) {
    return me.doGetFK(this, options, scope);
  };
}, createSetter:function() {
  var me = this;
  return function(value, options, scope) {
    return me.doSetFK(this, value, options, scope);
  };
}, onDrop:function(leftRecord, session) {
  var me = this, field = me.association.field, rightRecord = me.getAssociatedItem(leftRecord), id;
  if (me.inverse.owner) {
    if (session) {
      id = leftRecord.get(field.name);
      if (id || id === 0) {
        rightRecord = session.getEntry(me.cls, id).record;
        if (rightRecord) {
          rightRecord.drop();
        }
      }
    } else {
      if (rightRecord) {
        rightRecord.drop();
      }
    }
  }
  if (field) {
    leftRecord.set(field.name, null);
  }
  leftRecord[me.getInstanceName()] = null;
  if (rightRecord) {
    rightRecord[me.inverse.getInstanceName()] = null;
  }
}, onValueChange:function(leftRecord, session, newValue) {
  var me = this, rightRecord = leftRecord[me.getOldInstanceName()] || me.getAssociatedItem(leftRecord), hasNewValue = newValue || newValue === 0, instanceName = me.getInstanceName(), cls = me.cls;
  leftRecord.changingKey = true;
  me.doSetFK(leftRecord, newValue);
  if (!hasNewValue) {
    leftRecord[instanceName] = null;
  } else {
    if (session && cls) {
      leftRecord[instanceName] = session.peekRecord(cls, newValue) || undefined;
    }
  }
  if (me.inverse.owner && rightRecord) {
    me.association.schema.queueKeyCheck(rightRecord, me);
  }
  leftRecord.changingKey = false;
}, checkKeyForDrop:function(rightRecord) {
  var leftRecord = this.inverse.getAssociatedItem(rightRecord);
  if (!leftRecord) {
    rightRecord.drop();
  }
}, read:function(leftRecord, node, fromReader, readOptions) {
  var me = this, rightRecords = me.callParent([leftRecord, node, fromReader, readOptions]), rightRecord, field, fieldName, session, refs, id, oldId, setKey, data;
  if (rightRecords) {
    rightRecord = rightRecords[0];
    field = me.association.field;
    if (field) {
      fieldName = field.name;
    }
    session = leftRecord.session;
    data = leftRecord.data;
    if (rightRecord) {
      if (session) {
        refs = session.getRefs(rightRecord, this.inverse, true);
        setKey = refs && refs[leftRecord.id] || data[fieldName] === undefined;
      } else {
        setKey = true;
      }
      if (setKey) {
        if (field) {
          oldId = data[fieldName];
          id = rightRecord.id;
          if (oldId !== id) {
            data[fieldName] = id;
            if (session) {
              session.updateReference(leftRecord, field, id, oldId);
            }
          }
        }
        rightRecord[me.inverse.getInstanceName()] = leftRecord;
        leftRecord[me.getInstanceName()] = rightRecord;
      }
      delete data[me.role];
    }
  }
}})});
Ext.define('Ext.data.schema.ManyToOne', {extend:Ext.data.schema.Association, isManyToOne:true, isToOne:true, kind:'many-to-one', Left:Ext.define(null, {extend:'Ext.data.schema.Role', isMany:true, onDrop:function(rightRecord, session) {
  var me = this, store = me.getAssociatedItem(rightRecord), leftRecords, len, i, refs, id;
  if (store) {
    leftRecords = store.removeAll();
    if (leftRecords && me.inverse.owner) {
      for (i = 0, len = leftRecords.length; i < len; ++i) {
        leftRecords[i].drop();
      }
    }
    store.destroy();
    rightRecord[me.getStoreName()] = null;
  } else {
    if (session) {
      leftRecords = session.getRefs(rightRecord, me);
      if (leftRecords) {
        for (id in leftRecords) {
          leftRecords[id].drop();
        }
      }
    }
  }
}, processUpdate:function(session, associationData) {
  var me = this, entityType = me.inverse.cls, items = associationData.R, id, rightRecord, store, leftRecords;
  if (items) {
    for (id in items) {
      rightRecord = session.peekRecord(entityType, id);
      if (rightRecord) {
        leftRecords = session.getEntityList(me.cls, items[id]);
        store = me.getAssociatedItem(rightRecord);
        if (store) {
          store.loadData(leftRecords);
          store.complete = true;
        } else {
          rightRecord[me.getterName](null, null, leftRecords);
        }
      } else {
        session.onInvalidAssociationEntity(entityType, id);
      }
    }
  }
}, findRecords:function(session, rightRecord, leftRecords, allowInfer) {
  var ret = leftRecords, refs = session.getRefs(rightRecord, this, true), field = this.association.field, fieldName = field.name, leftRecord, id, i, len, seen;
  if (!rightRecord.phantom) {
    ret = [];
    if (refs || allowInfer) {
      if (leftRecords) {
        seen = {};
        for (i = 0, len = leftRecords.length; i < len; ++i) {
          leftRecord = leftRecords[i];
          id = leftRecord.id;
          if (refs && refs[id]) {
            ret.push(leftRecord);
          } else {
            if (allowInfer && leftRecord.data[fieldName] === undefined) {
              ret.push(leftRecord);
              leftRecord.data[fieldName] = rightRecord.id;
              session.updateReference(leftRecord, field, rightRecord.id, undefined);
            }
          }
          seen[id] = true;
        }
      }
      if (refs) {
        for (id in refs) {
          if (!seen || !seen[id]) {
            ret.push(refs[id]);
          }
        }
      }
    }
  }
  return ret;
}, processLoad:function(store, rightRecord, leftRecords, session) {
  var ret = leftRecords;
  if (session) {
    ret = this.findRecords(session, rightRecord, leftRecords, true);
  }
  this.onLoadMany(rightRecord, ret, session);
  return ret;
}, adoptAssociated:function(rightRecord, session) {
  var store = this.getAssociatedItem(rightRecord), leftRecords, i, len;
  if (store) {
    store.setSession(session);
    leftRecords = store.getData().items;
    for (i = 0, len = leftRecords.length; i < len; ++i) {
      session.adopt(leftRecords[i]);
    }
  }
}, createGetter:function() {
  var me = this;
  return function(options, scope, leftRecords) {
    return me.getAssociatedStore(this, options, scope, leftRecords, me, true);
  };
}, createSetter:null, onAddToMany:function(store, leftRecords) {
  this.syncFK(leftRecords, store.getAssociatedEntity(), false);
}, onLoadMany:function(rightRecord, leftRecords, session) {
  var instanceName = this.inverse.getInstanceName(), id = rightRecord.getId(), field = this.association.field, i, len, leftRecord, oldId, data, name;
  if (field) {
    for (i = 0, len = leftRecords.length; i < len; ++i) {
      leftRecord = leftRecords[i];
      leftRecord[instanceName] = rightRecord;
      if (field) {
        name = field.name;
        data = leftRecord.data;
        oldId = data[name];
        if (oldId !== id) {
          data[name] = id;
          if (session) {
            session.updateReference(leftRecord, field, id, oldId);
          }
        }
      }
    }
  }
}, onRemoveFromMany:function(store, leftRecords) {
  this.syncFK(leftRecords, store.getAssociatedEntity(), true);
}, read:function(rightRecord, node, fromReader, readOptions) {
  var me = this, instanceName = me.inverse.getInstanceName(), leftRecords = me.callParent([rightRecord, node, fromReader, readOptions]), store, len, i;
  if (leftRecords) {
    store = rightRecord[me.getterName](null, null, leftRecords);
    delete rightRecord.data[me.role];
    leftRecords = store.getData().items;
    for (i = 0, len = leftRecords.length; i < len; ++i) {
      leftRecords[i][instanceName] = rightRecord;
    }
  }
}, syncFK:function(leftRecords, rightRecord, clearing) {
  var foreignKeyName = this.association.getFieldName(), inverse = this.inverse, setter = inverse.setterName, instanceName = inverse.getInstanceName(), i = leftRecords.length, id = rightRecord.getId(), different, leftRecord, val;
  while (i-- > 0) {
    leftRecord = leftRecords[i];
    different = !leftRecord.isEqual(id, leftRecord.get(foreignKeyName));
    val = clearing ? null : rightRecord;
    if (different !== clearing) {
      leftRecord.changingKey = true;
      leftRecord[setter](val);
      leftRecord.changingKey = false;
    } else {
      leftRecord[instanceName] = val;
    }
  }
}}), Right:Ext.define(null, {extend:'Ext.data.schema.Role', left:false, side:'right', onDrop:function(leftRecord, session) {
  var field = this.association.field;
  if (field) {
    leftRecord.set(field.name, null);
  }
  leftRecord[this.getInstanceName()] = null;
}, createGetter:function() {
  var me = this;
  return function(options, scope) {
    return me.doGetFK(this, options, scope);
  };
}, createSetter:function() {
  var me = this;
  return function(rightRecord, options, scope) {
    return me.doSetFK(this, rightRecord, options, scope);
  };
}, checkMembership:function(session, leftRecord) {
  var field = this.association.field, store;
  store = this.getSessionStore(session, leftRecord.get(field.name));
  if (store && !store.contains(leftRecord)) {
    store.add(leftRecord);
  }
}, onValueChange:function(leftRecord, session, newValue, oldValue) {
  var me = this, instanceName = me.getInstanceName(), cls = me.cls, hasNewValue, joined, store, i, len, associated, rightRecord;
  if (!leftRecord.changingKey) {
    hasNewValue = newValue || newValue === 0;
    if (!hasNewValue) {
      leftRecord[instanceName] = null;
    }
    if (session) {
      store = me.getSessionStore(session, oldValue);
      if (store) {
        store.remove(leftRecord);
      }
      if (hasNewValue) {
        store = me.getSessionStore(session, newValue);
        if (store && !store.isLoading()) {
          store.add(leftRecord);
        }
        if (cls) {
          rightRecord = session.peekRecord(cls, newValue);
        }
        leftRecord[instanceName] = rightRecord || undefined;
      }
    } else {
      joined = leftRecord.joined;
      if (joined) {
        for (i = 0, len = joined.length; i < len; ++i) {
          store = joined[i];
          if (store.isStore) {
            associated = store.getAssociatedEntity();
            if (associated && associated.self === me.cls && associated.getId() === oldValue) {
              store.remove(leftRecord);
            }
          }
        }
      }
    }
  }
  if (me.owner && newValue === null) {
    me.association.schema.queueKeyCheck(leftRecord, me);
  }
}, checkKeyForDrop:function(leftRecord) {
  var field = this.association.field;
  if (leftRecord.get(field.name) === null) {
    leftRecord.drop();
  }
}, getSessionStore:function(session, value) {
  var cls = this.cls, rec;
  if (cls) {
    rec = session.peekRecord(cls, value);
    if (rec) {
      return this.inverse.getAssociatedItem(rec);
    }
  }
}, read:function(leftRecord, node, fromReader, readOptions) {
  var rightRecords = this.callParent([leftRecord, node, fromReader, readOptions]), rightRecord;
  if (rightRecords) {
    rightRecord = rightRecords[0];
    if (rightRecord) {
      leftRecord[this.getInstanceName()] = rightRecord;
      delete leftRecord.data[this.role];
    }
  }
}})});
Ext.define('Ext.data.schema.ManyToMany', {extend:Ext.data.schema.Association, isManyToMany:true, isToMany:true, kind:'many-to-many', Left:Ext.define(null, {extend:'Ext.data.schema.Role', isMany:true, digitRe:/^\d+$/, findRecords:function(session, rightRecord, leftRecords) {
  var slice = session.getMatrixSlice(this.inverse, rightRecord.id), members = slice.members, ret = [], cls = this.cls, seen, i, len, id, member, leftRecord;
  if (leftRecords) {
    seen = {};
    for (i = 0, len = leftRecords.length; i < len; ++i) {
      leftRecord = leftRecords[i];
      id = leftRecord.id;
      member = members[id];
      if (!(member && member[2] === -1)) {
        ret.push(leftRecord);
      }
      seen[id] = true;
    }
  }
  for (id in members) {
    member = members[id];
    if (!seen || !seen[id] && (member && member[2] !== -1)) {
      leftRecord = session.peekRecord(cls, id);
      if (leftRecord) {
        ret.push(leftRecord);
      }
    }
  }
  return ret;
}, processLoad:function(store, rightRecord, leftRecords, session) {
  var ret = leftRecords;
  if (session) {
    ret = this.findRecords(session, rightRecord, leftRecords);
    this.onAddToMany(store, ret, true);
  }
  return ret;
}, processUpdate:function(session, associationData) {
  var me = this, entityType = me.inverse.cls, items = associationData.R, id, rightRecord, store, leftRecords;
  if (items) {
    for (id in items) {
      rightRecord = session.peekRecord(entityType, id);
      if (rightRecord) {
        leftRecords = session.getEntityList(me.cls, items[id]);
        store = me.getAssociatedItem(rightRecord);
        if (store) {
          store.loadData(leftRecords);
          store.complete = true;
        } else {
          rightRecord[me.getterName](null, null, leftRecords);
        }
      } else {
        session.onInvalidAssociationEntity(entityType, id);
      }
    }
  }
  me.processMatrixBlock(session, associationData.C, 1);
  me.processMatrixBlock(session, associationData.D, -1);
}, checkMembership:function(session, rightRecord) {
  var matrix = session.getMatrix(this.association, true), side, entityType, inverse, slice, slices, id, members, member, leftRecord, store;
  if (!matrix) {
    return;
  }
  side = this.left ? matrix.right : matrix.left;
  entityType = side.inverse.role.cls;
  inverse = this.inverse;
  slices = side.slices;
  if (slices) {
    slice = slices[rightRecord.id];
    if (slice) {
      members = slice.members;
      for (id in members) {
        member = members[id];
        if (member[2] !== -1) {
          leftRecord = session.peekRecord(entityType, id);
          if (leftRecord) {
            store = inverse.getAssociatedItem(leftRecord);
            if (store) {
              store.matrixUpdate = 1;
              store.add(rightRecord);
              store.matrixUpdate = 0;
            }
          }
        }
      }
    }
  }
}, onStoreCreate:function(store, session, id) {
  var me = this, matrix;
  if (session) {
    matrix = session.getMatrixSlice(me.inverse, id);
    matrix.attach(store);
    matrix.notify = me.onMatrixUpdate;
    matrix.scope = me;
  }
}, processMatrixBlock:function(session, leftKeys, state) {
  var inverse = this.inverse, digitRe = this.digitRe, slice, id;
  if (leftKeys) {
    for (id in leftKeys) {
      if (digitRe.test(id)) {
        id = parseInt(id, 10);
      }
      slice = session.getMatrixSlice(inverse, id);
      slice.update(leftKeys[id], state);
    }
  }
}, createGetter:function() {
  var me = this;
  return function(options, scope, leftRecords) {
    return me.getAssociatedStore(this, options, scope, leftRecords, false);
  };
}, onAddToMany:function(store, leftRecords, load) {
  if (!store.matrixUpdate) {
    store.matrixUpdate = 1;
    store.matrix.update(leftRecords, load === true ? 0 : 1);
    store.matrixUpdate = 0;
  }
}, onRemoveFromMany:function(store, records) {
  if (!store.matrixUpdate) {
    store.matrixUpdate = 1;
    store.matrix.update(records, -1);
    store.matrixUpdate = 0;
  }
}, read:function(rightRecord, node, fromReader, readOptions) {
  var me = this, leftRecords = me.callParent([rightRecord, node, fromReader, readOptions]);
  if (leftRecords) {
    rightRecord[me.getterName](null, null, leftRecords);
    delete rightRecord.data[me.role];
  }
}, onMatrixUpdate:function(matrixSlice, id, state) {
  var store = matrixSlice.store, index, leftRecord, entry;
  if (store && !store.loading && !store.matrixUpdate) {
    store.matrixUpdate = 1;
    index = store.indexOfId(id);
    if (state < 0) {
      if (index >= 0) {
        store.remove([index]);
      }
    } else {
      if (index < 0) {
        entry = store.getSession().getEntry(this.type, id);
        leftRecord = entry && entry.record;
        if (leftRecord) {
          store.add(leftRecord);
        }
      }
    }
    store.matrixUpdate = 0;
  }
}, adoptAssociated:function(record, session) {
  var store = this.getAssociatedItem(record), records, i, len;
  if (store) {
    store.setSession(session);
    this.onStoreCreate(store, session, record.getId());
    records = store.getData().items;
    for (i = 0, len = records.length; i < len; ++i) {
      session.adopt(records[i]);
    }
  }
}}, function() {
  var Left = this;
  Ext.ClassManager.onCreated(function() {
    Ext.data.schema.ManyToMany.prototype.Right = Ext.define(null, {extend:Left, left:false, side:'right'});
  }, null, 'Ext.data.schema.ManyToMany');
})});
Ext.define('Ext.util.Inflector', {singleton:true, plurals:[[/(quiz)$/i, '$1zes'], [/^(ox)$/i, '$1en'], [/([m|l])ouse$/i, '$1ice'], [/(matr|vert|ind)ix|ex$/i, '$1ices'], [/(x|ch|ss|sh)$/i, '$1es'], [/([^aeiouy]|qu)y$/i, '$1ies'], [/(hive)$/i, '$1s'], [/(?:([^f])fe|([lr])f)$/i, '$1$2ves'], [/sis$/i, 'ses'], [/([ti])um$/i, '$1a'], [/(buffal|tomat|potat)o$/i, '$1oes'], [/(bu)s$/i, '$1ses'], [/(alias|status|sex)$/i, '$1es'], [/(octop|vir)us$/i, '$1i'], [/(ax|test)is$/i, '$1es'], [/^(p)erson$/i, '$1eople'], 
[/^(m)an$/i, '$1en'], [/(.*)(child)(ren)?$/i, '$1$2ren'], [/s$/i, 's'], [/$/, 's']], singulars:[[/(address)$/i, '$1'], [/(quiz)zes$/i, '$1'], [/(matr)ices$/i, '$1ix'], [/(vert|ind)ices$/i, '$1ex'], [/^(ox)en/i, '$1'], [/(alias|status)es$/i, '$1'], [/(octop|vir)i$/i, '$1us'], [/(cris|ax|test)es$/i, '$1is'], [/(shoe)s$/i, '$1'], [/(o)es$/i, '$1'], [/(bus)es$/i, '$1'], [/([m|l])ice$/i, '$1ouse'], [/(x|ch|ss|sh)es$/i, '$1'], [/(m)ovies$/i, '$1ovie'], [/(s)eries$/i, '$1eries'], [/([^aeiouy]|qu)ies$/i, 
'$1y'], [/([lr])ves$/i, '$1f'], [/(tive)s$/i, '$1'], [/(hive)s$/i, '$1'], [/([^f])ves$/i, '$1fe'], [/(^analy)ses$/i, '$1sis'], [/((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$/i, '$1$2sis'], [/([ti])a$/i, '$1um'], [/(n)ews$/i, '$1ews'], [/(p)eople$/i, '$1erson'], [/s$/i, '']], uncountable:['sheep', 'fish', 'series', 'species', 'money', 'rice', 'information', 'equipment', 'grass', 'mud', 'offspring', 'deer', 'means'], singular:function(matcher, replacer) {
  this.singulars.unshift([matcher, replacer]);
}, plural:function(matcher, replacer) {
  this.plurals.unshift([matcher, replacer]);
}, clearSingulars:function() {
  this.singulars = [];
}, clearPlurals:function() {
  this.plurals = [];
}, isTransnumeral:function(word) {
  return Ext.Array.indexOf(this.uncountable, word) != -1;
}, pluralize:function(word) {
  if (this.isTransnumeral(word)) {
    return word;
  }
  var plurals = this.plurals, length = plurals.length, tuple, regex, i;
  for (i = 0; i < length; i++) {
    tuple = plurals[i];
    regex = tuple[0];
    if (regex == word || regex.test && regex.test(word)) {
      return word.replace(regex, tuple[1]);
    }
  }
  return word;
}, singularize:function(word) {
  if (this.isTransnumeral(word)) {
    return word;
  }
  var singulars = this.singulars, length = singulars.length, tuple, regex, i;
  for (i = 0; i < length; i++) {
    tuple = singulars[i];
    regex = tuple[0];
    if (regex == word || regex.test && regex.test(word)) {
      return word.replace(regex, tuple[1]);
    }
  }
  return word;
}, classify:function(word) {
  return Ext.String.capitalize(this.singularize(word));
}, ordinalize:function(number) {
  var parsed = parseInt(number, 10), mod10 = parsed % 10, mod100 = parsed % 100;
  if (11 <= mod100 && mod100 <= 13) {
    return number + 'th';
  } else {
    switch(mod10) {
      case 1:
        return number + 'st';
      case 2:
        return number + 'nd';
      case 3:
        return number + 'rd';
      default:
        return number + 'th';
    }
  }
}}, function() {
  var irregulars = {alumnus:'alumni', cactus:'cacti', focus:'foci', nucleus:'nuclei', radius:'radii', stimulus:'stimuli', ellipsis:'ellipses', paralysis:'paralyses', oasis:'oases', appendix:'appendices', index:'indexes', beau:'beaux', bureau:'bureaux', tableau:'tableaux', woman:'women', child:'children', man:'men', corpus:'corpora', criterion:'criteria', curriculum:'curricula', genus:'genera', memorandum:'memoranda', phenomenon:'phenomena', foot:'feet', goose:'geese', tooth:'teeth', antenna:'antennae', 
  formula:'formulae', nebula:'nebulae', vertebra:'vertebrae', vita:'vitae'}, singular;
  for (singular in irregulars) {
    if (irregulars.hasOwnProperty(singular)) {
      this.plural(singular, irregulars[singular]);
      this.singular(irregulars[singular], singular);
    }
  }
});
Ext.define('Ext.data.schema.Namer', {mixins:[Ext.mixin.Factoryable], alias:'namer.default', isNamer:true, capitalize:function(name) {
  return Ext.String.capitalize(name);
}, fieldRole:function(name) {
  var match = name.match(this.endsWithIdRe, '');
  if (match) {
    name = name.substr(0, name.length - (match[1] || match[2]).length);
  }
  return this.apply('uncapitalize', name);
}, idField:function(name) {
  return this.apply('uncapitalize,singularize', name) + 'Id';
}, instanceName:function(roleName) {
  return this.apply('underscore', roleName);
}, multiRole:function(name) {
  return this.apply('undotted,uncapitalize,pluralize', name);
}, pluralize:function(name) {
  return Ext.util.Inflector.pluralize(name);
}, readerRoot:function(roleName) {
  return this.apply('uncapitalize', roleName);
}, singularize:function(name) {
  return Ext.util.Inflector.singularize(name);
}, storeName:function(roleName) {
  return this.apply('underscore', roleName);
}, uncapitalize:function(name) {
  return Ext.String.uncapitalize(name);
}, underscore:function(name) {
  return '_' + name;
}, uniRole:function(name) {
  return this.apply('undotted,uncapitalize,singularize', name);
}, undotted:function(name) {
  if (name.indexOf('.') < 0) {
    return name;
  }
  var parts = name.split('.'), index = parts.length;
  while (index-- > 1) {
    parts[index] = this.apply('capitalize', parts[index]);
  }
  return parts.join('');
}, getterName:function(role) {
  var name = role.role;
  if (role && role.isMany) {
    return name;
  }
  return 'get' + this.apply('capitalize', name);
}, inverseFieldRole:function(leftType, unique, rightRole, rightType) {
  var me = this, leftRole = me.apply(unique ? 'uniRole' : 'multiRole', leftType), s1 = me.apply('pluralize', rightRole), s2 = me.apply('undotted,pluralize', rightType);
  if (s1.toLowerCase() !== s2.toLowerCase()) {
    leftRole = rightRole + me.apply('capitalize', leftRole);
  }
  return leftRole;
}, manyToMany:function(relation, leftType, rightType) {
  var me = this, ret = me.apply('undotted,capitalize,singularize', leftType) + me.apply('undotted,capitalize,pluralize', rightType);
  if (relation) {
    ret = me.apply('capitalize', relation + ret);
  }
  return ret;
}, manyToOne:function(leftType, leftRole, rightType, rightRole) {
  return this.apply('capitalize,singularize', rightType) + this.apply('capitalize', leftRole);
}, matrixRole:function(relation, entityType) {
  var ret = this.apply(relation ? 'multiRole,capitalize' : 'multiRole', entityType);
  return relation ? relation + ret : ret;
}, oneToOne:function(leftType, leftRole, rightType, rightRole) {
  return this.apply('undotted,capitalize,singularize', rightType) + this.apply('capitalize', leftRole);
}, setterName:function(role) {
  return 'set' + this.apply('capitalize', role.role);
}, endsWithIdRe:/(?:(_id)|[^A-Z](Id))$/, cache:{}, apply:function(operation, name) {
  var me = this, cache = me.cache, entry = cache[name] || (cache[name] = {}), ret = entry[operation], i, length, operations;
  if (!ret) {
    if (operation.indexOf(',') < 0) {
      ret = me[operation](name);
    } else {
      length = (operations = operation.split(',')).length;
      ret = name;
      for (i = 0; i < length; ++i) {
        ret = me.apply(operations[i], ret);
      }
    }
    entry[operation] = ret;
  }
  return ret;
}});
Ext.define('Ext.data.schema.Schema', {mixins:[Ext.mixin.Factoryable], alias:'schema.default', aliasPrefix:'schema.', isSchema:true, type:'default', statics:{instances:{}, get:function(config) {
  var Schema = this, cache = Schema.instances, id = 'default', isString = config && Ext.isString(config), instance, newConfig;
  if (config) {
    if (config.isSchema) {
      return config;
    }
    id = isString ? config : config.id || id;
  }
  if (!(instance = cache[id])) {
    cache[id] = instance = Schema.create(config);
    instance.id = id;
  } else {
    if (config && !isString) {
      if (id !== 'default') {
        Ext.raise('Only the default Schema instance can be reconfigured');
      }
      newConfig = Ext.merge({}, instance.config);
      Ext.merge(newConfig, config);
      instance.setConfig(newConfig);
      instance.config = newConfig;
      instance.setConfig = function() {
        Ext.raise('The schema can only be reconfigured once');
      };
    }
  }
  return instance;
}, lookupEntity:function(entity) {
  var ret = null, instances = this.instances, match, name, schema;
  if (entity) {
    if (entity.isEntity) {
      ret = entity.self;
    } else {
      if (Ext.isFunction(entity)) {
        ret = entity;
      } else {
        if (Ext.isString(entity)) {
          ret = Ext.ClassManager.get(entity);
          if (ret && (!ret.prototype || !ret.prototype.isEntity)) {
            ret = null;
          }
          if (!ret) {
            for (name in instances) {
              schema = instances[name];
              match = schema.getEntity(entity);
              if (match) {
                if (ret) {
                  Ext.raise('Ambiguous entity name "' + entity + '". Defined by schema "' + ret.schema.type + '" and "' + name + '"');
                }
                ret = match;
              }
            }
          }
          if (!ret) {
            Ext.raise('No such Entity "' + entity + '".');
          }
        }
      }
    }
  }
  return ret;
}}, assocCount:0, entityCount:0, config:{defaultIdentifier:null, keyCheckDelay:10, namer:'default', namespace:null, proxy:{type:'ajax', url:'{prefix}/{entityName}'}, urlPrefix:''}, onClassExtended:function(cls, data) {
  var alias = data.alias;
  if (alias && !data.type) {
    if (!Ext.isString(alias)) {
      alias = alias[0];
    }
    cls.prototype.type = alias.substring(this.prototype.aliasPrefix.length);
  }
}, constructor:function(config) {
  this.initConfig(config);
  this.clear();
}, applyDefaultIdentifier:function(identifier) {
  return identifier && Ext.Factory.dataIdentifier(identifier);
}, applyNamer:function(namer) {
  var ret = Ext.data.schema.Namer.create(namer);
  ret.schema = this;
  return ret;
}, applyNamespace:function(namespace) {
  if (namespace) {
    var end = namespace.length - 1;
    if (namespace.charAt(end) !== '.') {
      namespace += '.';
    }
  }
  return namespace;
}, applyProxy:function(proxy) {
  return Ext.util.ObjectTemplate.create(proxy);
}, eachAssociation:function(fn, scope) {
  var associations = this.associations, name;
  for (name in associations) {
    if (associations.hasOwnProperty(name)) {
      if (fn.call(scope, name, associations[name]) === false) {
        break;
      }
    }
  }
}, eachEntity:function(fn, scope) {
  var entities = this.entities, name;
  for (name in entities) {
    if (entities.hasOwnProperty(name)) {
      if (fn.call(scope, name, entities[name].cls) === false) {
        break;
      }
    }
  }
}, getAssociation:function(name) {
  var entry = this.associations[name];
  return entry || null;
}, getEntity:function(name) {
  var entry = this.entityClasses[name] || this.entities[name];
  return entry && entry.cls || null;
}, getEntityName:function(cls) {
  var ns = this.getNamespace(), index, name;
  if (typeof cls === 'string') {
    name = cls;
  } else {
    name = cls.$className || null;
  }
  if (name) {
    if (ns) {
      index = ns.length;
      if (name.substring(0, index) !== ns) {
        return name;
      }
    }
    if (index) {
      name = name.substring(index);
    }
  }
  return name;
}, hasAssociations:function(name) {
  name = name.entityName || name;
  return !!this.associationEntityMap[name];
}, hasEntity:function(entity) {
  var name = this.getEntityName(entity);
  return !!(this.entities[name] || this.entityClasses[name]);
}, addMatrix:function(entityType, matrixName, relation, left, right) {
  var me = this, namer = me.getNamer(), associations = me.associations, entities = me.entities, leftType = left.type, rightType = right.type, leftField = left.field || namer.apply('idField', leftType), rightField = right.field || namer.apply('idField', rightType), leftRole = left.role || namer.matrixRole(relation, leftType), rightRole = right.role || namer.matrixRole(relation, rightType), matrix, leftEntry, rightEntry;
  leftEntry = entities[leftType] || (entities[leftType] = {cls:null, name:leftType, associations:{}});
  rightEntry = entities[rightType] || (entities[rightType] = {cls:null, name:rightType, associations:{}});
  ++me.assocCount;
  associations[matrixName] = matrix = new Ext.data.schema.ManyToMany({name:matrixName, schema:me, definedBy:entityType, left:{cls:leftEntry.cls, type:leftType, role:leftRole, field:leftField, associationKey:left.associationKey}, right:{cls:rightEntry.cls, type:rightType, role:rightRole, field:rightField, associationKey:right.associationKey}});
  leftEntry.associations[matrix.right.role] = matrix.right;
  rightEntry.associations[matrix.left.role] = matrix.left;
  if (leftEntry.cls) {
    me.associationEntityMap[leftEntry.cls.entityName] = true;
  }
  if (rightEntry.cls) {
    me.associationEntityMap[rightEntry.cls.entityName] = true;
  }
  me.decorateModel(matrix);
}, addReference:function(entityType, referenceField, descr, unique) {
  var me = this, namer = me.getNamer(), entities = me.entities, associations = me.associations, entityName = entityType.entityName, association = descr.association, legacy = !!descr.legacy, child = descr.child, parent = descr.parent, rightRole = descr.role, rightType = descr.type || parent || child, leftVal = descr.inverse, left = Ext.isString(leftVal) ? {role:leftVal} : leftVal, leftRole = left && left.role, entry, T;
  if (!rightRole) {
    if (legacy) {
      rightRole = namer.apply('uncapitalize', rightType);
    } else {
      rightRole = namer.apply('fieldRole', referenceField.name);
    }
  }
  if (!leftRole) {
    leftRole = namer.inverseFieldRole(entityName, unique, rightRole, rightType);
  }
  if (!association) {
    if (unique) {
      association = namer.oneToOne(entityType, leftRole, rightType, rightRole);
    } else {
      association = namer.manyToOne(entityType, leftRole, rightType, rightRole);
    }
  }
  if (association in associations) {
    Ext.raise('Duplicate association: "' + association + '" declared by ' + entityName + (referenceField ? '.' + referenceField.name : '') + ' (collides with ' + associations[association].definedBy.entityName + ')');
  }
  if (referenceField && referenceField.definedBy === entities[rightType]) {
    Ext.raise('ForeignKey reference should not be owned by the target model');
  }
  entry = entities[rightType] || (entities[rightType] = {cls:null, name:rightType, associations:{}});
  T = unique ? Ext.data.schema.OneToOne : Ext.data.schema.ManyToOne;
  association = new T({name:association, owner:child ? 'left' : parent ? 'right' : null, definedBy:entityType, schema:me, field:referenceField, nullable:referenceField ? !!referenceField.allowBlank : true, legacy:descr.legacy, left:{cls:entityType, type:entityName, role:leftRole, extra:left}, right:{cls:entry.cls, type:rightType, role:rightRole, extra:descr}});
  entityType.associations[rightRole] = association.right;
  entry.associations[leftRole] = association.left;
  if (referenceField) {
    referenceField.reference = association.right;
    entityType.references.push(referenceField);
  }
  ++me.assocCount;
  me.associationEntityMap[entityName] = true;
  if (entry.cls) {
    me.associationEntityMap[entry.cls.entityName] = true;
  }
  associations[association.name] = association;
  if (association.right.cls) {
    me.decorateModel(association);
  }
}, privates:{addEntity:function(entityType) {
  var me = this, entities = me.entities, entityName = entityType.entityName, entry = entities[entityName], fields = entityType.fields, associations, field, i, length, name;
  if (!entry) {
    entities[entityName] = entry = {name:entityName, associations:{}};
  } else {
    if (entry.cls) {
      Ext.raise('Duplicate entity name "' + entityName + '": ' + entry.cls.$className + ' and ' + entityType.$className);
    } else {
      associations = entry.associations;
      for (name in associations) {
        associations[name].inverse.cls = entityType;
        me.associationEntityMap[entityName] = true;
        me.decorateModel(associations[name].association);
      }
    }
  }
  entry.cls = entityType;
  entityType.prototype.associations = entityType.associations = entry.associations;
  me.entityClasses[entityType.$className] = entry;
  ++me.entityCount;
  for (i = 0, length = fields.length; i < length; ++i) {
    field = fields[i];
    if (field.reference) {
      me.addReferenceDescr(entityType, field);
    }
  }
}, addMatrices:function(entityType, matrices) {
  var me = this, i, length, matrixName;
  if (Ext.isString(matrices)) {
    me.addMatrixDescr(entityType, null, matrices);
  } else {
    if (matrices[0]) {
      for (i = 0, length = matrices.length; i < length; ++i) {
        me.addMatrixDescr(entityType, null, matrices[i]);
      }
    } else {
      for (matrixName in matrices) {
        me.addMatrixDescr(entityType, matrixName, matrices[matrixName]);
      }
    }
  }
}, addMatrixDescr:function(entityType, matrixName, matrixDef) {
  var me = this, entityName = entityType.entityName, associations = me.associations, namer = me.getNamer(), left = matrixDef.left, right = matrixDef.right, last, relation;
  if (Ext.isString(matrixDef)) {
    if (matrixDef.charAt(0) === '#') {
      left = {type:entityName};
      right = {type:matrixDef.substring(1)};
    } else {
      if (matrixDef.charAt(last = matrixDef.length - 1) === '#') {
        left = {type:matrixDef.substring(0, last)};
        right = {type:entityName};
      } else {
        if (namer.apply('multiRole', entityName) < namer.apply('multiRole', matrixDef)) {
          left = {type:entityName};
          right = {type:matrixDef};
        } else {
          left = {type:matrixDef};
          right = {type:entityName};
        }
      }
    }
  } else {
    Ext.Assert.isString(matrixDef.type, 'No "type" for manyToMany in ' + entityName);
    relation = matrixDef.relation;
    if (left || !right && namer.apply('multiRole', entityName) < namer.apply('multiRole', matrixDef.type)) {
      if (!left || left === true) {
        left = {type:entityName};
      } else {
        left = Ext.apply({type:entityName}, left);
      }
      right = matrixDef;
    } else {
      if (!right || right === true) {
        right = {type:entityName};
      } else {
        right = Ext.apply({type:entityName}, right);
      }
      left = matrixDef;
    }
  }
  if (!matrixName) {
    matrixName = namer.manyToMany(relation, left.type, right.type);
  }
  if (!(matrixName in associations)) {
    me.addMatrix(entityType, matrixName, relation, left, right);
  } else {
    var entry = associations[matrixName], before = [entry.kind, entry.left.type, entry.left.role, entry.left.field, entry.right.type, entry.right.role, entry.right.field].join('|');
    delete associations[matrixName];
    me.addMatrix(entityType, matrixName, relation, left, right);
    var after = associations[matrixName];
    associations[matrixName] = entry;
    entry.left.cls.associations[entry.right.role] = entry.right;
    entry.right.cls.associations[entry.left.role] = entry.left;
    --me.assocCount;
    after = [after.kind, after.left.type, after.left.role, after.left.field, after.right.type, after.right.role, after.right.field].join('|');
    if (before != after) {
      Ext.log.warn(matrixName + '(' + entry.definedBy.entityName + '): ' + before);
      Ext.log.warn(matrixName + '(' + entityName + '): ' + after);
      Ext.raise('Conflicting association: "' + matrixName + '" declared by ' + entityName + ' was previously declared by ' + entry.definedBy.entityName);
    }
  }
}, addReferenceDescr:function(entityType, referenceField) {
  var me = this, descr = referenceField.$reference;
  if (Ext.isString(descr)) {
    descr = {type:descr};
  } else {
    descr = Ext.apply({}, descr);
  }
  if (descr.legacy) {
    if (descr.single) {
      me.addLegacySingle(entityType, descr);
    } else {
      me.addLegacyHasMany(entityType, descr);
    }
  } else {
    me.addReference(entityType, referenceField, descr, referenceField.unique);
  }
}, addPending:function(name, entityType, assoc, type) {
  var pending = this.pending;
  if (!pending[name]) {
    pending[name] = [];
  }
  pending[name].push([entityType, assoc, type]);
}, addLegacyBelongsTo:function(entityType, assoc) {
  this.addLegacySingle(entityType, assoc);
}, addLegacyHasOne:function(entityType, assoc) {
  this.addLegacySingle(entityType, assoc);
}, addLegacySingle:function(entityType, assoc) {
  var foreignKey, name, referenceField;
  assoc = this.constructLegacyAssociation(entityType, assoc);
  assoc.single = true;
  name = assoc.type;
  foreignKey = assoc.foreignKey || name.toLowerCase() + '_id';
  referenceField = entityType.getField(foreignKey);
  if (referenceField) {
    referenceField.$reference = assoc;
  }
  this.addReference(entityType, referenceField, assoc, true);
}, addLegacyHasMany:function(entityType, assoc) {
  var me = this, entities = me.entities, pending = me.pending, associationKey = assoc.associationKey, cls, name, referenceField, target, foreignKey, assocName;
  assoc = this.constructLegacyAssociation(entityType, assoc);
  name = assoc.type;
  target = entities[name];
  if (target && target.cls) {
    assoc.type = entityType.entityName;
    foreignKey = assoc.foreignKey || assoc.type.toLowerCase() + '_id';
    cls = target.cls;
    referenceField = cls.getField(foreignKey);
    assoc.inverse = assoc || {};
    assocName = assoc.name;
    if (assocName || associationKey) {
      if (assocName) {
        assoc.inverse.role = assocName;
      }
      if (associationKey) {
        assoc.inverse.associationKey = associationKey;
      }
    }
    if (referenceField) {
      referenceField.$reference = assoc;
    }
    me.addReference(cls, referenceField, assoc, false);
  } else {
    if (!pending[name]) {
      pending[name] = [];
    }
    pending[name].push([entityType, assoc]);
  }
}, constructLegacyAssociation:function(entityType, assoc) {
  if (Ext.isString(assoc)) {
    assoc = {model:assoc};
  }
  assoc.legacy = true;
  assoc.type = this.getEntityName(assoc.model);
  var name = assoc.associatedName || assoc.name;
  if (name) {
    assoc.role = name;
  }
  return assoc;
}, afterLegacyAssociations:function(cls) {
  var pending = this.pending, name = cls.entityName, mine = pending[name], i, len;
  if (mine) {
    for (i = 0, len = mine.length; i < len; ++i) {
      this.addLegacyHasMany.apply(this, mine[i]);
    }
    delete pending[name];
  }
}, clear:function(clearNamespace) {
  var me = this, timer = me.timer;
  delete me.setConfig;
  if (timer) {
    window.clearTimeout(timer);
    me.timer = null;
  }
  me.associations = {};
  me.associationEntityMap = {};
  me.entities = {};
  me.entityClasses = {};
  me.pending = {};
  me.assocCount = me.entityCount = 0;
  if (clearNamespace) {
    me.setNamespace(null);
  }
}, constructProxy:function(Model) {
  var me = this, data = Ext.Object.chain(Model), proxy = me.getProxy();
  data.schema = me;
  data.prefix = me.getUrlPrefix();
  return proxy.apply(data);
}, applyDecoration:function(role) {
  var me = this, cls = role.inverse.cls, namer = me.getNamer(), getterName, setterName, proto;
  if (cls && !role.decorated) {
    role.decorated = true;
    proto = cls.prototype;
    if (!(getterName = role.getterName)) {
      role.getterName = getterName = namer.getterName(role);
    }
    proto[getterName] = role.createGetter();
    if (role.createSetter) {
      if (!(setterName = role.setterName)) {
        role.setterName = setterName = namer.setterName(role);
      }
      proto[setterName] = role.createSetter();
    }
  }
}, decorateModel:function(association) {
  this.applyDecoration(association.left);
  this.applyDecoration(association.right);
}, processKeyChecks:function(processAll) {
  var me = this, keyCheckQueue = me.keyCheckQueue, timer = me.timer, len, i, item;
  if (timer) {
    window.clearTimeout(timer);
    me.timer = null;
  }
  if (!keyCheckQueue) {
    return;
  }
  do {
    keyCheckQueue = me.keyCheckQueue;
    me.keyCheckQueue = [];
    for (i = 0, len = keyCheckQueue.length; i < len; ++i) {
      item = keyCheckQueue[i];
      item.role.checkKeyForDrop(item.record);
    }
  } while (processAll && me.keyCheckQueue.length);
}, queueKeyCheck:function(record, role) {
  var me = this, keyCheckQueue = me.keyCheckQueue, timer = me.timer;
  if (!keyCheckQueue) {
    me.keyCheckQueue = keyCheckQueue = [];
  }
  keyCheckQueue.push({record:record, role:role});
  if (!timer) {
    me.timer = timer = Ext.Function.defer(me.processKeyChecks, me.getKeyCheckDelay(), me);
  }
}, rankEntities:function() {
  var me = this, entities = me.entities, entityNames = Ext.Object.getKeys(entities), length = entityNames.length, entityType, i;
  me.nextRank = 1;
  entityNames.sort();
  for (i = 0; i < length; ++i) {
    entityType = entities[entityNames[i]].cls;
    if (!entityType.rank) {
      me.rankEntity(entityType);
    }
  }
  me.topoStack = null;
}, rankEntity:function(entityType) {
  var associations = entityType.associations, associatedType, role, roleName;
  var topoStack = this.topoStack || (this.topoStack = []), entityName = entityType.entityName;
  topoStack.push(entityName);
  if (entityType.rank === 0) {
    Ext.raise(entityName + ' has circular foreign-key references: ' + topoStack.join(' --\x3e '));
  }
  entityType.rank = 0;
  for (roleName in associations) {
    role = associations[roleName];
    if (!role.left && role.association.field) {
      associatedType = role.cls;
      if (!associatedType.rank) {
        this.rankEntity(associatedType);
      }
    }
  }
  entityType.rank = this.nextRank++;
  topoStack.pop();
}}});
Ext.define('Ext.data.AbstractStore', {mixins:[Ext.mixin.Observable, Ext.mixin.Factoryable], factoryConfig:{defaultType:'store', type:'store'}, $configPrefixed:false, $configStrict:false, config:{filters:null, autoDestroy:undefined, storeId:null, statefulFilters:false, sorters:null, remoteSort:{lazy:true, $value:false}, remoteFilter:{lazy:true, $value:false}, groupField:undefined, groupDir:'ASC', grouper:null, pageSize:25}, currentPage:1, loading:false, isStore:true, updating:0, constructor:function(config) {
  var me = this, storeId;
  me.isInitializing = true;
  me.mixins.observable.constructor.call(me, config);
  me.isInitializing = false;
  storeId = me.getStoreId();
  if (!storeId && (config && config.id)) {
    me.setStoreId(storeId = config.id);
  }
  if (storeId) {
    Ext.data.StoreManager.register(me);
  }
}, getCount:function() {
  return this.getData().getCount();
}, rangeCached:function(start, end) {
  return this.getData().getCount() >= Math.max(start, end);
}, find:function(property, value, startIndex, anyMatch, caseSensitive, exactMatch) {
  var startsWith = !anyMatch, endsWith = !!(startsWith && exactMatch);
  return this.getData().findIndex(property, value, startIndex, startsWith, endsWith, !caseSensitive);
}, findRecord:function() {
  var me = this, index = me.find.apply(me, arguments);
  return index !== -1 ? me.getAt(index) : null;
}, findExact:function(property, value, start) {
  return this.getData().findIndexBy(function(rec) {
    return rec.isEqual(rec.get(property), value);
  }, this, start);
}, findBy:function(fn, scope, start) {
  return this.getData().findIndexBy(fn, scope, start);
}, getAt:function(index) {
  return this.getData().getAt(index) || null;
}, getRange:function(start, end, options) {
  var result = this.getData().getRange(start, Ext.isNumber(end) ? end + 1 : end);
  if (options && options.callback) {
    options.callback.call(options.scope || this, result, start, end, options);
  }
  return result;
}, getFilters:function(autoCreate) {
  var result = this.callParent();
  if (!result && autoCreate !== false) {
    this.setFilters([]);
    result = this.callParent();
  }
  return result;
}, applyFilters:function(filters, filtersCollection) {
  var created;
  if (!filtersCollection) {
    filtersCollection = this.createFiltersCollection();
    created = true;
  }
  filtersCollection.add(filters);
  if (created) {
    this.onRemoteFilterSet(filtersCollection, this.getRemoteFilter());
  }
  return filtersCollection;
}, getSorters:function(autoCreate) {
  var result = this.callParent();
  if (!result && autoCreate !== false) {
    this.setSorters([]);
    result = this.callParent();
  }
  return result;
}, applySorters:function(sorters, sortersCollection) {
  var created;
  if (!sortersCollection) {
    sortersCollection = this.createSortersCollection();
    created = true;
  }
  sortersCollection.add(sorters);
  if (created) {
    this.onRemoteSortSet(sortersCollection, this.getRemoteSort());
  }
  return sortersCollection;
}, filter:function(filters, value, supressEvent) {
  if (Ext.isString(filters)) {
    filters = {property:filters, value:value};
  }
  this.suppressNextFilter = !!supressEvent;
  this.getFilters().add(filters);
  this.suppressNextFilter = false;
}, removeFilter:function(filter, supressEvent) {
  var me = this, filters = me.getFilters();
  me.suppressNextFilter = !!supressEvent;
  if (filter instanceof Ext.util.Filter) {
    filters.remove(filter);
  } else {
    filters.removeByKey(filter);
  }
  me.suppressNextFilter = false;
}, updateRemoteSort:function(remoteSort) {
  this.onRemoteSortSet(this.getSorters(false), remoteSort);
}, updateRemoteFilter:function(remoteFilter) {
  this.onRemoteFilterSet(this.getFilters(false), remoteFilter);
}, addFilter:function(filters, supressEvent) {
  this.suppressNextFilter = !!supressEvent;
  this.getFilters().add(filters);
  this.suppressNextFilter = false;
}, filterBy:function(fn, scope) {
  this.getFilters().add({filterFn:fn, scope:scope || this});
}, clearFilter:function(supressEvent) {
  var me = this, filters = me.getFilters(false);
  if (!filters || filters.getCount() === 0) {
    return;
  }
  me.suppressNextFilter = !!supressEvent;
  filters.removeAll();
  me.suppressNextFilter = false;
}, isFiltered:function() {
  return this.getFilters().getCount() > 0;
}, isSorted:function() {
  var sorters = this.getSorters(false);
  return !!(sorters && sorters.length > 0) || this.isGrouped();
}, addFieldTransform:function(sorter) {
  if (sorter.getTransform()) {
    return;
  }
  var fieldName = sorter.getProperty(), Model = this.getModel(), field, sortType;
  if (Model) {
    field = Model.getField(fieldName);
    sortType = field ? field.getSortType() : null;
  }
  if (sortType && sortType !== Ext.identityFn) {
    sorter.setTransform(sortType);
  }
}, beginUpdate:function() {
  if (!this.updating++) {
    this.fireEvent('beginupdate');
  }
}, endUpdate:function() {
  if (this.updating && !--this.updating) {
    this.fireEvent('endupdate');
    this.onEndUpdate();
  }
}, getState:function() {
  var me = this, sorters = [], filters = me.getFilters(), grouper = me.getGrouper(), filterState, hasState, result;
  me.getSorters().each(function(s) {
    sorters[sorters.length] = s.getState();
    hasState = true;
  });
  if (me.statefulFilters && me.saveStatefulFilters) {
    hasState = true;
    filterState = [];
    filters.each(function(f) {
      filterState[filterState.length] = f.getState();
    });
  }
  if (grouper) {
    hasState = true;
  }
  if (hasState) {
    result = {};
    if (sorters.length) {
      result.sorters = sorters;
    }
    if (filterState) {
      result.filters = filterState;
    }
    if (grouper) {
      result.grouper = grouper.getState();
    }
  }
  return result;
}, applyState:function(state) {
  var me = this, stateSorters = state.sorters, stateFilters = state.filters, stateGrouper = state.grouper;
  if (stateSorters) {
    me.getSorters().replaceAll(stateSorters);
  }
  if (stateFilters) {
    me.saveStatefulFilters = true;
    me.getFilters().replaceAll(stateFilters);
  }
  if (stateGrouper) {
    me.setGrouper(stateGrouper);
  }
}, hasPendingLoad:Ext.emptyFn, isLoaded:Ext.emptyFn, isLoading:Ext.emptyFn, destroy:function() {
  var me = this;
  if (me.getStoreId()) {
    Ext.data.StoreManager.unregister(me);
  }
  me.callParent();
  me.onDestroy();
}, sort:function(field, direction, mode) {
  var me = this;
  if (arguments.length === 0) {
    if (me.getRemoteSort()) {
      me.load();
    } else {
      me.forceLocalSort();
    }
  } else {
    me.getSorters().addSort(field, direction, mode);
  }
}, onBeforeCollectionSort:function(store, sorters) {
  if (sorters) {
    this.fireEvent('beforesort', this, sorters.getRange());
  }
}, onSorterEndUpdate:function() {
  var me = this, sorters;
  sorters = me.getSorters(false);
  if (me.settingGroups || !sorters) {
    return;
  }
  sorters = sorters.getRange();
  if (sorters.length) {
    if (me.getRemoteSort()) {
      me.load({callback:function() {
        me.fireEvent('sort', me, sorters);
      }});
    } else {
      me.fireEvent('datachanged', me);
      me.fireEvent('refresh', me);
      me.fireEvent('sort', me, sorters);
    }
  } else {
    me.fireEvent('sort', me, sorters);
  }
}, onFilterEndUpdate:function() {
  var me = this, suppressNext = me.suppressNextFilter;
  if (me.getRemoteFilter()) {
    me.getFilters().each(function(filter) {
      if (filter.getInitialConfig().filterFn) {
        Ext.raise('Unable to use a filtering function in conjunction with remote filtering.');
      }
    });
    me.currentPage = 1;
    if (!suppressNext) {
      me.load();
    }
  } else {
    if (!suppressNext) {
      me.fireEvent('datachanged', me);
      me.fireEvent('refresh', me);
    }
  }
  if (me.trackStateChanges) {
    me.saveStatefulFilters = true;
  }
  me.fireEvent('filterchange', me, me.getFilters().getRange());
}, updateGroupField:function(field) {
  if (field) {
    this.setGrouper({property:field, direction:this.getGroupDir()});
  } else {
    this.setGrouper(null);
  }
}, getGrouper:function() {
  return this.getData().getGrouper();
}, group:function(grouper, direction) {
  var me = this, sorters = me.getSorters(false), change = grouper || sorters && sorters.length;
  if (grouper && typeof grouper === 'string') {
    grouper = {property:grouper, direction:direction || me.getGroupDir()};
  }
  me.settingGroups = true;
  me.getData().setGrouper(grouper);
  delete me.settingGroups;
  if (change) {
    if (me.getRemoteSort()) {
      me.load({scope:me, callback:me.fireGroupChange});
    } else {
      me.fireEvent('datachanged', me);
      me.fireEvent('refresh', me);
      me.fireGroupChange();
    }
  } else {
    me.fireGroupChange();
  }
}, fireGroupChange:function() {
  if (!this.destroyed) {
    this.fireEvent('groupchange', this, this.getGrouper());
  }
}, clearGrouping:function() {
  this.group(null);
}, getGroupField:function() {
  var grouper = this.getGrouper(), group = '';
  if (grouper) {
    group = grouper.getProperty();
  }
  return group;
}, isGrouped:function() {
  return !!this.getGrouper();
}, applyGrouper:function(grouper) {
  this.group(grouper);
  return this.getData().getGrouper();
}, getGroups:function() {
  return this.getData().getGroups();
}, onEndUpdate:Ext.emptyFn, privates:{loadsSynchronously:Ext.privateFn, onRemoteFilterSet:function(filters, remoteFilter) {
  if (filters) {
    filters[remoteFilter ? 'on' : 'un']('endupdate', this.onFilterEndUpdate, this);
  }
}, onRemoteSortSet:function(sorters, remoteSort) {
  var me = this;
  if (sorters) {
    sorters[remoteSort ? 'on' : 'un']('endupdate', me.onSorterEndUpdate, me);
    me.getData()[remoteSort ? 'un' : 'on']('beforesort', me.onBeforeCollectionSort, me);
  }
}}, deprecated:{5:{methods:{destroyStore:function() {
  this.destroy();
}}}}});
Ext.define('Ext.data.Error', {isError:true, $configPrefixed:false, config:{field:null, message:''}, constructor:function(config) {
  this.initConfig(config);
  this.msg = this.message;
}});
Ext.define('Ext.data.ErrorCollection', {extend:Ext.util.MixedCollection, alternateClassName:'Ext.data.Errors', init:function(record) {
  var me = this, fields = record.fields, data = record.data, before, field, item, i, len, msg, val, name;
  for (i = 0, len = fields.length; i < len; ++i) {
    field = fields[i];
    name = field.name;
    val = data[name];
    if (field.validate && !field.validate.$nullFn) {
      before = me.length;
      msg = field.validate(val, null, me, record);
      if (before === me.length && msg !== true) {
        me.add(name, msg);
      }
    }
  }
  return me;
}, add:function(key, value) {
  var me = this, defaultMessage = Ext.data.field.Field.defaultInvalidMessage, obj = key, current;
  if (Ext.isString(key)) {
    obj = new Ext.data.Error({field:key, message:value || defaultMessage});
  } else {
    if (!obj.isError) {
      obj = new Ext.data.Error({field:obj.field || obj.name, message:obj.error || obj.message || obj.msg || defaultMessage});
    }
    key = obj.field;
  }
  current = me.get(key);
  if (current) {
    if (Ext.isArray(current)) {
      current.push(obj);
      return current;
    }
    me.removeAtKey(key);
    obj = [current, obj];
    obj.field = key;
    obj = [obj];
  }
  return me.callParent([obj]);
}, getKey:function(item) {
  return item.field;
}, isValid:function() {
  return this.length === 0;
}, getByField:function(fieldName) {
  var values = this.get(fieldName);
  if (values && !Ext.isArray(values)) {
    values = [values];
  }
  return values || [];
}});
Ext.define('Ext.data.operation.Operation', {alternateClassName:'Ext.data.Operation', isOperation:true, config:{synchronous:false, url:'', params:undefined, callback:undefined, scope:undefined, resultSet:null, response:null, request:null, records:null, id:undefined, proxy:null, batch:null, recordCreator:null, internalCallback:null, internalScope:null}, order:0, foreignKeyDirection:1, started:false, running:false, complete:false, success:undefined, exception:false, error:undefined, idPrefix:'ext-operation-', 
constructor:function(config) {
  var scope = config && config.scope;
  this.initConfig(config);
  if (config) {
    config.scope = scope;
  }
  if (scope) {
    this.setScope(scope);
    this.initialConfig.scope = scope;
  }
  this._internalId = Ext.id(this, this.idPrefix);
}, getAction:function() {
  return this.action;
}, execute:function() {
  var me = this, request;
  delete me.error;
  delete me.success;
  me.complete = me.exception = false;
  me.setStarted();
  me.request = request = me.doExecute();
  if (request) {
    request.setOperation(me);
  }
  return request;
}, doExecute:Ext.emptyFn, abort:function() {
  var me = this, request = me.request;
  if (me.running && request) {
    me.getProxy().abort(request);
    me.request = null;
  }
}, process:function(resultSet, request, response, autoComplete) {
  var me = this;
  autoComplete = autoComplete !== false;
  me.setResponse(response);
  me.setResultSet(resultSet);
  if (resultSet.getSuccess()) {
    me.doProcess(resultSet, request, response);
    me.setSuccessful(autoComplete);
  } else {
    if (autoComplete) {
      me.setException(resultSet.getMessage());
    }
  }
}, _commitSetOptions:{convert:true, commit:true}, doProcess:function(resultSet, request, response) {
  var me = this, commitSetOptions = me._commitSetOptions, clientRecords = me.getRecords(), clientLen = clientRecords.length, clientIdProperty = clientRecords[0].clientIdProperty, serverRecords = resultSet.getRecords(), serverLen = serverRecords ? serverRecords.length : 0, clientMap, serverRecord, clientRecord, i;
  if (serverLen && clientIdProperty) {
    clientMap = Ext.Array.toValueMap(clientRecords, 'id');
    for (i = 0; i < serverLen; ++i) {
      serverRecord = serverRecords[i];
      clientRecord = clientMap[serverRecord[clientIdProperty]];
      if (clientRecord) {
        delete clientMap[clientRecord.id];
        delete serverRecord[clientIdProperty];
        clientRecord.set(serverRecord, commitSetOptions);
      } else {
        Ext.log.warn('Ignoring server record: ' + Ext.encode(serverRecord));
      }
    }
    for (i in clientMap) {
      clientMap[i].commit();
    }
  } else {
    for (i = 0; i < clientLen; ++i) {
      clientRecord = clientRecords[i];
      if (serverLen === 0 || !(serverRecord = serverRecords[i])) {
        clientRecord.commit();
      } else {
        clientRecord.set(serverRecord, commitSetOptions);
      }
    }
  }
}, setStarted:function() {
  this.started = this.running = true;
}, setCompleted:function() {
  var me = this, proxy = me.getProxy();
  me.complete = true;
  me.running = false;
  me.triggerCallbacks();
  if (proxy) {
    proxy.completeOperation(me);
  }
}, setSuccessful:function(complete) {
  this.success = true;
  if (complete) {
    this.setCompleted();
  }
}, setException:function(error) {
  var me = this;
  me.exception = true;
  me.success = me.running = false;
  me.error = error;
  me.setCompleted();
}, triggerCallbacks:function() {
  var me = this, callback = me.getInternalCallback();
  if (callback) {
    callback.call(me.getInternalScope() || me, me);
    me.setInternalCallback(null);
    me.setInternalScope(null);
  }
  if (callback = me.getCallback()) {
    callback.call(me.getScope() || me, me.getRecords(), me, me.wasSuccessful());
    me.setCallback(null);
    me.setScope(null);
  }
}, hasException:function() {
  return this.exception;
}, getError:function() {
  return this.error;
}, getRecords:function() {
  var resultSet;
  return this._records || ((resultSet = this.getResultSet()) ? resultSet.getRecords() : null);
}, isStarted:function() {
  return this.started;
}, isRunning:function() {
  return this.running;
}, isComplete:function() {
  return this.complete;
}, wasSuccessful:function() {
  return this.isComplete() && this.success === true;
}, allowWrite:function() {
  return true;
}});
Ext.define('Ext.data.operation.Create', {extend:Ext.data.operation.Operation, alias:'data.operation.create', action:'create', isCreateOperation:true, order:10, config:{recordCreator:Ext.identityFn}, doExecute:function() {
  return this.getProxy().create(this);
}});
Ext.define('Ext.data.operation.Destroy', {extend:Ext.data.operation.Operation, alias:'data.operation.destroy', action:'destroy', isDestroyOperation:true, order:30, foreignKeyDirection:-1, doProcess:function() {
  var clientRecords = this.getRecords(), clientLen = clientRecords.length, i;
  for (i = 0; i < clientLen; ++i) {
    clientRecords[i].setErased();
  }
}, doExecute:function() {
  return this.getProxy().erase(this);
}, getRecordData:function(record, operation) {
  var data = {}, idField = record.idField, nameProperty = this.getNameProperty() || 'name';
  data[idField[nameProperty]] = record.id;
  return data;
}});
Ext.define('Ext.data.operation.Read', {extend:Ext.data.operation.Operation, alias:'data.operation.read', action:'read', isReadOperation:true, config:{filters:undefined, sorters:undefined, grouper:undefined, start:undefined, limit:undefined, page:undefined, addRecords:false}, doExecute:function() {
  return this.getProxy().read(this);
}, doProcess:Ext.emptyFn, allowWrite:function() {
  return false;
}});
Ext.define('Ext.data.operation.Update', {extend:Ext.data.operation.Operation, alias:'data.operation.update', action:'update', isUpdateOperation:true, order:20, config:{recordCreator:Ext.identityFn}, doExecute:function() {
  return this.getProxy().update(this);
}});
Ext.define('Ext.data.SortTypes', {singleton:true, none:Ext.identityFn, stripCommasRe:/,/g, stripTagsRE:/<\/?[^>]+>/gi, asText:function(s) {
  return s != null ? String(s).replace(this.stripTagsRe, '') : '\x00';
}, asUCText:function(s) {
  return s != null ? String(s).toUpperCase().replace(this.stripTagsRe, '') : '\x00';
}, asUCString:function(s) {
  return s != null ? String(s).toUpperCase() : '\x00';
}, asDate:function(s) {
  if (!s) {
    return 0;
  }
  if (Ext.isDate(s)) {
    return s.getTime();
  }
  return Date.parse(String(s));
}, asFloat:function(s) {
  var val = parseFloat(String(s).replace(this.stripCommasRe, ''));
  return isNaN(val) ? 0 : val;
}, asInt:function(s) {
  var val = parseInt(String(s).replace(this.stripCommasRe, ''), 10);
  return isNaN(val) ? 0 : val;
}});
Ext.define('Ext.data.validator.Validator', {mixins:[Ext.mixin.Factoryable], alias:'data.validator.base', isValidator:true, type:'base', statics:{all:{}, register:function(name, cls) {
  var all = this.all;
  all[name.toUpperCase()] = all[name.toLowerCase()] = all[name] = cls.prototype;
}}, onClassExtended:function(cls, data) {
  if (data.type) {
    Ext.data.validator.Validator.register(data.type, cls);
  }
}, constructor:function(config) {
  if (typeof config === 'function') {
    this.fnOnly = true;
    this.validate = config;
  } else {
    this.initConfig(config);
  }
}, validate:function() {
  return true;
}, clone:function() {
  var me = this;
  if (me.fnOnly) {
    return new Ext.data.validator.Validator(me.validate);
  }
  return new me.self(me.getCurrentConfig());
}}, function() {
  this.register(this.prototype.type, this);
});
Ext.define('Ext.data.field.Field', {mixins:[Ext.mixin.Factoryable], alternateClassName:'Ext.data.Field', alias:'data.field.auto', aliasPrefix:'data.field.', type:'auto', factoryConfig:{defaultProperty:'name'}, isDataField:true, isField:true, allowBlank:true, allowNull:false, critical:false, defaultInvalidMessage:'This field is invalid', defaultValue:undefined, definedBy:null, depends:null, dependents:null, mapping:null, name:null, ordinal:undefined, persist:null, reference:null, unique:false, rank:null, 
stripRe:/[\$,%]/g, calculated:false, evil:false, identifier:false, onClassExtended:function(cls, data) {
  var sortType = data.sortType, proto = cls.prototype, superValidators = proto.validators, validators = data.validators;
  if (sortType && Ext.isString(sortType)) {
    proto.sortType = Ext.data.SortTypes[sortType];
  }
  if (validators) {
    if (!Ext.isArray(validators)) {
      validators = [validators];
    }
    delete data.validators;
    if (superValidators) {
      validators = superValidators.concat(validators);
    }
    proto.validators = validators;
  }
}, argumentNamesRe:/^function\s*\(\s*([^,\)\s]+)/, calculateRe:/[^\.a-z0-9_]([a-z_][a-z_0-9]*)\.([a-z_][a-z_0-9]*)/gi, constructor:function(config) {
  var me = this, calculateRe = me.calculateRe, calculate, calculated, defaultValue, sortType, depends, map, match, dataProp, str, fld, validators;
  if (config) {
    if (Ext.isString(config)) {
      me.name = config;
    } else {
      validators = config.validators;
      if (validators) {
        delete config.validators;
        me.instanceValidators = validators;
      }
      Ext.apply(me, config);
    }
  }
  if (!me.allowNull) {
    me.allowNull = !!me.reference;
  }
  calculate = me.calculate;
  depends = me.depends;
  if (calculate) {
    me.convert = me.doCalculate;
    if (!depends) {
      if (!(depends = calculate.$depends)) {
        map = {};
        str = calculate.toString();
        calculate.$depends = depends = [];
        match = me.argumentNamesRe.exec(str);
        dataProp = match ? match[1] : 'data';
        while (match = calculateRe.exec(str)) {
          if (dataProp === match[1] && !map[fld = match[2]]) {
            map[fld] = 1;
            depends.push(fld);
          }
        }
      }
      me.depends = depends;
    }
  }
  defaultValue = me.defaultValue;
  if (me.convert) {
    me.calculated = calculated = me.convert.length > 1;
    me.evil = calculated && !depends;
  }
  if (me.persist === null) {
    me.persist = !calculate;
  }
  sortType = me.sortType;
  if (!me.sortType) {
    me.sortType = Ext.data.SortTypes.none;
  } else {
    if (Ext.isString(sortType)) {
      me.sortType = Ext.data.SortTypes[sortType];
    }
  }
  if (depends && typeof depends === 'string') {
    me.depends = [depends];
  }
  me.cloneDefaultValue = defaultValue !== undefined && (Ext.isDate(defaultValue) || Ext.isArray(defaultValue) || Ext.isObject(defaultValue));
}, setModelValidators:function(modelValidators) {
  this._validators = null;
  this.modelValidators = modelValidators;
}, compileValidators:function() {
  var me = this;
  me._validators = [];
  me.constructValidators(me.validators);
  me.constructValidators(me.modelValidators);
  me.constructValidators(me.instanceValidators);
}, constructValidators:function(validators) {
  if (validators) {
    if (!(validators instanceof Array)) {
      validators = [validators];
    }
    var length = validators.length, all = this._validators, i, item;
    for (i = 0; i < length; ++i) {
      item = validators[i];
      if (item.fn) {
        item = item.fn;
      }
      all.push(Ext.Factory.dataValidator(item));
    }
  }
}, collate:function(value1, value2) {
  var me = this, lhs = value1, rhs = value2;
  if (me.sortType) {
    lhs = me.sortType(lhs);
    rhs = me.sortType(rhs);
  }
  return lhs === rhs ? 0 : lhs < rhs ? -1 : 1;
}, compare:function(value1, value2) {
  return value1 === value2 ? 0 : value1 < value2 ? -1 : 1;
}, isEqual:function(value1, value2) {
  return this.compare(value1, value2) === 0;
}, convert:null, serialize:null, validate:function(value, separator, errors, record) {
  var me = this, ret = '', result, validator, validators, length, i;
  if (!me._validators) {
    me.compileValidators();
  }
  validators = me._validators;
  for (i = 0, length = validators.length; i < length; ++i) {
    validator = validators[i];
    result = validator.validate(value, record);
    if (result !== true) {
      result = result || me.defaultInvalidMessage;
      if (errors) {
        errors.add(me.name, result);
        ret = ret || result;
      } else {
        if (separator) {
          if (ret) {
            ret += separator;
          }
          ret += result;
        } else {
          ret = result;
          break;
        }
      }
    }
  }
  return ret || true;
}, doCalculate:function(v, rec) {
  return rec ? this.calculate(rec.data) : v;
}, getName:function() {
  return this.name;
}, getAllowBlank:function() {
  return this.allowBlank;
}, getAllowNull:function() {
  return this.allowNull;
}, getConvert:function() {
  return this.convert;
}, getDefaultValue:function() {
  return this.defaultValue;
}, getDepends:function() {
  return this.depends;
}, getMapping:function() {
  return this.mapping;
}, hasMapping:function() {
  var map = this.mapping;
  return !!(map || map === 0);
}, getPersist:function() {
  return this.persist;
}, getSortType:function() {
  return this.sortType;
}, getType:function() {
  return 'auto';
}, deprecated:{'5.1':{methods:{getSortDir:function() {
  return this.sortDir;
}}}}});
Ext.define('Ext.data.field.Boolean', {extend:Ext.data.field.Field, alias:['data.field.bool', 'data.field.boolean'], isBooleanField:true, trueRe:/^\s*(?:true|yes|on|1)\s*$/i, convert:function(v) {
  if (typeof v === 'boolean') {
    return v;
  }
  if (this.allowNull && (v === undefined || v === null || v === '')) {
    return null;
  }
  return this.trueRe.test(String(v));
}, getType:function() {
  return 'bool';
}});
Ext.define('Ext.data.field.Date', {extend:Ext.data.field.Field, alias:'data.field.date', sortType:'asDate', isDateField:true, dateFormat:null, dateReadFormat:null, dateWriteFormat:null, compare:function(lhs, rhs) {
  var lhsIsDate = lhs instanceof Date, rhsIsDate = rhs instanceof Date, result;
  if (rhsIsDate && lhsIsDate) {
    result = lhs.getTime() - rhs.getTime();
    if (result === 0) {
      result = 0;
    } else {
      result = result < 0 ? -1 : 1;
    }
  } else {
    if (lhsIsDate === rhsIsDate) {
      result = 0;
    } else {
      result = lhsIsDate ? 1 : -1;
    }
  }
  return result;
}, convert:function(v) {
  if (!v) {
    return null;
  }
  if (v instanceof Date) {
    return v;
  }
  var dateFormat = this.dateReadFormat || this.dateFormat, parsed;
  if (dateFormat) {
    return Ext.Date.parse(v, dateFormat);
  }
  parsed = Date.parse(v);
  return parsed ? new Date(parsed) : null;
}, serialize:function(value) {
  var result = null, format;
  if (Ext.isDate(value)) {
    format = this.getDateWriteFormat();
    result = format ? Ext.Date.format(value, format) : value;
  }
  return result;
}, getDateFormat:function() {
  return this.dateFormat;
}, getDateReadFormat:function() {
  return this.dateReadFormat;
}, getDateWriteFormat:function() {
  var me = this;
  if (me.hasOwnProperty('dateWriteFormat')) {
    return me.dateWriteFormat;
  }
  if (me.hasOwnProperty('dateFormat')) {
    return me.dateFormat;
  }
  return me.dateWriteFormat || me.dateFormat || 'timestamp';
}, getType:function() {
  return 'date';
}});
Ext.define('Ext.data.field.Integer', {extend:Ext.data.field.Field, alias:['data.field.int', 'data.field.integer'], isNumeric:true, isIntegerField:true, numericType:'int', convert:function(v) {
  if (typeof v === 'number') {
    return this.getNumber(v);
  }
  var empty = v === undefined || v === null || v === '', allowNull = this.allowNull, out;
  if (empty) {
    out = allowNull ? null : 0;
  } else {
    out = this.parse(v);
    if (allowNull && isNaN(out)) {
      out = null;
    }
  }
  return out;
}, getNumber:function(v) {
  return parseInt(v, 10);
}, getType:function() {
  return this.numericType;
}, parse:function(v) {
  return parseInt(String(v).replace(this.stripRe, ''), 10);
}, sortType:function(s) {
  if (s == null) {
    s = Infinity;
  }
  return s;
}});
Ext.define('Ext.data.field.Number', {extend:Ext.data.field.Integer, alias:['data.field.float', 'data.field.number'], isIntegerField:false, isNumberField:true, numericType:'float', getNumber:Ext.identityFn, parse:function(v) {
  return parseFloat(String(v).replace(this.stripRe, ''));
}});
Ext.define('Ext.data.field.String', {extend:Ext.data.field.Field, alias:'data.field.string', sortType:'asUCString', isStringField:true, convert:function(v) {
  var defaultValue = this.allowNull ? null : '';
  return v === undefined || v === null ? defaultValue : String(v);
}, getType:function() {
  return 'string';
}});
Ext.define('Ext.data.identifier.Generator', {'abstract':true, mixins:[Ext.mixin.Factoryable], alias:'data.identifier.default', factoryConfig:{defaultType:'sequential'}, isGenerator:true, config:{id:null}, constructor:function(config) {
  var me = this, cache, id;
  me.initConfig(config);
  id = me.getId();
  if (id) {
    cache = config && config.cache || Ext.data.identifier.Generator.all;
    cache[id] = me;
  }
}, privates:{clone:function(config) {
  var cfg = this.getInitialConfig();
  cfg = config ? Ext.apply({}, config, cfg) : cfg;
  return new this.self(cfg);
}, statics:{all:{}}}}, function() {
  var Generator = this, Factory = Ext.Factory, factory = Factory.dataIdentifier;
  Factory.dataIdentifier = function(config) {
    var id = Ext.isString(config) ? config : config && config.id, existing = id && (config && config.cache || Generator.all)[id];
    return existing || factory(config);
  };
});
Ext.define('Ext.data.identifier.Sequential', {extend:Ext.data.identifier.Generator, alias:'data.identifier.sequential', config:{increment:1, prefix:null, seed:1}, generate:function() {
  var me = this, seed = me._seed, prefix = me._prefix;
  me._seed += me._increment;
  return prefix !== null ? prefix + seed : seed;
}});
Ext.define('Ext.data.Model', {alternateClassName:'Ext.data.Record', isEntity:true, isModel:true, validIdRe:null, erasing:false, observableType:'record', constructor:function(data, session) {
  var me = this, cls = me.self, identifier = cls.identifier, Model = Ext.data.Model, modelIdentifier = Model.identifier, idProperty = me.idField.name, array, id, initializeFn, internalId, len, i, fields;
  me.data = me.data = data || (data = {});
  me.session = session || null;
  me.internalId = internalId = modelIdentifier.generate();
  var dataId = data[idProperty];
  if (session && !session.isSession) {
    Ext.raise('Bad Model constructor argument 2 - "session" is not a Session');
  }
  if ((array = data) instanceof Array) {
    me.data = data = {};
    fields = me.getFields();
    len = Math.min(fields.length, array.length);
    for (i = 0; i < len; ++i) {
      data[fields[i].name] = array[i];
    }
  }
  if (!(initializeFn = cls.initializeFn)) {
    cls.initializeFn = initializeFn = Model.makeInitializeFn(cls);
  }
  if (!initializeFn.$nullFn) {
    cls.initializeFn(me);
  }
  if (!(me.id = id = data[idProperty]) && id !== 0) {
    if (dataId) {
      Ext.raise('The model ID configured in data ("' + dataId + '") has been rejected by the ' + me.fieldsMap[idProperty].type + ' field converter for the ' + idProperty + ' field');
    }
    if (session) {
      identifier = session.getIdentifier(cls);
      id = identifier.generate();
    } else {
      if (modelIdentifier === identifier) {
        id = internalId;
      } else {
        id = identifier.generate();
      }
    }
    data[idProperty] = me.id = id;
    me.phantom = true;
  }
  if (session) {
    session.add(me);
  }
  if (me.init && Ext.isFunction(me.init)) {
    me.init();
  }
}, editing:false, dirty:false, session:null, dropped:false, erased:false, clientIdProperty:null, evented:false, phantom:false, idProperty:'id', manyToMany:null, identifier:null, previousValues:undefined, proxy:undefined, schema:'default', versionProperty:null, generation:1, validationSeparator:null, convertOnSet:true, beginEdit:function() {
  var me = this, modified = me.modified, previousValues = me.previousValues;
  if (!me.editing) {
    me.editing = true;
    me.editMemento = {dirty:me.dirty, data:Ext.apply({}, me.data), generation:me.generation, modified:modified && Ext.apply({}, modified), previousValues:previousValues && Ext.apply({}, previousValues)};
  }
}, cancelEdit:function() {
  var me = this, editMemento = me.editMemento;
  if (editMemento) {
    me.editing = false;
    Ext.apply(me, editMemento);
    me.editMemento = null;
  }
}, endEdit:function(silent, modifiedFieldNames) {
  var me = this, editMemento = me.editMemento;
  if (editMemento) {
    me.editing = false;
    me.editMemento = null;
    me.previousValues = editMemento.previousValues;
    if (!silent) {
      if (!modifiedFieldNames) {
        modifiedFieldNames = me.getModifiedFieldNames(editMemento.data);
      }
      if (me.dirty || modifiedFieldNames && modifiedFieldNames.length) {
        me.callJoined('afterEdit', [modifiedFieldNames]);
      }
    }
  }
}, getField:function(name) {
  return this.self.getField(name);
}, getFields:function() {
  return this.self.getFields();
}, getFieldsMap:function() {
  return this.fieldsMap;
}, getIdProperty:function() {
  return this.idProperty;
}, getId:function() {
  return this.id;
}, getObservableId:function() {
  return this.internalId;
}, setId:function(id, options) {
  this.set(this.idProperty, id, options);
}, getPrevious:function(fieldName) {
  var previousValues = this.previousValues;
  return previousValues && previousValues[fieldName];
}, isModified:function(fieldName) {
  var modified = this.modified;
  return !!(modified && modified.hasOwnProperty(fieldName));
}, getModified:function(fieldName) {
  var out;
  if (this.isModified(fieldName)) {
    out = this.modified[fieldName];
  }
  return out;
}, get:function(fieldName) {
  return this.data[fieldName];
}, _singleProp:{}, _rejectOptions:{convert:false, silent:true}, set:function(fieldName, newValue, options) {
  var me = this, cls = me.self, data = me.data, modified = me.modified, prevVals = me.previousValues, session = me.session, single = Ext.isString(fieldName), opt = single ? options : newValue, convertOnSet = opt ? opt.convert !== false : me.convertOnSet, fieldsMap = me.fieldsMap, silent = opt && opt.silent, commit = opt && opt.commit, updateRefs = !(opt && opt.refs === false) && session, dirty = !(opt && opt.dirty === false && !commit), modifiedFieldNames = null, currentValue, field, idChanged, key, 
  name, oldId, comparator, dep, dependents, i, dirtyRank = 0, numFields, newId, rankedFields, reference, value, values;
  if (single) {
    values = me._singleProp;
    values[fieldName] = newValue;
  } else {
    values = fieldName;
  }
  if (!(rankedFields = cls.rankedFields)) {
    rankedFields = cls.rankFields();
  }
  numFields = rankedFields.length;
  do {
    for (name in values) {
      value = values[name];
      currentValue = data[name];
      comparator = me;
      field = fieldsMap[name];
      if (field) {
        if (convertOnSet && field.convert) {
          value = field.convert(value, me);
        }
        comparator = field;
        reference = field.reference;
      } else {
        reference = null;
      }
      if (comparator.isEqual(currentValue, value)) {
        continue;
      }
      data[name] = value;
      (modifiedFieldNames || (modifiedFieldNames = [])).push(name);
      (prevVals || (me.previousValues = prevVals = {}))[name] = currentValue;
      if (reference && reference.cls) {
        if (updateRefs) {
          session.updateReference(me, field, value, currentValue);
        }
        reference.onValueChange(me, session, value, currentValue);
      }
      i = (dependents = field && field.dependents) && dependents.length;
      while (i-- > 0) {
        (dep = dependents[i]).dirty = true;
        dirtyRank = dirtyRank ? Math.min(dirtyRank, dep.rank) : dep.rank;
      }
      if (!field || field.persist) {
        if (modified && modified.hasOwnProperty(name)) {
          if (!dirty || comparator.isEqual(modified[name], value)) {
            delete modified[name];
            me.dirty = -1;
          }
        } else {
          if (dirty) {
            if (!modified) {
              me.modified = modified = {};
            }
            me.dirty = true;
            modified[name] = currentValue;
          }
        }
      }
      if (name === me.idField.name) {
        idChanged = true;
        oldId = currentValue;
        newId = value;
      }
    }
    if (!dirtyRank) {
      break;
    }
    field = rankedFields[dirtyRank - 1];
    field.dirty = false;
    if (single) {
      delete values[fieldName];
    } else {
      values = me._singleProp;
      single = true;
    }
    fieldName = field.name;
    values[fieldName] = data[fieldName];
    convertOnSet = true;
    for (; dirtyRank < numFields; ++dirtyRank) {
      if (rankedFields[dirtyRank].dirty) {
        break;
      }
    }
    if (dirtyRank < numFields) {
      ++dirtyRank;
    } else {
      dirtyRank = 0;
    }
  } while (1);
  if (me.dirty < 0) {
    me.dirty = false;
    for (key in modified) {
      if (modified.hasOwnProperty(key)) {
        me.dirty = true;
        break;
      }
    }
  }
  if (single) {
    delete values[fieldName];
  }
  ++me.generation;
  if (idChanged) {
    me.id = newId;
    me.callJoined('onIdChanged', [oldId, newId]);
  }
  if (commit) {
    me.commit(silent, modifiedFieldNames);
  } else {
    if (!silent && !me.editing && modifiedFieldNames) {
      me.callJoined('afterEdit', [modifiedFieldNames]);
    }
  }
  return modifiedFieldNames;
}, reject:function(silent) {
  var me = this, modified = me.modified;
  if (me.erased) {
    Ext.raise('Cannot reject once a record has been erased.');
  }
  if (modified) {
    me.set(modified, me._rejectOptions);
  }
  me.dropped = false;
  me.clearState();
  if (!silent) {
    me.callJoined('afterReject');
  }
}, commit:function(silent, modifiedFieldNames) {
  var me = this, versionProperty = me.versionProperty, data = me.data, erased;
  me.clearState();
  if (versionProperty && !me.phantom && !isNaN(data[versionProperty])) {
    ++data[versionProperty];
  }
  me.phantom = false;
  if (me.dropped) {
    me.erased = erased = true;
  }
  if (!silent) {
    if (erased) {
      me.callJoined('afterErase');
    } else {
      me.callJoined('afterCommit', [modifiedFieldNames]);
    }
  }
}, clearState:function() {
  var me = this;
  me.dirty = me.editing = false;
  me.editMemento = me.modified = null;
}, drop:function(cascade) {
  var me = this, associations = me.associations, session = me.session, roleName;
  if (me.erased || me.dropped) {
    return;
  }
  me.dropped = true;
  if (associations && cascade !== false) {
    for (roleName in associations) {
      associations[roleName].onDrop(me, session);
    }
  }
  me.callJoined('afterDrop');
  if (me.phantom) {
    me.setErased();
  }
}, join:function(item) {
  var me = this, joined = me.joined;
  if (!joined) {
    joined = me.joined = [item];
  } else {
    if (!joined.length) {
      joined[0] = item;
    } else {
      Ext.Array.include(joined, item);
    }
  }
  if (item.isStore && !me.store) {
    me.store = item;
  }
}, unjoin:function(item) {
  var me = this, joined = me.joined, len = joined && joined.length, store = me.store, i;
  if (len === 1 && joined[0] === item) {
    joined.length = 0;
  } else {
    if (len) {
      Ext.Array.remove(joined, item);
    }
  }
  if (store === item) {
    store = null;
    if (joined) {
      for (i = 0, len = joined.length; i < len; ++i) {
        item = joined[i];
        if (item.isStore) {
          store = item;
          break;
        }
      }
    }
    me.store = store;
  }
}, clone:function(session) {
  var me = this, modified = me.modified, ret = me.copy(me.id, session);
  if (modified) {
    ret.modified = Ext.apply({}, modified);
  }
  ret.dirty = me.dirty;
  ret.dropped = me.dropped;
  ret.phantom = me.phantom;
  return ret;
}, copy:function(newId, session) {
  var me = this, data = Ext.apply({}, me.data), idProperty = me.idProperty, T = me.self;
  if (newId || newId === 0) {
    data[idProperty] = newId;
  } else {
    if (newId === null) {
      delete data[idProperty];
    }
  }
  return new T(data, session);
}, getProxy:function() {
  return this.self.getProxy();
}, getValidation:function(refresh) {
  var me = this, ret = me.validation;
  if (!ret) {
    me.validation = ret = new Ext.data.Validation;
    ret.attach(me);
  }
  if (refresh === true || refresh !== false && ret.syncGeneration !== me.generation) {
    ret.refresh(refresh);
  }
  return ret;
}, validate:function() {
  return (new Ext.data.ErrorCollection).init(this);
}, isValid:function() {
  return this.getValidation().isValid();
}, toUrl:function() {
  var pieces = this.$className.split('.'), name = pieces[pieces.length - 1].toLowerCase();
  return name + '/' + this.getId();
}, erase:function(options) {
  var me = this;
  me.erasing = true;
  me.drop();
  me.erasing = false;
  return me.save(options);
}, setErased:function() {
  this.erased = true;
  this.callJoined('afterErase');
}, getChanges:function() {
  return this.getData(this._getChangesOptions);
}, getCriticalFields:function() {
  var cls = this.self, ret = cls.criticalFields;
  if (!ret) {
    cls.rankFields();
    ret = cls.criticalFields;
  }
  return ret;
}, getAssociatedData:function(result, options) {
  var me = this, associations = me.associations, deep, i, item, items, itemData, length, record, role, roleName, opts, clear, associated;
  result = result || {};
  me.$gathering = 1;
  if (options) {
    options = Ext.Object.chain(options);
  }
  for (roleName in associations) {
    role = associations[roleName];
    item = role.getAssociatedItem(me);
    if (!item || item.$gathering) {
      continue;
    }
    if (item.isStore) {
      item.$gathering = 1;
      items = item.getData().items;
      length = items.length;
      itemData = [];
      for (i = 0; i < length; ++i) {
        record = items[i];
        deep = !record.$gathering;
        record.$gathering = 1;
        if (options) {
          associated = options.associated;
          if (associated === undefined) {
            options.associated = deep;
            clear = true;
          } else {
            if (!deep) {
              options.associated = false;
              clear = true;
            }
          }
          opts = options;
        } else {
          opts = deep ? me._getAssociatedOptions : me._getNotAssociatedOptions;
        }
        itemData.push(record.getData(opts));
        if (clear) {
          options.associated = associated;
          clear = false;
        }
        delete record.$gathering;
      }
      delete item.$gathering;
    } else {
      opts = options || me._getAssociatedOptions;
      if (options && options.associated === undefined) {
        opts.associated = true;
      }
      itemData = item.getData(opts);
    }
    result[roleName] = itemData;
  }
  delete me.$gathering;
  return result;
}, getData:function(options) {
  var me = this, ret = {}, opts = options === true ? me._getAssociatedOptions : options || ret, data = me.data, associated = opts.associated, changes = opts.changes, critical = changes && opts.critical, content = changes ? me.modified : data, fieldsMap = me.fieldsMap, persist = opts.persist, serialize = opts.serialize, criticalFields, field, n, name, value;
  if (content) {
    for (name in content) {
      value = data[name];
      field = fieldsMap[name];
      if (field) {
        if (persist && !field.persist) {
          continue;
        }
        if (serialize && field.serialize) {
          value = field.serialize(value, me);
        }
      }
      ret[name] = value;
    }
  }
  if (critical) {
    criticalFields = me.self.criticalFields || me.getCriticalFields();
    for (n = criticalFields.length; n-- > 0;) {
      name = (field = criticalFields[n]).name;
      if (!(name in ret)) {
        value = data[name];
        if (serialize && field.serialize) {
          value = field.serialize(value, me);
        }
        ret[name] = value;
      }
    }
  }
  if (associated) {
    me.getAssociatedData(ret, opts);
  }
  return ret;
}, getTransientFields:function() {
  var cls = this.self, ret = cls.transientFields;
  if (!ret) {
    cls.rankFields();
    ret = cls.transientFields;
  }
  return ret;
}, isLoading:function() {
  return !!this.loadOperation;
}, abort:function() {
  var operation = this.loadOperation;
  if (operation) {
    operation.abort();
  }
}, load:function(options) {
  options = Ext.apply({}, options);
  var me = this, scope = options.scope || me, proxy = me.getProxy(), callback = options.callback, operation = me.loadOperation, id = me.getId(), extras;
  if (operation) {
    extras = operation.extraCalls;
    if (!extras) {
      extras = operation.extraCalls = [];
    }
    extras.push(options);
    return operation;
  }
  var doIdCheck = true;
  if (me.phantom) {
    doIdCheck = false;
  }
  options.id = id;
  options.recordCreator = function(data, type, readOptions) {
    var session = me.session;
    if (readOptions) {
      readOptions.recordCreator = session ? session.recordCreator : null;
    }
    me.set(data, me._commitOptions);
    if (doIdCheck && me.getId() !== id) {
      Ext.raise('Invalid record id returned for ' + id + '@' + me.entityName);
    }
    return me;
  };
  options.internalCallback = function(operation) {
    var success = operation.wasSuccessful() && operation.getRecords().length > 0, op = me.loadOperation, extras = op.extraCalls, successFailArgs = [me, operation], callbackArgs = [me, operation, success], i, len;
    me.loadOperation = null;
    if (success) {
      Ext.callback(options.success, scope, successFailArgs);
    } else {
      Ext.callback(options.failure, scope, successFailArgs);
    }
    Ext.callback(callback, scope, callbackArgs);
    if (extras) {
      for (i = 0, len = extras.length; i < len; ++i) {
        options = extras[i];
        if (success) {
          Ext.callback(options.success, scope, successFailArgs);
        } else {
          Ext.callback(options.failure, scope, successFailArgs);
        }
        Ext.callback(options.callback, scope, callbackArgs);
      }
    }
    me.callJoined('afterLoad');
  };
  delete options.callback;
  me.loadOperation = operation = proxy.createOperation('read', options);
  operation.execute();
  return operation;
}, save:function(options) {
  options = Ext.apply({}, options);
  var me = this, phantom = me.phantom, dropped = me.dropped, action = dropped ? 'destroy' : phantom ? 'create' : 'update', scope = options.scope || me, callback = options.callback, proxy = me.getProxy(), operation;
  options.records = [me];
  options.internalCallback = function(operation) {
    var args = [me, operation], success = operation.wasSuccessful();
    if (success) {
      Ext.callback(options.success, scope, args);
    } else {
      Ext.callback(options.failure, scope, args);
    }
    args.push(success);
    Ext.callback(callback, scope, args);
  };
  delete options.callback;
  operation = proxy.createOperation(action, options);
  if (dropped && phantom) {
    operation.setResultSet(Ext.data.reader.Reader.prototype.nullResultSet);
    me.setErased();
    operation.setSuccessful(true);
  } else {
    operation.execute();
  }
  return operation;
}, inheritableStatics:{addFields:function(newFields) {
  this.replaceFields(newFields);
}, replaceFields:function(newFields, removeFields) {
  var me = this, proto = me.prototype, Field = Ext.data.field.Field, fields = me.fields, fieldsMap = me.fieldsMap, ordinals = me.fieldOrdinals, field, i, idField, len, name, ordinal;
  if (removeFields === true) {
    fields.length = 0;
    me.fieldsMap = fieldsMap = {};
    me.fieldOrdinals = ordinals = {};
  } else {
    if (removeFields) {
      for (i = removeFields.length; i-- > 0;) {
        name = removeFields[i];
        if (name in ordinals) {
          delete ordinals[name];
          delete fieldsMap[name];
        }
      }
      for (i = 0, len = fields.length; i < len; ++i) {
        name = (field = fields[i]).name;
        if (name in ordinals) {
          ordinals[name] = i;
        } else {
          fields.splice(i, 1);
          --i;
          --len;
        }
      }
    }
  }
  for (i = 0, len = newFields ? newFields.length : 0; i < len; i++) {
    name = (field = newFields[i]).name;
    if (!(name in ordinals)) {
      ordinals[name] = ordinal = fields.length;
      fields.push(field = Field.create(field));
      fieldsMap[name] = field;
      field.ordinal = ordinal;
      field.definedBy = field.owner = this;
    }
  }
  me.idField = proto.idField = idField = fieldsMap[proto.idProperty];
  idField.allowNull = idField.critical = idField.identifier = true;
  idField.defaultValue = null;
  me.initializeFn = me.rankedFields = me.transientFields = me.criticalFields = null;
}, removeFields:function(removeFields) {
  this.replaceFields(null, removeFields);
}, getIdFromData:function(data) {
  var T = this, idField = T.idField, id = idField.calculated ? (new T(data)).id : data[idField.name];
  return id;
}, createWithId:function(id, data, session) {
  var d = data, T = this;
  if (id || id === 0) {
    d = {};
    if (data) {
      Ext.apply(d, data);
    }
    d[T.idField.name] = id;
  }
  return new T(d, session);
}, getFields:function() {
  return this.fields;
}, getFieldsMap:function() {
  return this.fieldsMap;
}, getField:function(name) {
  return this.fieldsMap[name] || null;
}, getProxy:function() {
  var me = this, proxy = me.proxy, defaultProxy = me.defaultProxy, defaults;
  if (!proxy) {
    proxy = me.proxyConfig;
    if (!proxy && defaultProxy) {
      proxy = defaultProxy;
    }
    if (!proxy || !proxy.isProxy) {
      if (typeof proxy === 'string') {
        proxy = {type:proxy};
      }
      defaults = me.schema.constructProxy(me);
      proxy = proxy ? Ext.merge(defaults, proxy) : defaults;
    }
    proxy = me.setProxy(proxy);
  }
  return proxy;
}, setProxy:function(proxy) {
  var me = this, model;
  if (proxy) {
    if (!proxy.isProxy) {
      proxy = Ext.Factory.proxy(proxy);
    } else {
      model = proxy.getModel();
      if (model && model !== me) {
        proxy = proxy.clone();
      }
    }
    proxy.setModel(me);
  }
  return me.prototype.proxy = me.proxy = proxy;
}, load:function(id, options, session) {
  var data = {}, rec;
  data[this.prototype.idProperty] = id;
  rec = new this(data, session);
  rec.load(options);
  return rec;
}}, deprecated:{5:{methods:{hasId:null, markDirty:null, setDirty:null, eachStore:function(callback, scope) {
  var me = this, stores = me.stores, len = stores.length, i;
  for (i = 0; i < len; ++i) {
    callback.call(scope, stores[i]);
  }
}, join:function(item) {
  var me = this, stores = me.stores, joined = me.joined;
  if (!joined) {
    joined = me.joined = [item];
  } else {
    joined.push(item);
  }
  if (item.isStore) {
    me.store = me.store || item;
    if (!stores) {
      stores = me.stores = [];
    }
    stores.push(item);
  }
}, unjoin:function(item) {
  var me = this, stores = me.stores, joined = me.joined;
  if (joined.length === 1) {
    joined.length = 0;
  } else {
    Ext.Array.remove(joined, item);
  }
  if (item.isStore) {
    Ext.Array.remove(stores, item);
    me.store = stores[0] || null;
  }
}}, properties:{persistenceProperty:null}, inheritableStatics:{methods:{setFields:null}}}}, privates:{_commitOptions:{commit:true}, _getChangesOptions:{changes:true}, _getAssociatedOptions:{associated:true}, _getNotAssociatedOptions:{associated:false}, copyFrom:function(sourceRecord) {
  var me = this, fields = me.fields, fieldCount = fields.length, modifiedFieldNames = [], field, i = 0, myData, sourceData, idProperty = me.idProperty, name, value;
  if (sourceRecord) {
    myData = me.data;
    sourceData = sourceRecord.data;
    for (; i < fieldCount; i++) {
      field = fields[i];
      name = field.name;
      if (name !== idProperty) {
        value = sourceData[name];
        if (value !== undefined && !me.isEqual(myData[name], value)) {
          myData[name] = value;
          modifiedFieldNames.push(name);
        }
      }
    }
    if (me.phantom && !sourceRecord.phantom) {
      me.beginEdit();
      me.setId(sourceRecord.getId());
      me.endEdit(true);
      me.commit(true);
    }
  }
  return modifiedFieldNames;
}, callJoined:function(funcName, args) {
  var me = this, joined = me.joined, session = me.session, i, len, fn, item;
  if (!joined && !session) {
    return;
  }
  if (args) {
    args.unshift(me);
  } else {
    args = [me];
  }
  if (joined) {
    for (i = 0, len = joined.length; i < len; ++i) {
      item = joined[i];
      if (item && (fn = item[funcName])) {
        fn.apply(item, args);
      }
    }
  }
  fn = session && session[funcName];
  if (fn) {
    fn.apply(session, args);
  }
}, setSession:function(session) {
  if (session) {
    if (this.session) {
      Ext.raise('This model already belongs to a session.');
    }
    if (!this.id) {
      Ext.raise('The model must have an id to participate in a session.');
    }
  }
  this.session = session;
  if (session) {
    session.add(this);
  }
}, getModifiedFieldNames:function(old) {
  var me = this, data = me.data, modified = [], oldData = old || me.editMemento.data, key;
  for (key in data) {
    if (data.hasOwnProperty(key)) {
      if (!me.isEqual(data[key], oldData[key], key)) {
        modified.push(key);
      }
    }
  }
  return modified;
}, isEqual:function(lhs, rhs, field) {
  var f;
  if (field) {
    f = field.isField ? field : this.fieldsMap[field];
    if (f) {
      return f.isEqual(lhs, rhs);
    }
  }
  if (lhs instanceof Date && rhs instanceof Date) {
    return lhs.getTime() === rhs.getTime();
  }
  return lhs === rhs;
}, statics:{EDIT:'edit', REJECT:'reject', COMMIT:'commit', defaultProxy:'memory', rankFields:function() {
  var cls = this, prototype = cls.prototype, fields = cls.fields, length = fields.length, rankedFields = [], criticalFields = [], transientFields = [], evilFields, field, i;
  cls.rankedFields = prototype.rankedFields = rankedFields;
  cls.criticalFields = prototype.criticalFields = criticalFields;
  cls.transientFields = prototype.transientFields = transientFields;
  for (i = 0; i < length; ++i) {
    field = fields[i];
    if (field.critical) {
      criticalFields.push(field);
    }
    if (!field.persist) {
      transientFields.push(field);
    }
    if (field.evil) {
      (evilFields || (evilFields = [])).push(field);
    } else {
      if (!field.depends) {
        rankedFields.push(field);
        field.rank = rankedFields.length;
      }
    }
  }
  for (i = 0; i < length; ++i) {
    if (!(field = fields[i]).rank && !field.evil) {
      cls.topoAdd(field);
    }
  }
  if (evilFields) {
    for (i = 0, length = evilFields.length; i < length; ++i) {
      rankedFields.push(field = evilFields[i]);
      field.rank = rankedFields.length;
    }
  }
  cls.topoStack = null;
  return rankedFields;
}, topoAdd:function(field) {
  var cls = this, dep = field.depends, dependsLength = dep ? dep.length : 0, rankedFields = cls.rankedFields, i, targetField;
  var topoStack = cls.topoStack || (cls.topoStack = []);
  topoStack.push(field.name);
  if (field.rank === 0) {
    Ext.raise(cls.$className + ' has circular field dependencies: ' + topoStack.join(' --\x3e '));
  }
  if (topoStack.length && field.evil) {
    Ext.raise(cls.$className + ': Field ' + topoStack[topoStack.length - 1] + ' cannot depend on depends-less field ' + field.name);
  }
  field.rank = 0;
  for (i = 0; i < dependsLength; ++i) {
    targetField = cls.fieldsMap[dep[i]];
    if (!targetField) {
      Ext.raise(cls.$className + ': Field ' + field.name + ' depends on undefined field ' + dep[i]);
    }
    (targetField.dependents || (targetField.dependents = [])).push(field);
    if (!targetField.rank) {
      cls.topoAdd(targetField);
    }
  }
  rankedFields.push(field);
  field.rank = rankedFields.length;
  topoStack.pop();
}, initFields:function(data, cls, proto) {
  var Field = Ext.data.field.Field, fieldDefs = data.fields, fields = [], fieldOrdinals = {}, fieldsMap = {}, references = [], superFields = proto.fields, versionProperty = data.versionProperty || proto.versionProperty, idProperty = cls.idProperty, idField, field, i, length, name, ordinal, reference, superIdField, superIdFieldName, idDeclared;
  cls.fields = proto.fields = fields;
  cls.fieldOrdinals = proto.fieldOrdinals = fieldOrdinals;
  cls.fieldsMap = proto.fieldsMap = fieldsMap;
  cls.references = proto.references = references;
  if (superFields) {
    for (i = 0, length = superFields.length; i < length; ++i) {
      fields[i] = field = Ext.Object.chain(superFields[i]);
      field.dependents = null;
      field.owner = cls;
      fieldOrdinals[name = field.name] = i;
      fieldsMap[name] = field;
      field.rank = null;
      if (field.generated) {
        superIdField = field;
        superIdFieldName = field.name;
      }
    }
  }
  if (fieldDefs) {
    delete data.fields;
    for (i = 0, length = fieldDefs.length; i < length; ++i) {
      field = fieldDefs[i];
      reference = field.reference;
      if (reference && typeof reference !== 'string') {
        reference = Ext.merge({}, reference);
      }
      field.$reference = reference;
      field = Field.create(fieldDefs[i]);
      name = field.name;
      ordinal = fieldOrdinals[name];
      if (ordinal === undefined) {
        fieldOrdinals[name] = ordinal = fields.length;
      }
      fieldsMap[name] = field;
      fields[ordinal] = field;
      field.definedBy = field.owner = cls;
      field.ordinal = ordinal;
      if (name === idProperty) {
        idDeclared = field;
      }
    }
  }
  idField = fieldsMap[idProperty];
  if (!idField) {
    if (superIdField && superIdField.generated) {
      ordinal = superIdField.ordinal;
    } else {
      ordinal = fields.length;
    }
    delete fieldsMap[superIdFieldName];
    delete fieldOrdinals[superIdFieldName];
    idField = new Field(idProperty);
    fields[ordinal] = idField;
    fieldOrdinals[idProperty] = ordinal;
    fieldsMap[idProperty] = idField;
    idField.definedBy = cls;
    idField.ordinal = ordinal;
    idField.generated = true;
  } else {
    if (idDeclared && superIdField && superIdField.generated) {
      Ext.Array.remove(fields, superIdField);
      delete fieldsMap[superIdFieldName];
      delete fieldOrdinals[superIdFieldName];
      fieldsMap[idProperty] = idDeclared;
      for (i = 0, length = fields.length; i < length; ++i) {
        field = fields[i];
        fields.ordinal = i;
        fieldOrdinals[field.name] = i;
      }
    }
  }
  idField.allowNull = idField.critical = idField.identifier = true;
  idField.defaultValue = null;
  cls.idField = proto.idField = idField;
  if (versionProperty) {
    field = fieldsMap[versionProperty];
    if (!field) {
      ordinal = fields.length;
      field = new Field({name:versionProperty, type:'int'});
      fields[ordinal] = field;
      fieldOrdinals[versionProperty] = ordinal;
      fieldsMap[versionProperty] = field;
      field.definedBy = cls;
      field.ordinal = ordinal;
      field.generated = true;
    }
    field.defaultValue = 1;
    field.critical = true;
  }
}, initValidators:function(data, cls, proto) {
  var superValidators = proto.validators, validators, field, copy, validatorDefs, i, length, fieldValidator, name, validator, item;
  if (superValidators) {
    validators = {};
    for (field in superValidators) {
      validators[field] = Ext.Array.clone(superValidators[field]);
    }
  }
  validatorDefs = data.validators || data.validations;
  if (data.validations) {
    delete data.validations;
    Ext.log.warn((cls.$className || 'Ext.data.Model') + ': validations has been deprecated. Please use validators instead.');
  }
  if (validatorDefs) {
    delete data.validators;
    validators = validators || {};
    if (Ext.isArray(validatorDefs)) {
      copy = {};
      for (i = 0, length = validatorDefs.length; i < length; ++i) {
        item = validatorDefs[i];
        name = item.field;
        if (!copy[name]) {
          copy[name] = [];
        }
        item = item.fn || item;
        copy[name].push(item);
      }
      validatorDefs = copy;
    }
    for (name in validatorDefs) {
      fieldValidator = validatorDefs[name];
      if (!Ext.isArray(fieldValidator)) {
        fieldValidator = [fieldValidator];
      }
      validator = validators[name];
      if (validators[name]) {
        Ext.Array.push(validator, fieldValidator);
      } else {
        validators[name] = fieldValidator;
      }
    }
  }
  if (validators) {
    for (name in validators) {
      field = cls.getField(name);
      if (field) {
        field.setModelValidators(validators[name]);
      }
    }
  }
  cls.validators = proto.validators = validators;
}, initAssociations:function(schema, data, cls) {
  var associations = data.associations, belongsTo = data.belongsTo, hasMany = data.hasMany, hasOne = data.hasOne, matrices = data.manyToMany, i, length, assoc;
  if (data.belongsTo) {
    Ext.log.warn('Use of "belongsTo" is obsolete' + (cls.$className ? ' in ' + cls.$className : ''));
    delete data.belongsTo;
  }
  delete data.manyToMany;
  if (matrices) {
    schema.addMatrices(cls, matrices);
  }
  delete data.associations;
  delete data.belongsTo;
  delete data.hasMany;
  delete data.hasOne;
  if (associations) {
    associations = Ext.isArray(associations) ? associations : [associations];
    for (i = 0, length = associations.length; i < length; ++i) {
      assoc = associations[i];
      switch(assoc.type) {
        case 'belongsTo':
          schema.addLegacyBelongsTo(cls, assoc);
          break;
        case 'hasMany':
          schema.addLegacyHasMany(cls, assoc);
          break;
        case 'hasOne':
          schema.addLegacyHasOne(cls, assoc);
          break;
        default:
          Ext.raise('Invalid association type: "' + assoc.type + '"');
      }
    }
  }
  if (belongsTo) {
    belongsTo = Ext.isArray(belongsTo) ? belongsTo : [belongsTo];
    for (i = 0, length = belongsTo.length; i < length; ++i) {
      schema.addLegacyBelongsTo(cls, belongsTo[i]);
    }
  }
  if (hasMany) {
    hasMany = Ext.isArray(hasMany) ? hasMany : [hasMany];
    for (i = 0, length = hasMany.length; i < length; ++i) {
      schema.addLegacyHasMany(cls, hasMany[i]);
    }
  }
  if (hasOne) {
    hasOne = Ext.isArray(hasOne) ? hasOne : [hasOne];
    for (i = 0, length = hasOne.length; i < length; ++i) {
      schema.addLegacyHasOne(cls, hasOne[i]);
    }
  }
  schema.afterLegacyAssociations(cls);
}, initIdentifier:function(data, cls, proto) {
  var identifier = data.identifier || data.idgen, superIdent = proto.identifier || cls.schema._defaultIdentifier, generatorPrefix;
  if (data.idgen) {
    Ext.log.warn('Ext.data.Model: idgen has been deprecated. Please use identifier instead.');
  }
  if (identifier) {
    delete data.identifier;
    delete data.idgen;
    identifier = Ext.Factory.dataIdentifier(identifier);
  } else {
    if (superIdent) {
      if (superIdent.clone && !superIdent.getId()) {
        identifier = superIdent.clone();
      } else {
        if (superIdent.isGenerator) {
          identifier = superIdent;
        } else {
          identifier = Ext.Factory.dataIdentifier(superIdent);
        }
      }
    }
  }
  cls.identifier = proto.identifier = identifier;
  if (!identifier) {
    generatorPrefix = cls.entityName;
    if (!generatorPrefix) {
      generatorPrefix = Ext.id(null, 'extModel');
    }
    cls.identifier = Ext.Factory.dataIdentifier({type:'sequential', prefix:generatorPrefix + '-'});
  }
}, findValidator:function(validators, name, cfg) {
  var type = cfg.type || cfg, field = validators[name], len, i, item;
  if (field) {
    for (i = 0, len = field.length; i < len; ++i) {
      item = field[i];
      if (item.type === type) {
        return item;
      }
    }
  }
  return null;
}, makeInitializeFn:function(cls) {
  var code = ['var '], body = ['\nreturn function (e) {\n    var data \x3d e.data, v;\n'], fieldVars = [], work = 0, bc, ec, convert, expr, factory, field, fields, fs, hasDefValue, i, length;
  if (!(fields = cls.rankedFields)) {
    fields = cls.rankFields();
  }
  for (i = 0, length = fields.length; i < length; ++i) {
    field = fields[i];
    fieldVars[i] = fs = 'f' + i;
    convert = field.convert;
    if (i) {
      code.push(',  \n    ');
    }
    code.push(fs, ' \x3d $fields[' + i + ']');
    code.push('  /*  ', field.name, '  */');
    if ((hasDefValue = field.defaultValue !== undefined) || convert) {
      expr = 'data["' + field.name + '"]';
      ++work;
      bc = ec = '';
      if (field.cloneDefaultValue) {
        bc = 'Ext.clone(';
        ec = ')';
      }
      body.push('\n');
      if (convert && hasDefValue) {
        body.push('    v \x3d ', expr, ';\n' + '    if (v !\x3d\x3d undefined) {\n' + '        v \x3d ', fs, '.convert(v, e);\n' + '    }\n' + '    if (v \x3d\x3d\x3d undefined) {\n' + '        v \x3d ', bc, fs, '.defaultValue', ec, ';\n' + '    }\n' + '    ', expr, ' \x3d v;');
      } else {
        if (convert) {
          body.push('    v \x3d ', fs, '.convert(', expr, ',e);\n' + '    if (v !\x3d\x3d undefined) {\n' + '        ', expr, ' \x3d v;\n' + '    }\n');
        } else {
          if (hasDefValue) {
            body.push('    if (', expr, ' \x3d\x3d\x3d undefined) {\n' + '        ', expr, ' \x3d ', bc, fs, '.defaultValue', ec, ';\n' + '    }\n');
          }
        }
      }
    }
  }
  if (!work) {
    return Ext.emptyFn;
  }
  code.push(';\n');
  code.push.apply(code, body);
  code.push('}');
  code = code.join('');
  factory = new Function('$fields', 'Ext', code);
  return factory(fields, Ext);
}}}}, function() {
  var Model = this, proto = Model.prototype, Schema = Ext.data.schema.Schema, defaultSchema;
  Model.proxyConfig = proto.proxy;
  delete proto.proxy;
  Model.fields = [];
  Model.fieldsMap = proto.fieldsMap = {};
  Model.schema = proto.schema = Schema.get(proto.schema);
  proto.idField = new Ext.data.field.Field(proto.idProperty);
  Model.identifier = new Ext.data.identifier.Sequential;
  Model.onExtended(function(cls, data) {
    var proto = cls.prototype, schemaName = data.schema, superCls = proto.superclass.self, schema, entityName, proxy;
    cls.idProperty = data.idProperty || proto.idProperty;
    if (schemaName) {
      delete data.schema;
      schema = Schema.get(schemaName);
    } else {
      if (!(schema = proto.schema)) {
        schema = defaultSchema || (defaultSchema = Schema.get('default'));
      }
    }
    cls.rankFields = Model.rankFields;
    cls.topoAdd = Model.topoAdd;
    proto.schema = cls.schema = schema;
    if (!(entityName = data.entityName)) {
      proto.entityName = entityName = schema.getEntityName(cls);
      if (!entityName) {
        if (data.associations) {
          Ext.raise('Anonymous entities cannot specify "associations"');
        }
        if (data.belongsTo) {
          Ext.raise('Anonymous entities cannot specify "belongsTo"');
        }
        if (data.hasMany) {
          Ext.raise('Anonymous entities cannot specify "hasMany"');
        }
        if (data.hasOne) {
          Ext.raise('Anonymous entities cannot specify "hasOne"');
        }
        if (data.matrices) {
          Ext.raise('Anonymous entities cannot specify "manyToMany"');
        }
      }
    }
    cls.entityName = entityName;
    cls.fieldExtractors = {};
    Model.initIdentifier(data, cls, proto);
    Model.initFields(data, cls, proto);
    Model.initValidators(data, cls, proto);
    cls.fields.items = cls.fields;
    if (entityName) {
      schema.addEntity(cls);
      Model.initAssociations(schema, data, cls);
    }
    proxy = data.proxy;
    if (proxy) {
      delete data.proxy;
    } else {
      if (superCls !== Model) {
        proxy = superCls.proxyConfig || superCls.proxy;
      }
    }
    cls.proxyConfig = proxy;
  });
});
Ext.define('Ext.data.ResultSet', {isResultSet:true, $configPrefixed:false, config:{loaded:true, count:null, total:null, success:false, records:null, message:null}, constructor:function(config) {
  this.initConfig(config);
}, getCount:function() {
  var count = this.callParent(), records;
  if (!count) {
    records = this.getRecords();
    if (records) {
      count = records.length;
    }
  }
  return count;
}});
Ext.define('Ext.data.reader.Reader', {alternateClassName:['Ext.data.Reader', 'Ext.data.DataReader'], mixins:[Ext.mixin.Observable, Ext.mixin.Factoryable], alias:'reader.base', factoryConfig:{defaultType:null}, config:{totalProperty:'total', successProperty:'success', rootProperty:'', messageProperty:'', typeProperty:'', implicitIncludes:true, readRecordsOnFailure:true, model:null, proxy:null, transform:null, keepRawData:null}, isReader:true, constructor:function(config) {
  if (config && config.hasOwnProperty('root')) {
    config = Ext.apply({}, config);
    config.rootProperty = config.root;
    delete config.root;
    Ext.log.error('Ext.data.reader.Reader: Using the deprecated "root" configuration. Use "rootProperty" instead.');
  }
  var me = this;
  me.duringInit = 1;
  me.mixins.observable.constructor.call(me, config);
  --me.duringInit;
  me.buildExtractors();
}, applyModel:function(model) {
  return Ext.data.schema.Schema.lookupEntity(model);
}, applyTransform:function(transform) {
  if (transform) {
    if (Ext.isFunction(transform)) {
      transform = {fn:transform};
    } else {
      if (transform.charAt) {
        transform = {fn:this[transform]};
      }
    }
    return transform.fn.bind(transform.scope || this);
  }
  return transform;
}, forceBuildExtractors:function() {
  if (!this.duringInit) {
    this.buildExtractors(true);
  }
}, updateTotalProperty:function() {
  this.forceBuildExtractors();
}, updateMessageProperty:function() {
  this.forceBuildExtractors();
}, updateSuccessProperty:function() {
  this.forceBuildExtractors();
}, read:function(response, readOptions) {
  var data, result;
  if (response) {
    if (response.responseText) {
      result = this.getResponseData(response);
      if (result && result.__$isError) {
        return new Ext.data.ResultSet({total:0, count:0, records:[], success:false, message:result.msg});
      } else {
        data = this.readRecords(result, readOptions);
      }
    } else {
      data = this.readRecords(response, readOptions);
    }
  }
  return data || this.nullResultSet;
}, getNullResultSet:function() {
  return this.nullResultSet;
}, createReadError:function(msg) {
  return {__$isError:true, msg:msg};
}, readRecords:function(data, readOptions, internalReadOptions) {
  var me = this, recordsOnly = internalReadOptions && internalReadOptions.recordsOnly, asRoot = internalReadOptions && internalReadOptions.asRoot, success, recordCount, records, root, total, value, message, transform;
  transform = this.getTransform();
  if (transform) {
    data = transform(data);
  }
  me.buildExtractors();
  if (me.getKeepRawData()) {
    me.rawData = data;
  }
  if (me.hasListeners.rawdata) {
    me.fireEventArgs('rawdata', [data]);
  }
  data = me.getData(data);
  success = true;
  recordCount = 0;
  records = [];
  if (me.getSuccessProperty()) {
    value = me.getSuccess(data);
    if (value === false || value === 'false') {
      success = false;
    }
  }
  if (me.getMessageProperty()) {
    message = me.getMessage(data);
  }
  if (success || me.getReadRecordsOnFailure()) {
    root = asRoot || Ext.isArray(data) ? data : me.getRoot(data);
    if (root) {
      total = root.length;
    }
    if (me.getTotalProperty()) {
      value = parseInt(me.getTotal(data), 10);
      if (!isNaN(value)) {
        total = value;
      }
    }
    if (root) {
      records = me.extractData(root, readOptions);
      recordCount = records.length;
    }
  }
  return recordsOnly ? records : new Ext.data.ResultSet({total:total || recordCount, count:recordCount, records:records, success:success, message:message});
}, extractData:function(root, readOptions) {
  var me = this, entityType = readOptions && readOptions.model ? Ext.data.schema.Schema.lookupEntity(readOptions.model) : me.getModel(), schema = entityType.schema, includes = schema.hasAssociations(entityType) && me.getImplicitIncludes(), fieldExtractorInfo = me.getFieldExtractorInfo(entityType.fieldExtractors), length = root.length, records = new Array(length), typeProperty = me.getTypeProperty(), reader, node, nodeType, record, i;
  if (!length && Ext.isObject(root)) {
    root = [root];
    length = 1;
  }
  for (i = 0; i < length; i++) {
    record = root[i];
    if (!record.isModel) {
      node = record;
      if (typeProperty && (nodeType = me.getChildType(schema, node, typeProperty))) {
        reader = nodeType.getProxy().getReader();
        record = reader.extractRecord(node, readOptions, nodeType, schema.hasAssociations(nodeType) && reader.getImplicitIncludes(), reader.getFieldExtractorInfo(nodeType.fieldExtractors));
      } else {
        record = me.extractRecord(node, readOptions, entityType, includes, fieldExtractorInfo);
      }
      if (record.isModel && record.isNode) {
        record.raw = node;
      }
    }
    if (record.onLoad) {
      record.onLoad();
    }
    records[i] = record;
  }
  return records;
}, getChildType:function(schema, rawNode, typeProperty) {
  var namespace;
  switch(typeof typeProperty) {
    case 'string':
      return schema.getEntity(rawNode[typeProperty]);
    case 'object':
      namespace = typeProperty.namespace;
      return schema.getEntity((namespace ? namespace + '.' : '') + rawNode[typeProperty.name]);
    case 'function':
      return schema.getEntity(typeProperty(rawNode));
  }
}, extractRecordData:function(node, readOptions) {
  var entityType = readOptions && readOptions.model ? Ext.data.schema.Schema.lookupEntity(readOptions.model) : this.getModel(), fieldExtractorInfo = this.getFieldExtractorInfo(entityType.fieldExtractors);
  return this.extractRecord(node, readOptions, entityType, false, fieldExtractorInfo);
}, extractRecord:function(node, readOptions, entityType, includes, fieldExtractorInfo) {
  var me = this, creatorFn = readOptions && readOptions.recordCreator || me.defaultRecordCreator, modelData, record;
  modelData = me.extractModelData(node, fieldExtractorInfo);
  record = creatorFn.call(me, modelData, entityType || me.getModel(), readOptions);
  if (includes && record.isModel) {
    me.readAssociated(record, node, readOptions);
  }
  return record;
}, getFieldExtractorInfo:function(extractors) {
  if (!extractors) {
    return;
  }
  var type = this.$className, extractor = extractors[type];
  if (extractor === undefined) {
    extractors[type] = extractor = this.buildFieldExtractors();
  }
  return extractor;
}, buildFieldExtractors:function() {
  var fields = this.getFields(), len = fields.length, buffer = [], extractors = [], out = null, cnt = 0, field, name, i, extractor;
  for (i = 0; i < len; ++i) {
    field = fields[i];
    extractor = this.createFieldAccessor(field);
    if (extractor) {
      name = field.name;
      buffer.push('val \x3d extractors[' + cnt + "](raw); if (val !\x3d\x3d undefined) { data['" + name + "'] \x3d val; }");
      extractors.push(extractor);
      ++cnt;
    }
  }
  if (buffer.length) {
    out = {extractors:extractors, fn:new Function('raw', 'data', 'extractors', 'var val;' + buffer.join(''))};
  }
  return out;
}, defaultRecordCreator:function(data, Model) {
  var record = new Model(data);
  record.phantom = false;
  return record;
}, getModelData:function(raw) {
  return {};
}, extractModelData:function(raw, fieldExtractorInfo) {
  var data = this.getModelData(raw), fn;
  if (fieldExtractorInfo) {
    fn = fieldExtractorInfo.fn;
    fn(raw, data, fieldExtractorInfo.extractors);
  }
  return data;
}, readAssociated:function(record, data, readOptions) {
  var roles = record.associations, key, role;
  for (key in roles) {
    if (roles.hasOwnProperty(key)) {
      role = roles[key];
      if (role.cls) {
        role.read(record, data, this, readOptions);
      }
    }
  }
}, getFields:function() {
  return this.getModel().fields;
}, getData:Ext.identityFn, getRoot:Ext.identityFn, getResponseData:function(response) {
  Ext.raise('getResponseData must be implemented in the Ext.data.reader.Reader subclass');
}, onMetaChange:function(meta) {
  var me = this, fields = meta.fields, model, newModel, clientIdProperty, proxy;
  me.metaData = meta;
  if (meta.root) {
    me.setRootProperty(meta.root);
  }
  if (meta.totalProperty) {
    me.setTotalProperty(meta.totalProperty);
  }
  if (meta.successProperty) {
    me.setSuccessProperty(meta.successProperty);
  }
  if (meta.messageProperty) {
    me.setMessageProperty(meta.messageProperty);
  }
  clientIdProperty = meta.clientIdProperty;
  if (fields) {
    newModel = Ext.define(null, {extend:'Ext.data.Model', fields:fields, clientIdProperty:clientIdProperty});
    me.setModel(newModel);
    proxy = me.getProxy();
    if (proxy) {
      proxy.setModel(newModel);
    }
  } else {
    if (clientIdProperty) {
      model = me.getModel();
      if (model) {
        model.self.prototype.clientIdProperty = clientIdProperty;
      }
    }
  }
}, buildExtractors:function(force) {
  var me = this, totalProp, successProp, messageProp;
  if (force || !me.hasExtractors) {
    totalProp = me.getTotalProperty();
    successProp = me.getSuccessProperty();
    messageProp = me.getMessageProperty();
    if (totalProp) {
      me.getTotal = me.getAccessor(totalProp);
    }
    if (successProp) {
      me.getSuccess = me.getAccessor(successProp);
    }
    if (messageProp) {
      me.getMessage = me.getAccessor(messageProp);
    }
    me.hasExtractors = true;
    return true;
  }
}, getAccessor:function(prop) {
  var me = this, cache = me.extractorCache, ret, key;
  if (typeof prop === 'string') {
    key = me.getAccessorKey(prop);
    ret = cache.get(key);
    if (!ret) {
      ret = me.createAccessor(prop);
      cache.add(key, ret);
    }
  } else {
    ret = me.createAccessor(prop);
  }
  return ret;
}, getAccessorKey:function(prop) {
  return this.$className + prop;
}, createAccessor:Ext.emptyFn, createFieldAccessor:Ext.emptyFn, destroy:function() {
  var me = this;
  me.model = me.getTotal = me.getSuccess = me.getMessage = me.rawData = null;
  me.onMetaChange = null;
  me.transform = null;
  me.callParent();
}, privates:{copyFrom:function(reader) {
  var me = this;
  reader.buildExtractors();
  me.getTotal = reader.getTotal;
  me.getSuccess = reader.getSuccess;
  me.getMessage = reader.getMessage;
  ++me.duringInit;
  me.setConfig(reader.getConfig());
  --me.duringInit;
  me.hasExtractors = true;
}}}, function(Cls) {
  var proto = Cls.prototype;
  Ext.apply(proto, {nullResultSet:new Ext.data.ResultSet({total:0, count:0, records:[], success:true, message:''})});
  proto.extractorCache = new Ext.util.LruCache;
});
Ext.define('Ext.data.writer.Writer', {mixins:[Ext.mixin.Factoryable], alias:'writer.base', factoryConfig:{defaultType:null}, alternateClassName:['Ext.data.DataWriter', 'Ext.data.Writer'], config:{clientIdProperty:null, allDataOptions:{persist:true}, partialDataOptions:{changes:true, critical:true}, writeAllFields:false, dateFormat:null, nameProperty:'name', writeRecordId:true, transform:null}, isWriter:true, constructor:function(config) {
  this.initConfig(config);
}, applyTransform:function(transform) {
  if (transform) {
    if (Ext.isFunction(transform)) {
      transform = {fn:transform};
    }
    return transform.fn.bind(transform.scope || this);
  }
  return transform;
}, write:function(request) {
  var operation = request.getOperation(), records = operation.getRecords() || [], len = records.length, data = [], i;
  for (i = 0; i < len; i++) {
    data.push(this.getRecordData(records[i], operation));
  }
  return this.writeRecords(request, data);
}, writeRecords:Ext.emptyFn, getRecordData:function(record, operation) {
  var me = this, nameProperty = me.getNameProperty(), mapping = nameProperty !== 'name', idField = record.self.idField, key = idField[nameProperty] || idField.name, value = record.id, writeAll = me.getWriteAllFields(), ret, dateFormat, phantom, options, clientIdProperty, fieldsMap, data, field;
  if (idField.serialize) {
    value = idField.serialize(value);
  }
  if (!writeAll && operation && operation.isDestroyOperation) {
    ret = {};
    ret[key] = value;
  } else {
    dateFormat = me.getDateFormat();
    phantom = record.phantom;
    options = phantom || writeAll ? me.getAllDataOptions() : me.getPartialDataOptions();
    clientIdProperty = phantom && me.getClientIdProperty();
    fieldsMap = record.getFieldsMap();
    options.serialize = false;
    data = record.getData(options);
    ret = mapping ? {} : data;
    if (clientIdProperty) {
      ret[clientIdProperty] = value;
      delete data[key];
    } else {
      if (!me.getWriteRecordId()) {
        delete data[key];
      }
    }
    for (key in data) {
      value = data[key];
      if (!(field = fieldsMap[key])) {
        if (mapping) {
          ret[key] = value;
        }
      } else {
        if (field.isDateField && dateFormat && Ext.isDate(value)) {
          value = Ext.Date.format(value, dateFormat);
        } else {
          if (field.serialize) {
            value = field.serialize(value, record);
          }
        }
        if (mapping) {
          key = field[nameProperty] || key;
        }
        ret[key] = value;
      }
    }
  }
  return ret;
}});
Ext.define('Ext.data.proxy.Proxy', {mixins:[Ext.mixin.Factoryable, Ext.mixin.Observable], $configPrefixed:false, alias:'proxy.proxy', alternateClassName:['Ext.data.DataProxy', 'Ext.data.Proxy'], config:{batchOrder:'create,update,destroy', batchActions:true, model:undefined, reader:{type:'json'}, writer:{type:'json'}}, isProxy:true, isSynchronous:false, constructor:function(config) {
  this.mixins.observable.constructor.call(this, config);
  this.pendingOperations = {};
}, applyModel:function(model) {
  return Ext.data.schema.Schema.lookupEntity(model);
}, updateModel:function(model) {
  if (model) {
    var reader = this.getReader();
    if (reader && !reader.getModel()) {
      reader.setModel(model);
    }
  }
}, applyReader:function(reader) {
  if (this.isSynchronous) {
    reader = reader || {};
    reader.keepRawData = true;
  }
  return Ext.Factory.reader(reader);
}, updateReader:function(reader) {
  if (reader) {
    var me = this, model = me.getModel();
    if (!model) {
      model = reader.getModel();
      if (model) {
        me.setModel(model);
      }
    } else {
      reader.setModel(model);
    }
    if (reader.onMetaChange) {
      reader.onMetaChange = Ext.Function.createSequence(reader.onMetaChange, me.onMetaChange, me);
    }
  }
}, applyWriter:function(writer) {
  var reader = this.getReader();
  writer = Ext.Factory.writer(writer);
  if (writer.getRecord && !writer.getRecord() && reader && reader.getRecord) {
    reader = reader.getRecord();
    if (reader) {
      writer.setRecord(reader);
    }
  }
  return writer;
}, abort:Ext.emptyFn, onMetaChange:function(meta) {
  this.fireEvent('metachange', this, meta);
}, create:Ext.emptyFn, read:Ext.emptyFn, update:Ext.emptyFn, erase:Ext.emptyFn, batch:function(options, listeners) {
  var me = this, useBatch = me.getBatchActions(), batch, records, actions, aLen, action, a, r, rLen, record;
  if (options.operations === undefined) {
    options = {operations:options, listeners:listeners};
  }
  if (options.batch) {
    if (Ext.isDefined(options.batch.runOperation)) {
      batch = Ext.applyIf(options.batch, {proxy:me, listeners:{}});
    }
  } else {
    options.batch = {proxy:me, listeners:options.listeners || {}};
  }
  if (!batch) {
    batch = new Ext.data.Batch(options.batch);
  }
  batch.on('complete', Ext.bind(me.onBatchComplete, me, [options], 0));
  actions = me.getBatchOrder().split(',');
  aLen = actions.length;
  for (a = 0; a < aLen; a++) {
    action = actions[a];
    records = options.operations[action];
    if (records) {
      if (useBatch) {
        batch.add(me.createOperation(action, {records:records, params:options.params}));
      } else {
        rLen = records.length;
        for (r = 0; r < rLen; r++) {
          record = records[r];
          batch.add(me.createOperation(action, {records:[record], params:options.params}));
        }
      }
    }
  }
  batch.start();
  return batch;
}, onBatchComplete:function(batchOptions, batch) {
  var scope = batchOptions.scope || this;
  if (batch.hasException()) {
    if (Ext.isFunction(batchOptions.failure)) {
      Ext.callback(batchOptions.failure, scope, [batch, batchOptions]);
    }
  } else {
    if (Ext.isFunction(batchOptions.success)) {
      Ext.callback(batchOptions.success, scope, [batch, batchOptions]);
    }
  }
  if (Ext.isFunction(batchOptions.callback)) {
    Ext.callback(batchOptions.callback, scope, [batch, batchOptions]);
  }
}, createOperation:function(action, config) {
  var operation = Ext.createByAlias('data.operation.' + action, config);
  operation.setProxy(this);
  this.pendingOperations[operation._internalId] = operation;
  return operation;
}, completeOperation:function(operation) {
  delete this.pendingOperations[operation._internalId];
}, clone:function() {
  return new this.self(this.getInitialConfig());
}, destroy:function() {
  var ops = this.pendingOperations, opId, op;
  for (opId in ops) {
    op = ops[opId];
    if (op && op.isRunning()) {
      op.abort();
    }
  }
  this.pendingOperations = null;
}});
Ext.define('Ext.data.proxy.Client', {extend:Ext.data.proxy.Proxy, alternateClassName:'Ext.data.ClientProxy', isSynchronous:true, clear:function() {
  Ext.raise("The Ext.data.proxy.Client subclass that you are using has not defined a 'clear' function. See src/data/ClientProxy.js for details.");
}});
Ext.define('Ext.data.proxy.Memory', {extend:Ext.data.proxy.Client, alias:'proxy.memory', alternateClassName:'Ext.data.MemoryProxy', isMemoryProxy:true, config:{enablePaging:false, data:{$value:null, merge:function(newValue, currentValue, target, mixinClass) {
  if (Ext.isArray(newValue)) {
    return Ext.Array.clone(newValue);
  } else {
    return Ext.clone(newValue);
  }
}}}, finishOperation:function(operation) {
  var i = 0, recs = operation.getRecords(), len = recs.length;
  for (i; i < len; i++) {
    recs[i].commit();
  }
  operation.setSuccessful(true);
}, create:function(operation) {
  this.finishOperation(operation);
}, update:function(operation) {
  this.finishOperation(operation);
}, erase:function(operation) {
  this.finishOperation(operation);
}, read:function(operation) {
  var me = this, resultSet = me.getReader().read(me.getData()), records = resultSet.getRecords(), sorters = operation.getSorters(), grouper = operation.getGrouper(), filters = operation.getFilters(), start = operation.getStart(), limit = operation.getLimit();
  if (operation.process(resultSet, null, null, false) !== false) {
    if (filters && filters.length) {
      resultSet.setRecords(records = Ext.Array.filter(records, Ext.util.Filter.createFilterFn(filters)));
      resultSet.setTotal(records.length);
    }
    if (grouper) {
      sorters = sorters ? sorters.concat(grouper) : sorters;
    }
    if (sorters && sorters.length) {
      resultSet.setRecords(records = Ext.Array.sort(records, Ext.util.Sortable.createComparator(sorters)));
    }
    if (me.getEnablePaging() && start !== undefined && limit !== undefined) {
      if (start >= resultSet.getTotal()) {
        resultSet.setConfig({success:false, records:[], total:0});
      } else {
        resultSet.setRecords(Ext.Array.slice(records, start, start + limit));
      }
    }
    operation.setCompleted();
  }
}, clear:Ext.emptyFn});
Ext.define('Ext.data.ProxyStore', {extend:Ext.data.AbstractStore, config:{model:undefined, fields:null, proxy:undefined, autoLoad:undefined, autoSync:false, batchUpdateMode:'operation', sortOnLoad:true, trackRemoved:true, asynchronousLoad:undefined}, onClassExtended:function(cls, data, hooks) {
  var model = data.model, onBeforeClassCreated;
  if (typeof model === 'string') {
    onBeforeClassCreated = hooks.onBeforeCreated;
    hooks.onBeforeCreated = function() {
      var me = this, args = arguments;
      Ext.require(model, function() {
        onBeforeClassCreated.apply(me, args);
      });
    };
  }
}, implicitModel:'Ext.data.Model', autoSyncSuspended:0, constructor:function(config) {
  var me = this;
  var configModel = me.model;
  me.removed = [];
  me.callParent(arguments);
  if (me.getAsynchronousLoad() === false) {
    me.flushLoad();
  }
  if (!me.getModel() && me.useModelWarning !== false && me.getStoreId() !== 'ext-empty-store') {
    var logMsg = [Ext.getClassName(me) || 'Store', ' created with no model.'];
    if (typeof configModel === 'string') {
      logMsg.push(" The name '", configModel, "'", ' does not correspond to a valid model.');
    }
    Ext.log.warn(logMsg.join(''));
  }
}, applyAsynchronousLoad:function(asynchronousLoad) {
  if (asynchronousLoad == null) {
    asynchronousLoad = !this.loadsSynchronously();
  }
  return asynchronousLoad;
}, updateAutoLoad:function(autoLoad) {
  this.getData();
  if (autoLoad) {
    this.load(Ext.isObject(autoLoad) ? autoLoad : undefined);
  }
}, getTotalCount:function() {
  return this.totalCount || 0;
}, applyFields:function(fields) {
  if (fields) {
    this.createImplicitModel(fields);
  }
}, applyModel:function(model) {
  if (model) {
    model = Ext.data.schema.Schema.lookupEntity(model);
  } else {
    this.getFields();
    model = this.getModel() || this.createImplicitModel();
  }
  return model;
}, applyProxy:function(proxy) {
  var model = this.getModel();
  if (proxy !== null) {
    if (proxy) {
      if (proxy.isProxy) {
        proxy.setModel(model);
      } else {
        if (Ext.isString(proxy)) {
          proxy = {type:proxy, model:model};
        } else {
          if (!proxy.model) {
            proxy = Ext.apply({model:model}, proxy);
          }
        }
        proxy = Ext.createByAlias('proxy.' + proxy.type, proxy);
        proxy.autoCreated = true;
      }
    } else {
      if (model) {
        proxy = model.getProxy();
      }
    }
    if (!proxy) {
      proxy = Ext.createByAlias('proxy.memory');
      proxy.autoCreated = true;
    }
  }
  return proxy;
}, applyState:function(state) {
  var me = this;
  me.callParent([state]);
  if (me.getAutoLoad() || me.isLoaded()) {
    me.load();
  }
}, updateProxy:function(proxy, oldProxy) {
  this.proxyListeners = Ext.destroy(this.proxyListeners);
}, updateTrackRemoved:function(track) {
  this.cleanRemoved();
  this.removed = track ? [] : null;
}, onMetaChange:function(proxy, meta) {
  this.fireEvent('metachange', this, meta);
}, create:function(data, options) {
  var me = this, Model = me.getModel(), instance = new Model(data), operation;
  options = Ext.apply({}, options);
  if (!options.records) {
    options.records = [instance];
  }
  options.internalScope = me;
  options.internalCallback = me.onProxyWrite;
  operation = me.createOperation('create', options);
  return operation.execute();
}, read:function() {
  return this.load.apply(this, arguments);
}, update:function(options) {
  var me = this, operation;
  options = Ext.apply({}, options);
  if (!options.records) {
    options.records = me.getUpdatedRecords();
  }
  options.internalScope = me;
  options.internalCallback = me.onProxyWrite;
  operation = me.createOperation('update', options);
  return operation.execute();
}, onProxyWrite:function(operation) {
  var me = this, success = operation.wasSuccessful(), records = operation.getRecords();
  switch(operation.getAction()) {
    case 'create':
      me.onCreateRecords(records, operation, success);
      break;
    case 'update':
      me.onUpdateRecords(records, operation, success);
      break;
    case 'destroy':
      me.onDestroyRecords(records, operation, success);
      break;
  }
  if (success) {
    me.fireEvent('write', me, operation);
    me.fireEvent('datachanged', me);
  }
}, onCreateRecords:Ext.emptyFn, onUpdateRecords:Ext.emptyFn, onDestroyRecords:function(records, operation, success) {
  if (success) {
    this.cleanRemoved();
  }
}, erase:function(options) {
  var me = this, operation;
  options = Ext.apply({}, options);
  if (!options.records) {
    options.records = me.getRemovedRecords();
  }
  options.internalScope = me;
  options.internalCallback = me.onProxyWrite;
  operation = me.createOperation('destroy', options);
  return operation.execute();
}, onBatchOperationComplete:function(batch, operation) {
  return this.onProxyWrite(operation);
}, onBatchComplete:function(batch, operation) {
  var me = this, operations = batch.operations, length = operations.length, i;
  if (me.batchUpdateMode !== 'operation') {
    me.suspendEvents();
    for (i = 0; i < length; i++) {
      me.onProxyWrite(operations[i]);
    }
    me.resumeEvents();
  }
  me.isSyncing = false;
  me.fireEvent('datachanged', me);
}, onBatchException:function(batch, operation) {
}, filterNew:function(item) {
  return item.phantom === true && item.isValid();
}, getNewRecords:function() {
  return [];
}, getUpdatedRecords:function() {
  return [];
}, getModifiedRecords:function() {
  return [].concat(this.getNewRecords(), this.getUpdatedRecords());
}, filterUpdated:function(item) {
  return item.dirty === true && item.phantom !== true && item.isValid();
}, getRemovedRecords:function() {
  var removed = this.getRawRemovedRecords();
  return removed ? Ext.Array.clone(removed) : removed;
}, sync:function(options) {
  var me = this, operations = {}, toCreate = me.getNewRecords(), toUpdate = me.getUpdatedRecords(), toDestroy = me.getRemovedRecords(), needsSync = false;
  if (me.isSyncing) {
    Ext.log.warn('Sync called while a sync operation is in progress. Consider configuring autoSync as false.');
  }
  me.needsSync = false;
  if (toCreate.length > 0) {
    operations.create = toCreate;
    needsSync = true;
  }
  if (toUpdate.length > 0) {
    operations.update = toUpdate;
    needsSync = true;
  }
  if (toDestroy.length > 0) {
    operations.destroy = toDestroy;
    needsSync = true;
  }
  if (needsSync && me.fireEvent('beforesync', operations) !== false) {
    me.isSyncing = true;
    options = options || {};
    me.proxy.batch(Ext.apply(options, {operations:operations, listeners:me.getBatchListeners()}));
  }
  return me;
}, getBatchListeners:function() {
  var me = this, listeners = {scope:me, exception:me.onBatchException, complete:me.onBatchComplete};
  if (me.batchUpdateMode === 'operation') {
    listeners.operationcomplete = me.onBatchOperationComplete;
  }
  return listeners;
}, save:function() {
  return this.sync.apply(this, arguments);
}, load:function(options) {
  var me = this;
  if (typeof options === 'function') {
    options = {callback:options};
  } else {
    options = options ? Ext.Object.chain(options) : {};
  }
  me.pendingLoadOptions = options;
  if (me.getAsynchronousLoad()) {
    if (!me.loadTimer) {
      me.loadTimer = Ext.asap(me.flushLoad, me);
    }
  } else {
    me.flushLoad();
  }
  return me;
}, flushLoad:function() {
  var me = this, options = me.pendingLoadOptions, operation;
  me.clearLoadTask();
  if (!options) {
    return;
  }
  me.setLoadOptions(options);
  if (me.getRemoteSort() && options.sorters) {
    me.fireEvent('beforesort', me, options.sorters);
  }
  operation = Ext.apply({internalScope:me, internalCallback:me.onProxyLoad, scope:me}, options);
  me.lastOptions = operation;
  operation = me.createOperation('read', operation);
  if (me.fireEvent('beforeload', me, operation) !== false) {
    me.onBeforeLoad(operation);
    me.loading = true;
    operation.execute();
  }
}, reload:function(options) {
  var o = Ext.apply({}, options, this.lastOptions);
  return this.load(o);
}, onEndUpdate:function() {
  var me = this;
  if (me.needsSync && me.autoSync && !me.autoSyncSuspended) {
    me.sync();
  }
}, afterReject:function(record) {
  var me = this;
  if (me.contains(record)) {
    me.onUpdate(record, Ext.data.Model.REJECT, null);
    me.fireEvent('update', me, record, Ext.data.Model.REJECT, null);
  }
}, afterCommit:function(record, modifiedFieldNames) {
  var me = this;
  if (!modifiedFieldNames) {
    modifiedFieldNames = null;
  }
  if (me.contains(record)) {
    me.onUpdate(record, Ext.data.Model.COMMIT, modifiedFieldNames);
    me.fireEvent('update', me, record, Ext.data.Model.COMMIT, modifiedFieldNames);
  }
}, afterErase:function(record) {
  this.onErase(record);
}, onErase:Ext.emptyFn, onUpdate:Ext.emptyFn, onDestroy:function() {
  var me = this, proxy = me.getProxy();
  me.clearLoadTask();
  me.getData().destroy();
  me.data = null;
  me.setProxy(null);
  if (proxy.autoCreated) {
    proxy.destroy();
  }
  me.setModel(null);
}, hasPendingLoad:function() {
  return !!this.pendingLoadOptions || this.isLoading();
}, isLoading:function() {
  return !!this.loading;
}, isLoaded:function() {
  return this.loadCount > 0;
}, suspendAutoSync:function() {
  ++this.autoSyncSuspended;
}, resumeAutoSync:function(syncNow) {
  var me = this;
  if (!me.autoSyncSuspended) {
    Ext.log.warn('Mismatched call to resumeAutoSync - auto synchronization is currently not suspended.');
  }
  if (me.autoSyncSuspended && !--me.autoSyncSuspended) {
    if (syncNow) {
      me.sync();
    }
  }
}, removeAll:Ext.emptyFn, clearData:Ext.emptyFn, privates:{getRawRemovedRecords:function() {
  return this.removed;
}, onExtraParamsChanged:function() {
}, clearLoadTask:function() {
  Ext.asapCancel(this.loadTimer);
  this.pendingLoadOptions = this.loadTimer = null;
}, cleanRemoved:function() {
  var removed = this.getRawRemovedRecords(), len, i;
  if (removed) {
    for (i = 0, len = removed.length; i < len; ++i) {
      removed[i].unjoin(this);
    }
    removed.length = 0;
  }
}, createOperation:function(type, options) {
  var me = this, proxy = me.getProxy(), listeners;
  if (!me.proxyListeners) {
    listeners = {scope:me, destroyable:true, beginprocessresponse:me.beginUpdate, endprocessresponse:me.endUpdate};
    if (!me.disableMetaChangeEvent) {
      listeners.metachange = me.onMetaChange;
    }
    me.proxyListeners = proxy.on(listeners);
  }
  return proxy.createOperation(type, options);
}, createImplicitModel:function(fields) {
  var me = this, modelCfg = {extend:me.implicitModel, statics:{defaultProxy:'memory'}}, proxy, model;
  if (fields) {
    modelCfg.fields = fields;
  }
  model = Ext.define(null, modelCfg);
  me.setModel(model);
  proxy = me.getProxy();
  if (proxy) {
    model.setProxy(proxy);
  } else {
    me.setProxy(model.getProxy());
  }
}, loadsSynchronously:function() {
  return this.getProxy().isSynchronous;
}, onBeforeLoad:Ext.privateFn, removeFromRemoved:function(record) {
  var removed = this.getRawRemovedRecords();
  if (removed) {
    Ext.Array.remove(removed, record);
    record.unjoin(this);
  }
}, setLoadOptions:function(options) {
  var me = this, filters, sorters;
  if (me.getRemoteFilter()) {
    filters = me.getFilters(false);
    if (filters && filters.getCount()) {
      options.filters = filters.getRange();
    }
  }
  if (me.getRemoteSort()) {
    sorters = me.getSorters(false);
    if (sorters && sorters.getCount()) {
      options.sorters = sorters.getRange();
    }
  }
}}});
Ext.define('Ext.data.LocalStore', {extend:Ext.Mixin, mixinConfig:{id:'localstore'}, config:{extraKeys:null}, applyExtraKeys:function(extraKeys) {
  var indexName, data = this.getData();
  data.setExtraKeys(extraKeys);
  extraKeys = data.getExtraKeys();
  for (indexName in extraKeys) {
    this[indexName] = extraKeys[indexName];
  }
}, add:function(arg) {
  return this.insert(this.getCount(), arguments.length === 1 ? arg : arguments);
}, constructDataCollection:function() {
  return new Ext.util.Collection({rootProperty:'data'});
}, createModel:function(record) {
  var session = this.getSession(), Model;
  if (!record.isModel) {
    Model = this.getModel();
    record = new Model(record, session);
  }
  return record;
}, createFiltersCollection:function() {
  return this.getData().getFilters();
}, createSortersCollection:function() {
  var sorters = this.getData().getSorters();
  sorters.setSorterConfigure(this.addFieldTransform, this);
  return sorters;
}, onCollectionSort:function() {
  this.onSorterEndUpdate();
}, onCollectionFilter:function() {
  this.onFilterEndUpdate();
}, notifySorterChange:function() {
  this.getData().onSorterChange();
}, forceLocalSort:function() {
  this.getData().onSortChange();
}, contains:function(record) {
  return this.indexOf(record) > -1;
}, each:function(fn, scope) {
  var data = this.data.items, len = data.length, record, i;
  for (i = 0; i < len; ++i) {
    record = data[i];
    if (fn.call(scope || record, record, i, len) === false) {
      break;
    }
  }
}, collect:function(dataIndex, allowNull, bypassFilter) {
  var me = this, data = me.getData();
  if (bypassFilter === true && data.filtered) {
    data = data.getSource();
  }
  return data.collect(dataIndex, 'data', allowNull);
}, getById:function(id) {
  var data = this.getData();
  if (data.filtered) {
    data = data.getSource();
  }
  return data.get(id) || null;
}, getByInternalId:function(internalId) {
  var data = this.getData(), keyCfg;
  if (data.filtered) {
    if (!data.$hasExtraKeys) {
      keyCfg = this.makeInternalKeyCfg();
      data.setExtraKeys(keyCfg);
      data.$hasExtraKeys = true;
    }
    data = data.getSource();
  }
  if (!data.$hasExtraKeys) {
    data.setExtraKeys(keyCfg || this.makeInternalKeyCfg());
    data.$hasExtraKeys = true;
  }
  return data.byInternalId.get(internalId) || null;
}, getDataSource:function() {
  var data = this.getData();
  return data.getSource() || data;
}, indexOf:function(record) {
  return this.getData().indexOf(record);
}, indexOfId:function(id) {
  return this.indexOf(this.getById(id));
}, insert:function(index, records) {
  var me = this, len, i;
  if (records) {
    if (!Ext.isIterable(records)) {
      records = [records];
    } else {
      records = Ext.Array.clone(records);
    }
    len = records.length;
  }
  if (!len) {
    return [];
  }
  for (i = 0; i < len; ++i) {
    records[i] = me.createModel(records[i]);
  }
  me.getData().insert(index, records);
  return records;
}, queryBy:function(fn, scope) {
  var data = this.getData();
  return (data.getSource() || data).createFiltered(fn, scope);
}, query:function(property, value, anyMatch, caseSensitive, exactMatch) {
  var data = this.getData();
  return (data.getSource() || data).createFiltered(property, value, anyMatch, caseSensitive, exactMatch);
}, first:function(grouped) {
  return this.getData().first(grouped) || null;
}, last:function(grouped) {
  return this.getData().last(grouped) || null;
}, sum:function(field, grouped) {
  var data = this.getData();
  return grouped && this.isGrouped() ? data.sumByGroup(field) : data.sum(field);
}, count:function(grouped) {
  var data = this.getData();
  return grouped && this.isGrouped() ? data.countByGroup() : data.count();
}, min:function(field, grouped) {
  var data = this.getData();
  return grouped && this.isGrouped() ? data.minByGroup(field) : data.min(field);
}, max:function(field, grouped) {
  var data = this.getData();
  return grouped && this.isGrouped() ? data.maxByGroup(field) : data.max(field);
}, average:function(field, grouped) {
  var data = this.getData();
  return grouped && this.isGrouped() ? data.averageByGroup(field) : data.average(field);
}, aggregate:function(fn, scope, grouped, field) {
  var me = this, groups, len, out, group, i;
  if (grouped && me.isGrouped()) {
    groups = me.getGroups().items;
    len = groups.length;
    out = {};
    for (i = 0; i < len; ++i) {
      group = groups[i];
      out[group.getGroupKey()] = me.getAggregate(fn, scope || me, group.items, field);
    }
    return out;
  } else {
    return me.getAggregate(fn, scope, me.getData().items, field);
  }
}, getAggregate:function(fn, scope, records, field) {
  var values = [], len = records.length, i;
  for (i = 0; i < len; ++i) {
    values[i] = records[i].get(field);
  }
  return fn.call(scope || this, records, values);
}, addObserver:function(observer) {
  var observers = this.observers;
  if (!observers) {
    this.observers = observers = new Ext.util.Collection;
  }
  observers.add(observer);
}, removeObserver:function(observer) {
  var observers = this.observers;
  if (observers) {
    observers.remove(observer);
  }
}, callObservers:function(action, args) {
  var observers = this.observers, len, items, i, methodName, item;
  if (observers) {
    items = observers.items;
    if (args) {
      args.unshift(this);
    } else {
      args = [this];
    }
    for (i = 0, len = items.length; i < len; ++i) {
      item = items[i];
      methodName = 'onSource' + action;
      if (item[methodName]) {
        item[methodName].apply(item, args);
      }
    }
  }
}, queryRecordsBy:function(fn, scope) {
  var data = this.getData(), matches = [], len, i, record;
  data = (data.getSource() || data).items;
  scope = scope || this;
  for (i = 0, len = data.length; i < len; ++i) {
    record = data[i];
    if (fn.call(scope, record) === true) {
      matches.push(record);
    }
  }
  return matches;
}, queryRecords:function(field, value) {
  var data = this.getData(), matches = [], len, i, record;
  data = (data.getSource() || data).items;
  for (i = 0, len = data.length; i < len; ++i) {
    record = data[i];
    if (record.get(field) === value) {
      matches.push(record);
    }
  }
  return matches;
}, privates:{isLast:function(record) {
  return record === this.last();
}, makeInternalKeyCfg:function() {
  return {byInternalId:{property:'internalId', rootProperty:''}};
}}});
Ext.define('Ext.data.proxy.Server', {extend:Ext.data.proxy.Proxy, alias:'proxy.server', alternateClassName:'Ext.data.ServerProxy', isRemote:true, config:{url:'', pageParam:'page', startParam:'start', limitParam:'limit', groupParam:'group', groupDirectionParam:'groupDir', sortParam:'sort', filterParam:'filter', directionParam:'dir', idParam:'id', simpleSortMode:false, simpleGroupMode:false, noCache:true, cacheString:'_dc', timeout:30000, api:{create:undefined, read:undefined, update:undefined, destroy:undefined}, 
extraParams:{}}, create:function() {
  return this.doRequest.apply(this, arguments);
}, read:function() {
  return this.doRequest.apply(this, arguments);
}, update:function() {
  return this.doRequest.apply(this, arguments);
}, erase:function() {
  return this.doRequest.apply(this, arguments);
}, setExtraParam:function(name, value) {
  var extraParams = this.getExtraParams();
  extraParams[name] = value;
  this.fireEvent('extraparamschanged', extraParams);
}, updateExtraParams:function(newExtraParams, oldExtraParams) {
  this.fireEvent('extraparamschanged', newExtraParams);
}, buildRequest:function(operation) {
  var me = this, initialParams = Ext.apply({}, operation.getParams()), params = Ext.applyIf(initialParams, me.getExtraParams() || {}), request, operationId, idParam;
  Ext.applyIf(params, me.getParams(operation));
  operationId = operation.getId();
  idParam = me.getIdParam();
  if (operationId !== undefined && params[idParam] === undefined) {
    params[idParam] = operationId;
  }
  request = new Ext.data.Request({params:params, action:operation.getAction(), records:operation.getRecords(), url:operation.getUrl(), operation:operation, proxy:me});
  request.setUrl(me.buildUrl(request));
  operation.setRequest(request);
  return request;
}, processResponse:function(success, operation, request, response) {
  var me = this, exception, reader, resultSet;
  me.fireEvent('beginprocessresponse', me, response, operation);
  if (success === true) {
    reader = me.getReader();
    if (response.status === 204) {
      resultSet = reader.getNullResultSet();
    } else {
      resultSet = reader.read(me.extractResponseData(response), {recordCreator:operation.getRecordCreator()});
    }
    operation.process(resultSet, request, response);
    exception = !operation.wasSuccessful();
  } else {
    me.setException(operation, response);
    exception = true;
  }
  if (exception) {
    me.fireEvent('exception', me, response, operation);
  }
  me.afterRequest(request, success);
  me.fireEvent('endprocessresponse', me, response, operation);
}, setException:function(operation, response) {
  operation.setException({status:response.status, statusText:response.statusText, response:response});
}, extractResponseData:Ext.identityFn, applyEncoding:function(value) {
  return Ext.encode(value);
}, encodeSorters:function(sorters, preventArray) {
  var out = [], length = sorters.length, i;
  for (i = 0; i < length; i++) {
    out[i] = sorters[i].serialize();
  }
  return this.applyEncoding(preventArray ? out[0] : out);
}, encodeFilters:function(filters) {
  var out = [], length = filters.length, i, op;
  for (i = 0; i < length; i++) {
    out[i] = filters[i].serialize();
  }
  return this.applyEncoding(out);
}, getParams:function(operation) {
  if (!operation.isReadOperation) {
    return {};
  }
  var me = this, params = {}, grouper = operation.getGrouper(), sorters = operation.getSorters(), filters = operation.getFilters(), page = operation.getPage(), start = operation.getStart(), limit = operation.getLimit(), simpleSortMode = me.getSimpleSortMode(), simpleGroupMode = me.getSimpleGroupMode(), pageParam = me.getPageParam(), startParam = me.getStartParam(), limitParam = me.getLimitParam(), groupParam = me.getGroupParam(), groupDirectionParam = me.getGroupDirectionParam(), sortParam = me.getSortParam(), 
  filterParam = me.getFilterParam(), directionParam = me.getDirectionParam(), hasGroups, index;
  if (pageParam && page) {
    params[pageParam] = page;
  }
  if (startParam && (start || start === 0)) {
    params[startParam] = start;
  }
  if (limitParam && limit) {
    params[limitParam] = limit;
  }
  hasGroups = groupParam && grouper;
  if (hasGroups) {
    if (simpleGroupMode) {
      params[groupParam] = grouper.getProperty();
      params[groupDirectionParam] = grouper.getDirection();
    } else {
      params[groupParam] = me.encodeSorters([grouper], true);
    }
  }
  if (sortParam && sorters && sorters.length > 0) {
    if (simpleSortMode) {
      index = 0;
      if (sorters.length > 1 && hasGroups) {
        index = 1;
      }
      params[sortParam] = sorters[index].getProperty();
      params[directionParam] = sorters[index].getDirection();
    } else {
      params[sortParam] = me.encodeSorters(sorters);
    }
  }
  if (filterParam && filters && filters.length > 0) {
    params[filterParam] = me.encodeFilters(filters);
  }
  return params;
}, buildUrl:function(request) {
  var me = this, url = me.getUrl(request);
  if (!url) {
    Ext.raise('You are using a ServerProxy but have not supplied it with a url.');
  }
  if (me.getNoCache()) {
    url = Ext.urlAppend(url, Ext.String.format('{0}\x3d{1}', me.getCacheString(), Ext.Date.now()));
  }
  return url;
}, getUrl:function(request) {
  var url;
  if (request) {
    url = request.getUrl() || this.getApi()[request.getAction()];
  }
  return url ? url : this.callParent();
}, doRequest:function(operation) {
  Ext.raise('The doRequest function has not been implemented on your Ext.data.proxy.Server subclass. See src/data/ServerProxy.js for details');
}, afterRequest:Ext.emptyFn, destroy:function() {
  this.callParent();
  Ext.destroy(this.getReader(), this.getWriter());
  this.reader = this.writer = null;
}});
Ext.define('Ext.data.proxy.Ajax', {extend:Ext.data.proxy.Server, alias:'proxy.ajax', alternateClassName:['Ext.data.HttpProxy', 'Ext.data.AjaxProxy'], isAjaxProxy:true, defaultActionMethods:{create:'POST', read:'GET', update:'POST', destroy:'POST'}, config:{binary:false, headers:undefined, paramsAsJson:false, withCredentials:false, useDefaultXhrHeader:true, username:null, password:null, actionMethods:{create:'POST', read:'GET', update:'POST', destroy:'POST'}}, doRequest:function(operation) {
  var me = this, writer = me.getWriter(), request = me.buildRequest(operation), method = me.getMethod(request), jsonData, params;
  if (writer && operation.allowWrite()) {
    request = writer.write(request);
  }
  request.setConfig({binary:me.getBinary(), headers:me.getHeaders(), timeout:me.getTimeout(), scope:me, callback:me.createRequestCallback(request, operation), method:method, useDefaultXhrHeader:me.getUseDefaultXhrHeader(), disableCaching:false});
  if (method.toUpperCase() !== 'GET' && me.getParamsAsJson()) {
    params = request.getParams();
    if (params) {
      jsonData = request.getJsonData();
      if (jsonData) {
        jsonData = Ext.Object.merge({}, jsonData, params);
      } else {
        jsonData = params;
      }
      request.setJsonData(jsonData);
      request.setParams(undefined);
    }
  }
  if (me.getWithCredentials()) {
    request.setWithCredentials(true);
    request.setUsername(me.getUsername());
    request.setPassword(me.getPassword());
  }
  return me.sendRequest(request);
}, sendRequest:function(request) {
  request.setRawRequest(Ext.Ajax.request(request.getCurrentConfig()));
  this.lastRequest = request;
  return request;
}, abort:function(request) {
  request = request || this.lastRequest;
  if (request) {
    Ext.Ajax.abort(request.getRawRequest());
  }
}, getMethod:function(request) {
  var actions = this.getActionMethods(), action = request.getAction(), method;
  if (actions) {
    method = actions[action];
  }
  return method || this.defaultActionMethods[action];
}, createRequestCallback:function(request, operation) {
  var me = this;
  return function(options, success, response) {
    if (request === me.lastRequest) {
      me.lastRequest = null;
    }
    me.processResponse(success, operation, request, response);
  };
}, destroy:function() {
  this.lastRequest = null;
  this.callParent();
}});
Ext.define('Ext.data.reader.Json', {extend:Ext.data.reader.Reader, alternateClassName:'Ext.data.JsonReader', alias:'reader.json', config:{record:null, metaProperty:'metaData', useSimpleAccessors:false, preserveRawData:false}, updateRootProperty:function() {
  this.forceBuildExtractors();
}, updateMetaProperty:function() {
  this.forceBuildExtractors();
}, readRecords:function(data, readOptions, internalReadOptions) {
  var me = this, meta;
  if (me.getMeta) {
    meta = me.getMeta(data);
    if (meta) {
      me.onMetaChange(meta);
    }
  } else {
    if (data.metaData) {
      me.onMetaChange(data.metaData);
    }
  }
  return me.callParent([data, readOptions, internalReadOptions]);
}, getResponseData:function(response) {
  var error;
  try {
    return Ext.decode(response.responseText);
  } catch (ex) {
    error = this.createReadError(ex.message);
    Ext.Logger.warn('Unable to parse the JSON returned by the server');
    this.fireEvent('exception', this, response, error);
    return error;
  }
}, buildExtractors:function() {
  var me = this, metaProp, rootProp;
  if (me.callParent(arguments)) {
    metaProp = me.getMetaProperty();
    rootProp = me.getRootProperty();
    if (rootProp) {
      me.getRoot = me.getAccessor(rootProp);
    } else {
      me.getRoot = Ext.identityFn;
    }
    if (metaProp) {
      me.getMeta = me.getAccessor(metaProp);
    }
  }
}, extractData:function(root, readOptions) {
  var recordName = this.getRecord(), data = [], length, i;
  if (recordName) {
    length = root.length;
    if (!length && Ext.isObject(root)) {
      length = 1;
      root = [root];
    }
    for (i = 0; i < length; i++) {
      data[i] = root[i][recordName];
    }
  } else {
    data = root;
  }
  return this.callParent([data, readOptions]);
}, getModelData:function(raw) {
  return this.getPreserveRawData() ? Ext.apply({}, raw) : raw;
}, createAccessor:function() {
  var re = /[\[\.]/;
  return function(expr) {
    var me = this, simple = me.getUseSimpleAccessors(), operatorIndex, result, current, parts, part, inExpr, isDot, isLeft, isRight, special, c, i, bracketed, len;
    if (!(expr || expr === 0)) {
      return;
    }
    if (typeof expr === 'function') {
      return expr;
    }
    if (!simple) {
      operatorIndex = String(expr).search(re);
    }
    if (simple === true || operatorIndex < 0) {
      result = function(raw) {
        return raw[expr];
      };
    } else {
      current = 'raw';
      parts = [];
      part = '';
      inExpr = 0;
      len = expr.length;
      for (i = 0; i <= len; ++i) {
        c = expr[i];
        isDot = c === '.';
        isLeft = c === '[';
        isRight = c === ']';
        special = isDot || isLeft || isRight || !c;
        if (!special || inExpr > 1 || inExpr && !isRight) {
          part += c;
        } else {
          if (special) {
            bracketed = false;
            if (isLeft) {
              ++inExpr;
            } else {
              if (isRight) {
                --inExpr;
                bracketed = true;
              }
            }
            if (part) {
              if (bracketed) {
                part = '[' + part + ']';
              } else {
                part = '.' + part;
              }
              current += part;
              parts.push('' + current);
              part = '';
            }
          }
        }
      }
      result = parts.join(' \x26\x26 ');
      result = Ext.functionFactory('raw', 'return ' + result);
    }
    return result;
  };
}(), createFieldAccessor:function(field) {
  var me = this, mapping = field.mapping, hasMap = mapping || mapping === 0, map = hasMap ? mapping : field.name;
  if (hasMap) {
    if (typeof map === 'function') {
      return function(raw) {
        return field.mapping(raw, me);
      };
    } else {
      return me.createAccessor(map);
    }
  }
}, getAccessorKey:function(prop) {
  var simple = this.getUseSimpleAccessors() ? 'simple' : '';
  return this.$className + simple + prop;
}, privates:{copyFrom:function(reader) {
  this.callParent([reader]);
  this.getRoot = reader.getRoot;
}}});
Ext.define('Ext.data.writer.Json', {extend:Ext.data.writer.Writer, alternateClassName:'Ext.data.JsonWriter', alias:'writer.json', config:{rootProperty:undefined, encode:false, allowSingle:true, expandData:false}, constructor:function(config) {
  if (config && config.hasOwnProperty('root')) {
    config = Ext.apply({}, config);
    config.rootProperty = config.root;
    delete config.root;
    Ext.log.warn('Ext.data.writer.Json: Using the deprecated "root" configuration. Use "rootProperty" instead.');
  }
  this.callParent([config]);
}, getExpandedData:function(data) {
  var dataLength = data.length, i = 0, item, prop, nameParts, j, tempObj, toObject = function(name, value) {
    var o = {};
    o[name] = value;
    return o;
  };
  for (; i < dataLength; i++) {
    item = data[i];
    for (prop in item) {
      if (item.hasOwnProperty(prop)) {
        nameParts = prop.split('.');
        j = nameParts.length - 1;
        if (j > 0) {
          tempObj = item[prop];
          for (; j > 0; j--) {
            tempObj = toObject(nameParts[j], tempObj);
          }
          item[nameParts[0]] = item[nameParts[0]] || {};
          Ext.Object.merge(item[nameParts[0]], tempObj);
          delete item[prop];
        }
      }
    }
  }
  return data;
}, writeRecords:function(request, data) {
  var me = this, root = me.getRootProperty(), json, single, transform;
  if (me.getExpandData()) {
    data = me.getExpandedData(data);
  }
  if (me.getAllowSingle() && data.length === 1) {
    data = data[0];
    single = true;
  }
  transform = this.getTransform();
  if (transform) {
    data = transform(data, request);
  }
  if (me.getEncode()) {
    if (root) {
      request.setParam(root, Ext.encode(data));
    } else {
      Ext.raise('Must specify a root when using encode');
    }
  } else {
    if (single || data && data.length) {
      json = request.getJsonData() || {};
      if (root) {
        json[root] = data;
      } else {
        json = data;
      }
      request.setJsonData(json);
    }
  }
  return request;
}});
Ext.define('Ext.util.Group', {extend:Ext.util.Collection, config:{groupKey:null}, $endUpdatePriority:2001});
Ext.define('Ext.util.SorterCollection', {extend:Ext.util.Collection, isSorterCollection:true, $sortable:null, sortFn:null, config:{sorterOptionsFn:null, sorterOptionsScope:null}, constructor:function(config) {
  var me = this;
  me.sortFn = Ext.util.Sorter.createComparator(me);
  me.callParent([config]);
  me.setDecoder(me.decodeSorter);
}, addSort:function(property, direction, mode) {
  var me = this, count, index, limit, options, primary, sorter, sorters;
  if (!property) {
    me.beginUpdate();
    me.endUpdate();
  } else {
    options = me.getOptions();
    if (property instanceof Array) {
      sorters = property;
      mode = direction;
      direction = null;
    } else {
      if (Ext.isString(property)) {
        if (!(sorter = me.get(property))) {
          sorters = [{property:property, direction:direction || options.getDefaultSortDirection()}];
        } else {
          sorters = [sorter];
        }
      } else {
        if (Ext.isFunction(property)) {
          sorters = [{sorterFn:property, direction:direction || options.getDefaultSortDirection()}];
        } else {
          if (!Ext.isObject(property)) {
            Ext.raise('Invalid sort descriptor: ' + property);
          }
          sorters = [property];
          mode = direction;
          direction = null;
        }
      }
    }
    if (mode && !me._sortModes[mode]) {
      Ext.raise('Sort mode should be "multi", "append", "prepend" or "replace", not "' + mode + '"');
    }
    mode = me._sortModes[mode || 'replace'];
    primary = me.getAt(0);
    count = me.length;
    index = mode.append ? count : 0;
    me.beginUpdate();
    me.splice(index, mode.replace ? count : 0, sorters);
    if (mode.multi) {
      count = me.length;
      limit = options.getMultiSortLimit();
      if (count > limit) {
        me.removeAt(limit, count);
      }
    }
    if (sorter && direction) {
      sorter.setDirection(direction);
    } else {
      if (index === 0 && primary && primary === me.getAt(0)) {
        primary.toggle();
      }
    }
    me.endUpdate();
  }
}, clear:function() {
  this.beginUpdate();
  this.callParent();
  this.endUpdate(this.items);
}, getSortFn:function() {
  return this.sortFn;
}, getByProperty:function(prop) {
  var items = this.items, len = items.length, i, item;
  for (i = 0; i < len; ++i) {
    item = items[i];
    if (item.getProperty() === prop) {
      return item;
    }
  }
  return null;
}, _sortModes:{append:{append:1}, multi:{multi:1}, prepend:{prepend:1}, replace:{replace:1}}, decodeSorter:function(sorter, xclass) {
  var me = this, options = me.getOptions(), root = options.getRootProperty(), sorterOptionsFn = me.getSorterOptionsFn(), currentSorter, sorterConfig, type;
  if (sorter.isSorter) {
    if (!sorter.getRoot()) {
      sorter.setRoot(root);
    }
  } else {
    sorterConfig = {direction:options.getDefaultSortDirection(), root:root};
    type = typeof sorter;
    if (type === 'string') {
      currentSorter = me.get(sorter);
      if (currentSorter) {
        return currentSorter;
      }
      sorterConfig.property = sorter;
    } else {
      if (type === 'function') {
        sorterConfig.sorterFn = sorter;
      } else {
        if (!Ext.isObject(sorter)) {
          Ext.raise('Invalid sorter specified: ' + sorter);
        }
        sorterConfig = Ext.apply(sorterConfig, sorter);
        if (sorterConfig.fn) {
          sorterConfig.sorterFn = sorterConfig.fn;
          delete sorterConfig.fn;
        }
      }
    }
    sorter = Ext.create(xclass || 'Ext.util.Sorter', sorterConfig);
  }
  if (sorterOptionsFn) {
    sorterOptionsFn.call(me.getSorterOptionsScope() || me, sorter);
  }
  return sorter;
}, setSorterConfigure:function(fn, scope) {
  this.setSorterOptionsFn(fn);
  this.setSorterOptionsScope(scope);
}, decodeRemoveItems:function(args, index) {
  var me = this, ret = index === undefined ? args : args[index];
  if (!ret || !ret.$cloned) {
    if (args.length > index + 1 || !Ext.isIterable(ret)) {
      ret = Ext.Array.slice(args, index);
    }
    var currentSorters = me.items, ln = ret.length, remove = [], i, item, n, sorter, type;
    for (i = 0; i < ln; i++) {
      sorter = ret[i];
      if (sorter && sorter.isSorter) {
        remove.push(sorter);
      } else {
        type = typeof sorter;
        if (type === 'string') {
          sorter = me.get(sorter);
          if (sorter) {
            remove.push(sorter);
          }
        } else {
          if (type === 'function') {
            for (n = currentSorters.length; n-- > 0;) {
              item = currentSorters[n];
              if (item.getSorterFn() === sorter) {
                remove.push(item);
              }
            }
          } else {
            Ext.raise('Invalid sorter specification: ' + sorter);
          }
        }
      }
    }
    ret = remove;
    ret.$cloned = true;
  }
  return ret;
}, getOptions:function() {
  return this.$sortable || this;
}});
Ext.define('Ext.util.FilterCollection', {extend:Ext.util.Collection, isFilterCollection:true, $filterable:null, filterFn:null, constructor:function(config) {
  var me = this;
  me.filterFn = Ext.util.Filter.createFilterFn(me);
  me.callParent([config]);
  me.setDecoder(me.decodeFilter);
}, filterData:function(data) {
  return this.filtered ? Ext.Array.filter(data, this.filterFn) : data;
}, getFilterFn:function() {
  return this.filterFn;
}, isItemFiltered:function(item) {
  return !this.filterFn(item);
}, decodeFilter:function(filter) {
  var options = this.getOptions(), filterRoot = options.getRootProperty(), filterConfig;
  if (filter.isFilter) {
    if (!filter.getRoot()) {
      filter.setRoot(filterRoot);
    }
  } else {
    filterConfig = {root:filterRoot};
    if (Ext.isFunction(filter)) {
      filterConfig.filterFn = filter;
    } else {
      if (!Ext.isObject(filter)) {
        Ext.raise('Invalid filter specified: ' + filter);
      }
      filterConfig = Ext.apply(filterConfig, filter);
      if (filterConfig.fn) {
        filterConfig.filterFn = filterConfig.fn;
        delete filterConfig.fn;
      }
      if (Ext.util.Filter.isInvalid(filterConfig)) {
        return false;
      }
    }
    filter = new Ext.util.Filter(filterConfig);
  }
  return filter;
}, decodeRemoveItems:function(args, index) {
  var me = this, ret = index === undefined ? args : args[index];
  if (!ret.$cloned) {
    if (args.length > index + 1 || !Ext.isIterable(ret)) {
      ret = Ext.Array.slice(args, index);
    }
    var currentFilters = me.items, ln = ret.length, remove = [], filter, i, isFunction, isProp, isString, item, match, n, type;
    for (i = 0; i < ln; i++) {
      filter = ret[i];
      if (filter && filter.isFilter) {
        remove.push(filter);
      } else {
        type = typeof filter;
        isFunction = type === 'function';
        isProp = filter.property !== undefined && filter.value !== undefined;
        isString = type === 'string';
        if (!isFunction && !isProp && !isString) {
          Ext.raise('Invalid filter specification: ' + filter);
        }
        for (n = currentFilters.length; n-- > 0;) {
          item = currentFilters[n];
          match = false;
          if (isString) {
            match = item.getProperty() === filter;
          } else {
            if (isFunction) {
              match = item.getFilterFn() === filter;
            } else {
              if (isProp) {
                match = item.getProperty() === filter.property && item.getValue() === filter.value;
              }
            }
          }
          if (match) {
            remove.push(item);
          }
        }
      }
    }
    ret = remove;
    ret.$cloned = true;
  }
  return ret;
}, getOptions:function() {
  return this.$filterable || this;
}});
Ext.define('Ext.util.GroupCollection', {extend:Ext.util.Collection, isGroupCollection:true, config:{grouper:null, itemRoot:null}, observerPriority:-100, onCollectionAdd:function(source, details) {
  this.addItemsToGroups(source, details.items);
}, onCollectionBeforeItemChange:function(source, details) {
  this.changeDetails = details;
}, onCollectionBeginUpdate:function() {
  this.beginUpdate();
}, onCollectionEndUpdate:function() {
  this.endUpdate();
}, onCollectionItemChange:function(source, details) {
  var item = details.item;
  if (!details.indexChanged) {
    this.syncItemGrouping(source, item, source.getKey(item), details.oldKey, details.oldIndex);
  }
  this.changeDetails = null;
}, onCollectionRefresh:function(source) {
  this.removeAll();
  this.addItemsToGroups(source, source.items);
}, onCollectionRemove:function(source, details) {
  var me = this, changeDetails = me.changeDetails, entries, entry, group, i, n, removeGroups, item;
  if (changeDetails) {
    item = changeDetails.item;
    group = me.findGroupForItem(item);
    entries = [];
    if (group) {
      entries.push({group:group, items:[item]});
    }
  } else {
    entries = me.groupItems(source, details.items, false);
  }
  for (i = 0, n = entries.length; i < n; ++i) {
    group = (entry = entries[i]).group;
    if (group) {
      group.remove(entry.items);
      if (!group.length) {
        (removeGroups || (removeGroups = [])).push(group);
      }
    }
  }
  if (removeGroups) {
    me.remove(removeGroups);
  }
}, onCollectionSort:function(source) {
  var me = this, sorters = source.getSorters(false), items, length, i, group;
  if (sorters) {
    items = me.items;
    length = me.length;
    for (i = 0; i < length; ++i) {
      group = items[i];
      if (group.getSorters() !== sorters) {
        group.setSorters(sorters);
      }
    }
  }
}, onCollectionUpdateKey:function(source, details) {
  var index = details.index, item = details.item;
  if (!details.indexChanged) {
    index = source.indexOf(item);
    this.syncItemGrouping(source, item, details.newKey, details.oldKey, index);
  }
}, addItemsToGroups:function(source, items) {
  this.groupItems(source, items, true);
}, groupItems:function(source, items, adding) {
  var me = this, byGroup = {}, entries = [], grouper = source.getGrouper(), groupKeys = me.itemGroupKeys, entry, group, groupKey, i, item, itemKey, len, newGroups;
  for (i = 0, len = items.length; i < len; ++i) {
    groupKey = grouper.getGroupString(item = items[i]);
    itemKey = source.getKey(item);
    if (adding) {
      (groupKeys || (me.itemGroupKeys = groupKeys = {}))[itemKey] = groupKey;
    } else {
      if (groupKeys) {
        delete groupKeys[itemKey];
      }
    }
    if (!(entry = byGroup[groupKey])) {
      if (!(group = me.getByKey(groupKey)) && adding) {
        (newGroups || (newGroups = [])).push(group = me.createGroup(source, groupKey));
      }
      entries.push(byGroup[groupKey] = entry = {group:group, items:[]});
    }
    entry.items.push(item);
  }
  for (i = 0, len = entries.length; i < len; ++i) {
    entry = entries[i];
    entry.group.add(entry.items);
  }
  if (newGroups) {
    me.add(newGroups);
  }
  return entries;
}, syncItemGrouping:function(source, item, itemKey, oldKey, itemIndex) {
  var me = this, itemGroupKeys = me.itemGroupKeys || (me.itemGroupKeys = {}), grouper = source.getGrouper(), groupKey = grouper.getGroupString(item), removeGroups = 0, index = -1, addGroups, group, oldGroup, oldGroupKey, firstIndex;
  if (oldKey) {
    oldGroupKey = itemGroupKeys[oldKey];
    delete itemGroupKeys[oldKey];
  } else {
    oldGroupKey = itemGroupKeys[itemKey];
  }
  itemGroupKeys[itemKey] = groupKey;
  if (!(group = me.get(groupKey))) {
    group = me.createGroup(source, groupKey);
    addGroups = [group];
  }
  if (group.get(itemKey) !== item) {
    if (group.getCount() > 0 && source.getSorters().getCount() === 0) {
      firstIndex = source.indexOf(group.items[0]);
      if (itemIndex < firstIndex) {
        index = 0;
      } else {
        index = itemIndex - firstIndex;
      }
    }
    if (index === -1) {
      group.add(item);
    } else {
      group.insert(index, item);
    }
  } else {
    group.itemChanged(item);
  }
  if (groupKey !== oldGroupKey && (oldGroupKey === 0 || oldGroupKey)) {
    oldGroup = me.get(oldGroupKey);
    if (oldGroup) {
      oldGroup.remove(item);
      if (!oldGroup.length) {
        removeGroups = [oldGroup];
      }
    }
  }
  if (addGroups) {
    me.splice(0, removeGroups, addGroups);
  } else {
    if (removeGroups) {
      me.splice(0, removeGroups);
    }
  }
}, createGroup:function(source, key) {
  var group = new Ext.util.Group({groupKey:key, rootProperty:this.getItemRoot(), sorters:source.getSorters()});
  return group;
}, getKey:function(item) {
  return item.getGroupKey();
}, createSortFn:function() {
  var me = this, grouper = me.getGrouper(), sorterFn = me.getSorters().getSortFn();
  if (!grouper) {
    return sorterFn;
  }
  return function(lhs, rhs) {
    return grouper.sort(lhs.items[0], rhs.items[0]) || sorterFn(lhs, rhs);
  };
}, updateGrouper:function(grouper) {
  var me = this;
  me.grouped = !!(grouper && me.$groupable.getAutoGroup());
  me.onSorterChange();
  me.onEndUpdateSorters(me.getSorters());
}, destroy:function() {
  this.$groupable = null;
  this.callParent();
}, privates:{findGroupForItem:function(item) {
  var items = this.items, len = items.length, i, group;
  for (i = 0; i < len; ++i) {
    group = items[i];
    if (group.contains(item)) {
      return group;
    }
  }
}}});
Ext.define('Ext.data.Store', {extend:Ext.data.ProxyStore, alias:'store.store', mixins:[Ext.data.LocalStore], config:{data:0, clearRemovedOnLoad:true, clearOnPageLoad:true, associatedEntity:null, role:null, session:null}, addRecordsOptions:{addRecords:true}, loadCount:0, complete:false, moveMapCount:0, constructor:function(config) {
  var me = this, data;
  if (config) {
    if (config.buffered) {
      if (this.self !== Ext.data.Store) {
        Ext.raise('buffered config not supported on derived Store classes. ' + 'Please derive from Ext.data.BufferedStore.');
      }
      return new Ext.data.BufferedStore(config);
    }
    if (config.remoteGroup) {
      Ext.log.warn('Ext.data.Store: remoteGroup has been removed. Use remoteSort instead.');
    }
  }
  me.callParent([config]);
  me.getData().addObserver(me);
  data = me.inlineData;
  if (data) {
    delete me.inlineData;
    me.loadInlineData(data);
  }
}, onCollectionBeginUpdate:function() {
  this.beginUpdate();
}, onCollectionEndUpdate:function() {
  this.endUpdate();
}, applyData:function(data, dataCollection) {
  var me = this;
  me.getFields();
  me.getModel();
  if (data && data.isCollection) {
    dataCollection = data;
  } else {
    if (!dataCollection) {
      dataCollection = me.constructDataCollection();
    }
    if (data) {
      if (me.isInitializing) {
        me.inlineData = data;
      } else {
        me.loadData(data);
      }
    }
  }
  return dataCollection;
}, loadInlineData:function(data) {
  var me = this, proxy = me.getProxy();
  if (proxy && proxy.isMemoryProxy) {
    proxy.setData(data);
    me.suspendEvents();
    me.read();
    me.resumeEvents();
  } else {
    me.removeAll(true);
    me.suspendEvents();
    me.loadData(data);
    me.resumeEvents();
  }
}, onCollectionAdd:function(collection, info) {
  this.onCollectionAddItems(collection, info.items, info);
}, onCollectionFilterAdd:function(collection, items) {
  this.onCollectionAddItems(collection, items);
}, onCollectionAddItems:function(collection, records, info) {
  var me = this, len = records.length, lastChunk = info ? !info.next : false, removed = me.removed, ignoreAdd = me.ignoreCollectionAdd, session = me.getSession(), replaced = info && info.replaced, i, sync, record, replacedItems;
  for (i = 0; i < len; ++i) {
    record = records[i];
    if (session) {
      session.adopt(record);
    }
    if (!ignoreAdd) {
      record.join(me);
      if (removed && removed.length) {
        Ext.Array.remove(removed, record);
      }
      sync = sync || record.phantom || record.dirty;
    }
  }
  if (ignoreAdd) {
    return;
  }
  if (replaced) {
    replacedItems = [];
    do {
      Ext.Array.push(replacedItems, replaced.items);
      replaced = replaced.next;
    } while (replaced);
    me.setMoving(replacedItems, true);
  }
  if (info) {
    if (info.replaced) {
      if (lastChunk) {
        me.fireEvent('refresh', me);
      }
    } else {
      me.fireEvent('add', me, records, info.at);
      if (lastChunk) {
        me.fireEvent('datachanged', me);
      }
    }
  }
  if (replacedItems) {
    me.setMoving(replacedItems, false);
  }
  me.needsSync = me.needsSync || sync;
}, onCollectionFilteredItemChange:function() {
  this.onCollectionItemChange.apply(this, arguments);
}, onCollectionItemChange:function(collection, info) {
  var me = this, record = info.item, modifiedFieldNames = info.modified || null, type = info.meta;
  if (me.fireChangeEvent(record)) {
    me.onUpdate(record, type, modifiedFieldNames, info);
    me.fireEvent('update', me, record, type, modifiedFieldNames, info);
  }
}, fireChangeEvent:function(record) {
  return this.getDataSource().contains(record);
}, afterChange:function(record, modifiedFieldNames, type) {
  this.getData().itemChanged(record, modifiedFieldNames || null, undefined, type);
}, afterCommit:function(record, modifiedFieldNames) {
  this.afterChange(record, modifiedFieldNames, Ext.data.Model.COMMIT);
}, afterEdit:function(record, modifiedFieldNames) {
  this.needsSync = this.needsSync || record.dirty;
  this.afterChange(record, modifiedFieldNames, Ext.data.Model.EDIT);
}, afterReject:function(record) {
  this.afterChange(record, null, Ext.data.Model.REJECT);
}, afterDrop:function(record) {
  this.getData().remove(record);
}, afterErase:function(record) {
  this.removeFromRemoved(record);
}, addSorted:function(record) {
  var me = this, remote = me.getRemoteSort(), data = me.getData(), index;
  if (remote) {
    data.setSorters(me.getSorters());
  }
  index = data.findInsertionIndex(record);
  if (remote) {
    data.setSorters(null);
  }
  return me.insert(index, record);
}, remove:function(records, isMove, silent) {
  var me = this, data = me.getDataSource(), len, i, toRemove, record;
  if (records) {
    if (records.isModel) {
      if (data.indexOf(records) > -1) {
        toRemove = [records];
        len = 1;
      } else {
        len = 0;
      }
    } else {
      toRemove = [];
      for (i = 0, len = records.length; i < len; ++i) {
        record = records[i];
        if (record && record.isEntity) {
          if (!data.contains(record)) {
            continue;
          }
        } else {
          if (!(record = data.getAt(record))) {
            continue;
          }
        }
        toRemove.push(record);
      }
      len = toRemove.length;
    }
  }
  if (!len) {
    return [];
  }
  me.removeIsMove = isMove === true;
  me.removeIsSilent = silent;
  data.remove(toRemove);
  me.removeIsSilent = false;
  return toRemove;
}, onCollectionRemove:function(collection, info) {
  var me = this, removed = me.removed, records = info.items, len = records.length, index = info.at, replacement = info.replacement, isMove = me.removeIsMove || replacement && Ext.Array.equals(records, replacement.items), silent = me.removeIsSilent, lastChunk = !info.next, data = me.getDataSource(), i, record;
  if (me.ignoreCollectionRemove) {
    return;
  }
  if (replacement) {
    me.setMoving(replacement.items, true);
  }
  for (i = 0; i < len; ++i) {
    record = records[i];
    if (!data.contains(record)) {
      if (removed && !isMove && !record.phantom && !record.erasing) {
        record.removedFrom = index + i;
        removed.push(record);
        me.needsSync = true;
      } else {
        record.unjoin(me);
      }
    }
  }
  if (!silent) {
    if (!replacement || !replacement.items.length) {
      me.fireEvent('remove', me, records, index, isMove);
      if (lastChunk) {
        me.fireEvent('datachanged', me);
      }
    }
  }
  if (replacement) {
    me.setMoving(replacement.items, false);
  }
}, onFilterEndUpdate:function() {
  this.callParent(arguments);
  this.callObservers('Filter');
}, removeAt:function(index, count) {
  var data = this.getData();
  index = Math.max(index, 0);
  if (index < data.length) {
    if (arguments.length === 1) {
      count = 1;
    } else {
      if (!count) {
        return;
      }
    }
    data.removeAt(index, count);
  }
}, removeAll:function(silent) {
  var me = this, data = me.getData(), hasClear = me.hasListeners.clear, records = data.getRange();
  if (data.length) {
    me.removeIsSilent = true;
    me.callObservers('BeforeRemoveAll');
    data.removeAll();
    me.removeIsSilent = false;
    if (!silent) {
      me.fireEvent('clear', me, records);
      me.fireEvent('datachanged', me);
    }
    me.callObservers('AfterRemoveAll', [!!silent]);
  }
  return records;
}, setRecords:function(records) {
  var count = this.getCount();
  ++this.loadCount;
  if (count) {
    this.getData().splice(0, count, records);
  } else {
    this.add(records);
  }
}, splice:function(index, toRemove, toAdd) {
  return this.getData().splice(index, toRemove, toAdd);
}, onProxyLoad:function(operation) {
  var me = this, resultSet = operation.getResultSet(), records = operation.getRecords(), successful = operation.wasSuccessful();
  if (me.destroyed) {
    return;
  }
  if (resultSet) {
    me.totalCount = resultSet.getTotal();
  }
  if (successful) {
    records = me.processAssociation(records);
    me.loadRecords(records, operation.getAddRecords() ? {addRecords:true} : undefined);
  } else {
    me.loading = false;
  }
  if (me.hasListeners.load) {
    me.fireEvent('load', me, records, successful, operation);
  }
  me.callObservers('AfterLoad', [records, successful, operation]);
}, filterDataSource:function(fn) {
  var source = this.getDataSource(), items = source.items, len = items.length, ret = [], i;
  for (i = 0; i < len; i++) {
    if (fn.call(source, items[i])) {
      ret.push(items[i]);
    }
  }
  return ret;
}, getNewRecords:function() {
  return this.filterDataSource(this.filterNew);
}, getRejectRecords:function() {
  return this.filterDataSource(this.filterRejects);
}, getUpdatedRecords:function() {
  return this.filterDataSource(this.filterUpdated);
}, loadData:function(data, append) {
  var me = this, length = data.length, newData = [], i;
  for (i = 0; i < length; i++) {
    newData.push(me.createModel(data[i]));
  }
  newData = me.processAssociation(newData);
  me.loadRecords(newData, append ? me.addRecordsOptions : undefined);
}, loadRawData:function(data, append) {
  var me = this, session = me.getSession(), result = me.getProxy().getReader().read(data, session ? {recordCreator:session.recordCreator} : undefined), records = result.getRecords(), success = result.getSuccess();
  if (success) {
    me.totalCount = result.getTotal();
    me.loadRecords(records, append ? me.addRecordsOptions : undefined);
  }
  return success;
}, loadRecords:function(records, options) {
  var me = this, length = records.length, data = me.getData(), addRecords, i, skipSort;
  if (options) {
    addRecords = options.addRecords;
  }
  if (!me.getRemoteSort() && !me.getSortOnLoad()) {
    skipSort = true;
    data.setAutoSort(false);
  }
  if (!addRecords) {
    me.clearData(true);
  }
  me.loading = false;
  me.ignoreCollectionAdd = true;
  me.callObservers('BeforePopulate');
  data.add(records);
  me.ignoreCollectionAdd = false;
  if (skipSort) {
    data.setAutoSort(true);
  }
  for (i = 0; i < length; i++) {
    records[i].join(me);
  }
  ++me.loadCount;
  me.complete = true;
  me.fireEvent('datachanged', me);
  me.fireEvent('refresh', me);
  me.callObservers('AfterPopulate');
}, loadPage:function(page, options) {
  var me = this, size = me.getPageSize();
  me.currentPage = page;
  options = Ext.apply({page:page, start:(page - 1) * size, limit:size, addRecords:!me.getClearOnPageLoad()}, options);
  me.read(options);
}, nextPage:function(options) {
  this.loadPage(this.currentPage + 1, options);
}, previousPage:function(options) {
  this.loadPage(this.currentPage - 1, options);
}, clearData:function(isLoad) {
  var me = this, removed = me.removed, data = me.getDataSource(), clearRemovedOnLoad = me.getClearRemovedOnLoad(), needsUnjoinCheck = removed && isLoad && !clearRemovedOnLoad, records, record, i, len;
  if (data) {
    records = data.items;
    for (i = 0, len = records.length; i < len; ++i) {
      record = records[i];
      if (needsUnjoinCheck && Ext.Array.contains(removed, record)) {
        continue;
      }
      record.unjoin(me);
    }
    me.ignoreCollectionRemove = true;
    me.callObservers('BeforeClear');
    data.removeAll();
    me.ignoreCollectionRemove = false;
    me.callObservers('AfterClear');
  }
  if (removed && (!isLoad || clearRemovedOnLoad)) {
    removed.length = 0;
  }
}, onIdChanged:function(rec, oldId, newId) {
  this.getData().updateKey(rec, oldId);
  this.fireEvent('idchanged', this, rec, oldId, newId);
}, commitChanges:function() {
  var me = this, recs = me.getModifiedRecords(), len = recs.length, i = 0;
  Ext.suspendLayouts();
  me.beginUpdate();
  for (; i < len; i++) {
    recs[i].commit();
  }
  me.cleanRemoved();
  me.endUpdate();
  Ext.resumeLayouts(true);
}, filterNewOnly:function(item) {
  return item.phantom === true;
}, filterRejects:function(item) {
  return item.phantom || item.dirty;
}, rejectChanges:function() {
  var me = this, recs = me.getRejectRecords(), len = recs.length, i, rec, toRemove, sorted, data, currentAutoSort;
  Ext.suspendLayouts();
  me.beginUpdate();
  for (i = 0; i < len; i++) {
    rec = recs[i];
    if (rec.phantom) {
      toRemove = toRemove || [];
      toRemove.push(rec);
    } else {
      rec.reject();
    }
  }
  if (toRemove) {
    me.remove(toRemove);
    for (i = 0, len = toRemove.length; i < len; ++i) {
      toRemove[i].reject();
    }
  }
  recs = me.getRawRemovedRecords();
  if (recs) {
    len = recs.length;
    sorted = !me.getRemoteSort() && me.isSorted();
    if (sorted) {
      data = me.getData();
      currentAutoSort = data.getAutoSort();
      data.setAutoSort(false);
    }
    for (i = len - 1; i >= 0; i--) {
      rec = recs[i];
      rec.reject();
      if (!sorted) {
        me.insert(rec.removedFrom || 0, rec);
      }
    }
    if (sorted) {
      data.setAutoSort(currentAutoSort);
      me.add(recs);
    }
    recs.length = 0;
  }
  me.endUpdate();
  Ext.resumeLayouts(true);
}, onDestroy:function() {
  var me = this, task = me.loadTask, data = me.getData(), source = data.getSource();
  me.clearData();
  me.callParent();
  me.setSession(null);
  me.observers = null;
  if (task) {
    task.cancel();
    me.loadTask = null;
  }
  if (source) {
    source.destroy();
  }
}, privates:{fetch:function(options) {
  options = Ext.apply({}, options);
  this.setLoadOptions(options);
  var operation = this.createOperation('read', options);
  operation.execute();
}, onBeforeLoad:function(operation) {
  this.callObservers('BeforeLoad', [operation]);
}, onRemoteFilterSet:function(filters, remoteFilter) {
  if (filters) {
    this.getData().setFilters(remoteFilter ? null : filters);
  }
  this.callParent([filters, remoteFilter]);
}, onRemoteSortSet:function(sorters, remoteSort) {
  var data = this.getData();
  if (sorters) {
    data.setSorters(remoteSort ? null : sorters);
  }
  data.setAutoGroup(!remoteSort);
  this.callParent([sorters, remoteSort]);
}, isMoving:function(records, getMap) {
  var map = this.moveMap, moving = 0, len, i;
  if (map) {
    if (records) {
      if (Ext.isArray(records)) {
        for (i = 0, len = records.length; i < len; ++i) {
          moving += map[records[i].id] ? 1 : 0;
        }
      } else {
        if (map[records.id]) {
          ++moving;
        }
      }
    } else {
      moving = getMap ? map : this.moveMapCount;
    }
  }
  return moving;
}, setLoadOptions:function(options) {
  var me = this, pageSize = me.getPageSize(), session, grouper;
  if (me.getRemoteSort() && !options.grouper) {
    grouper = me.getGrouper();
    if (grouper) {
      options.grouper = grouper;
    }
  }
  if (pageSize || 'start' in options || 'limit' in options || 'page' in options) {
    options.page = options.page != null ? options.page : me.currentPage;
    options.start = options.start !== undefined ? options.start : (options.page - 1) * pageSize;
    options.limit = options.limit != null ? options.limit : pageSize;
    me.currentPage = options.page;
  }
  options.addRecords = options.addRecords || false;
  if (!options.recordCreator) {
    session = me.getSession();
    if (session) {
      options.recordCreator = session.recordCreator;
    }
  }
  me.callParent([options]);
}, setMoving:function(records, isMoving) {
  var me = this, map = me.moveMap || (me.moveMap = {}), len = records.length, i, id;
  for (i = 0; i < len; ++i) {
    id = records[i].id;
    if (isMoving) {
      if (map[id]) {
        ++map[id];
      } else {
        map[id] = 1;
        ++me.moveMapCount;
      }
    } else {
      if (--map[id] === 0) {
        delete map[id];
        --me.moveMapCount;
      }
    }
  }
  if (me.moveMapCount === 0) {
    me.moveMap = null;
  }
}, processAssociation:function(records) {
  var me = this, associatedEntity = me.getAssociatedEntity();
  if (associatedEntity) {
    records = me.getRole().processLoad(me, associatedEntity, records, me.getSession());
  }
  return records;
}}});
Ext.define('Ext.data.reader.Array', {extend:Ext.data.reader.Json, alternateClassName:'Ext.data.ArrayReader', alias:'reader.array', config:{totalProperty:undefined, successProperty:undefined}, createFieldAccessor:function(field) {
  var oldMap = field.mapping, index = field.hasMapping() ? oldMap : field.ordinal, result;
  field.mapping = index;
  result = this.callParent(arguments);
  field.mapping = oldMap;
  return result;
}, getModelData:function(raw) {
  return {};
}});
Ext.define('Ext.data.ArrayStore', {extend:Ext.data.Store, alias:'store.array', alternateClassName:['Ext.data.SimpleStore'], config:{proxy:{type:'memory', reader:'array'}}, loadData:function(data, append) {
  if (this.expandData) {
    var r = [], i = 0, ln = data.length;
    for (; i < ln; i++) {
      r[r.length] = [data[i]];
    }
    data = r;
  }
  this.callParent([data, append]);
}});
Ext.define('Ext.data.StoreManager', {extend:Ext.util.MixedCollection, alternateClassName:['Ext.StoreMgr', 'Ext.data.StoreMgr', 'Ext.StoreManager'], singleton:true, register:function() {
  for (var i = 0, s; s = arguments[i]; i++) {
    this.add(s);
  }
}, unregister:function() {
  for (var i = 0, s; s = arguments[i]; i++) {
    this.remove(this.lookup(s));
  }
}, lookup:function(store, defaultType) {
  if (Ext.isArray(store)) {
    var fields = ['field1'], expand = !Ext.isArray(store[0]), data = store, i, len;
    if (expand) {
      data = [];
      for (i = 0, len = store.length; i < len; ++i) {
        data.push([store[i]]);
      }
    } else {
      for (i = 2, len = store[0].length; i <= len; ++i) {
        fields.push('field' + i);
      }
    }
    return new Ext.data.ArrayStore({data:data, fields:fields, autoDestroy:true, autoCreated:true, expanded:expand});
  }
  if (Ext.isString(store)) {
    return this.get(store);
  } else {
    return Ext.Factory.store(store, defaultType);
  }
}, getKey:function(o) {
  return o.storeId;
}}, function() {
  Ext.regStore = function(name, config) {
    var store;
    if (Ext.isObject(name)) {
      config = name;
    } else {
      if (Ext.data.StoreManager.containsKey(name)) {
        return Ext.data.StoreManager.lookup(name);
      }
      config.storeId = name;
    }
    if (config instanceof Ext.data.Store) {
      store = config;
    } else {
      store = new Ext.data.Store(config);
    }
    Ext.data.StoreManager.register(store);
    return store;
  };
  Ext.getStore = function(name) {
    return Ext.data.StoreManager.lookup(name);
  };
  var emptyStore = Ext.regStore('ext-empty-store', {proxy:'memory', useModelWarning:false});
  emptyStore.isEmptyStore = true;
  emptyStore.add = emptyStore.remove = emptyStore.insert = emptyStore.loadData = function() {
    Ext.raise('Cannot modify ext-empty-store');
  };
});
Ext.define('Ext.app.domain.Store', {extend:Ext.app.EventDomain, singleton:true, type:'store', prefix:'store.', idMatchRe:/^\#/, constructor:function() {
  var me = this;
  me.callParent();
  me.monitor(Ext.data.AbstractStore);
}, match:function(target, selector) {
  var result = false, alias = target.alias;
  if (selector === '*') {
    result = true;
  } else {
    if (this.idMatchRe.test(selector)) {
      result = target.getStoreId() === selector.substring(1);
    } else {
      if (alias) {
        result = Ext.Array.indexOf(alias, this.prefix + selector) > -1;
      }
    }
  }
  return result;
}});
Ext.define('Ext.app.route.Queue', {queue:null, token:null, constructor:function(config) {
  Ext.apply(this, config);
  this.queue = new Ext.util.MixedCollection;
}, queueAction:function(route, args) {
  this.queue.add({route:route, args:args});
}, clearQueue:function() {
  this.queue.removeAll();
}, runQueue:function() {
  var queue = this.queue, action = queue.removeAt(0), route;
  if (action) {
    route = action && action.route;
    route.execute(this.token, action.args, this.onActionExecute, this);
  }
}, onActionExecute:function(clearQueue) {
  if (clearQueue) {
    this.clearQueue();
  } else {
    this.runQueue();
  }
}});
Ext.define('Ext.app.route.Route', {action:null, conditions:null, controller:null, allowInactive:false, url:null, before:null, caseInsensitive:false, matcherRegex:null, paramMatchingRegex:null, paramsInMatchString:null, constructor:function(config) {
  var me = this, url;
  Ext.apply(me, config, {conditions:{}});
  url = me.url;
  me.paramMatchingRegex = new RegExp(/:([0-9A-Za-z\_]*)/g);
  me.paramsInMatchString = url.match(me.paramMatchingRegex) || [];
  me.matcherRegex = me.createMatcherRegex(url);
}, recognize:function(url) {
  var me = this, controller = me.controller, matches, args;
  if ((me.allowInactive || controller.isActive()) && me.recognizes(url)) {
    matches = me.matchesFor(url);
    args = url.match(me.matcherRegex);
    args.shift();
    return Ext.applyIf(matches, {controller:controller, action:me.action, historyUrl:url, args:args});
  }
  return false;
}, recognizes:function(url) {
  return this.matcherRegex.test(url);
}, execute:function(token, argConfig, callback, scope) {
  var args = argConfig.args || [], before = this.before, controller = this.controller, beforeCallback = this.createCallback(argConfig, callback, scope);
  if (before) {
    args.push(beforeCallback);
    if (Ext.isString(before)) {
      before = this.before = controller[before];
    }
    if (before) {
      before.apply(controller, args);
    } else {
      Ext.log.warn('The before action: ' + this.before + ' was not found on the controller. The action method will not be executed.');
    }
  } else {
    beforeCallback.resume();
  }
}, matchesFor:function(url) {
  var params = {}, keys = this.paramsInMatchString, values = url.match(this.matcherRegex), i = 0, len = keys.length;
  values.shift();
  for (; i < len; i++) {
    params[keys[i].replace(':', '')] = values[i];
  }
  return params;
}, createMatcherRegex:function(url) {
  var paramsInMatchString = this.paramsInMatchString, conditions = this.conditions, i = 0, len = paramsInMatchString.length, format = Ext.util.Format.format, modifiers = this.caseInsensitive ? 'i' : '', params, cond, matcher;
  for (; i < len; i++) {
    params = paramsInMatchString[i];
    cond = conditions[params];
    matcher = format('{0}', cond || '([%a-zA-Z0-9\\-\\_\\s,]+)');
    url = url.replace(new RegExp(params), matcher);
  }
  return new RegExp('^' + url + '$', modifiers);
}, createCallback:function(args, callback, scope) {
  var me = this;
  scope = scope || me;
  return {resume:function() {
    var controller = me.controller, action = me.action, resume;
    if (Ext.isString(action)) {
      action = controller[action];
    }
    args = args && args.args ? args.args : [];
    resume = args.pop();
    if (resume && !Ext.isObject(resume)) {
      args.push(resume);
    }
    if (action) {
      me.action = action;
      action.apply(controller, args);
    } else {
      Ext.log.warn('The action: ' + me.action + ' was not found on the controller.');
    }
    if (callback) {
      callback.call(scope);
    }
  }, stop:function(all) {
    if (callback) {
      callback.call(scope, all);
    }
  }};
}});
Ext.define('Ext.util.History', {singleton:true, alternateClassName:'Ext.History', mixins:{observable:Ext.util.Observable}, useTopWindow:false, constructor:function() {
  var me = this;
  me.hiddenField = null;
  me.ready = false;
  me.currentToken = null;
  me.mixins.observable.constructor.call(me);
}, getHash:function() {
  return this.win.location.hash.substr(1);
}, setHash:function(hash) {
  try {
    this.win.location.hash = hash;
    this.currentToken = hash;
  } catch (e$22) {
  }
}, handleStateChange:function(token) {
  this.currentToken = token;
  this.fireEvent('change', token);
}, startUp:function() {
  var me = this;
  me.currentToken = me.getHash();
  if (Ext.supports.Hashchange) {
    Ext.get(me.win).on('hashchange', me.onHashChange, me);
  } else {
    Ext.TaskManager.start({fireIdleEvent:false, run:me.onHashChange, interval:50, scope:me});
  }
  me.ready = true;
  me.fireEvent('ready', me);
}, onHashChange:function() {
  var me = this, newHash = me.getHash();
  if (newHash !== me.hash) {
    me.hash = newHash;
    me.handleStateChange(newHash);
  }
}, init:function(onReady, scope) {
  var me = this;
  if (me.ready) {
    Ext.callback(onReady, scope, [me]);
    return;
  }
  if (!Ext.isReady) {
    Ext.onInternalReady(function() {
      me.init(onReady, scope);
    });
    return;
  }
  me.win = me.useTopWindow ? window.top : window;
  me.hash = me.getHash();
  if (onReady) {
    me.on('ready', onReady, scope, {single:true});
  }
  me.startUp();
}, add:function(token, preventDuplicates) {
  var me = this, set = false;
  if (preventDuplicates === false || me.getToken() !== token) {
    me.setHash(token);
    set = true;
  }
  return set;
}, back:function() {
  var win = this.useTopWindow ? window.top : window;
  win.history.go(-1);
}, forward:function() {
  var win = this.useTopWindow ? window.top : window;
  win.history.go(1);
}, getToken:function() {
  return this.ready ? this.currentToken : this.getHash();
}});
Ext.define('Ext.app.route.Router', {singleton:true, multipleToken:'|', queueRoutes:true, constructor:function() {
  var History = Ext.util.History;
  if (!History.ready) {
    History.init();
  }
  History.on('change', this.onStateChange, this);
  this.clear();
}, onStateChange:function(token) {
  var me = this, app = me.application, routes = me.routes, len = routes.length, queueRoutes = me.queueRoutes, tokens = token.split(me.multipleToken), t = 0, length = tokens.length, i, queue, route, args, matched;
  for (; t < length; t++) {
    token = tokens[t];
    matched = false;
    if (queueRoutes) {
      queue = new Ext.app.route.Queue({token:token});
    }
    for (i = 0; i < len; i++) {
      route = routes[i];
      args = route.recognize(token);
      if (args) {
        matched = true;
        if (queueRoutes) {
          queue.queueAction(route, args);
        } else {
          route.execute(token, args);
        }
      }
    }
    if (queueRoutes) {
      queue.runQueue();
    }
    if (!matched && app) {
      app.fireEvent('unmatchedroute', token);
    }
  }
}, connect:function(url, action, controller) {
  var config = {url:url, action:action, controller:controller};
  if (Ext.isObject(action)) {
    Ext.merge(config, action);
  }
  this.routes.push(new Ext.app.route.Route(config));
}, disconnectAll:function(controller) {
  var routes = this.routes, len = routes.length, newRoutes = [], i, route;
  for (i = 0; i < len; ++i) {
    route = routes[i];
    if (route.controller !== controller) {
      newRoutes.push(route);
    }
  }
  this.routes = newRoutes;
}, recognize:function(url) {
  var routes = this.routes || [], i = 0, len = routes.length, route, args;
  for (; i < len; i++) {
    route = routes[i];
    args = route.recognize(url);
    if (args) {
      return {route:route, args:args};
    }
  }
  return false;
}, draw:function(fn) {
  fn.call(this, this);
}, clear:function() {
  this.routes = [];
}});
Ext.define('Ext.app.Controller', {extend:Ext.app.BaseController, statics:{strings:{model:{getter:'getModel', upper:'Model'}, view:{getter:'getView', upper:'View'}, controller:{getter:'getController', upper:'Controller'}, store:{getter:'getStore', upper:'Store'}, profile:{getter:'getProfile', upper:'Profiles'}}, controllerRegex:/^(.*)\.controller\./, profileRegex:/^(.*)\.profile\./, createGetter:function(baseGetter, name) {
  return function() {
    return this[baseGetter](name);
  };
}, getGetterName:function(name, kindUpper) {
  var fn = 'get', parts = name.split('.'), numParts = parts.length, index;
  for (index = 0; index < numParts; index++) {
    fn += Ext.String.capitalize(parts[index]);
  }
  fn += kindUpper;
  return fn;
}, resolveNamespace:function(cls, data) {
  var Controller = Ext.app.Controller, namespaceRe = cls.prototype.isProfile ? Controller.profileRegex : Controller.controllerRegex, className, namespace, match;
  className = Ext.getClassName(cls);
  namespace = data.$namespace || data.namespace || Ext.app.getNamespace(className) || (match = namespaceRe.exec(className)) && match[1];
  if (!namespace) {
    Ext.log.warn('Missing namespace for ' + className + ', please define it ' + 'in namespaces property of your Application class.');
  }
  return namespace;
}, processDependencies:function(cls, requires, namespace, kind, names, profileName) {
  if (!names || !names.length) {
    return;
  }
  var me = this, strings = me.strings[kind], o, absoluteName, shortName, name, j, subLn, getterName, getter;
  if (!Ext.isArray(names)) {
    names = [names];
  }
  for (j = 0, subLn = names.length; j < subLn; j++) {
    name = names[j];
    o = me.getFullName(name, kind, namespace, profileName);
    names[j] = absoluteName = o.absoluteName;
    shortName = o.shortName;
    requires.push(absoluteName);
    getterName = me.getGetterName(shortName, strings.upper);
    if (!cls[getterName]) {
      cls[getterName] = getter = me.createGetter(strings.getter, name);
    } else {
      if (getterName === 'getMainView') {
        Ext.log.warn("Cannot have a view named 'Main' - getter conflicts with mainView config.");
      }
    }
    if (getter && kind !== 'controller') {
      getter['Ext.app.getter'] = true;
    }
  }
}, getFullName:function(name, kind, namespace, profileName) {
  var shortName = name, sep, absoluteName;
  if ((sep = name.indexOf('@')) > 0) {
    shortName = name.substring(0, sep);
    absoluteName = name.substring(sep + 1) + '.' + shortName;
  } else {
    if (name.indexOf('.') > 0 && (Ext.ClassManager.isCreated(name) || this.hasRegisteredPrefix(name))) {
      absoluteName = name;
    } else {
      if (!namespace) {
        Ext.log.warn('Cannot find namespace for ' + kind + ' ' + name + ', ' + 'assuming it is fully qualified class name');
      }
      if (namespace) {
        absoluteName = namespace + '.' + kind + '.' + (profileName ? profileName + '.' + name : name);
        shortName = name;
      } else {
        absoluteName = name;
      }
    }
  }
  return {absoluteName:absoluteName, shortName:shortName};
}, hasRegisteredPrefix:function(className) {
  var inventory = Ext.ClassManager, prefix = inventory.getPrefix(className);
  return prefix && prefix !== className;
}}, models:null, views:null, stores:null, controllers:null, config:{application:null, refs:null, active:true, moduleClassName:null}, onClassExtended:function(cls, data, hooks) {
  var onBeforeClassCreated = hooks.onBeforeCreated;
  hooks.onBeforeCreated = function(cls, data) {
    var Controller = Ext.app.Controller, requires = [], namespace, proto;
    proto = cls.prototype;
    namespace = Controller.resolveNamespace(cls, data);
    if (namespace) {
      proto.$namespace = namespace;
    }
    Controller.processDependencies(proto, requires, namespace, 'model', data.models);
    Controller.processDependencies(proto, requires, namespace, 'view', data.views);
    Controller.processDependencies(proto, requires, namespace, 'store', data.stores);
    Controller.processDependencies(proto, requires, namespace, 'controller', data.controllers);
    Ext.require(requires, Ext.Function.pass(onBeforeClassCreated, arguments, this));
  };
}, constructor:function(config) {
  this.initAutoGetters();
  this.callParent(arguments);
}, normalizeRefs:function(refs) {
  var me = this, newRefs = [];
  if (refs) {
    if (Ext.isObject(refs)) {
      Ext.Object.each(refs, function(key, value) {
        if (Ext.isString(value)) {
          value = {selector:value};
        }
        value.ref = key;
        newRefs.push(value);
      });
    } else {
      if (Ext.isArray(refs)) {
        newRefs = Ext.Array.merge(newRefs, refs);
      }
    }
  }
  refs = me.refs;
  if (refs) {
    me.refs = null;
    refs = me.normalizeRefs(refs);
    if (refs) {
      newRefs = Ext.Array.merge(newRefs, refs);
    }
  }
  return newRefs;
}, getRefMap:function() {
  var me = this, refMap = me._refMap, refs, ref, ln, i;
  if (!refMap) {
    refs = me.getRefs();
    refMap = me._refMap = {};
    if (refs) {
      for (i = 0, ln = refs.length; i < ln; i++) {
        ref = refs[i];
        refMap[ref.ref] = ref.selector;
      }
    }
  }
  return refMap;
}, applyRefs:function(refs) {
  return this.normalizeRefs(Ext.clone(refs));
}, updateRefs:function(refs) {
  if (refs) {
    this.ref(refs);
  }
}, initAutoGetters:function() {
  var proto = this.self.prototype, prop, fn;
  for (prop in proto) {
    fn = proto[prop];
    if (fn && fn['Ext.app.getter']) {
      fn.call(this);
    }
  }
}, doInit:function(app) {
  var me = this;
  if (!me._initialized) {
    me.init(app);
    me._initialized = true;
  }
}, finishInit:function(app) {
  var me = this, controllers = me.controllers, controller, i, l;
  if (me._initialized && controllers && controllers.length) {
    for (i = 0, l = controllers.length; i < l; i++) {
      controller = me.getController(controllers[i]);
      controller.finishInit(app);
    }
  }
}, init:Ext.emptyFn, onLaunch:Ext.emptyFn, activate:function() {
  this.setActive(true);
}, deactivate:function() {
  this.setActive(false);
}, isActive:function() {
  return this.getActive();
}, ref:function(refs) {
  var me = this, i = 0, length = refs.length, info, ref, fn;
  refs = Ext.Array.from(refs);
  me.references = me.references || [];
  for (; i < length; i++) {
    info = refs[i];
    ref = info.ref;
    fn = 'get' + Ext.String.capitalize(ref);
    if (!me[fn]) {
      me[fn] = Ext.Function.pass(me.getRef, [ref, info], me);
    }
    me.references.push(ref.toLowerCase());
  }
}, addRef:function(refs) {
  this.ref(refs);
}, getRef:function(ref, info, config) {
  var me = this, refCache = me.refCache || (me.refCache = {}), cached = refCache[ref];
  info = info || {};
  config = config || {};
  Ext.apply(info, config);
  if (info.forceCreate) {
    return Ext.ComponentManager.create(info, 'component');
  }
  if (!cached) {
    if (info.selector) {
      refCache[ref] = cached = Ext.ComponentQuery.query(info.selector)[0];
    }
    if (!cached && info.autoCreate) {
      refCache[ref] = cached = Ext.ComponentManager.create(info, 'component');
    }
    if (cached) {
      cached.on('beforedestroy', function() {
        refCache[ref] = null;
      });
    }
  }
  return cached;
}, hasRef:function(ref) {
  var references = this.references;
  return references && Ext.Array.indexOf(references, ref.toLowerCase()) !== -1;
}, getController:function(id) {
  var app = this.getApplication();
  if (id === this.getId()) {
    return this;
  }
  return app && app.getController(id);
}, getStore:function(name) {
  var storeId, store;
  storeId = name.indexOf('@') === -1 ? name : name.split('@')[0];
  store = Ext.StoreManager.get(storeId);
  if (!store) {
    name = Ext.app.Controller.getFullName(name, 'store', this.$namespace);
    if (name) {
      store = Ext.create(name.absoluteName, {id:storeId});
    }
  }
  return store;
}, getModel:function(model) {
  var name = Ext.app.Controller.getFullName(model, 'model', this.$namespace), ret = Ext.ClassManager.get(name.absoluteName);
  if (!ret) {
    ret = Ext.data.schema.Schema.lookupEntity(model);
  }
  return ret;
}, getProfile:function(name) {
  name = Ext.app.Controller.getFullName(name, 'profile', this.$namespace);
  return name;
}, getView:function(view) {
  var name = Ext.app.Controller.getFullName(view, 'view', this.$namespace);
  return name && Ext.ClassManager.get(name.absoluteName);
}, ensureId:function() {
  var id = this.getId();
  if (!id) {
    this.setId(this.getModuleClassName(this.$className, 'controller'));
  }
}, destroy:function(destroyRefs, fromApp) {
  var me = this, app = me.application, refCache, ref;
  if (!fromApp && app) {
    app.unregister(me);
  }
  me.application = null;
  if (destroyRefs) {
    refCache = me.refCache;
    for (ref in refCache) {
      if (refCache.hasOwnProperty(ref)) {
        Ext.destroy(refCache[ref]);
      }
    }
  }
  me.callParent();
}});
Ext.define('Ext.app.Application', {extend:Ext.app.Controller, isApplication:true, scope:undefined, namespaces:[], paths:null, config:{name:'', appProperty:'app', profiles:[], currentProfile:null, mainView:{$value:null, lazy:true}, defaultToken:null, glyphFontFamily:null}, onClassExtended:function(cls, data, hooks) {
  var Controller = Ext.app.Controller, proto = cls.prototype, requires = [], onBeforeClassCreated, paths, namespace, ns;
  namespace = data.name || cls.superclass.name;
  if (namespace) {
    data.$namespace = namespace;
    Ext.app.addNamespaces(namespace);
  }
  if (data.namespaces) {
    Ext.app.addNamespaces(data.namespaces);
  }
  if (data['paths processed']) {
    delete data['paths processed'];
  } else {
    Ext.app.setupPaths(namespace, 'appFolder' in data ? data.appFolder : cls.superclass.appFolder, data.paths);
  }
  Controller.processDependencies(proto, requires, namespace, 'profile', data.profiles);
  proto.getDependencies(cls, data, requires);
  if (requires.length) {
    onBeforeClassCreated = hooks.onBeforeCreated;
    hooks.onBeforeCreated = function(cls, data) {
      var args = Ext.Array.clone(arguments);
      Ext.require(requires, function() {
        return onBeforeClassCreated.apply(this, args);
      });
    };
  }
}, getDependencies:Ext.emptyFn, constructor:function(config) {
  var me = this;
  Ext.app.route.Router.application = me;
  me.callParent(arguments);
  if (Ext.isEmpty(me.getName())) {
    Ext.raise('[Ext.app.Application] Name property is required');
  }
  me.doInit(me);
  me.initNamespace();
  Ext.on('appupdate', me.onAppUpdate, me, {single:true});
  Ext.Loader.setConfig({enabled:true});
  this.onProfilesReady();
}, onAppUpdate:Ext.emptyFn, onProfilesReady:function() {
  var me = this, profiles = me.getProfiles(), length = profiles.length, current, i, instance;
  for (i = 0; i < length; i++) {
    instance = Ext.create(profiles[i], {application:me});
    if (instance.isActive() && !current) {
      current = instance;
      me.setCurrentProfile(current);
    }
  }
  if (current) {
    current.init();
  }
  me.initControllers();
  me.onBeforeLaunch();
  me.finishInitControllers();
}, initNamespace:function() {
  var me = this, appProperty = me.getAppProperty(), ns;
  ns = Ext.namespace(me.getName());
  if (ns) {
    ns.getApplication = function() {
      return me;
    };
    if (appProperty) {
      if (!ns[appProperty]) {
        ns[appProperty] = me;
      } else {
        if (ns[appProperty] !== me) {
          Ext.log.warn('An existing reference is being overwritten for ' + name + '.' + appProperty + '. See the appProperty config.');
        }
      }
    }
  }
}, initControllers:function() {
  var me = this, controllers = Ext.Array.from(me.controllers), profile = me.getCurrentProfile(), i, ln;
  me.controllers = new Ext.util.MixedCollection;
  for (i = 0, ln = controllers.length; i < ln; i++) {
    me.getController(controllers[i]);
  }
  if (profile) {
    controllers = profile.getControllers();
    for (i = 0, ln = controllers.length; i < ln; i++) {
      me.getController(controllers[i]);
    }
  }
}, finishInitControllers:function() {
  var me = this, controllers, i, l;
  controllers = me.controllers.getRange();
  for (i = 0, l = controllers.length; i < l; i++) {
    controllers[i].finishInit(me);
  }
}, launch:Ext.emptyFn, onBeforeLaunch:function() {
  var me = this, History = Ext.util.History, defaultToken = me.getDefaultToken(), currentProfile = me.getCurrentProfile(), controllers, c, cLen, controller, token;
  me.initMainView();
  if (currentProfile) {
    currentProfile.launch();
  }
  me.launch.call(me.scope || me);
  me.launched = true;
  me.fireEvent('launch', me);
  controllers = me.controllers.items;
  cLen = controllers.length;
  for (c = 0; c < cLen; c++) {
    controller = controllers[c];
    controller.onLaunch(me);
  }
  if (!History.ready) {
    History.init();
  }
  token = History.getToken();
  if (token || token === defaultToken) {
    Ext.app.route.Router.onStateChange(token);
  } else {
    if (defaultToken) {
      History.add(defaultToken);
    }
  }
  if (Ext.Microloader && Ext.Microloader.appUpdate && Ext.Microloader.appUpdate.updated) {
    Ext.Microloader.fireAppUpdate();
  }
  Ext.defer(Ext.ClassManager.clearNamespaceCache, 2000, Ext.ClassManager);
}, getModuleClassName:function(name, kind) {
  return Ext.app.Controller.getFullName(name, kind, this.getName()).absoluteName;
}, initMainView:function() {
  var me = this, currentProfile = me.getCurrentProfile(), mainView;
  if (currentProfile) {
    mainView = currentProfile.getMainView();
  }
  if (mainView) {
    me.setMainView(mainView);
  } else {
    me.getMainView();
  }
}, applyMainView:function(value) {
  var view = this.getView(value);
  return view.create();
}, createController:function(name) {
  return this.getController(name);
}, destroyController:function(controller) {
  if (typeof controller === 'string') {
    controller = this.getController(controller, true);
  }
  Ext.destroy(controller);
}, getController:function(name, preventCreate) {
  var me = this, controllers = me.controllers, className, controller, len, i, c, all;
  controller = controllers.get(name);
  if (!controller) {
    all = controllers.items;
    for (i = 0, len = all.length; i < len; ++i) {
      c = all[i];
      className = c.getModuleClassName();
      if (className && className === name) {
        controller = c;
        break;
      }
    }
  }
  if (!controller && !preventCreate) {
    className = me.getModuleClassName(name, 'controller');
    controller = Ext.create(className, {application:me, moduleClassName:name});
    controllers.add(controller);
    if (me._initialized) {
      controller.doInit(me);
    }
  }
  return controller;
}, unregister:function(controller) {
  this.controllers.remove(controller);
}, getApplication:function() {
  return this;
}, destroy:function(destroyRefs) {
  var me = this, controllers = me.controllers, ns = Ext.namespace(me.getName()), appProp = me.getAppProperty();
  Ext.destroy(me.viewport);
  if (controllers) {
    controllers.each(function(controller) {
      controller.destroy(destroyRefs, true);
    });
  }
  me.controllers = null;
  me.callParent([destroyRefs, true]);
  if (ns && ns[appProp] === me) {
    delete ns[appProp];
  }
}, updateGlyphFontFamily:function(fontFamily) {
  Ext.setGlyphFontFamily(fontFamily);
}, applyProfiles:function(profiles) {
  var me = this;
  return Ext.Array.map(profiles, function(profile) {
    return me.getModuleClassName(profile, 'profile');
  });
}});
Ext.application = function(config) {
  var createApp = function(App) {
    Ext.onReady(function() {
      var Viewport = Ext.viewport;
      Viewport = Viewport && Viewport['Viewport'];
      if (Viewport && Viewport.setup) {
        Viewport.setup(App.prototype.config.viewport);
      }
      Ext.app.Application.instance = new App;
    });
  };
  if (typeof config === 'string') {
    Ext.require(config, function() {
      createApp(Ext.ClassManager.get(config));
    });
  } else {
    config = Ext.apply({extend:'Ext.app.Application'}, config);
    Ext.app.setupPaths(config.name, config.appFolder, config.paths);
    config['paths processed'] = true;
    Ext.define(config.name + '.$application', config, function() {
      createApp(this);
    });
  }
};
Ext.define('Ext.scroll.Scroller', {extend:Ext.Evented, alias:'scroller.scroller', mixins:[Ext.mixin.Factoryable], factoryConfig:{defaultType:'dom'}, isScroller:true, _spacerCls:Ext.baseCSSPrefix + 'domscroller-spacer', config:{direction:undefined, directionLock:false, disabled:null, element:undefined, indicators:null, maxPosition:{x:0, y:0}, maxUserPosition:{x:0, y:0}, minPosition:{x:0, y:0}, minUserPosition:{x:0, y:0}, momentumEasing:null, size:null, slotSnapSize:{x:0, y:0}, x:true, y:true, spacerXY:null}, 
statics:{create:function(config) {
  return Ext.Factory.scroller(config, Ext.supports.Touch ? 'touch' : 'dom');
}}, constructor:function(config) {
  var me = this;
  me.position = {x:0, y:0};
  me.callParent([config]);
  me.onDomScrollEnd = Ext.Function.createBuffered(me.onDomScrollEnd, 100, me);
}, destroy:function() {
  var me = this;
  me.setX(Ext.emptyString);
  me.setY(Ext.emptyString);
  me.setElement(null);
  me.onDomScrollEnd = me._partners = me.component = null;
  me.callParent();
}, addPartner:function(partner, axis) {
  var me = this, partners = me._partners || (me._partners = {}), otherPartners = partner._partners || (partner._partners = {});
  partners[partner.getId()] = {scroller:partner, axis:axis};
  otherPartners[me.getId()] = {scroller:me, axis:axis};
}, applyElement:function(element, oldElement) {
  var me = this, el, eventSource;
  if (oldElement) {
    me.scrollListener.destroy();
  }
  if (element) {
    if (element.isElement) {
      el = element;
    } else {
      el = Ext.get(element);
      if (!el && typeof element === 'string') {
        Ext.raise('Cannot create Ext.scroll.Scroller instance. ' + "Element with id '" + element + "' not found.");
      }
    }
    if (el.dom === document.body) {
      el = Ext.get(document.scrollingElement || (Ext.isWebKit ? document.body : document.documentElement));
      eventSource = Ext.get(Ext.isIE9m ? window : document);
    } else {
      eventSource = el;
    }
    me.scrollListener = eventSource.on({scroll:me.onDomScroll, scope:me, destroyable:true});
    return el;
  }
}, getClientSize:function() {
  var dom = this.getElement().dom;
  return {x:dom.clientWidth, y:dom.clientHeight};
}, getScrollbarSize:function() {
  var me = this, width = 0, height = 0, element, dom, x, y, hasXScroll, hasYScroll, scrollbarSize;
  if (me.isDomScroller || Ext.supports.touchScroll === 1) {
    element = me.getElement();
    if (element && !element.destroyed) {
      x = me.getX();
      y = me.getY();
      dom = element.dom;
      if (x || y) {
        scrollbarSize = Ext.getScrollbarSize();
      }
      if (x === 'scroll') {
        hasXScroll = true;
      } else {
        if (x) {
          hasXScroll = dom.scrollWidth > dom.clientWidth;
        }
      }
      if (y === 'scroll') {
        hasYScroll = true;
      } else {
        if (y) {
          hasYScroll = dom.scrollHeight > dom.clientHeight;
        }
      }
      if (hasXScroll) {
        height = scrollbarSize.height;
      }
      if (hasYScroll) {
        width = scrollbarSize.width;
      }
    }
  }
  return {width:width, height:height};
}, getPosition:function() {
  return this.position;
}, updateDirectionLock:Ext.emptyFn, updateDisabled:Ext.emptyFn, updateIndicators:Ext.emptyFn, updateMaxPosition:Ext.emptyFn, updateMaxUserPosition:Ext.emptyFn, updateMinPosition:Ext.emptyFn, updateMinUserPosition:Ext.emptyFn, updateMomenumEasing:Ext.emptyFn, updateX:Ext.emptyFn, updateY:Ext.emptyFn, onPartnerScrollStart:Ext.emptyFn, onPartnerScrollEnd:Ext.emptyFn, refresh:function() {
  this.fireEvent('refresh', this);
  return this;
}, removePartner:function(partner) {
  var partners = this._partners, otherPartners = partner._partners;
  if (partners) {
    delete partners[partner.getId()];
  }
  if (otherPartners) {
    delete otherPartners[this.getId()];
  }
}, scrollBy:function(deltaX, deltaY, animate) {
  var position = this.getPosition();
  if (deltaX) {
    if (deltaX.length) {
      animate = deltaY;
      deltaY = deltaX[1];
      deltaX = deltaX[0];
    } else {
      if (typeof deltaX !== 'number') {
        animate = deltaY;
        deltaY = deltaX.y;
        deltaX = deltaX.x;
      }
    }
  }
  deltaX = typeof deltaX === 'number' ? deltaX + position.x : null;
  deltaY = typeof deltaY === 'number' ? deltaY + position.y : null;
  return this.doScrollTo(deltaX, deltaY, animate);
}, scrollIntoView:function(el, hscroll, animate, highlight) {
  var me = this, position = me.getPosition(), newPosition, newX, newY, myEl = me.getElement();
  if (el) {
    newPosition = Ext.fly(el).getScrollIntoViewXY(myEl, position.x, position.y);
    newX = hscroll === false ? position.x : newPosition.x;
    newY = newPosition.y;
    if (highlight) {
      me.on({scrollend:'doHighlight', scope:me, single:true, args:[el, highlight]});
    }
    me.doScrollTo(newX, newY, animate);
  }
}, isInView:function(el) {
  var me = this, result = {x:false, y:false}, elRegion, myEl = me.getElement(), myElRegion;
  if (el && myEl.contains(el)) {
    myElRegion = myEl.getRegion();
    elRegion = Ext.fly(el).getRegion();
    result.x = elRegion.right > myElRegion.left && elRegion.left < myElRegion.right;
    result.y = elRegion.bottom > myElRegion.top && elRegion.top < myElRegion.bottom;
  }
  return result;
}, scrollTo:function(x, y, animate) {
  var maxPosition;
  if (x) {
    if (x.length) {
      animate = y;
      y = x[1];
      x = x[0];
    } else {
      if (typeof x !== 'number') {
        animate = y;
        y = x.y;
        x = x.x;
      }
    }
  }
  if (x < 0 || y < 0) {
    maxPosition = this.getMaxPosition();
    if (x < 0) {
      x += maxPosition.x;
    }
    if (y < 0) {
      y += maxPosition.y;
    }
  }
  this.doScrollTo(x, y, animate);
}, updateDirection:function(direction) {
  var me = this, x, y;
  if (!direction) {
    x = me.getX();
    y = me.getY();
    if (x && y) {
      direction = y === 'scroll' && x === 'scroll' ? 'both' : 'auto';
    } else {
      if (y) {
        direction = 'vertical';
      } else {
        if (x) {
          direction = 'horizontal';
        }
      }
    }
    me._direction = direction;
  } else {
    if (direction === 'auto') {
      x = true;
      y = true;
    } else {
      if (direction === 'vertical') {
        x = false;
        y = true;
      } else {
        if (direction === 'horizontal') {
          x = true;
          y = false;
        } else {
          if (direction === 'both') {
            x = 'scroll';
            y = 'scroll';
          }
        }
      }
    }
    me.setX(x);
    me.setY(y);
  }
}, updateSize:function(size) {
  var me = this, element = me.getElement(), spacer, x, y;
  if (element) {
    spacer = me.getSpacer();
    if (size == null) {
      spacer.hide();
    } else {
      if (typeof size === 'number') {
        x = size;
        y = size;
      } else {
        x = size.x || 0;
        y = size.y || 0;
      }
      if (x > 0) {
        x -= 1;
      }
      if (y > 0) {
        y -= 1;
      }
      me.setSpacerXY({x:x, y:y});
      spacer.show();
    }
  }
}, deprecated:{5:{methods:{getScroller:function() {
  return this;
}}}, '5.1.0':{methods:{scrollToTop:function(animate) {
  return this.scrollTo(0, 0, animate);
}, scrollToEnd:function(animate) {
  return this.scrollTo(Infinity, Infinity, animate);
}}}}, privates:{getSpacer:function() {
  var me = this, spacer = me._spacer, element;
  if (!spacer) {
    element = me.getElement();
    spacer = me._spacer = element.createChild({cls:me._spacerCls, role:'presentation'});
    spacer.setVisibilityMode(2);
    element.position();
  }
  return spacer;
}, applySpacerXY:function(pos, oldPos) {
  if (oldPos && pos.x === oldPos.x && pos.y === oldPos.y) {
    pos = undefined;
  }
  return pos;
}, updateSpacerXY:function(pos) {
  this.getSpacer().setLocalXY(pos.x, pos.y);
}, convertX:function(x) {
  return x;
}, doHighlight:function(el, highlight) {
  if (highlight !== true) {
    Ext.fly(el).highlight(highlight);
  } else {
    Ext.fly(el).highlight();
  }
}, fireScrollStart:function(x, y) {
  var me = this, component = me.component;
  me.invokePartners('onPartnerScrollStart', x, y);
  if (me.hasListeners.scrollstart) {
    me.fireEvent('scrollstart', me, x, y);
  }
  if (component && component.onScrollStart) {
    component.onScrollStart(x, y);
  }
  Ext.GlobalEvents.fireEvent('scrollstart', me, x, y);
}, fireScroll:function(x, y) {
  var me = this, component = me.component;
  me.invokePartners('onPartnerScroll', x, y);
  if (me.hasListeners.scroll) {
    me.fireEvent('scroll', me, x, y);
  }
  if (component && component.onScrollMove) {
    component.onScrollMove(x, y);
  }
  Ext.GlobalEvents.fireEvent('scroll', me, x, y);
}, fireScrollEnd:function(x, y) {
  var me = this, component = me.component;
  me.invokePartners('onPartnerScrollEnd', x, y);
  if (me.hasListeners.scrollend) {
    me.fireEvent('scrollend', me, x, y);
  }
  if (component && component.onScrollEnd) {
    component.onScrollEnd(x, y);
  }
  Ext.GlobalEvents.fireEvent('scrollend', me, x, y);
}, initXStyle:function() {
  var element = this.getElement(), x = this.getX();
  if (element && element.dom) {
    if (!x) {
      x = 'hidden';
    } else {
      if (x === true) {
        x = 'auto';
      }
    }
    element.setStyle('overflow-x', x);
  }
}, initYStyle:function() {
  var element = this.getElement(), y = this.getY();
  if (element && element.dom) {
    if (!y) {
      y = 'hidden';
    } else {
      if (y === true) {
        y = 'auto';
      }
    }
    element.setStyle('overflow-y', y);
  }
}, invokePartners:function(method, x, y) {
  var me = this, partners = me._partners, partner, id, isEnd = method === 'onPartnerScrollEnd';
  if (!me.suspendSync & !me.isReflecting) {
    for (id in partners) {
      partner = partners[id].scroller;
      partner.isReflecting = true;
      partner[method](me, x, y);
      if (isEnd) {
        partner.isReflecting = false;
      }
    }
  }
}, clearReflecting:function() {
  this.isReflecting = false;
}, suspendPartnerSync:function() {
  this.suspendSync = (this.suspendSync || 0) + 1;
}, resumePartnerSync:function() {
  if (this.suspendSync) {
    this.suspendSync--;
  }
}, updateDomScrollPosition:function() {
  var me = this, element = me.getElement(), elScroll, position = me.position;
  if (element && !element.destroyed) {
    elScroll = me.getElementScroll(element);
    position.x = elScroll.left;
    position.y = elScroll.top;
  }
  me.positionDirty = false;
  return position;
}, getElementScroll:function(element) {
  return element.getScroll();
}, onDomScroll:function() {
  var me = this, position, x, y, el;
  if (me.isTouchScroller && Ext.supports.touchScroll === 2) {
    el = me.getElement().dom;
    el.scrollTop = el.scrollLeft = 0;
    return;
  }
  position = me.updateDomScrollPosition();
  x = position.x;
  y = position.y;
  if (!me.isScrolling) {
    me.isScrolling = Ext.isScrolling = true;
    me.fireScrollStart(x, y);
  }
  me.fireScroll(x, y);
  me.onDomScrollEnd();
}, onDomScrollEnd:function() {
  var me = this, position = me.getPosition(), x = position.x, y = position.y;
  me.isScrolling = Ext.isScrolling = false;
  me.trackingScrollLeft = x;
  me.trackingScrollTop = y;
  me.fireScrollEnd(x, y);
}, onPartnerScroll:function(partner, x, y) {
  var axis = partner._partners[this.getId()].axis;
  if (axis) {
    if (axis === 'x') {
      y = null;
    } else {
      if (axis === 'y') {
        x = null;
      }
    }
  }
  this.doScrollTo(x, y, false, true);
}, restoreState:function() {
  var me = this, el = me.getElement(), dom;
  if (el) {
    dom = el.dom;
    if (me.trackingScrollTop !== undefined) {
      dom.scrollTop = me.trackingScrollTop;
      dom.scrollLeft = me.trackingScrollLeft;
    }
  }
}}});
Ext.define('Ext.fx.easing.Abstract', {config:{startTime:0, startValue:0}, isEasing:true, isEnded:false, constructor:function(config) {
  this.initConfig(config);
  return this;
}, applyStartTime:function(startTime) {
  if (!startTime) {
    startTime = Ext.Date.now();
  }
  return startTime;
}, updateStartTime:function(startTime) {
  this.reset();
}, reset:function() {
  this.isEnded = false;
}, getValue:Ext.emptyFn});
Ext.define('Ext.fx.easing.Momentum', {extend:Ext.fx.easing.Abstract, config:{acceleration:30, friction:0, startVelocity:0}, alpha:0, updateFriction:function(friction) {
  var theta = Math.log(1 - friction / 10);
  this.theta = theta;
  this.alpha = theta / this.getAcceleration();
}, updateStartVelocity:function(velocity) {
  this.velocity = velocity * this.getAcceleration();
}, updateAcceleration:function(acceleration) {
  this.velocity = this.getStartVelocity() * acceleration;
  this.alpha = this.theta / acceleration;
}, getValue:function() {
  return this.getStartValue() - this.velocity * (1 - this.getFrictionFactor()) / this.theta;
}, getFrictionFactor:function() {
  var deltaTime = Ext.Date.now() - this.getStartTime();
  return Math.exp(deltaTime * this.alpha);
}, getVelocity:function() {
  return this.getFrictionFactor() * this.velocity;
}});
Ext.define('Ext.fx.easing.Bounce', {extend:Ext.fx.easing.Abstract, config:{springTension:0.3, acceleration:30, startVelocity:0}, getValue:function() {
  var deltaTime = Ext.Date.now() - this.getStartTime(), theta = deltaTime / this.getAcceleration(), powTime = theta * Math.pow(Math.E, -this.getSpringTension() * theta);
  return this.getStartValue() + this.getStartVelocity() * powTime;
}});
Ext.define('Ext.fx.easing.BoundMomentum', {extend:Ext.fx.easing.Abstract, config:{momentum:null, bounce:null, minMomentumValue:0, maxMomentumValue:0, minVelocity:0.01, startVelocity:0}, applyMomentum:function(config, currentEasing) {
  return Ext.factory(config, Ext.fx.easing.Momentum, currentEasing);
}, applyBounce:function(config, currentEasing) {
  return Ext.factory(config, Ext.fx.easing.Bounce, currentEasing);
}, updateStartTime:function(startTime) {
  this.getMomentum().setStartTime(startTime);
  this.callParent(arguments);
}, updateStartVelocity:function(startVelocity) {
  this.getMomentum().setStartVelocity(startVelocity);
}, updateStartValue:function(startValue) {
  this.getMomentum().setStartValue(startValue);
}, reset:function() {
  this.lastValue = null;
  this.isBouncingBack = false;
  this.isOutOfBound = false;
  return this.callParent(arguments);
}, getValue:function() {
  var momentum = this.getMomentum(), bounce = this.getBounce(), startVelocity = momentum.getStartVelocity(), direction = startVelocity > 0 ? 1 : -1, minValue = this.getMinMomentumValue(), maxValue = this.getMaxMomentumValue(), boundedValue = direction == 1 ? maxValue : minValue, lastValue = this.lastValue, value, velocity;
  if (startVelocity === 0) {
    return this.getStartValue();
  }
  if (!this.isOutOfBound) {
    value = momentum.getValue();
    velocity = momentum.getVelocity();
    if (Math.abs(velocity) < this.getMinVelocity()) {
      this.isEnded = true;
    }
    if (value >= minValue && value <= maxValue) {
      return value;
    }
    this.isOutOfBound = true;
    bounce.setStartTime(Ext.Date.now()).setStartVelocity(velocity).setStartValue(boundedValue);
  }
  value = bounce.getValue();
  if (!this.isEnded) {
    if (!this.isBouncingBack) {
      if (lastValue !== null) {
        if (direction == 1 && value < lastValue || direction == -1 && value > lastValue) {
          this.isBouncingBack = true;
        }
      }
    } else {
      if (Math.round(value) == boundedValue) {
        this.isEnded = true;
      }
    }
  }
  this.lastValue = value;
  return value;
}});
Ext.define('Ext.fx.easing.Linear', {extend:Ext.fx.easing.Abstract, alias:'easing.linear', config:{duration:0, endValue:0}, updateStartValue:function(startValue) {
  this.distance = this.getEndValue() - startValue;
}, updateEndValue:function(endValue) {
  this.distance = endValue - this.getStartValue();
}, getValue:function() {
  var deltaTime = Ext.Date.now() - this.getStartTime(), duration = this.getDuration();
  if (deltaTime > duration) {
    this.isEnded = true;
    return this.getEndValue();
  } else {
    return this.getStartValue() + deltaTime / duration * this.distance;
  }
}});
Ext.define('Ext.fx.easing.EaseOut', {extend:Ext.fx.easing.Linear, alias:'easing.ease-out', config:{exponent:4, duration:1500}, getValue:function() {
  var deltaTime = Ext.Date.now() - this.getStartTime(), duration = this.getDuration(), startValue = this.getStartValue(), endValue = this.getEndValue(), distance = this.distance, theta = deltaTime / duration, thetaC = 1 - theta, thetaEnd = 1 - Math.pow(thetaC, this.getExponent()), currentValue = startValue + thetaEnd * distance;
  if (deltaTime >= duration) {
    this.isEnded = true;
    return endValue;
  }
  return currentValue;
}});
Ext.define('Ext.util.translatable.Abstract', {extend:Ext.Evented, config:{useWrapper:null, easing:null, easingX:null, easingY:null}, x:0, y:0, activeEasingX:null, activeEasingY:null, isAnimating:false, isTranslatable:true, constructor:function(config) {
  this.mixins.observable.constructor.call(this, config);
  this.position = {x:0, y:0};
}, factoryEasing:function(easing) {
  return Ext.factory(easing, Ext.fx.easing.Linear, null, 'easing');
}, applyEasing:function(easing) {
  if (!this.getEasingX()) {
    this.setEasingX(this.factoryEasing(easing));
  }
  if (!this.getEasingY()) {
    this.setEasingY(this.factoryEasing(easing));
  }
}, applyEasingX:function(easing) {
  return this.factoryEasing(easing);
}, applyEasingY:function(easing) {
  return this.factoryEasing(easing);
}, doTranslate:Ext.emptyFn, translate:function(x, y, animation) {
  if (animation) {
    return this.translateAnimated(x, y, animation);
  }
  if (this.isAnimating) {
    this.stopAnimation();
  }
  if (!isNaN(x) && typeof x == 'number') {
    this.x = x;
  }
  if (!isNaN(y) && typeof y == 'number') {
    this.y = y;
  }
  this.doTranslate(x, y);
}, translateAxis:function(axis, value, animation) {
  var x, y;
  if (axis == 'x') {
    x = value;
  } else {
    y = value;
  }
  return this.translate(x, y, animation);
}, getPosition:function() {
  var me = this, position = me.position;
  position.x = -me.x;
  position.y = -me.y;
  return position;
}, animate:function(easingX, easingY) {
  this.activeEasingX = easingX;
  this.activeEasingY = easingY;
  this.isAnimating = true;
  this.lastX = null;
  this.lastY = null;
  Ext.AnimationQueue.start(this.doAnimationFrame, this);
  this.fireEvent('animationstart', this, this.x, this.y);
  return this;
}, translateAnimated:function(x, y, animation) {
  var me = this;
  if (!Ext.isObject(animation)) {
    animation = {};
  }
  if (me.isAnimating) {
    me.stopAnimation();
  }
  me.callback = animation.callback;
  me.callbackScope = animation.scope;
  var now = Ext.Date.now(), easing = animation.easing, easingX = typeof x == 'number' ? animation.easingX || easing || me.getEasingX() || true : null, easingY = typeof y == 'number' ? animation.easingY || easing || me.getEasingY() || true : null;
  if (easingX) {
    easingX = me.factoryEasing(easingX);
    easingX.setStartTime(now);
    easingX.setStartValue(me.x);
    easingX.setEndValue(x);
    if ('duration' in animation) {
      easingX.setDuration(animation.duration);
    }
  }
  if (easingY) {
    easingY = me.factoryEasing(easingY);
    easingY.setStartTime(now);
    easingY.setStartValue(me.y);
    easingY.setEndValue(y);
    if ('duration' in animation) {
      easingY.setDuration(animation.duration);
    }
  }
  return me.animate(easingX, easingY);
}, doAnimationFrame:function() {
  var me = this, easingX = me.activeEasingX, easingY = me.activeEasingY, now = Date.now(), x, y;
  if (!me.isAnimating) {
    return;
  }
  me.lastRun = now;
  if (easingX === null && easingY === null) {
    me.stopAnimation();
    return;
  }
  if (easingX !== null) {
    me.x = x = Math.round(easingX.getValue());
    if (easingX.isEnded) {
      me.activeEasingX = null;
      me.fireEvent('axisanimationend', me, 'x', x);
    }
  } else {
    x = me.x;
  }
  if (easingY !== null) {
    me.y = y = Math.round(easingY.getValue());
    if (easingY.isEnded) {
      me.activeEasingY = null;
      me.fireEvent('axisanimationend', me, 'y', y);
    }
  } else {
    y = me.y;
  }
  if (me.lastX !== x || me.lastY !== y) {
    me.doTranslate(x, y);
    me.lastX = x;
    me.lastY = y;
  }
  me.fireEvent('animationframe', me, x, y);
}, stopAnimation:function() {
  var me = this;
  if (!me.isAnimating) {
    return;
  }
  me.activeEasingX = null;
  me.activeEasingY = null;
  me.isAnimating = false;
  Ext.AnimationQueue.stop(me.doAnimationFrame, me);
  me.fireEvent('animationend', me, me.x, me.y);
  if (me.callback) {
    me.callback.call(me.callbackScope);
    me.callback = null;
  }
}, refresh:function() {
  this.translate(this.x, this.y);
}, destroy:function() {
  if (this.isAnimating) {
    this.stopAnimation();
  }
  this.callParent();
}});
Ext.define('Ext.util.translatable.Dom', {extend:Ext.util.translatable.Abstract, config:{element:null}, applyElement:function(element) {
  if (!element) {
    return;
  }
  return Ext.get(element);
}, updateElement:function() {
  this.refresh();
}});
Ext.define('Ext.util.translatable.CssTransform', {extend:Ext.util.translatable.Dom, doTranslate:function(x, y) {
  var element = this.getElement();
  if (!this.destroyed && !element.destroyed) {
    element.translate(x, y);
  }
}, destroy:function() {
  var element = this.getElement();
  if (element && !element.destroyed) {
    element.dom.style.webkitTransform = null;
  }
  this.callParent();
}});
Ext.define('Ext.util.translatable.ScrollPosition', {extend:Ext.util.translatable.Dom, type:'scrollposition', config:{useWrapper:true}, getWrapper:function() {
  var wrapper = this.wrapper, element = this.getElement(), container;
  if (!wrapper) {
    container = element.getParent();
    if (!container) {
      return null;
    }
    if (container.hasCls(Ext.baseCSSPrefix + 'translatable-hboxfix')) {
      container = container.getParent();
    }
    if (this.getUseWrapper()) {
      wrapper = element.wrap();
    } else {
      wrapper = container;
    }
    element.addCls(Ext.baseCSSPrefix + 'translatable');
    wrapper.addCls(Ext.baseCSSPrefix + 'translatable-container');
    this.wrapper = wrapper;
    wrapper.on('painted', function() {
      if (!this.isAnimating) {
        this.refresh();
      }
    }, this);
    this.refresh();
  }
  return wrapper;
}, doTranslate:function(x, y) {
  var wrapper = this.getWrapper(), dom;
  if (wrapper) {
    dom = wrapper.dom;
    if (typeof x == 'number') {
      dom.scrollLeft = 500000 - x;
    }
    if (typeof y == 'number') {
      dom.scrollTop = 500000 - y;
    }
  }
}, destroy:function() {
  var me = this, element = me.getElement(), wrapper = me.wrapper;
  if (wrapper) {
    if (!element.destroyed) {
      if (me.getUseWrapper()) {
        wrapper.doReplaceWith(element);
      }
      element.removeCls(Ext.baseCSSPrefix + 'translatable');
    }
    if (!wrapper.destroyed) {
      wrapper.removeCls(Ext.baseCSSPrefix + 'translatable-container');
      wrapper.un('painted', 'refresh', me);
    }
    delete me.wrapper;
    delete me._element;
  }
  me.callParent();
}});
Ext.define('Ext.util.translatable.ScrollParent', {extend:Ext.util.translatable.Dom, isScrollParent:true, applyElement:function(element) {
  var el = Ext.get(element);
  if (el) {
    this.parent = el.parent();
  }
  return el;
}, doTranslate:function(x, y) {
  var parent = this.parent;
  parent.setScrollLeft(Math.round(-x));
  parent.setScrollTop(Math.round(-y));
}, getPosition:function() {
  var me = this, position = me.position, parent = me.parent;
  position.x = parent.getScrollLeft();
  position.y = parent.getScrollTop();
  return position;
}});
Ext.define('Ext.util.translatable.CssPosition', {extend:Ext.util.translatable.Dom, doTranslate:function(x, y) {
  var domStyle = this.getElement().dom.style;
  if (typeof x == 'number') {
    domStyle.left = x + 'px';
  }
  if (typeof y == 'number') {
    domStyle.top = y + 'px';
  }
}, destroy:function() {
  var domStyle = this.getElement().dom.style;
  domStyle.left = null;
  domStyle.top = null;
  this.callParent();
}});
Ext.define('Ext.util.Translatable', {constructor:function(config) {
  var namespace = Ext.util.translatable;
  switch(Ext.browser.getPreferredTranslationMethod(config)) {
    case 'scrollposition':
      return new namespace.ScrollPosition(config);
    case 'scrollparent':
      return new namespace.ScrollParent(config);
    case 'csstransform':
      return new namespace.CssTransform(config);
    case 'cssposition':
      return new namespace.CssPosition(config);
  }
}});
Ext.define('Ext.scroll.Indicator', {extend:Ext.Widget, xtype:'scrollindicator', config:{axis:null, hideAnimation:true, hideDelay:0, scroller:null, minLength:24}, defaultHideAnimation:{to:{opacity:0}, duration:300}, names:{x:{side:'l', getSize:'getHeight', setLength:'setWidth', translate:'translateX'}, y:{side:'t', getSize:'getWidth', setLength:'setHeight', translate:'translateY'}}, oppositeAxis:{x:'y', y:'x'}, cls:Ext.baseCSSPrefix + 'scroll-indicator', applyHideAnimation:function(hideAnimation) {
  if (hideAnimation) {
    hideAnimation = Ext.mergeIf({onEnd:this.onHideAnimationEnd, scope:this}, this.defaultHideAnimation, hideAnimation);
  }
  return hideAnimation;
}, constructor:function(config) {
  var me = this, axis;
  me.callParent([config]);
  axis = me.getAxis();
  me.names = me.names[axis];
  me.element.addCls(me.cls + ' ' + me.cls + '-' + axis);
}, hide:function() {
  var me = this, delay = me.getHideDelay();
  if (delay) {
    me._hideTimer = Ext.defer(me.doHide, delay, me);
  } else {
    me.doHide();
  }
}, setValue:function(value) {
  var me = this, el = me.element, names = me.names, axis = me.getAxis(), scroller = me.getScroller(), maxScrollPosition = scroller.getMaxUserPosition()[axis], elementSize = scroller.getElementSize()[axis], baseLength = me.length, minLength = me.getMinLength(), length = baseLength, maxPosition = elementSize - baseLength - me.sizeAdjust, round = Math.round, max = Math.max, position;
  if (value < 0) {
    length = round(max(baseLength + baseLength * value / elementSize, minLength));
    position = 0;
  } else {
    if (value > maxScrollPosition) {
      length = round(max(baseLength - baseLength * (value - maxScrollPosition) / elementSize, minLength));
      position = maxPosition + baseLength - length;
    } else {
      position = round(value / maxScrollPosition * maxPosition);
    }
  }
  me[names.translate](position);
  el[names.setLength](length);
}, show:function() {
  var me = this, el = me.element, anim = el.getActiveAnimation();
  if (anim) {
    anim.end();
  }
  if (!me._inDom) {
    me.getScroller().getElement().appendChild(el);
    me._inDom = true;
    if (!me.size) {
      me.cacheStyles();
    }
  }
  me.refreshLength();
  clearTimeout(me._hideTimer);
  el.setStyle('opacity', '');
}, privates:{cacheStyles:function() {
  var me = this, el = me.element, names = me.names;
  me.size = el[names.getSize]();
  me.margin = el.getMargin(names.side);
}, doHide:function() {
  var animation = this.getHideAnimation(), el = this.element;
  if (animation) {
    el.animate(animation);
  } else {
    el.setStyle('opacity', 0);
  }
}, hasOpposite:function() {
  return this.getScroller().isAxisEnabled(this.oppositeAxis[this.getAxis()]);
}, onHideAnimationEnd:function() {
  this.element.setStyle('opacity', '0');
}, refreshLength:function() {
  var me = this, names = me.names, axis = me.getAxis(), scroller = me.getScroller(), scrollSize = scroller.getSize()[axis], elementSize = scroller.getElementSize()[axis], ratio = elementSize / scrollSize, baseSizeAdjust = me.margin * 2, sizeAdjust = me.hasOpposite() ? baseSizeAdjust + me.size : baseSizeAdjust, length = Math.max(Math.round((elementSize - sizeAdjust) * ratio), me.getMinLength());
  me.sizeAdjust = sizeAdjust;
  me.length = length;
  me.element[names.setLength](length);
}, translateX:function(value) {
  this.element.translate(value);
}, translateY:function(value) {
  this.element.translate(0, value);
}}});
Ext.define('Ext.scroll.TouchScroller', {extend:Ext.scroll.Scroller, alias:'scroller.touch', isTouchScroller:true, config:{autoRefresh:true, bounceEasing:{duration:400}, elementSize:undefined, indicators:true, fps:'auto', maxAbsoluteVelocity:6, momentumEasing:{momentum:{acceleration:30, friction:0.5}, bounce:{acceleration:30, springTension:0.3}, minVelocity:1}, outOfBoundRestrictFactor:0.5, innerElement:null, size:undefined, slotSnapEasing:{duration:150}, slotSnapOffset:{x:0, y:0}, startMomentumResetTime:300, 
translatable:{translationMethod:'auto', useWrapper:false}}, cls:Ext.baseCSSPrefix + 'scroll-container', scrollerCls:Ext.baseCSSPrefix + 'scroll-scroller', dragStartTime:0, dragEndTime:0, isDragging:false, isAnimating:false, isMouseEvent:{mousedown:1, mousemove:1, mouseup:1}, listenerMap:{touchstart:'onTouchStart', touchmove:'onTouchMove', dragstart:'onDragStart', drag:'onDrag', dragend:'onDragEnd'}, refreshCounter:0, constructor:function(config) {
  var me = this, onEvent = 'onEvent';
  me.elementListeners = {touchstart:onEvent, touchmove:onEvent, dragstart:onEvent, drag:onEvent, dragend:onEvent, scope:me};
  me.minPosition = {x:0, y:0};
  me.startPosition = {x:0, y:0};
  me.velocity = {x:0, y:0};
  me.isAxisEnabledFlags = {x:false, y:false};
  me.flickStartPosition = {x:0, y:0};
  me.flickStartTime = {x:0, y:0};
  me.lastDragPosition = {x:0, y:0};
  me.dragDirection = {x:0, y:0};
  me.callParent([config]);
  me.refreshAxes();
  me.scheduleRefresh = {idle:me.doRefresh, scope:me, single:true, destroyable:true};
}, applyBounceEasing:function(easing) {
  var defaultClass = Ext.fx.easing.EaseOut;
  return {x:Ext.factory(easing, defaultClass), y:Ext.factory(easing, defaultClass)};
}, applyElementSize:function(size) {
  var el = this.getElement(), dom, x, y;
  if (!el) {
    return null;
  }
  dom = el.dom;
  if (!dom) {
    return;
  }
  if (size == null) {
    x = dom.clientWidth;
    y = dom.clientHeight;
  } else {
    x = size.x;
    y = size.y;
  }
  return {x:x, y:y};
}, applyIndicators:function(indicators, oldIndicators) {
  var me = this, xIndicator, yIndicator, x, y;
  if (indicators) {
    if (indicators === true) {
      xIndicator = yIndicator = {};
    } else {
      x = indicators.x;
      y = indicators.y;
      if (x || y) {
        xIndicator = x == null || x === true ? {} : x;
        yIndicator = x == null || y === true ? {} : y;
      } else {
        xIndicator = yIndicator = indicators;
      }
    }
    if (oldIndicators) {
      if (xIndicator) {
        oldIndicators.x.setConfig(xIndicator);
      } else {
        oldIndicators.x.destroy();
        oldIndicators.x = null;
      }
      if (yIndicator) {
        oldIndicators.y.setConfig(yIndicator);
      } else {
        oldIndicators.y.destroy();
        oldIndicators.y = null;
      }
      indicators = oldIndicators;
    } else {
      indicators = {x:null, y:null};
      if (xIndicator) {
        indicators.x = new Ext.scroll.Indicator(Ext.applyIf({axis:'x', scroller:me}, xIndicator));
      }
      if (yIndicator) {
        indicators.y = new Ext.scroll.Indicator(Ext.applyIf({axis:'y', scroller:me}, yIndicator));
      }
    }
  } else {
    if (oldIndicators) {
      if (oldIndicators.x) {
        oldIndicators.x.destroy();
      }
      if (oldIndicators.y) {
        oldIndicators.y.destroy();
      }
      oldIndicators.x = oldIndicators.y = null;
    }
  }
  return indicators;
}, applyMomentumEasing:function(easing) {
  var defaultClass = Ext.fx.easing.BoundMomentum;
  return {x:Ext.factory(easing, defaultClass), y:Ext.factory(easing, defaultClass)};
}, applyInnerElement:function(innerElement) {
  if (innerElement && !innerElement.isElement) {
    innerElement = Ext.get(innerElement);
  }
  if (this.isConfiguring && !innerElement) {
    Ext.raise('Cannot create Ext.scroll.TouchScroller instance with null innerElement');
  }
  return innerElement;
}, applyMaxPosition:function(maxPosition, oldMaxPosition) {
  if (oldMaxPosition && maxPosition.x === oldMaxPosition.x && maxPosition.y === oldMaxPosition.y) {
    return;
  }
  var translatable = this.getTranslatable(), yEasing;
  if (translatable.isAnimating) {
    yEasing = translatable.activeEasingY;
    if (yEasing && yEasing.getStartVelocity && yEasing.getStartVelocity() < 0 && maxPosition.y < oldMaxPosition.y) {
      yEasing.setMinMomentumValue(-maxPosition.y);
    }
  }
  return maxPosition;
}, applyMaxUserPosition:function(maxUserPosition, oldMaxUserPosition) {
  if (oldMaxUserPosition && maxUserPosition.x === oldMaxUserPosition.x && maxUserPosition.y === oldMaxUserPosition.y) {
    return;
  }
  return maxUserPosition;
}, applySize:function(size) {
  var el = this.getElement(), dom, scrollerDom, x, y;
  if (typeof size === 'number') {
    x = size;
    y = size;
  } else {
    if (size) {
      x = size.x;
      y = size.y;
    }
  }
  if (el && (x == null || y == null)) {
    dom = el.dom;
    scrollerDom = this.getInnerElement().dom;
    if (x == null) {
      x = Math.max(scrollerDom.scrollWidth, dom.clientWidth);
    }
    if (y == null) {
      y = Math.max(scrollerDom.scrollHeight, dom.clientHeight);
    }
  }
  return {x:x, y:y};
}, applySlotSnapOffset:function(snapOffset) {
  if (typeof snapOffset === 'number') {
    snapOffset = {x:snapOffset, y:snapOffset};
  }
  return snapOffset;
}, applySlotSnapSize:function(snapSize) {
  if (typeof snapSize === 'number') {
    snapSize = {x:snapSize, y:snapSize};
  }
  return snapSize;
}, applySlotSnapEasing:function(easing) {
  var defaultClass = Ext.fx.easing.EaseOut;
  return {x:Ext.factory(easing, defaultClass), y:Ext.factory(easing, defaultClass)};
}, applyTranslatable:function(config, translatable) {
  return Ext.factory(config, Ext.util.Translatable, translatable);
}, destroy:function() {
  var me = this, element = me.getElement(), innerElement = me.getInnerElement(), sizeMonitors = me.sizeMonitors;
  if (sizeMonitors) {
    sizeMonitors.element.destroy();
    sizeMonitors.container.destroy();
  }
  if (element && !element.destroyed) {
    element.removeCls(me.cls);
  }
  if (innerElement && !innerElement.destroyed) {
    innerElement.removeCls(me.scrollerCls);
  }
  if (me._isWrapped) {
    if (!element.destroyed) {
      me.unwrapContent();
    }
    innerElement.destroy();
  }
  me.setElement(null);
  me.setInnerElement(null);
  me.setIndicators(null);
  Ext.destroy(me.getTranslatable());
  me.callParent();
}, refresh:function(immediate, options) {
  var me = this;
  ++me.refreshCounter;
  if (immediate) {
    me.doRefresh(options);
  } else {
    if (!me.refreshScheduled) {
      me.scheduleRefresh.args = [options];
      me.refreshScheduled = Ext.on(me.scheduleRefresh);
    }
  }
}, updateAutoRefresh:function(autoRefresh) {
  this.toggleResizeListeners(autoRefresh);
}, updateBounceEasing:function(easing) {
  this.getTranslatable().setEasingX(easing.x).setEasingY(easing.y);
}, updateElementSize:function() {
  if (!this.isConfiguring) {
    this.refreshAxes();
  }
}, updateDisabled:function(disabled) {
  if (!this.isConfiguring) {
    if (disabled) {
      this.detachListeners();
    } else {
      this.attachListeners();
    }
  }
}, updateElement:function(element, oldElement) {
  var me = this, innerElement = me.getInnerElement(), listeners, autoRefresh;
  if (!innerElement) {
    innerElement = element.dom.firstChild;
    if (!innerElement || innerElement.nodeType !== 1 || !Ext.fly(innerElement).hasCls(me.scrollerCls)) {
      innerElement = me.wrapContent(element);
    }
    me.setInnerElement(innerElement);
  }
  element.addCls(me.cls);
  if (me.isConfiguring) {
    if (!me.getTranslatable().isScrollParent) {
      element.dom.style.overflowX = element.dom.style.overflowY = '';
      listeners = me.elementListeners;
      listeners.mousewheel = 'onMouseWheel';
      listeners.scroll = {fn:'onElementScroll', delegated:false, scope:me};
    }
  }
  if (!me.getDisabled()) {
    me.attachListeners();
  }
  if (!me.isConfiguring) {
    autoRefresh = me.getAutoRefresh();
    if (autoRefresh !== false) {
      me.toggleResizeListeners(autoRefresh);
      if (autoRefresh) {
        me.refresh();
      } else {
        if (autoRefresh === null) {
          me.setElementSize(null);
        }
      }
    }
  }
}, updateFps:function(fps) {
  if (fps !== 'auto') {
    this.getTranslatable().setFps(fps);
  }
}, updateMaxUserPosition:function() {
  this.snapToBoundary();
}, updateMinUserPosition:function() {
  this.snapToBoundary();
}, updateInnerElement:function(innerElement) {
  if (innerElement) {
    innerElement.addCls(this.scrollerCls);
  }
  this.getTranslatable().setElement(innerElement);
}, updateSize:function(size) {
  if (!this.isConfiguring) {
    if (Ext.supports.touchScroll === 1) {
      this.callParent([size]);
    }
    this.refreshAxes();
  }
}, updateTranslatable:function(translatable) {
  translatable.setElement(this.getInnerElement());
  if (!translatable.isScrollParent) {
    translatable.on({animationframe:'onAnimationFrame', animationend:'onAnimationEnd', scope:this});
  }
}, updateX:function() {
  if (!this.isConfiguring) {
    this.refreshAxes();
  }
}, updateY:function() {
  if (!this.isConfiguring) {
    this.refreshAxes();
  }
}, privates:{attachListeners:function() {
  this.getElement().on(this.elementListeners);
}, constrainX:function(x) {
  return Math.min(this.getMaxPosition().x, Math.max(x, 0));
}, constrainY:function(y) {
  return Math.min(this.getMaxPosition().y, Math.max(y, 0));
}, convertEasingConfig:function(config) {
  return config;
}, detachListeners:function() {
  this.getElement().un(this.elementListeners);
}, doRefresh:function(options) {
  var me = this, size, elementSize;
  if (me.refreshScheduled) {
    me.refreshScheduled = me.refreshScheduled.destroy();
  }
  if (me.refreshCounter && me.getElement()) {
    me.stopAnimation();
    me.getTranslatable().refresh();
    if (options) {
      size = options.size;
      elementSize = options.elementSize;
    }
    me.setSize(size);
    me.setElementSize(elementSize);
    me.fireEvent('refresh', me);
    me.refreshCounter = 0;
  }
}, doScrollTo:function(x, y, animation, allowOverscroll) {
  var me = this, isDragging = me.isDragging, DOMScrolling = me.getTranslatable().isScrollParent, fireStartEnd = !me.isReflecting && !DOMScrolling;
  if (me.destroyed || !me.getElement()) {
    return me;
  }
  allowOverscroll = allowOverscroll || me.isDragging;
  var translatable = me.getTranslatable(), position = me.position, positionChanged = false, translationX, translationY;
  if (!isDragging || me.isAxisEnabled('x')) {
    if (isNaN(x) || typeof x !== 'number') {
      x = position.x;
    } else {
      if (!allowOverscroll) {
        x = me.constrainX(x);
      }
      if (position.x !== x) {
        position.x = x;
        positionChanged = true;
      }
    }
    translationX = me.convertX(-x);
  }
  if (!isDragging || me.isAxisEnabled('y')) {
    if (isNaN(y) || typeof y !== 'number') {
      y = position.y;
    } else {
      if (!allowOverscroll) {
        y = me.constrainY(y);
      }
      if (position.y !== y) {
        position.y = y;
        positionChanged = true;
      }
    }
    translationY = -y;
  }
  if (positionChanged) {
    if (fireStartEnd) {
      me.onScrollStart();
    }
    if (animation) {
      translatable.translateAnimated(translationX, translationY, animation);
    } else {
      if (!DOMScrolling) {
        me.onScroll();
      }
      translatable.translate(translationX, translationY);
      if (fireStartEnd) {
        me.onScrollEnd();
      }
    }
  } else {
    if (animation && animation.callback) {
      animation.callback();
    }
  }
  return me;
}, getAnimationEasing:function(axis, e) {
  if (!this.isAxisEnabled(axis)) {
    return null;
  }
  var me = this, currentPosition = me.position[axis], minPosition = me.getMinUserPosition()[axis], maxPosition = me.getMaxUserPosition()[axis], maxAbsVelocity = me.getMaxAbsoluteVelocity(), boundValue = null, dragEndTime = me.dragEndTime, velocity = e.flick.velocity[axis], isX = axis === 'x', easingConfig, easing;
  if (currentPosition < minPosition) {
    boundValue = minPosition;
  } else {
    if (currentPosition > maxPosition) {
      boundValue = maxPosition;
    }
  }
  if (isX) {
    currentPosition = me.convertX(currentPosition);
    boundValue = me.convertX(boundValue);
  }
  if (boundValue !== null) {
    easing = me.getBounceEasing()[axis];
    easing.setConfig({startTime:dragEndTime, startValue:-currentPosition, endValue:-boundValue});
    return easing;
  }
  if (velocity === 0) {
    return null;
  }
  if (velocity < -maxAbsVelocity) {
    velocity = -maxAbsVelocity;
  } else {
    if (velocity > maxAbsVelocity) {
      velocity = maxAbsVelocity;
    }
  }
  easing = me.getMomentumEasing()[axis];
  easingConfig = {startTime:dragEndTime, startValue:-currentPosition, startVelocity:velocity * 1.5, minMomentumValue:-maxPosition, maxMomentumValue:0};
  if (isX) {
    me.convertEasingConfig(easingConfig);
  }
  easing.setConfig(easingConfig);
  return easing;
}, getSnapPosition:function(axis) {
  var me = this, snapSize = me.getSlotSnapSize()[axis], snapPosition = null, position, snapOffset, maxPosition, mod;
  if (snapSize !== 0 && me.isAxisEnabled(axis)) {
    position = me.position[axis];
    snapOffset = me.getSlotSnapOffset()[axis];
    maxPosition = me.getMaxUserPosition()[axis];
    mod = Math.floor((position - snapOffset) % snapSize);
    if (mod !== 0) {
      if (position !== maxPosition) {
        if (Math.abs(mod) > snapSize / 2) {
          snapPosition = Math.min(maxPosition, position + (mod > 0 ? snapSize - mod : mod - snapSize));
        } else {
          snapPosition = position - mod;
        }
      } else {
        snapPosition = position - mod;
      }
    }
  }
  return snapPosition;
}, hideIndicators:function() {
  var me = this, indicators = me.getIndicators(), xIndicator, yIndicator;
  if (indicators) {
    if (me.isAxisEnabled('x')) {
      xIndicator = indicators.x;
      if (xIndicator) {
        xIndicator.hide();
      }
    }
    if (me.isAxisEnabled('y')) {
      yIndicator = indicators.y;
      if (yIndicator) {
        yIndicator.hide();
      }
    }
  }
}, isAxisEnabled:function(axis) {
  this.getX();
  this.getY();
  return this.isAxisEnabledFlags[axis];
}, onAnimationEnd:function() {
  this.snapToBoundary();
  this.onScrollEnd();
}, onAnimationFrame:function(translatable, x, y) {
  var position = this.position;
  position.x = this.convertX(-x);
  position.y = -y;
  this.onScroll();
}, onAxisDrag:function(axis, delta) {
  if (delta && this.isAxisEnabled(axis)) {
    var me = this, flickStartPosition = me.flickStartPosition, flickStartTime = me.flickStartTime, lastDragPosition = me.lastDragPosition, dragDirection = me.dragDirection, old = me.position[axis], min = me.getMinUserPosition()[axis], max = me.getMaxUserPosition()[axis], start = me.startPosition[axis], last = lastDragPosition[axis], current = start - delta, lastDirection = dragDirection[axis], restrictFactor = me.getOutOfBoundRestrictFactor(), startMomentumResetTime = me.getStartMomentumResetTime(), 
    now = Ext.Date.now(), distance;
    if (current < min) {
      current *= restrictFactor;
    } else {
      if (current > max) {
        distance = current - max;
        current = max + distance * restrictFactor;
      }
    }
    if (current > last) {
      dragDirection[axis] = 1;
    } else {
      if (current < last) {
        dragDirection[axis] = -1;
      }
    }
    if (lastDirection !== 0 && dragDirection[axis] !== lastDirection || now - flickStartTime[axis] > startMomentumResetTime) {
      flickStartPosition[axis] = old;
      flickStartTime[axis] = now;
    }
    lastDragPosition[axis] = current;
    return true;
  }
}, onDomScroll:function() {
  var me = this, dom, position;
  if (me.getTranslatable().isScrollParent) {
    dom = me.getElement().dom;
    position = me.position;
    position.x = dom.scrollLeft;
    position.y = dom.scrollTop;
  }
  me.callParent();
}, onDrag:function(e) {
  var me = this, lastDragPosition = me.lastDragPosition;
  if (!me.isDragging) {
    return;
  }
  if (me.onAxisDrag('x', me.convertX(e.deltaX)) | me.onAxisDrag('y', e.deltaY)) {
    me.doScrollTo(lastDragPosition.x, lastDragPosition.y);
  }
}, onDragEnd:function(e) {
  var me = this, easingX, easingY;
  if (!me.isDragging) {
    return;
  }
  me.dragEndTime = Ext.Date.now();
  me.onDrag(e);
  me.isDragging = false;
  easingX = me.getAnimationEasing('x', e);
  easingY = me.getAnimationEasing('y', e);
  if (easingX || easingY) {
    me.getTranslatable().animate(easingX, easingY);
  } else {
    me.onScrollEnd();
  }
}, onDragStart:function(e) {
  var me = this, direction = me.getDirection(), absDeltaX = e.absDeltaX, absDeltaY = e.absDeltaY, directionLock = me.getDirectionLock(), startPosition = me.startPosition, flickStartPosition = me.flickStartPosition, flickStartTime = me.flickStartTime, lastDragPosition = me.lastDragPosition, currentPosition = me.position, dragDirection = me.dragDirection, x = currentPosition.x, y = currentPosition.y, now = Ext.Date.now();
  if (directionLock && direction !== 'both') {
    if (direction === 'horizontal' && absDeltaX > absDeltaY || direction === 'vertical' && absDeltaY > absDeltaX) {
      e.stopPropagation();
    } else {
      return;
    }
  }
  lastDragPosition.x = x;
  lastDragPosition.y = y;
  flickStartPosition.x = x;
  flickStartPosition.y = y;
  startPosition.x = x;
  startPosition.y = y;
  flickStartTime.x = now;
  flickStartTime.y = now;
  dragDirection.x = 0;
  dragDirection.y = 0;
  me.dragStartTime = now;
  me.isDragging = true;
  if (!me.isScrolling) {
    me.onScrollStart();
  }
}, onElementResize:function(element, info) {
  this.refresh(true, {elementSize:{x:info.contentWidth, y:info.contentHeight}, size:this.getAutoRefresh() ? null : this.getSize()});
}, onElementScroll:function(event, targetEl) {
  targetEl.scrollTop = targetEl.scrollLeft = 0;
}, onEvent:function(e) {
  var me = this, browserEvent = e.browserEvent;
  if ((!me.self.isTouching || me.isTouching) && (!me.getTranslatable().isScrollParent || !me.isMouseEvent[browserEvent.type] && browserEvent.pointerType !== 'mouse') && (me.getY() || me.getX())) {
    me[me.listenerMap[e.type]](e);
  }
}, onInnerElementResize:function(element, info) {
  this.refresh(true, {size:{x:info.width, y:info.height}});
}, onMouseWheel:function(e) {
  var me = this, delta = e.getWheelDeltas(), deltaX = -delta.x, deltaY = -delta.y, position = me.position, maxPosition = me.getMaxUserPosition(), minPosition = me.getMinUserPosition(), max = Math.max, min = Math.min, positionX = max(min(position.x + deltaX, maxPosition.x), minPosition.x), positionY = max(min(position.y + deltaY, maxPosition.y), minPosition.y);
  deltaX = positionX - position.x;
  deltaY = positionY - position.y;
  if (!deltaX && !deltaY) {
    return;
  }
  e.stopEvent();
  me.onScrollStart();
  me.scrollBy(deltaX, deltaY);
  me.onScroll();
  me.onScrollEnd();
}, onPartnerScrollEnd:function(x, y) {
  var me = this;
  if (!me.getTranslatable().isScrollParent) {
    me.fireScrollEnd(x, y);
  }
  me.callParent([x, y]);
  me.isScrolling = false;
  me.hideIndicators();
}, onPartnerScrollStart:function(x, y) {
  var me = this;
  me.isScrolling = true;
  if (!me.getTranslatable().isScrollParent) {
    me.fireScrollStart(x, y);
  }
  me.showIndicators();
}, onScroll:function() {
  var me = this, position = me.position, x = position.x, y = position.y, indicators = me.getIndicators(), xIndicator, yIndicator;
  if (indicators) {
    if (me.isAxisEnabled('x')) {
      xIndicator = indicators.x;
      if (xIndicator) {
        xIndicator.setValue(x);
      }
    }
    if (me.isAxisEnabled('y')) {
      yIndicator = indicators.y;
      if (yIndicator) {
        yIndicator.setValue(y);
      }
    }
  }
  me.fireScroll(x, y);
}, onScrollEnd:function() {
  var me = this, position = me.position;
  if (me.isScrolling && !me.isTouching && !me.snapToSlot()) {
    me.hideIndicators();
    me.isScrolling = Ext.isScrolling = false;
    me.fireScrollEnd(position.x, position.y);
  }
}, onScrollStart:function() {
  var me = this, position = me.position;
  if (!me.isScrolling) {
    me.showIndicators();
    me.isScrolling = Ext.isScrolling = true;
    me.fireScrollStart(position.x, position.y);
  }
}, onTouchEnd:function() {
  var me = this;
  me.isTouching = me.self.isTouching = false;
  if (!me.isDragging && me.snapToSlot()) {
    me.onScrollStart();
  }
}, onTouchMove:function(e) {
  e.preventDefault();
}, onTouchStart:function() {
  var me = this;
  me.isTouching = me.self.isTouching = true;
  Ext.getDoc().on({touchend:'onTouchEnd', scope:me, single:true});
  me.stopAnimation();
}, refreshAxes:function() {
  var me = this, flags = me.isAxisEnabledFlags, size = me.getSize(), elementSize = me.getElementSize(), indicators = me.getIndicators(), maxX, maxY, x, y, xIndicator, yIndicator;
  if (!size || !elementSize) {
    return;
  }
  maxX = Math.max(0, size.x - elementSize.x);
  maxY = Math.max(0, size.y - elementSize.y);
  x = me.getX();
  y = me.getY();
  me.setMaxPosition({x:maxX, y:maxY});
  if (x === true || x === 'auto') {
    flags.x = !!maxX;
  } else {
    if (x === false) {
      flags.x = false;
      xIndicator = indicators && indicators.x;
      if (xIndicator) {
        xIndicator.hide();
      }
    } else {
      if (x === 'scroll') {
        flags.x = true;
      }
    }
  }
  if (y === true || y === 'auto') {
    flags.y = !!maxY;
  } else {
    if (y === false) {
      flags.y = false;
      yIndicator = indicators && indicators.y;
      if (yIndicator) {
        yIndicator.hide();
      }
    } else {
      if (y === 'scroll') {
        flags.y = true;
      }
    }
  }
  me.setMaxUserPosition({x:flags.x ? maxX : 0, y:flags.y ? maxY : 0});
  if (Ext.supports.touchScroll === 1) {
    me.initXStyle();
    me.initYStyle();
  }
}, showIndicators:function() {
  var me = this, indicators = me.getIndicators(), xIndicator, yIndicator;
  if (indicators) {
    if (me.isAxisEnabled('x')) {
      xIndicator = indicators.x;
      if (xIndicator) {
        xIndicator.show();
      }
    }
    if (me.isAxisEnabled('y')) {
      yIndicator = indicators.y;
      if (yIndicator) {
        yIndicator.show();
      }
    }
  }
}, snapToBoundary:function() {
  var me = this, position = me.getPosition();
  if (me.isConfiguring || !(position.x || position.y)) {
    return;
  }
  var minPosition = me.getMinUserPosition(), maxPosition = me.getMaxUserPosition(), minX = minPosition.x, minY = minPosition.y, maxX = maxPosition.x, maxY = maxPosition.y, x = Math.round(position.x), y = Math.round(position.y);
  if (x < minX) {
    x = minX;
  } else {
    if (x > maxX) {
      x = maxX;
    }
  }
  if (y < minY) {
    y = minY;
  } else {
    if (y > maxY) {
      y = maxY;
    }
  }
  me.doScrollTo(x, y);
}, snapToSlot:function() {
  var me = this, snapX = me.getSnapPosition('x'), snapY = me.getSnapPosition('y'), easing = me.getSlotSnapEasing();
  if (snapX !== null || snapY !== null) {
    me.doScrollTo(snapX, snapY, {easingX:easing.x, easingY:easing.y});
    return true;
  }
  return false;
}, stopAnimation:function() {
  this.getTranslatable().stopAnimation();
}, toggleResizeListeners:function(autoRefresh) {
  var me = this, element = me.getElement(), method, innerMethod, innerElement;
  if (element) {
    innerElement = me.getInnerElement();
    if (autoRefresh) {
      method = innerMethod = 'on';
    } else {
      if (autoRefresh === null) {
        method = 'on';
        innerMethod = 'un';
      } else {
        method = innerMethod = 'un';
      }
    }
    element[method]('resize', 'onElementResize', me);
    innerElement[innerMethod]('resize', 'onInnerElementResize', me);
  }
}, unwrapContent:function() {
  var innerDom = this.getInnerElement().dom, dom = this.getElement().dom, child;
  while (child = innerDom.firstChild) {
    dom.insertBefore(child, innerDom);
  }
}, wrapContent:function(element) {
  var wrap = document.createElement('div'), dom = element.dom, child;
  while (child = dom.lastChild) {
    wrap.insertBefore(child, wrap.firstChild);
  }
  dom.appendChild(wrap);
  this.setInnerElement(wrap);
  this._isWrapped = true;
  return this.getInnerElement();
}}});
Ext.define('Ext.scroll.DomScroller', {extend:Ext.scroll.Scroller, alias:'scroller.dom', isDomScroller:true, getMaxPosition:function() {
  var element = this.getElement(), x = 0, y = 0, dom;
  if (element && !element.destroyed) {
    dom = element.dom;
    x = dom.scrollWidth - dom.clientWidth;
    y = dom.scrollHeight - dom.clientHeight;
  }
  return {x:x, y:y};
}, getMaxUserPosition:function() {
  var me = this, element = me.getElement(), x = 0, y = 0, dom;
  if (element && !element.destroyed) {
    dom = element.dom;
    if (me.getX()) {
      x = dom.scrollWidth - dom.clientWidth;
    }
    if (me.getY()) {
      y = dom.scrollHeight - dom.clientHeight;
    }
  }
  return {x:x, y:y};
}, getPosition:function() {
  var me = this;
  if (me.positionDirty) {
    me.updateDomScrollPosition();
  }
  return me.position;
}, getSize:function() {
  var element = this.getElement(), size, dom;
  if (element && !element.destroyed) {
    dom = element.dom;
    size = {x:dom.scrollWidth, y:dom.scrollHeight};
  } else {
    size = {x:0, y:0};
  }
  return size;
}, updateElement:function(element, oldElement) {
  this.initXStyle();
  this.initYStyle();
}, updateX:function(x) {
  this.initXStyle();
}, updateY:function(y) {
  this.initYStyle();
}, privates:{doScrollTo:function(x, y, animate) {
  var me = this, element = me.getElement(), maxPosition, dom, to, xInf, yInf, i;
  if (element && !element.destroyed) {
    dom = element.dom;
    xInf = x === Infinity;
    yInf = y === Infinity;
    if (xInf || yInf) {
      maxPosition = me.getMaxPosition();
      if (xInf) {
        x = maxPosition.x;
      }
      if (yInf) {
        y = maxPosition.y;
      }
    }
    x = me.convertX(x);
    if (animate) {
      to = {};
      if (y != null) {
        to.scrollTop = y;
      }
      if (x != null) {
        to.scrollLeft = x;
      }
      element.animate(Ext.mergeIf({to:{scrollTop:y, scrollLeft:x}}, animate));
    } else {
      if (y != null) {
        dom.scrollTop = y;
      }
      if (x != null) {
        dom.scrollLeft = x;
        if (Ext.isIE8) {
          i = dom.scrollLeft;
          dom.scrollLeft = x;
        }
      }
    }
    me.positionDirty = true;
  }
}, getElementScroll:function(element) {
  return element.getScroll();
}, stopAnimation:function() {
  var anim = this.getElement().getActiveAnimation();
  if (anim) {
    anim.end();
  }
}}}, function(DomScroller) {
  Ext.onDocumentReady(function() {
    DomScroller.document = new DomScroller({x:true, y:true, element:document.body});
  });
});
Ext.define('Ext.overrides.scroll.DomScroller', {override:'Ext.scroll.DomScroller', _scrollerCls:Ext.baseCSSPrefix + 'domscroller', updateElement:function(element, oldElement) {
  element.addCls(this._scrollerCls);
  this.callParent([element, oldElement]);
}});
Ext.define('Ext.behavior.Behavior', {constructor:function(component) {
  this.component = component;
  component.on('destroy', 'onComponentDestroy', this);
}, onComponentDestroy:Ext.emptyFn});
Ext.define('Ext.behavior.Translatable', {extend:Ext.behavior.Behavior, setConfig:function(config) {
  var translatable = this.translatable, component = this.component;
  if (config) {
    if (!translatable) {
      this.translatable = translatable = new Ext.util.Translatable(config);
      translatable.setElement(component.renderElement);
      translatable.on('destroy', 'onTranslatableDestroy', this);
    } else {
      if (Ext.isObject(config)) {
        translatable.setConfig(config);
      }
    }
  } else {
    if (translatable) {
      translatable.destroy();
    }
  }
  return this;
}, getTranslatable:function() {
  return this.translatable;
}, onTranslatableDestroy:function() {
  delete this.translatable;
}, onComponentDestroy:function() {
  var translatable = this.translatable;
  if (translatable) {
    translatable.destroy();
  }
}});
Ext.define('Ext.util.Draggable', {isDraggable:true, mixins:[Ext.mixin.Observable], config:{cls:Ext.baseCSSPrefix + 'draggable', draggingCls:Ext.baseCSSPrefix + 'dragging', element:null, constraint:'container', disabled:null, direction:'both', initialOffset:{x:0, y:0}, translatable:{}}, DIRECTION_BOTH:'both', DIRECTION_VERTICAL:'vertical', DIRECTION_HORIZONTAL:'horizontal', defaultConstraint:{min:{x:-Infinity, y:-Infinity}, max:{x:Infinity, y:Infinity}}, containerWidth:0, containerHeight:0, width:0, 
height:0, constructor:function(config) {
  var element;
  this.extraConstraint = {};
  this.initialConfig = config;
  this.offset = {x:0, y:0};
  this.elementListeners = {dragstart:'onDragStart', drag:'onDrag', dragend:'onDragEnd', resize:'onElementResize', touchstart:'onPress', touchend:'onRelease', scope:this};
  if (config && config.element) {
    element = config.element;
    delete config.element;
    this.setElement(element);
  }
  return this;
}, applyElement:function(element) {
  if (!element) {
    return;
  }
  return Ext.get(element);
}, updateElement:function(element) {
  element.on(this.elementListeners);
  this.mixins.observable.constructor.call(this, this.initialConfig);
}, updateInitialOffset:function(initialOffset) {
  if (typeof initialOffset == 'number') {
    initialOffset = {x:initialOffset, y:initialOffset};
  }
  var offset = this.offset, x, y;
  offset.x = x = initialOffset.x;
  offset.y = y = initialOffset.y;
  this.getTranslatable().translate(x, y);
}, updateCls:function(cls) {
  this.getElement().addCls(cls);
}, applyTranslatable:function(translatable, currentInstance) {
  translatable = Ext.factory(translatable, Ext.util.Translatable, currentInstance);
  if (translatable) {
    translatable.setElement(this.getElement());
  }
  return translatable;
}, setExtraConstraint:function(constraint) {
  this.extraConstraint = constraint || {};
  this.refreshConstraint();
  return this;
}, addExtraConstraint:function(constraint) {
  Ext.merge(this.extraConstraint, constraint);
  this.refreshConstraint();
  return this;
}, applyConstraint:function(newConstraint) {
  this.currentConstraint = newConstraint;
  if (!newConstraint) {
    newConstraint = this.defaultConstraint;
  }
  if (newConstraint === 'container') {
    return Ext.merge(this.getContainerConstraint(), this.extraConstraint);
  }
  return Ext.merge({}, this.extraConstraint, newConstraint);
}, updateConstraint:function() {
  this.refreshOffset();
}, getContainerConstraint:function() {
  var container = this.getContainer(), element = this.getElement();
  if (!container || !element.dom) {
    return this.defaultConstraint;
  }
  return {min:{x:0, y:0}, max:{x:this.containerWidth - this.width, y:this.containerHeight - this.height}};
}, getContainer:function() {
  var container = this.container;
  if (!container) {
    container = this.getElement().getParent();
    if (container) {
      this.container = container;
      container.on({resize:'onContainerResize', destroy:'onContainerDestroy', scope:this});
    }
  }
  return container;
}, onElementResize:function(element, info) {
  this.width = info.width;
  this.height = info.height;
  this.refresh();
}, onContainerResize:function(container, info) {
  this.containerWidth = info.width;
  this.containerHeight = info.height;
  this.refresh();
}, onContainerDestroy:function() {
  delete this.container;
  delete this.containerSizeMonitor;
}, detachListeners:function() {
  this.getElement().un(this.elementListeners);
}, isAxisEnabled:function(axis) {
  var direction = this.getDirection();
  if (axis === 'x') {
    return direction === this.DIRECTION_BOTH || direction === this.DIRECTION_HORIZONTAL;
  }
  return direction === this.DIRECTION_BOTH || direction === this.DIRECTION_VERTICAL;
}, onPress:function(e) {
  this.fireEvent('touchstart', this, e);
}, onRelease:function(e) {
  this.fireEvent('touchend', this, e);
}, onDragStart:function(e) {
  var me = this, offset = me.offset;
  if (me.getDisabled()) {
    return false;
  }
  me.fireEventedAction('dragstart', [me, e, offset.x, offset.y], me.initDragStart, me);
}, initDragStart:function(me, e, offsetX, offsetY) {
  this.dragStartOffset = {x:offsetX, y:offsetY};
  this.isDragging = true;
  this.getElement().addCls(this.getDraggingCls());
}, onDrag:function(e) {
  if (!this.isDragging) {
    return;
  }
  var startOffset = this.dragStartOffset;
  this.fireAction('drag', [this, e, startOffset.x + e.deltaX, startOffset.y + e.deltaY], this.doDrag);
}, doDrag:function(me, e, offsetX, offsetY) {
  me.setOffset(offsetX, offsetY);
}, onDragEnd:function(e) {
  if (!this.isDragging) {
    return;
  }
  this.onDrag(e);
  this.isDragging = false;
  this.getElement().removeCls(this.getDraggingCls());
  this.fireEvent('dragend', this, e, this.offset.x, this.offset.y);
}, setOffset:function(x, y, animation) {
  var currentOffset = this.offset, constraint = this.getConstraint(), minOffset = constraint.min, maxOffset = constraint.max, min = Math.min, max = Math.max;
  if (this.isAxisEnabled('x') && typeof x == 'number') {
    x = min(max(x, minOffset.x), maxOffset.x);
  } else {
    x = currentOffset.x;
  }
  if (this.isAxisEnabled('y') && typeof y == 'number') {
    y = min(max(y, minOffset.y), maxOffset.y);
  } else {
    y = currentOffset.y;
  }
  currentOffset.x = x;
  currentOffset.y = y;
  this.getTranslatable().translate(x, y, animation);
}, getOffset:function() {
  return this.offset;
}, refreshConstraint:function() {
  this.setConstraint(this.currentConstraint);
}, refreshOffset:function() {
  var offset = this.offset;
  this.setOffset(offset.x, offset.y);
}, refresh:function() {
  this.refreshConstraint();
  this.getTranslatable().refresh();
  this.refreshOffset();
}, enable:function() {
  return this.setDisabled(false);
}, disable:function() {
  return this.setDisabled(true);
}, destroy:function() {
  var me = this, translatable = me.getTranslatable();
  var element = me.getElement();
  if (element && !element.destroyed) {
    element.removeCls(me.getCls());
  }
  me.detachListeners();
  if (translatable) {
    translatable.destroy();
  }
  me.callParent();
}});
Ext.define('Ext.behavior.Draggable', {extend:Ext.behavior.Behavior, setConfig:function(config) {
  var draggable = this.draggable, component = this.component, listeners = this.listeners;
  if (config) {
    if (!draggable) {
      component.setTranslatable(config.translatable);
      this.draggable = draggable = new Ext.util.Draggable(config);
      draggable.setTranslatable(component.getTranslatable());
      draggable.setElement(component.renderElement);
      draggable.on('destroy', 'onDraggableDestroy', this);
      if (listeners) {
        component.on(listeners);
      }
    } else {
      if (Ext.isObject(config)) {
        draggable.setConfig(config);
      }
    }
  } else {
    if (draggable) {
      draggable.destroy();
    }
  }
  return this;
}, getDraggable:function() {
  return this.draggable;
}, onDraggableDestroy:function() {
  delete this.draggable;
}, onComponentDestroy:function() {
  var draggable = this.draggable;
  if (draggable) {
    draggable.destroy();
  }
}});
Ext.define('Ext.Component', {extend:Ext.Widget, alternateClassName:'Ext.lib.Component', mixins:[Ext.mixin.Traversable], xtype:'component', cachedConfig:{baseCls:null, cls:null, floatingCls:Ext.baseCSSPrefix + 'floating', hiddenCls:Ext.baseCSSPrefix + 'item-hidden', ui:null, margin:null, padding:null, border:null, styleHtmlCls:Ext.baseCSSPrefix + 'html', styleHtmlContent:null}, eventedConfig:{left:null, top:null, right:null, bottom:null, minWidth:null, minHeight:null, maxWidth:null, maxHeight:null, 
scrollable:null, docked:null, centered:null, hidden:null, disabled:null}, config:{html:null, draggable:null, translatable:null, renderTo:null, zIndex:null, tpl:null, enterAnimation:null, exitAnimation:null, showAnimation:null, hideAnimation:null, tplWriteMode:'overwrite', data:null, disabledCls:Ext.baseCSSPrefix + 'item-disabled', contentEl:null, record:null, plugins:null, useBodyElement:null}, defaultBindProperty:'html', alignmentRegex:/^([a-z]+)-([a-z]+)(\?)?$/, isComponent:true, floating:false, 
rendered:false, isInner:true, activeAnimation:null, dockPositions:{top:true, right:true, bottom:true, left:true}, innerElement:null, element:{reference:'element', classList:['x-unsized']}, widthLayoutSized:false, heightLayoutSized:false, layoutStretched:false, sizeState:false, sizeFlags:0, LAYOUT_WIDTH:1, LAYOUT_HEIGHT:2, LAYOUT_BOTH:3, LAYOUT_STRETCHED:4, _scrollableCfg:{x:{x:true, y:false}, y:{x:false, y:true}, horizontal:{x:true, y:false}, vertical:{x:false, y:true}, both:{x:true, y:true}, 'true':{x:true, 
y:true}}, statics:{fromElement:function(node, limit, selector) {
  return Ext.ComponentManager.fromElement(node, limit, selector);
}}, initialConfig:null, $initParent:null, constructor:function(config) {
  var me = this, plugins = config && config.plugins, responsive = 'responsive', i, p;
  me.onInitializedListeners = [];
  if (config) {
    me.initialConfig = config;
    me.$initParent = config.$initParent;
  }
  if (plugins) {
    plugins = Ext.Array.from(plugins);
    for (i = plugins.length; i-- > 0;) {
      p = plugins[i];
      if (p === responsive || p.type === responsive) {
        me.initialConfig = config = Ext.apply({}, config);
        config.plugins = plugins = plugins.slice(0);
        plugins[i] = me.createPlugin(p);
        config = me.initialConfig;
        break;
      }
    }
  }
  me.callParent([config]);
  me.refreshSizeState = me.doRefreshSizeState;
  me.refreshFloating = me.doRefreshFloating;
  if (me.refreshSizeStateOnInitialized) {
    me.refreshSizeState();
  }
  if (me.refreshFloatingOnInitialized) {
    me.refreshFloating();
  }
  me.initialize();
  me.triggerInitialized();
  if (me.fullscreen) {
    me.fireEvent('fullscreen', me);
  }
  me.fireEvent('initialize', me);
}, beforeInitConfig:function(config) {
  this.beforeInitialize.apply(this, arguments);
}, beforeInitialize:Ext.emptyFn, initialize:Ext.emptyFn, triggerInitialized:function() {
  var listeners = this.onInitializedListeners, ln = listeners.length, listener, fn, scope, args, i;
  if (!this.initialized) {
    this.initialized = true;
    if (ln > 0) {
      for (i = 0; i < ln; i++) {
        listener = listeners[i];
        fn = listener.fn;
        scope = listener.scope;
        args = listener.args;
        if (typeof fn == 'string') {
          scope[fn].apply(scope, args);
        } else {
          fn.apply(scope, args);
        }
      }
      listeners.length = 0;
    }
  }
}, onInitialized:function(fn, scope, args) {
  var listeners = this.onInitializedListeners;
  if (!scope) {
    scope = this;
  }
  if (this.initialized) {
    if (typeof fn == 'string') {
      scope[fn].apply(scope, args);
    } else {
      fn.apply(scope, args);
    }
  } else {
    listeners.push({fn:fn, scope:scope, args:args});
  }
}, initElement:function() {
  var me = this;
  me.callParent();
  if (!me.innerElement) {
    me.innerElement = me.element;
  }
  if (!me.bodyElement) {
    me.bodyElement = me.innerElement;
  }
}, applyPlugins:function(plugins) {
  var me = this, config, ln, i, plugin;
  if (!plugins) {
    return plugins;
  }
  plugins = [].concat(plugins);
  for (i = 0, ln = plugins.length; i < ln; i++) {
    plugins[i] = me.createPlugin(plugins[i]);
  }
  return plugins;
}, createPlugin:function(config) {
  if (typeof config === 'string') {
    config = {type:config};
  }
  var ret = config;
  if (!config.isInstance) {
    config.cmp = this;
    ret = Ext.factory(config, null, null, 'plugin');
    delete config.cmp;
  }
  if (ret.setCmp) {
    ret.setCmp(this);
  }
  return ret;
}, updatePlugins:function(newPlugins, oldPlugins) {
  var ln, i;
  if (newPlugins) {
    for (i = 0, ln = newPlugins.length; i < ln; i++) {
      newPlugins[i].init(this);
    }
  }
  if (oldPlugins) {
    for (i = 0, ln = oldPlugins.length; i < ln; i++) {
      Ext.destroy(oldPlugins[i]);
    }
  }
}, applyScrollable:function(scrollable, oldScrollable) {
  var me = this, bodyElement, touchScroll, x, y, scrollableCfg;
  if (scrollable) {
    if (scrollable === true || typeof scrollable === 'string') {
      scrollableCfg = me._scrollableCfg[scrollable];
      if (!scrollableCfg) {
        Ext.raise("'" + scrollable + "'is not a valid value for 'scrollable'");
      }
      scrollable = scrollableCfg;
    }
    if (oldScrollable) {
      oldScrollable.setConfig(scrollable);
      scrollable = oldScrollable;
    } else {
      touchScroll = Ext.supports.touchScroll;
      if (touchScroll && !scrollable.translatable) {
        scrollable.translatable = {translationMethod:touchScroll === 1 ? 'scrollparent' : 'csstransform'};
      }
      if (touchScroll === 1) {
        scrollable = Ext.Object.chain(scrollable);
        scrollable.indicators = false;
      }
      scrollable = Ext.scroll.Scroller.create(scrollable);
      scrollable.component = me;
      me.setUseBodyElement(true);
      bodyElement = me.bodyElement;
      if (touchScroll === 2) {
        scrollable.setInnerElement(me.innerElement);
        scrollable.setElement(bodyElement);
      } else {
        if (touchScroll === 1) {
          x = scrollable.getX();
          y = scrollable.getY();
          bodyElement.setStyle({overflowX:x === true ? 'auto' : !x ? 'hidden' : x, overflowY:y === true ? 'auto' : !y ? 'hidden' : y});
          bodyElement.disableTouchScroll();
        }
        scrollable.setElement(bodyElement);
      }
      if (me.isPainted()) {
        me.onPainted();
      }
      me.on('painted', 'onPainted', me);
    }
  }
  return scrollable;
}, onPainted:function() {
  var scrollable = this.getScrollable();
  if (scrollable && scrollable.isTouchScroller && scrollable.getAutoRefresh()) {
    scrollable.refresh();
  }
}, updateRenderTo:function(newContainer) {
  this.renderTo(newContainer);
}, updateBorder:function(border) {
  this.element.setStyle('border-width', border ? '' : '0');
}, updatePadding:function(padding) {
  this.innerElement.setPadding(padding);
}, updateMargin:function(margin) {
  this.element.setMargin(margin);
}, updateUi:function(newUi, oldUi) {
  var baseCls = this.getBaseCls(), element = this.element, currentUi = this.currentUi;
  if (baseCls) {
    if (oldUi) {
      if (currentUi) {
        element.removeCls(currentUi);
      } else {
        element.removeCls(baseCls + '-' + oldUi);
      }
    }
    if (newUi) {
      element.addCls(newUi, baseCls);
      this.currentUi = baseCls + '-' + newUi;
      if (!this.self.prototype.currentUi) {
        this.self.prototype.currentUi = this.currentUi;
      }
    }
  }
}, applyBaseCls:function(baseCls) {
  return baseCls || Ext.baseCSSPrefix + this.xtype;
}, updateBaseCls:function(newBaseCls, oldBaseCls) {
  var me = this, ui = me.getUi();
  if (oldBaseCls) {
    this.element.removeCls(oldBaseCls);
    if (ui) {
      this.element.removeCls(this.currentUi);
    }
  }
  if (newBaseCls) {
    this.element.addCls(newBaseCls);
    if (ui) {
      this.element.addCls(newBaseCls, null, ui);
      this.currentUi = newBaseCls + '-' + ui;
    }
  }
}, addCls:function(cls, prefix, suffix) {
  var oldCls = this.getCls(), newCls = oldCls ? oldCls.slice() : [], ln, i, cachedCls;
  prefix = prefix || '';
  suffix = suffix || '';
  if (typeof cls == 'string') {
    cls = [cls];
  }
  ln = cls.length;
  if (!newCls.length && prefix === '' && suffix === '') {
    newCls = cls;
  } else {
    for (i = 0; i < ln; i++) {
      cachedCls = prefix + cls[i] + suffix;
      if (newCls.indexOf(cachedCls) == -1) {
        newCls.push(cachedCls);
      }
    }
  }
  this.setCls(newCls);
}, removeCls:function(cls, prefix, suffix) {
  var oldCls = this.getCls(), newCls = oldCls ? oldCls.slice() : [], ln, i;
  prefix = prefix || '';
  suffix = suffix || '';
  if (typeof cls == 'string') {
    newCls = Ext.Array.remove(newCls, prefix + cls + suffix);
  } else {
    ln = cls.length;
    for (i = 0; i < ln; i++) {
      newCls = Ext.Array.remove(newCls, prefix + cls[i] + suffix);
    }
  }
  this.setCls(newCls);
}, replaceCls:function(oldCls, newCls, prefix, suffix) {
  var cls = this.getCls(), array = cls ? cls.slice() : [], ln, i, cachedCls;
  prefix = prefix || '';
  suffix = suffix || '';
  if (typeof oldCls == 'string') {
    array = Ext.Array.remove(array, prefix + oldCls + suffix);
  } else {
    if (oldCls) {
      ln = oldCls.length;
      for (i = 0; i < ln; i++) {
        array = Ext.Array.remove(array, prefix + oldCls[i] + suffix);
      }
    }
  }
  if (typeof newCls == 'string') {
    array.push(prefix + newCls + suffix);
  } else {
    if (newCls) {
      ln = newCls.length;
      if (!array.length && prefix === '' && suffix === '') {
        array = newCls;
      } else {
        for (i = 0; i < ln; i++) {
          cachedCls = prefix + newCls[i] + suffix;
          if (array.indexOf(cachedCls) == -1) {
            array.push(cachedCls);
          }
        }
      }
    }
  }
  this.setCls(array);
}, toggleCls:function(className, state) {
  var oldCls = this.getCls(), newCls = oldCls ? oldCls.slice() : [];
  if (typeof state !== 'boolean') {
    state = newCls.indexOf(className) === -1;
  }
  if (state) {
    Ext.Array.include(newCls, className);
  } else {
    Ext.Array.remove(newCls, className);
  }
  this.setCls(newCls);
  return this;
}, applyCls:function(cls) {
  if (typeof cls == 'string') {
    cls = [cls];
  }
  if (!cls || !cls.length) {
    cls = null;
  }
  return cls;
}, updateCls:function(newCls, oldCls) {
  var el = this.element;
  if (el && (newCls && !oldCls || !newCls && oldCls || newCls.length != oldCls.length || Ext.Array.difference(newCls, oldCls).length > 0)) {
    el.replaceCls(oldCls, newCls);
  }
}, updateStyleHtmlCls:function(newHtmlCls, oldHtmlCls) {
  var innerHtmlElement = this.innerHtmlElement, innerElement = this.innerElement;
  if (this.getStyleHtmlContent() && oldHtmlCls) {
    if (innerHtmlElement) {
      innerHtmlElement.replaceCls(oldHtmlCls, newHtmlCls);
    } else {
      innerElement.replaceCls(oldHtmlCls, newHtmlCls);
    }
  }
}, applyStyleHtmlContent:function(config) {
  return Boolean(config);
}, updateStyleHtmlContent:function(styleHtmlContent) {
  var htmlCls = this.getStyleHtmlCls(), innerElement = this.innerElement, innerHtmlElement = this.innerHtmlElement;
  if (styleHtmlContent) {
    if (innerHtmlElement) {
      innerHtmlElement.addCls(htmlCls);
    } else {
      innerElement.addCls(htmlCls);
    }
  } else {
    if (innerHtmlElement) {
      innerHtmlElement.removeCls(htmlCls);
    } else {
      innerElement.addCls(htmlCls);
    }
  }
}, applyContentEl:function(contentEl) {
  if (contentEl) {
    return Ext.get(contentEl);
  }
}, updateContentEl:function(newContentEl, oldContentEl) {
  if (oldContentEl) {
    oldContentEl.hide();
    Ext.getBody().append(oldContentEl);
  }
  if (newContentEl) {
    this.setHtml(newContentEl.dom);
    newContentEl.show();
  }
}, updateUseBodyElement:function(useBodyElement) {
  if (useBodyElement) {
    this.link('bodyElement', this.innerElement.wrap({cls:'x-body'}));
  }
}, isCentered:function() {
  return Boolean(this.getCentered());
}, isFloating:function() {
  return this.floating;
}, isDocked:function() {
  return Boolean(this.getDocked());
}, isInnerItem:function() {
  return this.isInner;
}, setIsInner:function(isInner) {
  if (isInner !== this.isInner) {
    this.isInner = isInner;
    if (this.initialized) {
      this.fireEvent('innerstatechange', this, isInner);
    }
  }
}, applyTop:function(top) {
  return this.filterLengthValue(top);
}, applyRight:function(right) {
  return this.filterLengthValue(right);
}, applyBottom:function(bottom) {
  return this.filterLengthValue(bottom);
}, applyLeft:function(left) {
  return this.filterLengthValue(left);
}, applyMinWidth:function(width) {
  return this.filterLengthValue(width);
}, applyMinHeight:function(height) {
  return this.filterLengthValue(height);
}, applyMaxWidth:function(width) {
  return this.filterLengthValue(width);
}, applyMaxHeight:function(height) {
  return this.filterLengthValue(height);
}, updateTop:function(top) {
  this.element.setTop(top);
  this.refreshFloating();
}, updateRight:function(right) {
  this.element.setRight(right);
  this.refreshFloating();
}, updateBottom:function(bottom) {
  this.element.setBottom(bottom);
  this.refreshFloating();
}, updateLeft:function(left) {
  this.element.setLeft(left);
  this.refreshFloating();
}, updateWidth:function(width) {
  this.element.setWidth(width);
  this.refreshSizeState();
}, updateHeight:function(height) {
  this.element.setHeight(height);
  this.refreshSizeState();
}, updateFlex:Ext.emptyFn, refreshSizeState:function() {
  this.refreshSizeStateOnInitialized = true;
}, doRefreshSizeState:function() {
  var hasWidth = this.getWidth() !== null || this.widthLayoutSized || this.getLeft() !== null && this.getRight() !== null, hasHeight = this.getHeight() !== null || this.heightLayoutSized || this.getTop() !== null && this.getBottom() !== null, stretched = this.layoutStretched || this.hasCSSMinHeight || !hasHeight && this.getMinHeight() !== null, state = hasWidth && hasHeight, flags = (hasWidth && this.LAYOUT_WIDTH) | (hasHeight && this.LAYOUT_HEIGHT) | (stretched && this.LAYOUT_STRETCHED);
  if (!state && stretched) {
    state = null;
  }
  this.setSizeState(state);
  this.setSizeFlags(flags);
}, setLayoutSizeFlags:function(flags) {
  this.layoutStretched = !!(flags & this.LAYOUT_STRETCHED);
  this.widthLayoutSized = !!(flags & this.LAYOUT_WIDTH);
  this.heightLayoutSized = !!(flags & this.LAYOUT_HEIGHT);
  this.refreshSizeState();
}, setSizeFlags:function(flags) {
  var me = this, el = me.element, hasWidth, hasHeight, stretched;
  if (flags !== this.sizeFlags) {
    me.sizeFlags = flags;
    hasWidth = !!(flags & this.LAYOUT_WIDTH);
    hasHeight = !!(flags & this.LAYOUT_HEIGHT);
    stretched = !!(flags & this.LAYOUT_STRETCHED);
    el.toggleCls(Ext.baseCSSPrefix + 'has-width', hasWidth && !stretched && !hasHeight);
    el.toggleCls(Ext.baseCSSPrefix + 'has-height', hasHeight && !stretched && !hasWidth);
    if (me.initialized) {
      me.fireEvent('sizeflagschange', me, flags);
    }
  }
}, getSizeFlags:function() {
  if (!this.initialized) {
    this.doRefreshSizeState();
  }
  return this.sizeFlags;
}, setSizeState:function(state) {
  if (state !== this.sizeState) {
    this.sizeState = state;
    this.element.setSizeState(state);
    if (this.initialized) {
      this.fireEvent('sizestatechange', this, state);
    }
  }
}, getSizeState:function() {
  if (!this.initialized) {
    this.doRefreshSizeState();
  }
  return this.sizeState;
}, updateMinWidth:function(width) {
  this.element.setMinWidth(width);
}, updateMinHeight:function(height) {
  this.element.setMinHeight(height);
  this.refreshSizeState();
}, updateMaxWidth:function(width) {
  this.element.setMaxWidth(width);
}, updateMaxHeight:function(height) {
  this.element.setMaxHeight(height);
}, applyCentered:function(centered) {
  centered = Boolean(centered);
  if (centered) {
    this.refreshInnerState = Ext.emptyFn;
    if (this.isFloating()) {
      this.resetFloating();
    }
    if (this.isDocked()) {
      this.setDocked(false);
    }
    this.setIsInner(false);
    delete this.refreshInnerState;
  }
  return centered;
}, updateCentered:function(centered) {
  this.toggleCls(this.getFloatingCls(), centered);
  if (!centered) {
    this.refreshInnerState();
  }
}, applyDocked:function(docked) {
  if (!docked) {
    return null;
  }
  if (!/^(top|right|bottom|left)$/.test(docked)) {
    Ext.Logger.error("Invalid docking position of '" + docked.position + "', must be either 'top', 'right', 'bottom', " + "'left' or `null` (for no docking)", this);
    return;
  }
  this.refreshInnerState = Ext.emptyFn;
  if (this.isFloating()) {
    this.resetFloating();
  }
  if (this.isCentered()) {
    this.setCentered(false);
  }
  this.setIsInner(false);
  delete this.refreshInnerState;
  return docked;
}, updateDocked:function(docked, oldDocked) {
  this.fireEvent('afterdockedchange', this, docked, oldDocked);
  if (!docked) {
    this.refreshInnerState();
  }
}, resetFloating:function() {
  this.setTop(null);
  this.setRight(null);
  this.setBottom(null);
  this.setLeft(null);
}, refreshInnerState:function() {
  this.setIsInner(!this.isCentered() && !this.isFloating() && !this.isDocked());
}, refreshFloating:function() {
  this.refreshFloatingOnInitialized = true;
}, doRefreshFloating:function() {
  var me = this, floating = true, floatingCls = this.getFloatingCls();
  if (me.getTop() === null && me.getBottom() === null && me.getRight() === null && me.getLeft() === null) {
    floating = false;
  } else {
    me.refreshSizeState();
  }
  if (floating !== this.floating) {
    me.floating = floating;
    if (floating) {
      me.refreshInnerState = Ext.emptyFn;
      if (me.isCentered()) {
        me.setCentered(false);
      }
      if (me.isDocked()) {
        me.setDocked(false);
      }
      me.setIsInner(false);
      delete me.refreshInnerState;
    }
    me.element.toggleCls(floatingCls, floating);
    if (me.initialized) {
      me.fireEvent('floatingchange', me, floating);
    }
    if (!floating) {
      me.refreshInnerState();
    }
  }
}, updateFloatingCls:function(newFloatingCls, oldFloatingCls) {
  if (this.isFloating()) {
    this.replaceCls(oldFloatingCls, newFloatingCls);
  }
}, applyDisabled:function(disabled) {
  return Boolean(disabled);
}, updateDisabled:function(disabled) {
  this.element.toggleCls(this.getDisabledCls(), disabled);
}, updateDisabledCls:function(newDisabledCls, oldDisabledCls) {
  if (this.isDisabled()) {
    this.element.replaceCls(oldDisabledCls, newDisabledCls);
  }
}, disable:function() {
  this.setDisabled(true);
}, enable:function() {
  this.setDisabled(false);
}, isDisabled:function() {
  return this.getDisabled();
}, applyZIndex:function(zIndex) {
  if (!zIndex && zIndex !== 0) {
    zIndex = null;
  }
  if (zIndex !== null) {
    zIndex = Number(zIndex);
    if (isNaN(zIndex)) {
      zIndex = null;
    }
  }
  return zIndex;
}, updateZIndex:function(zIndex) {
  var element = this.element, domStyle;
  if (element && !element.destroyed) {
    domStyle = element.dom.style;
    if (zIndex !== null) {
      domStyle.setProperty('z-index', zIndex, 'important');
    } else {
      domStyle.removeProperty('z-index');
    }
  }
}, getInnerHtmlElement:function() {
  var innerHtmlElement = this.innerHtmlElement, styleHtmlCls;
  if (!innerHtmlElement || !innerHtmlElement.dom || !innerHtmlElement.dom.parentNode) {
    this.innerHtmlElement = innerHtmlElement = Ext.Element.create({cls:'x-innerhtml'});
    if (this.getStyleHtmlContent()) {
      styleHtmlCls = this.getStyleHtmlCls();
      this.innerHtmlElement.addCls(styleHtmlCls);
      this.innerElement.removeCls(styleHtmlCls);
    }
    this.innerElement.appendChild(innerHtmlElement);
  }
  return innerHtmlElement;
}, updateHtml:function(html) {
  if (!this.destroyed) {
    var innerHtmlElement = this.getInnerHtmlElement();
    if (Ext.isElement(html)) {
      innerHtmlElement.setHtml('');
      innerHtmlElement.append(html);
    } else {
      innerHtmlElement.setHtml(html);
    }
  }
}, applyHidden:function(hidden) {
  return Boolean(hidden);
}, updateHidden:function(hidden) {
  var me = this, element = me.renderElement;
  if (element.destroyed) {
    return;
  }
  if (hidden) {
    element.hide();
  } else {
    element.show();
  }
  if (me.element) {
    me.element.toggleCls(me.getHiddenCls(), hidden);
  }
  me.fireEvent(hidden ? 'hide' : 'show', me);
}, updateHiddenCls:function(newHiddenCls, oldHiddenCls) {
  if (this.isHidden()) {
    this.element.replaceCls(oldHiddenCls, newHiddenCls);
  }
}, isHidden:function(deep) {
  var hidden = !!this.getHidden(), owner;
  if (!hidden && deep) {
    owner = this.getRefOwner();
    while (owner) {
      hidden = !!owner.getHidden();
      if (hidden) {
        break;
      }
      owner = owner.getRefOwner();
    }
  }
  return hidden;
}, isVisible:function(deep) {
  return !this.isHidden(deep);
}, hide:function(animation) {
  var me = this, activeAnim = me.activeAnimation;
  me.setCurrentAlignmentInfo(null);
  if (activeAnim) {
    activeAnim.on({animationend:function() {
      me.hide(animation);
    }, single:true});
    return me;
  }
  if (!me.getHidden()) {
    if (animation === undefined || animation && animation.isComponent) {
      animation = me.getHideAnimation();
    }
    if (animation) {
      if (animation === true) {
        animation = 'fadeOut';
      }
      me.on({beforehiddenchange:'animateFn', scope:this, single:true, args:[animation]});
    }
    me.setHidden(true);
  }
  return me;
}, show:function(animation) {
  if (this.activeAnimation) {
    this.activeAnimation.on({animationend:function() {
      this.show(animation);
    }, scope:this, single:true});
    return this;
  }
  var hidden = this.getHidden();
  if (hidden || hidden === null) {
    if (animation === true) {
      animation = 'fadeIn';
    } else {
      if (animation === undefined || animation && animation.isComponent) {
        animation = this.getShowAnimation();
      }
    }
    if (animation) {
      this.beforeShowAnimation();
      this.on({beforehiddenchange:'animateFn', scope:this, single:true, args:[animation]});
    }
    this.setHidden(false);
  }
  return this;
}, beforeShowAnimation:function() {
  var element = this.element;
  if (element) {
    this.renderElement.show();
    element.removeCls(this.getHiddenCls());
  }
}, animateFn:function(animation, component, newState, oldState, controller) {
  var me = this;
  if (animation && (!newState || newState && me.isPainted())) {
    me.activeAnimation = new Ext.fx.Animation(animation);
    me.activeAnimation.setElement(component.element);
    if (!Ext.isEmpty(newState)) {
      me.activeAnimation.setOnEnd(function() {
        me.activeAnimation = null;
        controller.resume();
      });
      controller.pause();
    }
    Ext.Animator.run(me.activeAnimation);
  }
}, setVisibility:function(isVisible) {
  this.renderElement.setVisible(isVisible);
}, isRendered:function() {
  return this.rendered;
}, isPainted:function() {
  return this.renderElement.isPainted();
}, applyTpl:function(config) {
  return Ext.isObject(config) && config.isTemplate ? config : new Ext.XTemplate(config);
}, applyData:function(data) {
  if (Ext.isObject(data)) {
    return Ext.apply({}, data);
  } else {
    if (!data) {
      data = {};
    }
  }
  return data;
}, updateData:function(newData) {
  var me = this;
  if (newData) {
    var tpl = me.getTpl(), tplWriteMode = me.getTplWriteMode();
    if (tpl) {
      tpl[tplWriteMode](me.getInnerHtmlElement(), newData);
    }
    this.fireEvent('updatedata', me, newData);
  }
}, applyRecord:function(config) {
  if (config && Ext.isObject(config) && config.isModel) {
    return config;
  }
  return null;
}, updateRecord:function(newRecord, oldRecord) {
  var me = this;
  if (oldRecord) {
    oldRecord.unjoin(me);
  }
  if (!newRecord) {
    me.updateData('');
  } else {
    newRecord.join(me);
    me.updateData(newRecord.getData(true));
  }
}, afterEdit:function() {
  this.updateRecord(this.getRecord());
}, afterErase:function() {
  this.setRecord(null);
}, getXTypes:function() {
  return this.xtypesChain.join('/');
}, getDraggableBehavior:function() {
  var behavior = this.draggableBehavior;
  if (!behavior) {
    behavior = this.draggableBehavior = new Ext.behavior.Draggable(this);
  }
  return behavior;
}, applyDraggable:function(config) {
  this.getDraggableBehavior().setConfig(config);
}, getDraggable:function() {
  return this.getDraggableBehavior().getDraggable();
}, getTranslatableBehavior:function() {
  var behavior = this.translatableBehavior;
  if (!behavior) {
    behavior = this.translatableBehavior = new Ext.behavior.Translatable(this);
  }
  return behavior;
}, applyTranslatable:function(config) {
  this.getTranslatableBehavior().setConfig(config);
}, getTranslatable:function() {
  return this.getTranslatableBehavior().getTranslatable();
}, translateAxis:function(axis, value, animation) {
  var x, y;
  if (axis === 'x') {
    x = value;
  } else {
    y = value;
  }
  return this.translate(x, y, animation);
}, translate:function() {
  var translatable = this.getTranslatable();
  if (!translatable) {
    this.setTranslatable(true);
    translatable = this.getTranslatable();
  }
  translatable.translate.apply(translatable, arguments);
}, showBy:function(component, alignment) {
  var me = this, viewport = Ext.Viewport, parent = me.getParent();
  me.setVisibility(false);
  if (parent !== viewport) {
    viewport.add(me);
  }
  me.show();
  me.on({hide:'onShowByErased', destroy:'onShowByErased', single:true, scope:me});
  viewport.on('resize', 'alignTo', me, {args:[component, alignment]});
  me.alignTo(component, alignment);
  me.setVisibility(true);
}, onShowByErased:function() {
  Ext.Viewport.un('resize', 'alignTo', this);
}, getAlignmentInfo:function(component, alignment) {
  var alignToElement = component.isComponent ? component.renderElement : component, alignToBox = alignToElement.getBox(), element = this.renderElement, box = element.getBox(), stats = {alignToBox:alignToBox, alignment:alignment, top:alignToBox.top, left:alignToBox.left, alignToWidth:alignToBox.width, alignToHeight:alignToBox.height, width:box.width, height:box.height}, currentAlignmentInfo = this.getCurrentAlignmentInfo(), isAligned = true;
  if (!Ext.isEmpty(currentAlignmentInfo)) {
    Ext.Object.each(stats, function(key, value) {
      if (!Ext.isObject(value) && currentAlignmentInfo[key] != value) {
        isAligned = false;
        return false;
      }
      return true;
    });
  } else {
    isAligned = false;
  }
  return {isAligned:isAligned, stats:stats};
}, getCurrentAlignmentInfo:function() {
  return this.$currentAlignmentInfo;
}, setCurrentAlignmentInfo:function(alignmentInfo) {
  this.$currentAlignmentInfo = Ext.isEmpty(alignmentInfo) ? null : Ext.merge({}, alignmentInfo.stats ? alignmentInfo.stats : alignmentInfo);
}, alignTo:function(component, alignment) {
  var alignmentInfo = this.getAlignmentInfo(component, alignment);
  if (alignmentInfo.isAligned) {
    return;
  }
  var alignToBox = alignmentInfo.stats.alignToBox, constrainBox = this.getParent().element.getBox(), alignToHeight = alignmentInfo.stats.alignToHeight, alignToWidth = alignmentInfo.stats.alignToWidth, height = alignmentInfo.stats.height, width = alignmentInfo.stats.width;
  constrainBox.bottom -= 5;
  constrainBox.height -= 10;
  constrainBox.left += 5;
  constrainBox.right -= 5;
  constrainBox.top += 5;
  constrainBox.width -= 10;
  if (!alignment || alignment === 'auto') {
    if (constrainBox.bottom - alignToBox.bottom < height) {
      if (alignToBox.top - constrainBox.top < height) {
        if (alignToBox.left - constrainBox.left < width) {
          alignment = 'cl-cr?';
        } else {
          alignment = 'cr-cl?';
        }
      } else {
        alignment = 'bc-tc?';
      }
    } else {
      alignment = 'tc-bc?';
    }
  }
  var matches = alignment.match(this.alignmentRegex);
  if (!matches) {
    Ext.Logger.error("Invalid alignment value of '" + alignment + "'");
  }
  var from = matches[1].split(''), to = matches[2].split(''), constrained = matches[3] === '?', fromVertical = from[0], fromHorizontal = from[1] || fromVertical, toVertical = to[0], toHorizontal = to[1] || toVertical, top = alignToBox.top, left = alignToBox.left, halfAlignHeight = alignToHeight / 2, halfAlignWidth = alignToWidth / 2, halfWidth = width / 2, halfHeight = height / 2, maxLeft, maxTop;
  switch(fromVertical) {
    case 't':
      switch(toVertical) {
        case 'c':
          top += halfAlignHeight;
          break;
        case 'b':
          top += alignToHeight;
      }break;
    case 'b':
      switch(toVertical) {
        case 'c':
          top -= height - halfAlignHeight;
          break;
        case 't':
          top -= height;
          break;
        case 'b':
          top -= height - alignToHeight;
      }break;
    case 'c':
      switch(toVertical) {
        case 't':
          top -= halfHeight;
          break;
        case 'c':
          top -= halfHeight - halfAlignHeight;
          break;
        case 'b':
          top -= halfHeight - alignToHeight;
      }break;
  }
  switch(fromHorizontal) {
    case 'l':
      switch(toHorizontal) {
        case 'c':
          left += halfAlignHeight;
          break;
        case 'r':
          left += alignToWidth;
      }break;
    case 'r':
      switch(toHorizontal) {
        case 'r':
          left -= width - alignToWidth;
          break;
        case 'c':
          left -= width - halfWidth;
          break;
        case 'l':
          left -= width;
      }break;
    case 'c':
      switch(toHorizontal) {
        case 'l':
          left -= halfWidth;
          break;
        case 'c':
          left -= halfWidth - halfAlignWidth;
          break;
        case 'r':
          left -= halfWidth - alignToWidth;
      }break;
  }
  if (constrained) {
    maxLeft = constrainBox.left + constrainBox.width - width;
    maxTop = constrainBox.top + constrainBox.height - height;
    left = Math.max(constrainBox.left, Math.min(maxLeft, left));
    top = Math.max(constrainBox.top, Math.min(maxTop, top));
  }
  this.setLeft(left);
  this.setTop(top);
  this.setCurrentAlignmentInfo(alignmentInfo);
}, up:function(selector) {
  var result = this.parent;
  if (selector) {
    for (; result; result = result.parent) {
      if (Ext.ComponentQuery.is(result, selector)) {
        return result;
      }
    }
  }
  return result;
}, getBubbleTarget:function() {
  return this.getParent();
}, destroy:function() {
  var me = this;
  me.isDestroying = me.destroying = true;
  if (me.hasListeners.destroy) {
    me.fireEvent('destroy', me);
  }
  Ext.destroy(me.getTranslatable(), me.getPlugins(), me.innerHtmlElement, me.scrollerElement, me.getScrollable());
  me.setRecord(null);
  me.callParent();
  me.isDestroying = me.destroying = false;
}, privates:{doAddListener:function(name, fn, scope, options, order, caller, manager) {
  if (name == 'painted' || name == 'resize') {
    this.element.doAddListener(name, fn, scope || this, options, order);
  }
  this.callParent([name, fn, scope, options, order, caller, manager]);
}, doRemoveListener:function(name, fn, scope) {
  if (name == 'painted' || name == 'resize') {
    this.element.doRemoveListener(name, fn, scope);
  }
  this.callParent([name, fn, scope]);
}}}, function() {
  var metaTags = document.getElementsByTagName('head')[0].getElementsByTagName('meta'), len = metaTags.length, i, hasViewport;
  for (i = 0; i < len; i++) {
    if (metaTags[i].name === 'viewport') {
      hasViewport = true;
    }
  }
  if (!hasViewport) {
    Ext.log.warn('Ext JS requires a viewport meta tag in order to function correctly on mobile devices.  Please add the following tag to the \x3chead\x3e of your html page: \n \x3cmeta name\x3d"viewport" content\x3d"width\x3ddevice-width, initial-scale\x3d1, maximum-scale\x3d1, user-scalable\x3dno"\x3e');
  }
});
Ext.define('Ext.theme.neptune.Component', {override:'Ext.Component'}, function() {
  Ext.namespace('Ext.theme.is').Neptune = true;
  Ext.theme.name = 'Neptune';
  Ext.theme.getDocCls = function() {
    return Ext.platformTags.desktop ? '' : 'x-big';
  };
});
Ext.define('Ext.theme.triton.Component', {override:'Ext.Component'}, function() {
  Ext.namespace('Ext.theme.is').Triton = true;
  Ext.theme.name = 'Triton';
  Ext.theme.getDocCls = function() {
    return Ext.platformTags.phone ? 'x-big' : '';
  };
});
Ext.define('Ext.layout.Abstract', {mixins:[Ext.mixin.Observable], isLayout:true, constructor:function(config) {
  this.initialConfig = config;
}, isCompatible:function(layout) {
  if (!layout) {
    return true;
  }
  if (layout.isInstance) {
    return false;
  }
  var type = Ext.isString(layout) ? layout : layout.type, alias = this.alias;
  if (!alias || !type) {
    return false;
  }
  return alias.indexOf('layout.' + type) > -1;
}, setContainer:function(container) {
  var me = this;
  me.container = container;
  me.mixins.observable.constructor.call(me, me.initialConfig);
  return me;
}, onItemAdd:Ext.emptyFn, onItemRemove:Ext.emptyFn, onItemMove:Ext.emptyFn, onItemCenteredChange:Ext.emptyFn, onItemFloatingChange:Ext.emptyFn, onItemDockedChange:Ext.emptyFn, onItemInnerStateChange:Ext.emptyFn});
Ext.define('Ext.mixin.Hookable', {extend:Ext.Mixin, mixinConfig:{id:'hookable'}, bindHook:function(instance, boundMethod, bindingMethod, preventDefault, extraArgs) {
  if (!bindingMethod) {
    bindingMethod = boundMethod;
  }
  var boundFn = instance[boundMethod], fn, binding;
  if (boundFn && boundFn.hasOwnProperty('$binding')) {
    binding = boundFn.$binding;
    if (binding.bindingMethod === bindingMethod && binding.bindingScope === this) {
      return this;
    }
  }
  instance[boundMethod] = fn = function() {
    var binding = fn.$binding, scope = binding.bindingScope, args = Array.prototype.slice.call(arguments);
    args.push(arguments);
    if (extraArgs) {
      args.push.apply(args, extraArgs);
    }
    if (!binding.preventDefault && scope[binding.bindingMethod].apply(scope, args) !== false) {
      return binding.boundFn.apply(this, arguments);
    }
  };
  fn.$binding = {preventDefault:!!preventDefault, boundFn:boundFn, bindingMethod:bindingMethod, bindingScope:this};
  return this;
}, unbindHook:function(instance, boundMethod, bindingMethod) {
  if (!bindingMethod) {
    bindingMethod = boundMethod;
  }
  var fn = instance[boundMethod], binding = fn.$binding, boundFn, currentBinding;
  while (binding) {
    boundFn = binding.boundFn;
    if (binding.bindingMethod === bindingMethod && binding.bindingScope === this) {
      if (currentBinding) {
        currentBinding.boundFn = boundFn;
      } else {
        instance[boundMethod] = boundFn;
      }
      return this;
    }
    currentBinding = binding;
    binding = boundFn.$binding;
  }
  return this;
}});
Ext.define('Ext.util.Wrapper', {mixins:[Ext.mixin.Hookable], constructor:function(elementConfig, wrappedElement) {
  var element = this.link('element', Ext.Element.create(elementConfig));
  if (wrappedElement) {
    element.insertBefore(wrappedElement);
    this.wrap(wrappedElement);
  }
}, bindSize:function(sizeName) {
  var wrappedElement = this.wrappedElement, boundMethodName;
  this.boundSizeName = sizeName;
  this.boundMethodName = boundMethodName = sizeName === 'width' ? 'setWidth' : 'setHeight';
  this.bindHook(wrappedElement, boundMethodName, 'onBoundSizeChange');
  wrappedElement[boundMethodName].call(wrappedElement, wrappedElement.getStyleValue(sizeName));
}, onBoundSizeChange:function(size, args) {
  var element = this.element;
  if (typeof size === 'string' && size.substr(-1) === '%') {
    args[0] = '100%';
  } else {
    size = '';
  }
  element[this.boundMethodName].call(element, size);
}, wrap:function(wrappedElement) {
  var element = this.element, innerDom;
  this.wrappedElement = wrappedElement;
  innerDom = element.dom;
  while (innerDom.firstElementChild !== null) {
    innerDom = innerDom.firstElementChild;
  }
  innerDom.appendChild(wrappedElement.dom);
}, destroy:function() {
  var me = this, element = me.element, dom = element.dom, wrappedElement = me.wrappedElement, boundMethodName = me.boundMethodName, parentNode = dom.parentNode, size;
  if (boundMethodName) {
    me.unbindHook(wrappedElement, boundMethodName, 'onBoundSizeChange');
    size = element.getStyle(me.boundSizeName);
    if (size) {
      wrappedElement[boundMethodName].call(wrappedElement, size);
    }
  }
  if (parentNode) {
    if (!wrappedElement.destroyed) {
      parentNode.replaceChild(dom.firstElementChild, dom);
    }
    delete me.wrappedElement;
  }
  me.callParent();
}});
Ext.define('Ext.layout.wrapper.BoxDock', {config:{direction:'horizontal', element:{className:Ext.baseCSSPrefix + 'dock'}, bodyElement:{className:Ext.baseCSSPrefix + 'dock-body'}, innerWrapper:null, sizeState:false, container:null}, positionMap:{top:'start', left:'start', bottom:'end', right:'end'}, constructor:function(config) {
  this.items = {start:[], end:[]};
  this.itemsCount = 0;
  this.initConfig(config);
}, addItems:function(items) {
  var i, ln, item;
  for (i = 0, ln = items.length; i < ln; i++) {
    item = items[i];
    this.addItem(item);
  }
}, addItem:function(item) {
  var docked = item.getDocked(), position = this.positionMap[docked], wrapper = item.$dockWrapper, container = this.getContainer(), index = container.indexOf(item), element = item.element, items = this.items, sideItems = items[position], i, ln, sibling, referenceElement, siblingIndex;
  if (wrapper) {
    wrapper.removeItem(item);
  }
  item.$dockWrapper = this;
  item.addCls(Ext.baseCSSPrefix + 'dock-item');
  item.addCls(Ext.baseCSSPrefix + 'docked-' + docked);
  for (i = 0, ln = sideItems.length; i < ln; i++) {
    sibling = sideItems[i];
    siblingIndex = container.indexOf(sibling);
    if (siblingIndex > index) {
      referenceElement = sibling.element;
      sideItems.splice(i, 0, item);
      break;
    }
  }
  if (!referenceElement) {
    sideItems.push(item);
    referenceElement = this.getBodyElement();
  }
  this.itemsCount++;
  if (position === 'start') {
    element.insertBefore(referenceElement);
  } else {
    element.insertAfter(referenceElement);
  }
}, removeItem:function(item) {
  var position = item.getDocked(), items = this.items[this.positionMap[position]];
  Ext.Array.remove(items, item);
  item.element.detach();
  delete item.$dockWrapper;
  item.removeCls(Ext.baseCSSPrefix + 'dock-item');
  item.removeCls(Ext.baseCSSPrefix + 'docked-' + position);
  if (--this.itemsCount === 0) {
    this.destroy();
  }
}, getItemsSlice:function(index) {
  var container = this.getContainer(), items = this.items, slice = [], sideItems, i, ln, item;
  for (sideItems = items.start, i = 0, ln = sideItems.length; i < ln; i++) {
    item = sideItems[i];
    if (container.indexOf(item) > index) {
      slice.push(item);
    }
  }
  for (sideItems = items.end, i = 0, ln = sideItems.length; i < ln; i++) {
    item = sideItems[i];
    if (container.indexOf(item) > index) {
      slice.push(item);
    }
  }
  return slice;
}, applyElement:function(element) {
  return Ext.Element.create(element);
}, updateElement:function(element) {
  element.addCls(Ext.baseCSSPrefix + 'dock-' + this.getDirection());
}, applyBodyElement:function(bodyElement) {
  return Ext.Element.create(bodyElement);
}, updateBodyElement:function(bodyElement) {
  this.getElement().append(bodyElement);
}, updateInnerWrapper:function(innerWrapper, oldInnerWrapper) {
  var bodyElement = this.getBodyElement();
  if (oldInnerWrapper && oldInnerWrapper.$outerWrapper === this) {
    oldInnerWrapper.getElement().detach();
    delete oldInnerWrapper.$outerWrapper;
  }
  if (innerWrapper) {
    innerWrapper.setSizeState(this.getSizeState());
    innerWrapper.$outerWrapper = this;
    bodyElement.append(innerWrapper.getElement());
  }
}, updateSizeState:function(state) {
  var innerWrapper = this.getInnerWrapper();
  this.getElement().setSizeState(state);
  if (innerWrapper) {
    innerWrapper.setSizeState(state);
  }
}, destroy:function() {
  var me = this, innerWrapper = me.getInnerWrapper(), outerWrapper = me.$outerWrapper, innerWrapperElement;
  if (innerWrapper) {
    if (outerWrapper) {
      outerWrapper.setInnerWrapper(innerWrapper);
    } else {
      innerWrapperElement = innerWrapper.getElement();
      if (!innerWrapperElement.destroyed) {
        innerWrapperElement.replace(me.getElement());
      }
      delete innerWrapper.$outerWrapper;
    }
  }
  delete me.$outerWrapper;
  me.setInnerWrapper(null);
  me.unlink(['_bodyElement', '_element']);
  me.callParent();
}});
Ext.define('Ext.layout.wrapper.Inner', {config:{sizeState:null, container:null}, constructor:function(config) {
  this.initConfig(config);
}, getElement:function() {
  return this.getContainer().bodyElement;
}, setInnerWrapper:Ext.emptyFn, getInnerWrapper:Ext.emptyFn});
Ext.define('Ext.layout.Default', {extend:Ext.layout.Abstract, isAuto:true, alias:['layout.default', 'layout.auto'], config:{animation:null}, centerWrapperClass:'x-center', dockWrapperClass:'x-dock', positionMap:{top:'start', left:'start', middle:'center', bottom:'end', right:'end'}, positionDirectionMap:{top:'vertical', bottom:'vertical', left:'horizontal', right:'horizontal'}, setContainer:function(container) {
  var me = this;
  me.dockedItems = [];
  me.callParent([container]);
  if (container.initialized) {
    me.onContainerInitialized();
  } else {
    container.onInitialized('onContainerInitialized', me);
  }
}, onContainerInitialized:function() {
  var me = this;
  me.handleDockedItemBorders();
  me.container.on({delegate:'\x3e component', beforecenteredchange:'onItemCenteredChange', beforefloatingchange:'onItemFloatingChange', afterdockedchange:'onAfterItemDockedChange', scope:me});
}, monitorSizeStateChange:function() {
  this.monitorSizeStateChange = Ext.emptyFn;
  this.container.on('sizestatechange', 'onContainerSizeStateChange', this);
}, monitorSizeFlagsChange:function() {
  this.monitorSizeFlagsChange = Ext.emptyFn;
  this.container.on('sizeflagschange', 'onContainerSizeFlagsChange', this);
}, onItemAdd:function(item) {
  var docked = item.getDocked();
  if (docked != null) {
    this.dockItem(item);
  } else {
    if (item.isCentered()) {
      this.onItemCenteredChange(item, true);
    } else {
      if (item.isFloating()) {
        this.onItemFloatingChange(item, true);
      } else {
        this.onItemInnerStateChange(item, true);
      }
    }
  }
}, onItemInnerStateChange:function(item, isInner, destroying) {
  if (isInner) {
    this.insertInnerItem(item, this.container.innerIndexOf(item));
  } else {
    this.removeInnerItem(item);
  }
}, insertInnerItem:function(item, index) {
  var container = this.container, containerDom = container.innerElement.dom, itemDom = item.element.dom, nextSibling = index !== -1 ? container.getInnerAt(index + 1) : null, nextSiblingDom = null, translatable;
  if (nextSibling) {
    translatable = nextSibling.getTranslatable();
    if (translatable && translatable.getUseWrapper()) {
      nextSiblingDom = translatable.getWrapper().dom;
    } else {
      nextSiblingDom = nextSibling ? nextSibling.element.dom : null;
    }
  }
  containerDom.insertBefore(itemDom, nextSiblingDom);
  return this;
}, insertBodyItem:function(item) {
  var container = this.container.setUseBodyElement(true), bodyDom = container.bodyElement.dom;
  if (item.getZIndex() === null) {
    item.setZIndex((container.indexOf(item) + 1) * 2);
  }
  bodyDom.insertBefore(item.element.dom, bodyDom.firstChild);
  return this;
}, removeInnerItem:function(item) {
  item.element.detach();
}, removeBodyItem:function(item) {
  item.setZIndex(null);
  item.element.detach();
}, onItemRemove:function(item, index, destroying) {
  var docked = item.getDocked();
  if (docked) {
    this.undockItem(item);
  } else {
    if (item.isCentered()) {
      this.onItemCenteredChange(item, false);
    } else {
      if (item.isFloating()) {
        this.onItemFloatingChange(item, false);
      } else {
        this.onItemInnerStateChange(item, false, destroying);
      }
    }
  }
}, onItemMove:function(item, toIndex, fromIndex) {
  if (item.isCentered() || item.isFloating()) {
    item.setZIndex((toIndex + 1) * 2);
  } else {
    if (item.isInnerItem()) {
      this.insertInnerItem(item, this.container.innerIndexOf(item));
    } else {
      this.undockItem(item);
      this.dockItem(item);
    }
  }
}, onItemCenteredChange:function(item, centered) {
  var wrapperName = '$centerWrapper';
  if (centered) {
    this.insertBodyItem(item);
    item.link(wrapperName, new Ext.util.Wrapper({className:this.centerWrapperClass}, item.element));
  } else {
    item.unlink([wrapperName]);
    this.removeBodyItem(item);
  }
}, onItemFloatingChange:function(item, floating) {
  if (floating) {
    this.insertBodyItem(item);
  } else {
    this.removeBodyItem(item);
  }
}, onAfterItemDockedChange:function(item, docked, oldDocked) {
  if (item.initialized) {
    if (oldDocked) {
      this.undockItem(item);
    }
    if (docked) {
      this.dockItem(item);
    }
  }
}, onContainerSizeStateChange:function() {
  var dockWrapper = this.getDockWrapper();
  if (dockWrapper) {
    dockWrapper.setSizeState(this.container.getSizeState());
  }
}, onContainerSizeFlagsChange:function() {
  var items = this.dockedItems, i, ln, item;
  for (i = 0, ln = items.length; i < ln; i++) {
    item = items[i];
    this.refreshDockedItemLayoutSizeFlags(item);
  }
}, refreshDockedItemLayoutSizeFlags:function(item) {
  var container = this.container, dockedDirection = this.positionDirectionMap[item.getDocked()], binaryMask = dockedDirection === 'horizontal' ? container.LAYOUT_HEIGHT : container.LAYOUT_WIDTH, flags = container.getSizeFlags() & binaryMask;
  item.setLayoutSizeFlags(flags);
}, dockItem:function(item) {
  var me = this, DockClass = Ext.layout.wrapper.BoxDock, dockedItems = me.dockedItems, ln = dockedItems.length, container = me.container, itemIndex = container.indexOf(item), positionDirectionMap = me.positionDirectionMap, direction = positionDirectionMap[item.getDocked()], dockInnerWrapper = me.dockInnerWrapper, referenceDirection, i, dockedItem, index, previousItem, slice, referenceItem, referenceDocked, referenceWrapper, newWrapper, nestedWrapper, oldInnerWrapper;
  me.monitorSizeStateChange();
  me.monitorSizeFlagsChange();
  if (!dockInnerWrapper) {
    dockInnerWrapper = me.link('dockInnerWrapper', new Ext.layout.wrapper.Inner({container:container}));
  }
  if (ln === 0) {
    dockedItems.push(item);
    newWrapper = new DockClass({container:container, direction:direction});
    newWrapper.addItem(item);
    newWrapper.getElement().replace(dockInnerWrapper.getElement(), false);
    newWrapper.setInnerWrapper(dockInnerWrapper);
    container.onInitialized('onContainerSizeStateChange', me);
  } else {
    for (i = 0; i < ln; i++) {
      dockedItem = dockedItems[i];
      index = container.indexOf(dockedItem);
      if (index > itemIndex) {
        referenceItem = previousItem || dockedItems[0];
        dockedItems.splice(i, 0, item);
        break;
      }
      previousItem = dockedItem;
    }
    if (!referenceItem) {
      referenceItem = dockedItems[ln - 1];
      dockedItems.push(item);
    }
    referenceDocked = referenceItem.getDocked();
    referenceWrapper = referenceItem.$dockWrapper;
    referenceDirection = positionDirectionMap[referenceDocked];
    if (direction === referenceDirection) {
      referenceWrapper.addItem(item);
    } else {
      slice = referenceWrapper.getItemsSlice(itemIndex);
      newWrapper = new DockClass({container:container, direction:direction});
      if (slice.length > 0) {
        if (slice.length === referenceWrapper.itemsCount) {
          nestedWrapper = referenceWrapper;
          newWrapper.setSizeState(nestedWrapper.getSizeState());
          newWrapper.getElement().replace(nestedWrapper.getElement(), false);
        } else {
          nestedWrapper = new DockClass({container:container, direction:referenceDirection});
          nestedWrapper.setInnerWrapper(referenceWrapper.getInnerWrapper());
          nestedWrapper.addItems(slice);
          referenceWrapper.setInnerWrapper(newWrapper);
        }
        newWrapper.setInnerWrapper(nestedWrapper);
      } else {
        oldInnerWrapper = referenceWrapper.getInnerWrapper();
        referenceWrapper.setInnerWrapper(null);
        newWrapper.setInnerWrapper(oldInnerWrapper);
        referenceWrapper.setInnerWrapper(newWrapper);
      }
      newWrapper.addItem(item);
    }
  }
  if (container.initialized) {
    me.handleDockedItemBorders();
  }
  container.onInitialized('refreshDockedItemLayoutSizeFlags', me, [item]);
}, getDockWrapper:function() {
  var dockedItems = this.dockedItems;
  if (dockedItems.length > 0) {
    return dockedItems[0].$dockWrapper;
  }
  return null;
}, undockItem:function(item) {
  var me = this, dockedItems = me.dockedItems, lastBorderMask, lastBorderCollapse;
  if (item.$dockWrapper) {
    item.$dockWrapper.removeItem(item);
  }
  if (me.container.initialized) {
    lastBorderMask = item.lastBorderMask;
    lastBorderCollapse = item.lastBorderCollapse;
    if (lastBorderMask) {
      item.lastBorderMask = 0;
      item.removeCls(me.noBorderClassTable[lastBorderMask]);
    }
    if (lastBorderCollapse) {
      item.lastBorderCollapse = 0;
      item.removeCls(me.getBorderCollapseTable()[lastBorderCollapse]);
    }
    me.handleDockedItemBorders();
  }
  Ext.Array.remove(dockedItems, item);
  item.setLayoutSizeFlags(0);
}, destroy:function() {
  this.dockedItems = null;
  this.callParent();
}, noBorderClassTable:[0, Ext.baseCSSPrefix + 'noborder-l', Ext.baseCSSPrefix + 'noborder-b', Ext.baseCSSPrefix + 'noborder-bl', Ext.baseCSSPrefix + 'noborder-r', Ext.baseCSSPrefix + 'noborder-rl', Ext.baseCSSPrefix + 'noborder-rb', Ext.baseCSSPrefix + 'noborder-rbl', Ext.baseCSSPrefix + 'noborder-t', Ext.baseCSSPrefix + 'noborder-tl', Ext.baseCSSPrefix + 'noborder-tb', Ext.baseCSSPrefix + 'noborder-tbl', Ext.baseCSSPrefix + 'noborder-tr', Ext.baseCSSPrefix + 'noborder-trl', Ext.baseCSSPrefix + 'noborder-trb', 
Ext.baseCSSPrefix + 'noborder-trbl'], edgeMasks:{top:8, right:4, bottom:2, left:1}, handleDockedItemBorders:function() {
  var me = this, edges = 0, maskT = 8, maskR = 4, maskB = 2, maskL = 1, container = me.container, bodyBorder = container.getBoodyBorder && container.getBodyBorder(), containerBorder = container.getBorder(), collapsed = me.collapsed, edgeMasks = me.edgeMasks, noBorderCls = me.noBorderClassTable, dockedItemsGen = container.items.generation, b, borderCls, docked, edgesTouched, i, ln, item, dock, lastValue, mask, addCls, removeCls;
  if (me.initializedBorders === dockedItemsGen || !container.manageBorders) {
    return;
  }
  addCls = [];
  removeCls = [];
  borderCls = me.getBorderCollapseTable();
  noBorderCls = me.getBorderClassTable ? me.getBorderClassTable() : noBorderCls;
  me.initializedBorders = dockedItemsGen;
  me.collapsed = false;
  docked = container.getDockedItems();
  me.collapsed = collapsed;
  for (i = 0, ln = docked.length; i < ln; i++) {
    item = docked[i];
    dock = item.getDocked();
    mask = edgesTouched = 0;
    addCls.length = 0;
    removeCls.length = 0;
    if (dock !== 'bottom') {
      if (edges & maskT) {
        b = item.border;
      } else {
        b = containerBorder;
        if (b !== false) {
          edgesTouched += maskT;
        }
      }
      if (b === false) {
        mask += maskT;
      }
    }
    if (dock !== 'left') {
      if (edges & maskR) {
        b = item.border;
      } else {
        b = containerBorder;
        if (b !== false) {
          edgesTouched += maskR;
        }
      }
      if (b === false) {
        mask += maskR;
      }
    }
    if (dock !== 'top') {
      if (edges & maskB) {
        b = item.border;
      } else {
        b = containerBorder;
        if (b !== false) {
          edgesTouched += maskB;
        }
      }
      if (b === false) {
        mask += maskB;
      }
    }
    if (dock !== 'right') {
      if (edges & maskL) {
        b = item.border;
      } else {
        b = containerBorder;
        if (b !== false) {
          edgesTouched += maskL;
        }
      }
      if (b === false) {
        mask += maskL;
      }
    }
    if ((lastValue = item.lastBorderMask) !== mask) {
      item.lastBorderMask = mask;
      if (lastValue) {
        removeCls[0] = noBorderCls[lastValue];
      }
      if (mask) {
        addCls[0] = noBorderCls[mask];
      }
    }
    if ((lastValue = item.lastBorderCollapse) !== edgesTouched) {
      item.lastBorderCollapse = edgesTouched;
      if (lastValue) {
        removeCls[removeCls.length] = borderCls[lastValue];
      }
      if (edgesTouched) {
        addCls[addCls.length] = borderCls[edgesTouched];
      }
    }
    if (removeCls.length) {
      item.removeCls(removeCls);
    }
    if (addCls.length) {
      item.addCls(addCls);
    }
    edges |= edgeMasks[dock];
  }
  mask = edgesTouched = 0;
  addCls.length = 0;
  removeCls.length = 0;
  if (edges & maskT) {
    b = bodyBorder;
  } else {
    b = containerBorder;
    if (b !== false) {
      edgesTouched += maskT;
    }
  }
  if (b === false) {
    mask += maskT;
  }
  if (edges & maskR) {
    b = bodyBorder;
  } else {
    b = containerBorder;
    if (b !== false) {
      edgesTouched += maskR;
    }
  }
  if (b === false) {
    mask += maskR;
  }
  if (edges & maskB) {
    b = bodyBorder;
  } else {
    b = containerBorder;
    if (b !== false) {
      edgesTouched += maskB;
    }
  }
  if (b === false) {
    mask += maskB;
  }
  if (edges & maskL) {
    b = bodyBorder;
  } else {
    b = containerBorder;
    if (b !== false) {
      edgesTouched += maskL;
    }
  }
  if (b === false) {
    mask += maskL;
  }
  if ((lastValue = me.lastBodyBorderMask) !== mask) {
    me.lastBodyBorderMask = mask;
    if (lastValue) {
      removeCls[0] = noBorderCls[lastValue];
    }
    if (mask) {
      addCls[0] = noBorderCls[mask];
    }
  }
  if ((lastValue = me.lastBodyBorderCollapse) !== edgesTouched) {
    me.lastBodyBorderCollapse = edgesTouched;
    if (lastValue) {
      removeCls[removeCls.length] = borderCls[lastValue];
    }
    if (edgesTouched) {
      addCls[addCls.length] = borderCls[edgesTouched];
    }
  }
  if (removeCls.length && container.removeBodyCls) {
    container.removeBodyCls(removeCls);
  }
  if (addCls.length && container.addBodyCls) {
    container.addBodyCls(addCls);
  }
}, borderCollapseMap:{}, getBorderCollapseTable:function() {
  var me = this, map = me.borderCollapseMap, container = me.container, baseCls = container.getBaseCls(), ui = container.ui, uiCls = ui ? '-' + ui : '', table;
  ui = ui || 'default';
  map = map[baseCls] || (map[baseCls] = {});
  table = map[ui];
  if (!table) {
    baseCls += uiCls + '-outer-border-';
    map[ui] = table = [0, baseCls + 'l', baseCls + 'b', baseCls + 'bl', baseCls + 'r', baseCls + 'rl', baseCls + 'rb', baseCls + 'rbl', baseCls + 't', baseCls + 'tl', baseCls + 'tb', baseCls + 'tbl', baseCls + 'tr', baseCls + 'trl', baseCls + 'trb', baseCls + 'trbl'];
  }
  return table;
}});
Ext.define('Ext.layout.Box', {extend:Ext.layout.Default, config:{orient:'horizontal', align:'start', pack:'start'}, alias:'layout.tablebox', layoutBaseClass:'x-layout-tablebox', itemClass:'x-layout-tablebox-item', setContainer:function(container) {
  this.callParent([container]);
  container.innerElement.addCls(this.layoutBaseClass);
  container.on('flexchange', 'onItemFlexChange', this, {delegate:'\x3e component'});
}, onItemInnerStateChange:function(item, isInner) {
  this.callParent(arguments);
  item.toggleCls(this.itemClass, isInner);
}, onItemFlexChange:Ext.emptyFn});
Ext.define('Ext.fx.layout.card.Abstract', {extend:Ext.Evented, isAnimation:true, config:{direction:'left', duration:null, reverse:null, layout:null}, updateLayout:function(layout) {
  if (layout) {
    this.enable();
  }
}, enable:function() {
  var layout = this.getLayout();
  if (layout) {
    layout.on('beforeactiveitemchange', 'onActiveItemChange', this);
  }
}, disable:function() {
  var layout = this.getLayout();
  if (this.isAnimating) {
    this.stopAnimation();
  }
  if (layout) {
    layout.un('beforeactiveitemchange', 'onActiveItemChange', this);
  }
}, onActiveItemChange:Ext.emptyFn, destroy:function() {
  var me = this, layout = me.getLayout();
  if (me.isAnimating) {
    me.stopAnimation();
  }
  if (layout) {
    layout.un('beforeactiveitemchange', 'onActiveItemChange', this);
  }
  me.setLayout(null);
  if (me.observableId) {
    me.fireEvent('destroy', this);
  }
  me.callParent();
}});
Ext.define('Ext.fx.State', {isAnimatable:{'background-color':true, 'background-image':true, 'background-position':true, 'border-bottom-color':true, 'border-bottom-width':true, 'border-color':true, 'border-left-color':true, 'border-left-width':true, 'border-right-color':true, 'border-right-width':true, 'border-spacing':true, 'border-top-color':true, 'border-top-width':true, 'border-width':true, 'bottom':true, 'color':true, 'crop':true, 'font-size':true, 'font-weight':true, 'height':true, 'left':true, 
'letter-spacing':true, 'line-height':true, 'margin-bottom':true, 'margin-left':true, 'margin-right':true, 'margin-top':true, 'max-height':true, 'max-width':true, 'min-height':true, 'min-width':true, 'opacity':true, 'outline-color':true, 'outline-offset':true, 'outline-width':true, 'padding-bottom':true, 'padding-left':true, 'padding-right':true, 'padding-top':true, 'right':true, 'text-indent':true, 'text-shadow':true, 'top':true, 'vertical-align':true, 'visibility':true, 'width':true, 'word-spacing':true, 
'z-index':true, 'zoom':true, 'transform':true}, constructor:function(data) {
  this.data = {};
  this.set(data);
}, setConfig:function(data) {
  this.set(data);
  return this;
}, setRaw:function(data) {
  this.data = data;
  return this;
}, clear:function() {
  return this.setRaw({});
}, setTransform:function(name, value) {
  var data = this.data, isArray = Ext.isArray(value), transform = data.transform, ln, key;
  if (!transform) {
    transform = data.transform = {translateX:0, translateY:0, translateZ:0, scaleX:1, scaleY:1, scaleZ:1, rotate:0, rotateX:0, rotateY:0, rotateZ:0, skewX:0, skewY:0};
  }
  if (typeof name == 'string') {
    switch(name) {
      case 'translate':
        if (isArray) {
          ln = value.length;
          if (ln == 0) {
            break;
          }
          transform.translateX = value[0];
          if (ln == 1) {
            break;
          }
          transform.translateY = value[1];
          if (ln == 2) {
            break;
          }
          transform.translateZ = value[2];
        } else {
          transform.translateX = value;
        }
        break;
      case 'rotate':
        if (isArray) {
          ln = value.length;
          if (ln == 0) {
            break;
          }
          transform.rotateX = value[0];
          if (ln == 1) {
            break;
          }
          transform.rotateY = value[1];
          if (ln == 2) {
            break;
          }
          transform.rotateZ = value[2];
        } else {
          transform.rotate = value;
        }
        break;
      case 'scale':
        if (isArray) {
          ln = value.length;
          if (ln == 0) {
            break;
          }
          transform.scaleX = value[0];
          if (ln == 1) {
            break;
          }
          transform.scaleY = value[1];
          if (ln == 2) {
            break;
          }
          transform.scaleZ = value[2];
        } else {
          transform.scaleX = value;
          transform.scaleY = value;
        }
        break;
      case 'skew':
        if (isArray) {
          ln = value.length;
          if (ln == 0) {
            break;
          }
          transform.skewX = value[0];
          if (ln == 1) {
            break;
          }
          transform.skewY = value[1];
        } else {
          transform.skewX = value;
        }
        break;
      default:
        transform[name] = value;
    }
  } else {
    for (key in name) {
      if (name.hasOwnProperty(key)) {
        value = name[key];
        this.setTransform(key, value);
      }
    }
  }
}, set:function(name, value) {
  var data = this.data, key;
  if (typeof name != 'string') {
    for (key in name) {
      value = name[key];
      if (key === 'transform') {
        this.setTransform(value);
      } else {
        data[key] = value;
      }
    }
  } else {
    if (name === 'transform') {
      this.setTransform(value);
    } else {
      data[name] = value;
    }
  }
  return this;
}, unset:function(name) {
  var data = this.data;
  if (data.hasOwnProperty(name)) {
    delete data[name];
  }
  return this;
}, getData:function() {
  return this.data;
}});
Ext.define('Ext.fx.animation.Abstract', {extend:Ext.Evented, isAnimation:true, config:{name:'', element:null, before:null, from:{}, to:{}, after:null, states:{}, duration:300, easing:'linear', iteration:1, direction:'normal', delay:0, onBeforeStart:null, callback:null, onEnd:null, onBeforeEnd:null, scope:null, reverse:null, preserveEndState:false, replacePrevious:true}, STATE_FROM:'0%', STATE_TO:'100%', DIRECTION_UP:'up', DIRECTION_DOWN:'down', DIRECTION_LEFT:'left', DIRECTION_RIGHT:'right', stateNameRegex:/^(?:[\d\.]+)%$/, 
constructor:function() {
  this.states = {};
  this.callParent(arguments);
  return this;
}, applyElement:function(element) {
  return Ext.get(element);
}, applyBefore:function(before, current) {
  if (before) {
    return Ext.factory(before, Ext.fx.State, current);
  }
}, applyAfter:function(after, current) {
  if (after) {
    return Ext.factory(after, Ext.fx.State, current);
  }
}, setFrom:function(from) {
  return this.setState(this.STATE_FROM, from);
}, setTo:function(to) {
  return this.setState(this.STATE_TO, to);
}, getFrom:function() {
  return this.getState(this.STATE_FROM);
}, getTo:function() {
  return this.getState(this.STATE_TO);
}, setStates:function(states) {
  var validNameRegex = this.stateNameRegex, name;
  for (name in states) {
    if (validNameRegex.test(name)) {
      this.setState(name, states[name]);
    }
  }
  return this;
}, getStates:function() {
  return this.states;
}, updateCallback:function(callback) {
  if (callback) {
    this.setOnEnd(callback);
  }
}, end:function() {
  this.stop();
}, stop:function() {
  this.fireEvent('stop', this);
}, destroy:function() {
  this.stop();
  this.callParent();
}, setState:function(name, state) {
  var states = this.getStates(), stateInstance;
  stateInstance = Ext.factory(state, Ext.fx.State, states[name]);
  if (stateInstance) {
    states[name] = stateInstance;
  } else {
    if (name === this.STATE_TO) {
      Ext.Logger.error("Setting and invalid '100%' / 'to' state of: " + state);
    }
  }
  return this;
}, getState:function(name) {
  return this.getStates()[name];
}, getData:function() {
  var me = this, states = me.getStates(), statesData = {}, before = me.getBefore(), after = me.getAfter(), from = states[me.STATE_FROM], to = states[me.STATE_TO], fromData = from.getData(), toData = to.getData(), data, name, state;
  for (name in states) {
    if (states.hasOwnProperty(name)) {
      state = states[name];
      data = state.getData();
      statesData[name] = data;
    }
  }
  return {before:before ? before.getData() : {}, after:after ? after.getData() : {}, states:statesData, from:fromData, to:toData, duration:me.getDuration(), iteration:me.getIteration(), direction:me.getDirection(), easing:me.getEasing(), delay:me.getDelay(), onEnd:me.getOnEnd(), onBeforeEnd:me.getOnBeforeEnd(), onBeforeStart:me.getOnBeforeStart(), scope:me.getScope(), preserveEndState:me.getPreserveEndState(), replacePrevious:me.getReplacePrevious()};
}});
Ext.define('Ext.fx.animation.Slide', {extend:Ext.fx.animation.Abstract, alternateClassName:'Ext.fx.animation.SlideIn', alias:['animation.slide', 'animation.slideIn'], config:{direction:'left', out:false, offset:0, easing:'auto', containerBox:'auto', elementBox:'auto', isElementBoxFit:true, useCssTransform:true}, reverseDirectionMap:{up:'down', down:'up', left:'right', right:'left'}, applyEasing:function(easing) {
  if (easing === 'auto') {
    return 'ease-' + (this.getOut() ? 'in' : 'out');
  }
  return easing;
}, getContainerBox:function() {
  var box = this._containerBox;
  if (box === 'auto') {
    box = this.getElement().getParent().getBox();
  }
  return box;
}, getElementBox:function() {
  var box = this._elementBox;
  if (this.getIsElementBoxFit()) {
    return this.getContainerBox();
  }
  if (box === 'auto') {
    box = this.getElement().getBox();
  }
  return box;
}, getData:function() {
  var elementBox = this.getElementBox(), containerBox = this.getContainerBox(), box = elementBox ? elementBox : containerBox, from = this.getFrom(), to = this.getTo(), out = this.getOut(), offset = this.getOffset(), direction = this.getDirection(), useCssTransform = this.getUseCssTransform(), reverse = this.getReverse(), translateX = 0, translateY = 0, fromX, fromY, toX, toY;
  if (reverse) {
    direction = this.reverseDirectionMap[direction];
  }
  switch(direction) {
    case this.DIRECTION_UP:
      if (out) {
        translateY = containerBox.top - box.top - box.height - offset;
      } else {
        translateY = containerBox.bottom - box.bottom + box.height + offset;
      }
      break;
    case this.DIRECTION_DOWN:
      if (out) {
        translateY = containerBox.bottom - box.bottom + box.height + offset;
      } else {
        translateY = containerBox.top - box.height - box.top - offset;
      }
      break;
    case this.DIRECTION_RIGHT:
      if (out) {
        translateX = containerBox.right - box.right + box.width + offset;
      } else {
        translateX = containerBox.left - box.left - box.width - offset;
      }
      break;
    case this.DIRECTION_LEFT:
      if (out) {
        translateX = containerBox.left - box.left - box.width - offset;
      } else {
        translateX = containerBox.right - box.right + box.width + offset;
      }
      break;
  }
  fromX = out ? 0 : translateX;
  fromY = out ? 0 : translateY;
  if (useCssTransform) {
    from.setTransform({translateX:fromX, translateY:fromY});
  } else {
    from.set('left', fromX);
    from.set('top', fromY);
  }
  toX = out ? translateX : 0;
  toY = out ? translateY : 0;
  if (useCssTransform) {
    to.setTransform({translateX:toX, translateY:toY});
  } else {
    to.set('left', toX);
    to.set('top', toY);
  }
  return this.callParent(arguments);
}});
Ext.define('Ext.fx.animation.SlideOut', {extend:Ext.fx.animation.Slide, alias:['animation.slideOut'], config:{out:true}});
Ext.define('Ext.fx.animation.Fade', {extend:Ext.fx.animation.Abstract, alternateClassName:'Ext.fx.animation.FadeIn', alias:['animation.fade', 'animation.fadeIn'], config:{out:false, before:{display:null, opacity:0}, after:{opacity:null}, reverse:null}, updateOut:function(newOut) {
  var to = this.getTo(), from = this.getFrom();
  if (newOut) {
    from.set('opacity', 1);
    to.set('opacity', 0);
  } else {
    from.set('opacity', 0);
    to.set('opacity', 1);
  }
}});
Ext.define('Ext.fx.animation.FadeOut', {extend:Ext.fx.animation.Fade, alias:'animation.fadeOut', config:{out:true, before:{}}});
Ext.define('Ext.fx.animation.Flip', {extend:Ext.fx.animation.Abstract, alias:'animation.flip', config:{easing:'ease-in', direction:'right', half:false, out:null}, getData:function() {
  var me = this, from = me.getFrom(), to = me.getTo(), direction = me.getDirection(), out = me.getOut(), half = me.getHalf(), rotate = half ? 90 : 180, fromScale = 1, toScale = 1, fromRotateX = 0, fromRotateY = 0, toRotateX = 0, toRotateY = 0;
  if (out) {
    toScale = 0.8;
  } else {
    fromScale = 0.8;
  }
  switch(direction) {
    case this.DIRECTION_UP:
      if (out) {
        toRotateX = rotate;
      } else {
        fromRotateX = -rotate;
      }
      break;
    case this.DIRECTION_DOWN:
      if (out) {
        toRotateX = -rotate;
      } else {
        fromRotateX = rotate;
      }
      break;
    case this.DIRECTION_RIGHT:
      if (out) {
        toRotateY = rotate;
      } else {
        fromRotateY = -rotate;
      }
      break;
    case this.DIRECTION_LEFT:
      if (out) {
        toRotateY = -rotate;
      } else {
        fromRotateY = rotate;
      }
      break;
  }
  from.setTransform({rotateX:fromRotateX, rotateY:fromRotateY, scale:fromScale});
  to.setTransform({rotateX:toRotateX, rotateY:toRotateY, scale:toScale});
  return this.callParent();
}});
Ext.define('Ext.fx.animation.Pop', {extend:Ext.fx.animation.Abstract, alias:['animation.pop', 'animation.popIn'], alternateClassName:'Ext.fx.animation.PopIn', config:{out:false, before:{display:null, opacity:0}, after:{opacity:null}}, getData:function() {
  var to = this.getTo(), from = this.getFrom(), out = this.getOut();
  if (out) {
    from.set('opacity', 1);
    from.setTransform({scale:1});
    to.set('opacity', 0);
    to.setTransform({scale:0});
  } else {
    from.set('opacity', 0);
    from.setTransform({scale:0});
    to.set('opacity', 1);
    to.setTransform({scale:1});
  }
  return this.callParent(arguments);
}});
Ext.define('Ext.fx.animation.PopOut', {extend:Ext.fx.animation.Pop, alias:'animation.popOut', config:{out:true, before:{}}});
Ext.define('Ext.fx.Animation', {constructor:function(config) {
  var defaultClass = Ext.fx.animation.Abstract, type;
  if (typeof config == 'string') {
    type = config;
    config = {};
  } else {
    if (config && config.type) {
      type = config.type;
    }
  }
  if (type) {
    defaultClass = Ext.ClassManager.getByAlias('animation.' + type);
    if (!defaultClass) {
      Ext.Logger.error("Invalid animation type of: '" + type + "'");
    }
  }
  return Ext.factory(config, defaultClass);
}});
Ext.define('Ext.fx.layout.card.Style', {extend:Ext.fx.layout.card.Abstract, config:{inAnimation:{before:{visibility:null}, preserveEndState:false, replacePrevious:true}, outAnimation:{preserveEndState:false, replacePrevious:true}}, constructor:function(config) {
  var inAnimation, outAnimation;
  this.callParent([config]);
  this.endAnimationCounter = 0;
  inAnimation = this.getInAnimation();
  outAnimation = this.getOutAnimation();
  inAnimation.on('animationend', 'incrementEnd', this);
  outAnimation.on('animationend', 'incrementEnd', this);
}, updateDirection:function(direction) {
  this.getInAnimation().setDirection(direction);
  this.getOutAnimation().setDirection(direction);
}, updateDuration:function(duration) {
  this.getInAnimation().setDuration(duration);
  this.getOutAnimation().setDuration(duration);
}, updateReverse:function(reverse) {
  this.getInAnimation().setReverse(reverse);
  this.getOutAnimation().setReverse(reverse);
}, incrementEnd:function() {
  this.endAnimationCounter++;
  if (this.endAnimationCounter > 1) {
    this.endAnimationCounter = 0;
    this.fireEvent('animationend', this);
  }
}, applyInAnimation:function(animation, inAnimation) {
  return Ext.factory(animation, Ext.fx.Animation, inAnimation);
}, applyOutAnimation:function(animation, outAnimation) {
  return Ext.factory(animation, Ext.fx.Animation, outAnimation);
}, updateInAnimation:function(animation) {
  animation.setScope(this);
}, updateOutAnimation:function(animation) {
  animation.setScope(this);
}, onActiveItemChange:function(cardLayout, newItem, oldItem, controller) {
  var inAnimation = this.getInAnimation(), outAnimation = this.getOutAnimation(), inElement, outElement;
  if (newItem && oldItem && oldItem.isPainted()) {
    inElement = newItem.renderElement;
    outElement = oldItem.renderElement;
    inAnimation.setElement(inElement);
    outAnimation.setElement(outElement);
    outAnimation.setOnEnd(function() {
      controller.resume();
    });
    inElement.dom.style.setProperty('visibility', 'hidden', 'important');
    newItem.show();
    Ext.Animator.run([outAnimation, inAnimation]);
    controller.pause();
  }
}, destroy:function() {
  Ext.destroy(this.getInAnimation(), this.getOutAnimation());
  this.callParent();
}});
Ext.define('Ext.fx.layout.card.Slide', {extend:Ext.fx.layout.card.Style, alias:'fx.layout.card.slide', config:{inAnimation:{type:'slide', easing:'ease-out'}, outAnimation:{type:'slide', easing:'ease-out', out:true}}, updateReverse:function(reverse) {
  this.getInAnimation().setReverse(reverse);
  this.getOutAnimation().setReverse(reverse);
}});
Ext.define('Ext.fx.layout.card.Cover', {extend:Ext.fx.layout.card.Style, alias:'fx.layout.card.cover', config:{reverse:null, inAnimation:{before:{'z-index':100}, after:{'z-index':0}, type:'slide', easing:'ease-out'}, outAnimation:{easing:'ease-out', from:{opacity:0.99}, to:{opacity:1}, out:true}}, updateReverse:function(reverse) {
  this.getInAnimation().setReverse(reverse);
  this.getOutAnimation().setReverse(reverse);
}});
Ext.define('Ext.fx.layout.card.Reveal', {extend:Ext.fx.layout.card.Style, alias:'fx.layout.card.reveal', config:{inAnimation:{easing:'ease-out', from:{opacity:0.99}, to:{opacity:1}}, outAnimation:{before:{'z-index':100}, after:{'z-index':0}, type:'slide', easing:'ease-out', out:true}}, updateReverse:function(reverse) {
  this.getInAnimation().setReverse(reverse);
  this.getOutAnimation().setReverse(reverse);
}});
Ext.define('Ext.fx.layout.card.Fade', {extend:Ext.fx.layout.card.Style, alias:'fx.layout.card.fade', config:{reverse:null, inAnimation:{type:'fade', easing:'ease-out'}, outAnimation:{type:'fade', easing:'ease-out', out:true}}});
Ext.define('Ext.fx.layout.card.Flip', {extend:Ext.fx.layout.card.Style, alias:'fx.layout.card.flip', config:{duration:500, inAnimation:{type:'flip', half:true, easing:'ease-out', before:{'backface-visibility':'hidden'}, after:{'backface-visibility':null}}, outAnimation:{type:'flip', half:true, easing:'ease-in', before:{'backface-visibility':'hidden'}, after:{'backface-visibility':null}, out:true}}, onActiveItemChange:function(cardLayout, newItem, oldItem, controller) {
  var parent = newItem.element.getParent();
  parent.addCls(Ext.baseCSSPrefix + 'layout-card-perspective');
  this.on('animationend', function() {
    parent.removeCls(Ext.baseCSSPrefix + 'layout-card-perspective');
  }, this, {single:true});
  this.callParent(arguments);
}, updateDuration:function(duration) {
  var halfDuration = duration / 2, inAnimation = this.getInAnimation(), outAnimation = this.getOutAnimation();
  inAnimation.setDelay(halfDuration);
  inAnimation.setDuration(halfDuration);
  outAnimation.setDuration(halfDuration);
}});
Ext.define('Ext.fx.layout.card.Pop', {extend:Ext.fx.layout.card.Style, alias:'fx.layout.card.pop', config:{duration:500, inAnimation:{type:'pop', easing:'ease-out'}, outAnimation:{type:'pop', easing:'ease-in', out:true}}, updateDuration:function(duration) {
  var halfDuration = duration / 2, inAnimation = this.getInAnimation(), outAnimation = this.getOutAnimation();
  inAnimation.setDelay(halfDuration);
  inAnimation.setDuration(halfDuration);
  outAnimation.setDuration(halfDuration);
}});
Ext.define('Ext.fx.layout.card.Scroll', {extend:Ext.fx.layout.card.Abstract, alias:'fx.layout.card.scroll', config:{duration:150}, constructor:function(config) {
  this.initConfig(config);
}, getEasing:function() {
  var easing = this.easing;
  if (!easing) {
    this.easing = easing = new Ext.fx.easing.Linear;
  }
  return easing;
}, updateDuration:function(duration) {
  this.getEasing().setDuration(duration);
}, onActiveItemChange:function(cardLayout, newItem, oldItem, controller) {
  var direction = this.getDirection(), easing = this.getEasing(), containerElement, inElement, outElement, containerWidth, containerHeight, reverse;
  if (newItem && oldItem) {
    if (this.isAnimating) {
      this.stopAnimation();
    }
    newItem.setWidth('100%');
    newItem.setHeight('100%');
    containerElement = this.getLayout().container.innerElement;
    containerWidth = containerElement.getWidth();
    containerHeight = containerElement.getHeight();
    inElement = newItem.renderElement;
    outElement = oldItem.renderElement;
    this.oldItem = oldItem;
    this.newItem = newItem;
    this.containerElement = containerElement;
    this.currentEventController = controller;
    this.isReverse = reverse = this.getReverse();
    newItem.show();
    if (direction == 'right') {
      direction = 'left';
      this.isReverse = reverse = !reverse;
    } else {
      if (direction == 'down') {
        direction = 'up';
        this.isReverse = reverse = !reverse;
      }
    }
    if (direction == 'left') {
      if (reverse) {
        easing.setConfig({startValue:containerWidth, endValue:0});
        containerElement.dom.scrollLeft = containerWidth;
        outElement.setLeft(containerWidth);
      } else {
        easing.setConfig({startValue:0, endValue:containerWidth});
        inElement.setLeft(containerWidth);
      }
    } else {
      if (reverse) {
        easing.setConfig({startValue:containerHeight, endValue:0});
        containerElement.dom.scrollTop = containerHeight;
        outElement.setTop(containerHeight);
      } else {
        easing.setConfig({startValue:0, endValue:containerHeight});
        inElement.setTop(containerHeight);
      }
    }
    this.startAnimation();
    controller.pause();
  }
}, startAnimation:function() {
  this.isAnimating = true;
  this.getEasing().setStartTime(Date.now());
  Ext.AnimationQueue.start(this.doAnimationFrame, this);
}, doAnimationFrame:function() {
  var easing = this.getEasing(), direction = this.getDirection(), scroll = 'scrollTop', value;
  if (direction == 'left' || direction == 'right') {
    scroll = 'scrollLeft';
  }
  if (easing.isEnded) {
    this.stopAnimation();
  } else {
    value = easing.getValue();
    this.containerElement.dom[scroll] = value;
  }
}, stopAnimation:function() {
  var me = this, direction = me.getDirection(), scroll = 'setTop', oldItem = me.oldItem, newItem = me.newItem;
  if (direction == 'left' || direction == 'right') {
    scroll = 'setLeft';
  }
  me.currentEventController.resume();
  if (me.isReverse && oldItem && oldItem.renderElement && oldItem.renderElement.dom) {
    oldItem.renderElement[scroll](null);
  } else {
    if (newItem && newItem.renderElement && newItem.renderElement.dom) {
      newItem.renderElement[scroll](null);
    }
  }
  Ext.AnimationQueue.stop(this.doAnimationFrame, this);
  me.isAnimating = false;
  me.fireEvent('animationend', me);
}});
Ext.define('Ext.fx.layout.Card', {constructor:function(config) {
  var defaultClass = Ext.fx.layout.card.Abstract, type;
  if (!config) {
    return null;
  }
  if (typeof config == 'string') {
    type = config;
    config = {};
  } else {
    if (config.type) {
      type = config.type;
    }
  }
  config.elementBox = false;
  if (type) {
    defaultClass = Ext.ClassManager.getByAlias('fx.layout.card.' + type);
    if (!defaultClass) {
      Ext.Logger.error("Unknown card animation type: '" + type + "'");
    }
  }
  return Ext.factory(config, defaultClass);
}});
Ext.define('Ext.layout.Card', {extend:Ext.layout.Default, alias:'layout.card', isCard:true, layoutClass:Ext.baseCSSPrefix + 'layout-card', itemClass:Ext.baseCSSPrefix + 'layout-card-item', applyAnimation:function(animation) {
  return new Ext.fx.layout.Card(animation);
}, updateAnimation:function(animation, oldAnimation) {
  if (animation && animation.isAnimation) {
    animation.setLayout(this);
  }
  if (oldAnimation) {
    oldAnimation.destroy();
  }
}, setContainer:function(container) {
  this.callParent(arguments);
  container.innerElement.addCls(this.layoutClass);
  container.onInitialized('onContainerInitialized', this);
}, onContainerInitialized:function() {
  var me = this, container = me.container, firstItem = container.getInnerAt(0), activeItem = container.getActiveItem();
  me.callParent();
  if (activeItem) {
    activeItem.show();
    if (firstItem && firstItem !== activeItem) {
      firstItem.hide();
    }
  }
  container.on('activeitemchange', 'onContainerActiveItemChange', me);
}, onContainerActiveItemChange:function(container, newItem, oldItem) {
  this.fireEventedAction('activeitemchange', [this, newItem, oldItem], 'doActiveItemChange', this);
}, onItemInnerStateChange:function(item, isInner, destroying) {
  this.callParent(arguments);
  var container = this.container, activeItem = container.getActiveItem();
  item.toggleCls(this.itemClass, isInner);
  item.setLayoutSizeFlags(isInner ? container.LAYOUT_BOTH : 0);
  if (isInner) {
    if (activeItem !== container.innerIndexOf(item) && activeItem !== item && item !== container.pendingActiveItem) {
      item.hide();
    }
  } else {
    if (!destroying && !item.destroyed && item.destroying !== true) {
      item.show();
    }
  }
}, doActiveItemChange:function(me, newActiveItem, oldActiveItem) {
  if (oldActiveItem) {
    oldActiveItem.hide();
  }
  if (newActiveItem) {
    newActiveItem.show();
  }
}, destroy:function() {
  this.callParent();
  Ext.destroy(this.getAnimation());
}});
Ext.define('Ext.layout.Fit', {extend:Ext.layout.Default, isFit:true, alias:'layout.fit', layoutClass:'x-layout-fit', itemClass:'x-layout-fit-item', setContainer:function(container) {
  this.callParent(arguments);
  container.innerElement.addCls(this.layoutClass);
  this.onContainerSizeFlagsChange();
  this.monitorSizeFlagsChange();
}, onContainerSizeFlagsChange:function() {
  var container = this.container, sizeFlags = container.getSizeFlags(), stretched = Boolean(sizeFlags & container.LAYOUT_STRETCHED), innerItems = container.innerItems, i, ln, item;
  this.callParent();
  for (i = 0, ln = innerItems.length; i < ln; i++) {
    item = innerItems[i];
    item.setLayoutSizeFlags(sizeFlags);
  }
  container.innerElement.toggleCls('x-stretched', stretched);
}, onItemInnerStateChange:function(item, isInner) {
  this.callParent(arguments);
  item.toggleCls(this.itemClass, isInner);
  item.setLayoutSizeFlags(isInner ? this.container.getSizeFlags() : 0);
}});
Ext.define('Ext.layout.FlexBox', {extend:Ext.layout.Box, alias:'layout.box', config:{align:'stretch'}, layoutBaseClass:'x-layout-box', itemClass:'x-layout-box-item', setContainer:function(container) {
  this.callParent(arguments);
  this.monitorSizeFlagsChange();
}, applyOrient:function(orient) {
  if (orient !== 'horizontal' && orient !== 'vertical') {
    Ext.Logger.error("Invalid box orient of: '" + orient + "', must be either 'horizontal' or 'vertical'");
  }
  return orient;
}, updateOrient:function(orient, oldOrient) {
  var container = this.container, delegation = {delegate:'\x3e component'};
  if (orient === 'horizontal') {
    this.sizePropertyName = 'width';
  } else {
    this.sizePropertyName = 'height';
  }
  container.innerElement.swapCls('x-' + orient, 'x-' + oldOrient);
  if (oldOrient) {
    container.un(oldOrient === 'horizontal' ? 'widthchange' : 'heightchange', 'onItemSizeChange', this, delegation);
    this.redrawContainer();
  }
  container.on(orient === 'horizontal' ? 'widthchange' : 'heightchange', 'onItemSizeChange', this, delegation);
}, onItemInnerStateChange:function(item, isInner) {
  this.callParent(arguments);
  var flex, size;
  item.toggleCls(this.itemClass, isInner);
  if (isInner) {
    flex = item.getFlex();
    size = item.getConfig(this.sizePropertyName);
    if (flex) {
      this.doItemFlexChange(item, flex);
    } else {
      if (size) {
        this.doItemSizeChange(item, size);
      }
    }
  }
  this.refreshItemSizeState(item);
}, refreshItemSizeState:function(item) {
  var isInner = item.isInnerItem(), container = this.container, LAYOUT_HEIGHT = container.LAYOUT_HEIGHT, LAYOUT_WIDTH = container.LAYOUT_WIDTH, dimension = this.sizePropertyName, layoutSizeFlags = 0, containerSizeFlags = container.getSizeFlags();
  if (isInner) {
    layoutSizeFlags |= container.LAYOUT_STRETCHED;
    if (this.getAlign() === 'stretch') {
      layoutSizeFlags |= containerSizeFlags & (dimension === 'width' ? LAYOUT_HEIGHT : LAYOUT_WIDTH);
    }
    if (item.getFlex()) {
      layoutSizeFlags |= containerSizeFlags & (dimension === 'width' ? LAYOUT_WIDTH : LAYOUT_HEIGHT);
    }
  }
  item.setLayoutSizeFlags(layoutSizeFlags);
}, refreshAllItemSizedStates:function() {
  var innerItems = this.container.innerItems, i, ln, item;
  for (i = 0, ln = innerItems.length; i < ln; i++) {
    item = innerItems[i];
    this.refreshItemSizeState(item);
  }
}, onContainerSizeFlagsChange:function() {
  this.refreshAllItemSizedStates();
  this.callParent(arguments);
}, onItemSizeChange:function(item, size) {
  if (item.isInnerItem()) {
    this.doItemSizeChange(item, size);
  }
}, doItemSizeChange:function(item, size) {
  if (size) {
    item.setFlex(null);
    this.redrawContainer();
  }
}, onItemFlexChange:function(item, flex) {
  if (item.isInnerItem()) {
    this.doItemFlexChange(item, flex);
    this.refreshItemSizeState(item);
  }
}, doItemFlexChange:function(item, flex) {
  this.setItemFlex(item, flex);
  if (flex) {
    item.setConfig(this.sizePropertyName, null);
  } else {
    this.redrawContainer();
  }
}, redrawContainer:function() {
  var container = this.container, renderedTo = container.element.dom.parentNode;
  if (renderedTo && renderedTo.nodeType !== 11) {
    container.innerElement.redraw();
  }
}, setItemFlex:function(item, flex) {
  var element = item.element, style = element.dom.style;
  element.toggleCls(Ext.baseCSSPrefix + 'flexed', !!flex);
  flex = flex ? String(flex) : '';
  if (Ext.browser.is.WebKit) {
    style.setProperty('-webkit-box-flex', flex, null);
  } else {
    if (Ext.browser.is.IE) {
      style.setProperty('-ms-flex', flex + ' 0 0px', null);
    } else {
      style.setProperty('flex', flex + ' 0 0px', null);
    }
  }
}, convertPosition:function(position) {
  var positionMap = this.positionMap;
  if (positionMap.hasOwnProperty(position)) {
    return positionMap[position];
  }
  return position;
}, applyAlign:function(align) {
  return this.convertPosition(align);
}, updateAlign:function(align, oldAlign) {
  var container = this.container;
  container.innerElement.swapCls(align, oldAlign, true, 'x-align');
  if (oldAlign !== undefined) {
    this.refreshAllItemSizedStates();
  }
}, applyPack:function(pack) {
  return this.convertPosition(pack);
}, updatePack:function(pack, oldPack) {
  this.container.innerElement.swapCls(pack, oldPack, true, 'x-pack');
}});
Ext.define('Ext.layout.Float', {extend:Ext.layout.Default, alias:'layout.float', config:{direction:'left'}, layoutClass:'layout-float', itemClass:'layout-float-item', setContainer:function(container) {
  this.callParent(arguments);
  container.innerElement.addCls(this.layoutClass);
}, onItemInnerStateChange:function(item, isInner) {
  this.callParent(arguments);
  item.toggleCls(this.itemClass, isInner);
}, updateDirection:function(direction, oldDirection) {
  var prefix = 'direction-';
  this.container.innerElement.swapCls(prefix + direction, prefix + oldDirection);
}});
Ext.define('Ext.layout.HBox', {extend:Ext.layout.FlexBox, alias:'layout.hbox'});
Ext.define('Ext.layout.VBox', {extend:Ext.layout.FlexBox, alias:'layout.vbox', config:{orient:'vertical'}});
Ext.define('Ext.layout.wrapper.Dock', {config:{direction:'horizontal', element:{className:'x-dock'}, bodyElement:{className:'x-dock-body'}, innerWrapper:null, sizeState:false, container:null}, positionMap:{top:'start', left:'start', bottom:'end', right:'end'}, constructor:function(config) {
  this.items = {start:[], end:[]};
  this.itemsCount = 0;
  this.initConfig(config);
}, addItems:function(items) {
  var i, ln, item;
  for (i = 0, ln = items.length; i < ln; i++) {
    item = items[i];
    this.addItem(item);
  }
}, addItem:function(item) {
  var docked = item.getDocked(), position = this.positionMap[docked], wrapper = item.$dockWrapper, container = this.getContainer(), index = container.indexOf(item), items = this.items, sideItems = items[position], itemWrapper, element, i, ln, sibling, referenceElement, siblingIndex;
  if (wrapper) {
    wrapper.removeItem(item);
  }
  item.$dockWrapper = this;
  itemWrapper = item.link('$dockItemWrapper', new Ext.util.Wrapper({className:'x-dock-item'}));
  item.addCls('x-docked-' + docked);
  element = itemWrapper.element;
  for (i = 0, ln = sideItems.length; i < ln; i++) {
    sibling = sideItems[i];
    siblingIndex = container.indexOf(sibling);
    if (siblingIndex > index) {
      referenceElement = sibling.element;
      sideItems.splice(i, 0, item);
      break;
    }
  }
  if (!referenceElement) {
    sideItems.push(item);
    referenceElement = this.getBodyElement();
  }
  this.itemsCount++;
  if (position === 'start') {
    element.insertBefore(referenceElement);
  } else {
    element.insertAfter(referenceElement);
  }
  itemWrapper.wrap(item.element);
  itemWrapper.bindSize(this.getDirection() === 'horizontal' ? 'width' : 'height');
}, removeItem:function(item) {
  var position = item.getDocked(), items = this.items[this.positionMap[position]];
  item.removeCls('x-docked-' + position);
  Ext.Array.remove(items, item);
  item.unlink(['$dockItemWrapper']);
  item.element.detach();
  delete item.$dockWrapper;
  if (--this.itemsCount === 0) {
    this.destroy();
  }
}, getItemsSlice:function(index) {
  var container = this.getContainer(), items = this.items, slice = [], sideItems, i, ln, item;
  for (sideItems = items.start, i = 0, ln = sideItems.length; i < ln; i++) {
    item = sideItems[i];
    if (container.indexOf(item) > index) {
      slice.push(item);
    }
  }
  for (sideItems = items.end, i = 0, ln = sideItems.length; i < ln; i++) {
    item = sideItems[i];
    if (container.indexOf(item) > index) {
      slice.push(item);
    }
  }
  return slice;
}, applyElement:function(element) {
  return Ext.Element.create(element);
}, updateElement:function(element) {
  element.addCls('x-dock-' + this.getDirection());
}, applyBodyElement:function(bodyElement) {
  return Ext.Element.create(bodyElement);
}, updateBodyElement:function(bodyElement) {
  this.getElement().append(bodyElement);
}, updateInnerWrapper:function(innerWrapper, oldInnerWrapper) {
  var innerElement = this.getBodyElement();
  if (oldInnerWrapper && oldInnerWrapper.$outerWrapper === this) {
    innerElement.remove(oldInnerWrapper.getElement());
    delete oldInnerWrapper.$outerWrapper;
  }
  if (innerWrapper) {
    innerWrapper.setSizeState(this.getSizeState());
    innerWrapper.$outerWrapper = this;
    innerElement.append(innerWrapper.getElement());
  }
}, updateSizeState:function(state) {
  var innerWrapper = this.getInnerWrapper();
  this.getElement().setSizeState(state);
  if (innerWrapper) {
    innerWrapper.setSizeState(state);
  }
}, destroy:function() {
  var me = this, innerWrapper = me.getInnerWrapper(), outerWrapper = me.$outerWrapper;
  if (innerWrapper) {
    if (outerWrapper) {
      outerWrapper.setInnerWrapper(innerWrapper);
    } else {
      innerWrapper.getElement().replace(me.getElement());
      delete innerWrapper.$outerWrapper;
    }
  }
  delete me.$outerWrapper;
  me.setInnerWrapper(null);
  me.unlink(['_bodyElement', '_element']);
  me.callParent();
}});
Ext.define('Ext.util.ItemCollection', {extend:Ext.util.MixedCollection, alternateClassName:'Ext.ItemCollection', getKey:function(item) {
  return item.getItemId && item.getItemId();
}, has:function(item) {
  return this.map.hasOwnProperty(item.getId());
}});
Ext.define('Ext.util.InputBlocker', {singleton:true, blockInputs:function() {
  if (Ext.browser.is.ie) {
    Ext.select('.x-field-text .x-field-input:not(.x-item-disabled) .x-input-el, .x-field-textarea .x-field-input:not(.x-item-disabled) .x-input-el, .x-field-search .x-field-input:not(.x-item-disabled) .x-input-el').each(function(item) {
      if (item.dom.offsetWidth > 0) {
        item.dom.setAttribute('disabled', true);
        item.dom.setAttribute('overlayfix', true);
      }
    });
  }
}, unblockInputs:function() {
  if (Ext.browser.is.ie) {
    Ext.select('[overlayfix]').each(function(item) {
      item.dom.removeAttribute('disabled');
      item.dom.removeAttribute('overlayfix');
    });
  }
}});
Ext.define('Ext.Mask', {extend:Ext.Component, xtype:'mask', config:{baseCls:Ext.baseCSSPrefix + 'mask', transparent:false, top:0, left:0, right:0, bottom:0}, initialize:function() {
  var me = this;
  me.callParent();
  me.element.on('tap', 'onTap', me);
  me.on('hide', 'onHide', me);
}, onHide:function() {
  Ext.util.InputBlocker.unblockInputs();
  if (Ext.browser.is.AndroidStock4 && Ext.os.version.getMinor() === 0) {
    var firstChild = this.element.getFirstChild();
    if (firstChild) {
      firstChild.redraw();
    }
  }
}, onTap:function(e) {
  this.fireEvent('tap', this, e);
}, updateTransparent:function(transparent) {
  this.toggleCls(this.getBaseCls() + '-transparent', transparent);
}});
Ext.define('Ext.mixin.Queryable', {mixinId:'queryable', isQueryable:true, query:function(selector) {
  selector = selector || '*';
  return Ext.ComponentQuery.query(selector, this.getQueryRoot());
}, queryBy:function(fn, scope) {
  var out = [], items = this.getQueryRoot().getRefItems(true), i = 0, len = items.length, item;
  for (; i < len; ++i) {
    item = items[i];
    if (fn.call(scope || item, item) !== false) {
      out.push(item);
    }
  }
  return out;
}, queryById:function(id) {
  return this.down(Ext.makeIdSelector(id));
}, child:function(selector) {
  var children = this.getQueryRoot().getRefItems();
  if (selector && selector.isComponent) {
    return this.matchById(children, selector.getItemId());
  }
  if (selector) {
    children = Ext.ComponentQuery.query(selector, children);
  }
  if (children.length) {
    return children[0];
  }
  return null;
}, down:function(selector) {
  if (selector && selector.isComponent) {
    return this.matchById(this.getRefItems(true), selector.getItemId());
  }
  selector = selector || '';
  return this.query(selector)[0] || null;
}, visitPreOrder:function(selector, fn, scope, extraArgs) {
  Ext.ComponentQuery._visit(true, selector, this.getQueryRoot(), fn, scope, extraArgs);
}, visitPostOrder:function(selector, fn, scope, extraArgs) {
  Ext.ComponentQuery._visit(false, selector, this.getQueryRoot(), fn, scope, extraArgs);
}, getRefItems:function() {
  return [];
}, getQueryRoot:function() {
  return this;
}, privates:{matchById:function(items, id) {
  var len = items.length, i, item;
  for (i = 0; i < len; ++i) {
    item = items[i];
    if (item.getItemId() === id) {
      return item;
    }
  }
  return null;
}}});
Ext.define('Ext.mixin.Container', {extend:Ext.Mixin, mixinConfig:{id:'container'}, isContainer:true, config:{referenceHolder:false}, getReferences:function() {
  Ext.ComponentManager.fixReferences();
  return this.refs || null;
}, lookup:function(key) {
  var refs = this.getReferences();
  return refs && refs[key] || null;
}, lookupReference:function(key) {
  return this.lookup(key);
}, privates:{attachReference:function(component) {
  var me = this, key, refs;
  if (me.destroying || me.destroyed) {
    return;
  }
  refs = me.refs || (me.refs = {});
  key = component.referenceKey;
  if (refs[key] && refs[key] !== component) {
    Ext.log.warn('Duplicate reference: "' + key + '" on ' + me.id);
  }
  refs[key] = component;
}, clearReference:function(component) {
  var refs = this.refs, key = component.referenceKey;
  if (refs && key) {
    component.viewModelKey = component.referenceKey = refs[key] = null;
  }
}, containerOnAdded:function(component, instanced) {
  if (instanced) {
    Ext.ComponentManager.markReferencesDirty();
  }
}, containerOnRemoved:function(destroying) {
  var refHolder;
  if (!destroying) {
    refHolder = this.lookupReferenceHolder();
    if (refHolder) {
      Ext.ComponentManager.markReferencesDirty();
      refHolder.clearReferences();
    }
  }
}, clearReferences:function() {
  this.refs = null;
}, initContainerInheritedState:function(inheritedState, inheritedStateInner) {
  var me = this, controller = me.getController(), session = me.getSession(), viewModel = me.getConfig('viewModel', true), reference = me.getReference(), referenceHolder = me.getReferenceHolder();
  if (controller) {
    inheritedState.referenceHolder = controller;
    referenceHolder = true;
  } else {
    if (referenceHolder) {
      inheritedState.referenceHolder = me;
    }
  }
  if (referenceHolder) {
    inheritedState.referencePath = '';
  } else {
    if (reference && me.isParentReference) {
      inheritedState.referencePath = me.referenceKey + '.';
    }
  }
  if (session) {
    inheritedState.session = session;
  }
  if (viewModel) {
    inheritedState.viewModelPath = '';
  } else {
    if (reference && me.isParentReference) {
      inheritedState.viewModelPath = me.viewModelKey + '.';
    }
  }
}, setupReference:function(reference) {
  var len;
  if (reference && reference.charAt(len = reference.length - 1) === '\x3e') {
    this.isParentReference = true;
    reference = reference.substring(0, len);
  }
  if (reference && !Ext.validIdRe.test(reference)) {
    Ext.Error.raise('Invalid reference "' + reference + '" for ' + this.getId() + ' - not a valid identifier');
  }
  return reference;
}}});
Ext.define('Ext.Container', {extend:Ext.Component, alternateClassName:['Ext.lib.Container', 'Ext.container.Container'], xtype:'container', mixins:[Ext.mixin.Queryable, Ext.mixin.Container], eventedConfig:{activeItem:0}, config:{layout:'default', control:{}, defaults:null, items:null, autoDestroy:true, defaultType:null, masked:null, modal:null, hideOnMaskTap:null}, manageBorders:false, constructor:function(config) {
  var me = this;
  me._items = me.items = new Ext.util.ItemCollection;
  me.innerItems = [];
  me.getReferences = me.getFirstReferences;
  me.onItemAdd = me.onFirstItemAdd;
  me.callParent(arguments);
  delete me.getReferences;
  if (me.manageBorders) {
    me.element.addCls('x-managed-borders');
  }
}, initialize:function() {
  this.callParent();
  this.getLayout();
}, getElementConfig:function() {
  return {reference:'element', classList:['x-container', 'x-unsized'], children:[{reference:'innerElement', className:'x-inner'}]};
}, applyMasked:function(masked) {
  var isVisible = true, currentMask;
  if (masked === false) {
    masked = true;
    isVisible = false;
  }
  currentMask = Ext.factory(masked, Ext.Mask, this.getMasked());
  if (currentMask) {
    this.add(currentMask);
    currentMask.setHidden(!isVisible);
  }
  return currentMask;
}, mask:function(mask) {
  this.setMasked(mask || true);
}, unmask:function() {
  this.setMasked(false);
}, initInheritedState:function(inheritedState, inheritedStateInner) {
  this.callParent([inheritedState, inheritedStateInner]);
  this.initContainerInheritedState(inheritedState, inheritedStateInner);
}, onAdded:function(parent, instanced) {
  var me = this, modal;
  me.callParent([parent, instanced]);
  me.containerOnAdded(parent, instanced);
  modal = me.getModal();
  if (modal) {
    parent.insertBefore(modal, me);
    modal.setZIndex(me.getZIndex() - 1);
  }
}, onRemoved:function(destroying) {
  this.containerOnRemoved(destroying);
  this.callParent([destroying]);
}, applyModal:function(modal, currentModal) {
  var isVisible = true;
  if (modal === false) {
    modal = true;
    isVisible = false;
  }
  currentModal = Ext.factory(modal, Ext.Mask, currentModal);
  if (currentModal) {
    currentModal.setVisibility(isVisible);
  }
  return currentModal;
}, updateModal:function(modal) {
  var container = this.getParent();
  if (container) {
    if (modal) {
      container.insertBefore(modal, this);
      modal.setZIndex(this.getZIndex() - 1);
    } else {
      container.remove(modal);
    }
  }
}, updateHideOnMaskTap:function(hide) {
  var mask = this.getModal();
  if (mask) {
    mask[hide ? 'on' : 'un'].call(mask, 'tap', 'hide', this);
  }
}, updateZIndex:function(zIndex) {
  var modal = this.getModal();
  this.callParent(arguments);
  if (modal) {
    modal.setZIndex(zIndex - 1);
  }
}, updateBaseCls:function(newBaseCls, oldBaseCls) {
  var me = this, element = me.element, ui = me.getUi();
  if (oldBaseCls) {
    element.removeCls(oldBaseCls);
    me.innerElement.removeCls(newBaseCls, null, 'inner');
    if (ui) {
      element.removeCls(me.currentUi);
    }
  }
  if (newBaseCls) {
    element.addCls(newBaseCls);
    me.innerElement.addCls(newBaseCls, null, 'inner');
    if (ui) {
      element.addCls(newBaseCls, null, ui);
      me.currentUi = newBaseCls + '-' + ui;
    }
  }
}, applyItems:function(items, collection) {
  if (items) {
    var me = this, activeItem;
    me.getDefaultType();
    me.getDefaults();
    if (me.initialized && collection.length > 0) {
      me.removeAll();
    }
    me.add(items);
    if (me.initialized) {
      activeItem = me.initialConfig.activeItem || me.config.activeItem || 0;
      me.setActiveItem(activeItem);
    }
  }
}, applyControl:function(selectors) {
  var selector, key, listener, listeners;
  for (selector in selectors) {
    listeners = selectors[selector];
    for (key in listeners) {
      listener = listeners[key];
      if (Ext.isObject(listener)) {
        listener.delegate = selector;
      }
    }
    listeners.delegate = selector;
    this.addListener(listeners);
  }
  return selectors;
}, onFirstItemAdd:function() {
  var me = this;
  delete me.onItemAdd;
  if (me.innerHtmlElement && !me.getHtml()) {
    me.innerHtmlElement.destroy();
    delete me.innerHtmlElement;
  }
  me.on('innerstatechange', 'onItemInnerStateChange', me, {delegate:'\x3e component'});
  return me.onItemAdd.apply(me, arguments);
}, updateLayout:function(newLayout, oldLayout) {
  if (!oldLayout || !oldLayout.isLayout) {
    return;
  }
  if (!oldLayout.isCompatible(newLayout)) {
    Ext.Logger.error('Replacing a layout after one has already been initialized is not supported. ' + this.$className + '#' + this.getId() + ' (' + oldLayout.$className + ' / ' + (Ext.isString(newLayout) ? newLayout : JSON.stringify(newLayout)) + ')');
  }
}, getLayout:function() {
  var layout = this.layout;
  if (!(layout && layout.isLayout)) {
    layout = this.link('_layout', this.link('layout', Ext.factory(this._layout || 'default', Ext.layout.Default, null, 'layout')));
    layout.setContainer(this);
  }
  return layout;
}, updateDefaultType:function(defaultType) {
  this.defaultItemClass = Ext.ClassManager.getByAlias('widget.' + defaultType);
  if (!this.defaultItemClass) {
    Ext.Logger.error("Invalid defaultType of: '" + defaultType + "', must be a valid component xtype");
  }
}, factoryItem:function(item) {
  if (!item) {
    Ext.Logger.error('Invalid item given: ' + item + ', must be either the config object to factory a new item, ' + 'or an existing component instance');
  }
  var me = this, defaults = me.getDefaults(), instance;
  if (item.isComponent) {
    instance = item;
    if (defaults && item.isInnerItem() && !me.has(instance)) {
      instance.setConfig(defaults, true);
    }
  } else {
    if (defaults && !item.ignoreDefaults) {
      if (!(item.hasOwnProperty('left') && item.hasOwnProperty('right') && item.hasOwnProperty('top') && item.hasOwnProperty('bottom') && item.hasOwnProperty('docked') && item.hasOwnProperty('centered'))) {
        item = Ext.mergeIf({}, item, defaults);
      }
    }
    if (!me.$hasCachedDefaultItemClass) {
      me.getDefaultType();
      me.$hasCachedDefaultItemClass = true;
    }
    instance = Ext.factory(item, me.defaultItemClass);
  }
  return instance;
}, add:function(newItems) {
  var me = this, addingArray = true, addedItems = [], i, ln, item, newActiveItem, instanced;
  if (!Ext.isArray(newItems)) {
    newItems = [newItems];
    addingArray = false;
  }
  for (i = 0, ln = newItems.length; i < ln; i++) {
    item = newItems[i];
    instanced = item.isWidget;
    if (!instanced) {
      item.$initParent = me;
    }
    item = me.factoryItem(item);
    me.doAdd(item, instanced);
    delete item.$initParent;
    if (!newActiveItem && !me.getActiveItem() && me.innerItems.length > 0 && item.isInnerItem()) {
      newActiveItem = item;
    }
    addedItems.push(item);
  }
  if (newActiveItem) {
    me.setActiveItem(newActiveItem);
  }
  return addingArray ? addedItems : addedItems[0];
}, doAdd:function(item, instanced) {
  var me = this, items = me.getItems(), index;
  if (!items.has(item)) {
    index = items.length;
    items.add(item);
    if (item.isInnerItem()) {
      me.insertInner(item);
    }
    item.onAdded(me, !!instanced);
    me.onItemAdd(item, index);
  }
}, remove:function(item, destroy) {
  var me = this, index, innerItems;
  item = me.getComponent(item);
  index = me.indexOf(item);
  innerItems = me.getInnerItems();
  if (destroy === undefined) {
    destroy = me.getAutoDestroy();
  }
  if (index !== -1) {
    if (!me.removingAll && innerItems.length > 1 && item === me.getActiveItem()) {
      me.on({activeitemchange:'doRemove', scope:me, single:true, order:'after', args:[item, index, destroy]});
      me.doResetActiveItem(innerItems.indexOf(item));
    } else {
      me.doRemove(item, index, destroy);
      if (innerItems.length === 0) {
        me.setActiveItem(null);
      }
    }
  }
  return item;
}, doResetActiveItem:function(innerIndex) {
  if (innerIndex === 0) {
    this.setActiveItem(1);
  } else {
    this.setActiveItem(0);
  }
}, doRemove:function(item, index, destroy) {
  var me = this;
  me.items.remove(item);
  if (item.isInnerItem()) {
    me.removeInner(item);
  }
  me.onItemRemove(item, index, destroy);
  item.onRemoved(item.destroying || destroy);
  if (destroy) {
    item.destroy();
  }
}, removeAll:function(destroy, everything) {
  var items = this.items, removed = [], ln = items.length, i = 0, item;
  if (typeof destroy != 'boolean') {
    destroy = this.getAutoDestroy();
  }
  everything = Boolean(everything);
  this.removingAll = true;
  for (; i < ln; i++) {
    item = items.getAt(i);
    if (item && (everything || item.isInnerItem())) {
      this.doRemove(item, i, destroy);
      i--;
      ln--;
    }
    removed.push(item);
  }
  this.setActiveItem(null);
  this.removingAll = false;
  return removed;
}, getAt:function(index) {
  return this.items.getAt(index);
}, getInnerAt:function(index) {
  return this.innerItems[index];
}, removeAt:function(index) {
  var item = this.getAt(index);
  if (item) {
    this.remove(item);
  }
  return item;
}, removeInnerAt:function(index) {
  var item = this.getInnerItems()[index];
  if (item) {
    this.remove(item);
  }
  return item;
}, has:function(item) {
  return this.getItems().indexOf(item) != -1;
}, hasInnerItem:function(item) {
  return this.innerItems.indexOf(item) != -1;
}, indexOf:function(item) {
  return this.getItems().indexOf(item);
}, innerIndexOf:function(item) {
  return this.innerItems.indexOf(item);
}, insertInner:function(item, index) {
  var items = this.getItems().items, innerItems = this.innerItems, currentInnerIndex = innerItems.indexOf(item), newInnerIndex = -1, nextSibling;
  if (currentInnerIndex !== -1) {
    innerItems.splice(currentInnerIndex, 1);
  }
  if (typeof index == 'number') {
    do {
      nextSibling = items[++index];
    } while (nextSibling && !nextSibling.isInnerItem());
    if (nextSibling) {
      newInnerIndex = innerItems.indexOf(nextSibling);
      innerItems.splice(newInnerIndex, 0, item);
    }
  }
  if (newInnerIndex === -1) {
    innerItems.push(item);
    newInnerIndex = innerItems.length - 1;
  }
  if (currentInnerIndex !== -1) {
    this.onInnerItemMove(item, newInnerIndex, currentInnerIndex);
  }
  return this;
}, onInnerItemMove:Ext.emptyFn, removeInner:function(item) {
  Ext.Array.remove(this.innerItems, item);
  return this;
}, insert:function(index, item) {
  var me = this, instanced, i;
  if (typeof index != 'number') {
    Ext.Logger.error("Invalid index of '" + index + "', must be a valid number");
  }
  if (Ext.isArray(item)) {
    for (i = item.length - 1; i >= 0; i--) {
      me.insert(index, item[i]);
    }
    return me;
  }
  instanced = item.isWidget;
  if (!instanced) {
    item.$initParent = me;
  }
  item = me.factoryItem(item);
  me.doInsert(index, item, instanced);
  delete item.$initParent;
  return item;
}, doInsert:function(index, item, instanced) {
  var me = this, items = me.items, itemsLength = items.length, currentIndex, isInnerItem;
  isInnerItem = item.isInnerItem();
  if (index > itemsLength) {
    index = itemsLength;
  }
  if (items[index - 1] === item) {
    return me;
  }
  currentIndex = me.indexOf(item);
  if (currentIndex !== -1) {
    items.removeAt(currentIndex);
  }
  items.insert(index, item);
  if (currentIndex === -1) {
    item.onAdded(me, !!instanced);
  }
  if (isInnerItem) {
    me.insertInner(item, index);
  }
  if (currentIndex !== -1) {
    me.onItemMove(item, index, currentIndex);
  } else {
    me.onItemAdd(item, index);
  }
}, insertFirst:function(item) {
  return this.insert(0, item);
}, insertLast:function(item) {
  return this.insert(this.getItems().length, item);
}, insertBefore:function(item, relativeToItem) {
  var index = this.indexOf(relativeToItem);
  if (index !== -1) {
    this.insert(index, item);
  }
  return this;
}, insertAfter:function(item, relativeToItem) {
  var index = this.indexOf(relativeToItem);
  if (index !== -1) {
    this.insert(index + 1, item);
  }
  return this;
}, onItemAdd:function(item, index) {
  var me = this;
  me.doItemLayoutAdd(item, index);
  if (me.initialized) {
    if (item.hasListeners.added) {
      item.fireEvent('added', item, me, index);
    }
    if (me.hasListeners.add) {
      me.fireEvent('add', me, item, index);
    }
  }
}, doItemLayoutAdd:function(item, index) {
  var layout = this.getLayout();
  if (this.isRendered() && item.setRendered(true)) {
    item.fireAction('renderedchange', [this, item, true], 'onItemAdd', layout, {args:[item, index]});
  } else {
    layout.onItemAdd(item, index);
  }
}, onItemRemove:function(item, index, destroying) {
  var me = this;
  me.doItemLayoutRemove(item, index, destroying);
  if (item.hasListeners.removed) {
    item.fireEvent('removed', item, me, index);
  }
  if (me.hasListeners.remove) {
    me.fireEvent('remove', me, item, index);
  }
}, doItemLayoutRemove:function(item, index, destroying) {
  var layout = this.getLayout();
  if (this.isRendered() && item.setRendered(false)) {
    item.fireAction('renderedchange', [this, item, false], 'onItemRemove', layout, {args:[item, index, destroying]});
  } else {
    layout.onItemRemove(item, index, destroying);
  }
}, onItemMove:function(item, toIndex, fromIndex) {
  var me = this;
  if (item.isDocked()) {
    item.setDocked(null);
  }
  me.doItemLayoutMove(item, toIndex, fromIndex);
  if (item.hasListeners.moved) {
    item.fireEvent('moved', item, me, toIndex, fromIndex);
  }
  if (me.hasListeners.move) {
    me.fireEvent('move', me, item, toIndex, fromIndex);
  }
}, doItemLayoutMove:function(item, toIndex, fromIndex) {
  this.getLayout().onItemMove(item, toIndex, fromIndex);
}, onItemInnerStateChange:function(item, isInner) {
  var layout = this.getLayout();
  if (isInner) {
    this.insertInner(item, this.items.indexOf(item));
  } else {
    this.removeInner(item);
  }
  layout.onItemInnerStateChange.apply(layout, arguments);
}, getInnerItems:function() {
  return this.innerItems;
}, getDockedItems:function() {
  var items = this.getItems().items, dockedItems = [], ln = items.length, item, i;
  for (i = 0; i < ln; i++) {
    item = items[i];
    if (item.isDocked()) {
      dockedItems.push(item);
    }
  }
  return dockedItems;
}, applyActiveItem:function(activeItem, currentActiveItem) {
  var me = this, innerItems = me.getInnerItems();
  me.getItems();
  if (!activeItem && innerItems.length === 0) {
    return 0;
  } else {
    if (typeof activeItem == 'number') {
      activeItem = Math.max(0, Math.min(activeItem, innerItems.length - 1));
      activeItem = innerItems[activeItem];
      if (activeItem) {
        return activeItem;
      } else {
        if (currentActiveItem) {
          return null;
        }
      }
    } else {
      if (activeItem) {
        var item;
        if (typeof activeItem == 'string') {
          item = me.child(activeItem);
          activeItem = {xtype:activeItem};
        }
        if (!item || !item.isComponent) {
          activeItem.$initParent = me;
          item = me.factoryItem(activeItem);
        }
        me.pendingActiveItem = item;
        if (!item.isInnerItem()) {
          Ext.Logger.error('Setting activeItem to be a non-inner item');
        }
        if (!me.has(item)) {
          me.add(item);
        }
        delete item.$initParent;
        return item;
      }
    }
  }
}, animateActiveItem:function(activeItem, animation) {
  var layout = this.getLayout(), defaultAnimation;
  if (this.activeItemAnimation) {
    this.activeItemAnimation.destroy();
  }
  this.activeItemAnimation = animation = new Ext.fx.layout.Card(animation);
  if (animation && layout.isCard) {
    animation.setLayout(layout);
    defaultAnimation = layout.getAnimation();
    if (defaultAnimation) {
      defaultAnimation.disable();
    }
    animation.on('animationend', function() {
      if (defaultAnimation) {
        defaultAnimation.enable();
      }
      animation.destroy();
    }, this);
  }
  return this.setActiveItem(activeItem);
}, updateActiveItem:function(newActiveItem, oldActiveItem) {
  delete this.pendingActiveItem;
  if (oldActiveItem) {
    oldActiveItem.fireEvent('deactivate', oldActiveItem, this, newActiveItem);
  }
  if (newActiveItem) {
    newActiveItem.fireEvent('activate', newActiveItem, this, oldActiveItem);
  }
}, show:function() {
  this.callParent(arguments);
  var modal = this.getModal();
  if (modal) {
    modal.setHidden(false);
  }
  return this;
}, hide:function() {
  this.callParent(arguments);
  var modal = this.getModal();
  if (modal) {
    modal.setHidden(true);
  }
  return this;
}, updateHidden:function(hidden) {
  var modal = this.getModal();
  if (modal && modal.getHidden() !== hidden) {
    modal.setHidden(hidden);
  }
  this.callParent(arguments);
}, setRendered:function(rendered) {
  if (this.callParent(arguments)) {
    var items = this.items.items, i, ln;
    for (i = 0, ln = items.length; i < ln; i++) {
      items[i].setRendered(rendered);
    }
    return true;
  }
  return false;
}, getRefItems:function(deep) {
  var items = this.getItems().items.slice(), ln = items.length, i, item;
  if (deep) {
    for (i = 0; i < ln; i++) {
      item = items[i];
      if (item.getRefItems) {
        items = items.concat(item.getRefItems(true));
      }
    }
  }
  return items;
}, getComponent:function(component) {
  if (typeof component === 'number') {
    return this.getItems().getAt(component);
  }
  if (Ext.isObject(component)) {
    component = component.getItemId();
  }
  return this.getItems().get(component);
}, getDockedComponent:function(component) {
  if (Ext.isObject(component)) {
    component = component.getItemId();
  }
  var dockedItems = this.getDockedItems(), ln = dockedItems.length, item, i;
  if (Ext.isNumber(component)) {
    return dockedItems[component];
  }
  for (i = 0; i < ln; i++) {
    item = dockedItems[i];
    if (item.id == component) {
      return item;
    }
  }
  return false;
}, destroy:function() {
  var me = this, modal = me.getModal();
  if (modal) {
    modal.destroy();
  }
  me.removeAll(true, true);
  me.callParent();
  Ext.destroy(me.items);
  me.items = null;
}, privates:{applyReference:function(reference) {
  return this.setupReference(reference);
}, getFirstReferences:function() {
  var me = this;
  delete me.getReferences;
  me.getItems();
  return me.getReferences.apply(me, arguments);
}}}, function() {
  this.prototype.defaultItemClass = this;
});
Ext.define('Ext.LoadMask', {extend:Ext.Mask, xtype:'loadmask', config:{message:'Loading...', cls:Ext.baseCSSPrefix + 'loading-mask', messageCls:Ext.baseCSSPrefix + 'mask-message', indicator:true}, getTemplate:function() {
  var prefix = Ext.baseCSSPrefix;
  return [{reference:'innerElement', cls:prefix + 'mask-inner', children:[{reference:'indicatorElement', cls:prefix + 'loading-spinner-outer', children:[{cls:prefix + 'loading-spinner', children:[{tag:'span', cls:prefix + 'loading-top'}, {tag:'span', cls:prefix + 'loading-right'}, {tag:'span', cls:prefix + 'loading-bottom'}, {tag:'span', cls:prefix + 'loading-left'}]}]}, {reference:'messageElement'}]}];
}, updateMessage:function(newMessage) {
  var cls = Ext.baseCSSPrefix + 'has-message';
  if (newMessage) {
    this.addCls(cls);
  } else {
    this.removeCls(cls);
  }
  this.messageElement.setHtml(newMessage);
}, updateMessageCls:function(newMessageCls, oldMessageCls) {
  this.messageElement.replaceCls(oldMessageCls, newMessageCls);
}, updateIndicator:function(newIndicator) {
  this[newIndicator ? 'removeCls' : 'addCls'](Ext.baseCSSPrefix + 'indicator-hidden');
}});
Ext.define('Ext.viewport.Default', {extend:Ext.Container, xtype:'viewport', PORTRAIT:'portrait', LANDSCAPE:'landscape', config:{autoMaximize:false, autoBlurInput:true, preventPanning:true, preventZooming:false, autoRender:true, layout:'card', width:'100%', height:'100%', useBodyElement:true, menus:{}}, isReady:false, isViewport:true, isMaximizing:false, id:'ext-viewport', isInputRegex:/^(input|textarea|select|a)$/i, isInteractiveWebComponentRegEx:/^(audio|video)$/i, focusedElement:null, fullscreenItemCls:Ext.baseCSSPrefix + 
'fullscreen', constructor:function(config) {
  var me = this, bind = Ext.Function.bind, Component = Ext.Component, DomScroller = Ext.scroll.DomScroller;
  if (DomScroller.document) {
    DomScroller.document = DomScroller.document.destroy();
  }
  me.doPreventPanning = bind(me.doPreventPanning, me);
  me.doPreventZooming = bind(me.doPreventZooming, me);
  me.doBlurInput = bind(me.doBlurInput, me);
  me.maximizeOnEvents = ['ready', 'orientationchange'];
  window.devicePixelRatio = window.devicePixelRatio || 1;
  me.callParent([config]);
  me.orientation = me.determineOrientation();
  me.windowWidth = me.getWindowWidth();
  me.windowHeight = me.getWindowHeight();
  me.windowOuterHeight = me.getWindowOuterHeight();
  me.stretchHeights = me.stretchHeights || {};
  if (!Ext.os.is.Android || Ext.browser.is.ChromeMobile) {
    if (me.supportsOrientation()) {
      me.addWindowListener('orientationchange', bind(me.onOrientationChange, me));
    } else {
      me.addWindowListener('resize', bind(me.onResize, me));
    }
  }
  document.addEventListener('focus', bind(me.onElementFocus, me), true);
  document.addEventListener('blur', bind(me.onElementBlur, me), true);
  Ext.onDocumentReady(me.onDomReady, me);
  if (!Component.on) {
    Ext.util.Observable.observe(Component);
  }
  Component.on('fullscreen', 'onItemFullscreenChange', me);
  return me;
}, initialize:function() {
  var me = this;
  me.addMeta('apple-mobile-web-app-capable', 'yes');
  me.addMeta('apple-touch-fullscreen', 'yes');
  me.callParent();
}, initInheritedState:function(inheritedState, inheritedStateInner) {
  var me = this, root = Ext.rootInheritedState;
  if (inheritedState !== root) {
    me.initInheritedState(me.inheritedState = root, me.inheritedStateInner = Ext.Object.chain(root));
  } else {
    me.callParent([inheritedState, inheritedStateInner]);
  }
}, onAppLaunch:function() {
  var me = this;
  if (!me.isReady) {
    me.onDomReady();
  }
}, onDomReady:function() {
  var me = this;
  if (me.isReady) {
    return;
  }
  me.isReady = true;
  me.updateSize();
  me.onReady();
  me.fireEvent('ready', me);
  Ext.GlobalEvents.fireEvent('viewportready', me);
}, onReady:function() {
  if (this.getAutoRender()) {
    this.render();
  }
  if (Ext.browser.name === 'ChromeiOS') {
    this.setHeight('-webkit-calc(100% - ' + (window.outerHeight - window.innerHeight) / 2 + 'px)');
  }
}, onElementFocus:function(e) {
  this.focusedElement = e.target;
}, onElementBlur:function() {
  this.focusedElement = null;
}, render:function() {
  if (!this.rendered) {
    var body = Ext.getBody(), clsPrefix = Ext.baseCSSPrefix, classList = [], osEnv = Ext.os, osName = osEnv.name.toLowerCase(), browserName = Ext.browser.name.toLowerCase(), osMajorVersion = osEnv.version.getMajor(), orientation = this.getOrientation(), theme;
    this.renderTo(body);
    classList.push(clsPrefix + osEnv.deviceType.toLowerCase());
    if (osEnv.is.iPad) {
      classList.push(clsPrefix + 'ipad');
    }
    classList.push(clsPrefix + osName);
    classList.push(clsPrefix + browserName);
    if (osMajorVersion) {
      classList.push(clsPrefix + osName + '-' + osMajorVersion);
    }
    if (osEnv.is.BlackBerry) {
      classList.push(clsPrefix + 'bb');
      if (Ext.browser.userAgent.match(/Kbd/gi)) {
        classList.push(clsPrefix + 'bb-keyboard');
      }
    }
    if (Ext.browser.is.WebKit) {
      classList.push(clsPrefix + 'webkit');
    }
    if (Ext.browser.is.Standalone) {
      classList.push(clsPrefix + 'standalone');
    }
    if (Ext.browser.is.AndroidStock) {
      classList.push(clsPrefix + 'android-stock');
    }
    if (Ext.browser.is.GoogleGlass) {
      classList.push(clsPrefix + 'google-glass');
    }
    classList.push(clsPrefix + orientation);
    body.addCls(classList);
    theme = Ext.theme;
    if (theme && theme.getDocCls) {
      Ext.fly(document.documentElement).addCls(theme.getDocCls());
    }
  }
}, updateAutoBlurInput:function(autoBlurInput) {
  var touchstart = Ext.feature.has.TouchEvents ? 'touchstart' : 'mousedown';
  this.toggleWindowListener(autoBlurInput, touchstart, this.doBlurInput, false);
}, applyAutoMaximize:function(autoMaximize) {
  return Ext.browser.is.WebView ? false : autoMaximize;
}, updateAutoMaximize:function(autoMaximize) {
  var me = this;
  if (autoMaximize) {
    me.on('ready', 'doAutoMaximizeOnReady', me, {single:true});
    me.on('orientationchange', 'doAutoMaximizeOnOrientationChange', me);
  } else {
    me.un('ready', 'doAutoMaximizeOnReady', me);
    me.un('orientationchange', 'doAutoMaximizeOnOrientationChange', me);
  }
}, updatePreventPanning:function(preventPanning) {
  this.toggleWindowListener(preventPanning, 'touchmove', this.doPreventPanning, false);
}, updatePreventZooming:function(preventZooming) {
  var touchstart = Ext.feature.has.TouchEvents ? 'touchstart' : 'mousedown';
  this.toggleWindowListener(preventZooming, touchstart, this.doPreventZooming, false);
}, doAutoMaximizeOnReady:function() {
  var me = this;
  me.isMaximizing = true;
  me.on('maximize', function() {
    me.isMaximizing = false;
    me.updateSize();
    me.fireEvent('ready', me);
  }, me, {single:true});
  me.maximize();
}, doAutoMaximizeOnOrientationChange:function() {
  var me = this;
  me.isMaximizing = true;
  me.on('maximize', function() {
    me.isMaximizing = false;
    me.updateSize();
  }, me, {single:true});
  me.maximize();
}, doBlurInput:function(e) {
  var target = e.target, focusedElement = this.focusedElement;
  if (focusedElement && focusedElement.blur && focusedElement.nodeName.toUpperCase() != 'BODY' && !this.isInputRegex.test(target.tagName)) {
    delete this.focusedElement;
    focusedElement.blur();
  }
}, doPreventPanning:function(e) {
  var target = e.target, touch;
  if (this.isInteractiveWebComponentRegEx.test(target.tagName) && e.touches && e.touches.length > 0) {
    touch = e.touches[0];
    if (touch && touch.target && this.isInputRegex.test(touch.target.tagName)) {
      return;
    }
  }
  if (target && target.nodeType === 1 && !this.isInputRegex.test(target.tagName)) {
    e.preventDefault();
  }
}, doPreventZooming:function(e) {
  if ('button' in e && e.button !== 0) {
    return;
  }
  var target = e.target, inputRe = this.isInputRegex, touch;
  if (this.isInteractiveWebComponentRegEx.test(target.tagName) && e.touches && e.touches.length > 0) {
    touch = e.touches[0];
    if (touch && touch.target && inputRe.test(touch.target.tagName)) {
      return;
    }
  }
  if (target && target.nodeType === 1 && !inputRe.test(target.tagName)) {
    e.preventDefault();
  }
}, addWindowListener:function(eventName, fn, capturing) {
  window.addEventListener(eventName, fn, Boolean(capturing));
}, removeWindowListener:function(eventName, fn, capturing) {
  window.removeEventListener(eventName, fn, Boolean(capturing));
}, supportsOrientation:function() {
  return Ext.feature.has.Orientation;
}, onResize:function() {
  var me = this, oldWidth = me.windowWidth, oldHeight = me.windowHeight, width = me.getWindowWidth(), height = me.getWindowHeight(), currentOrientation = me.getOrientation(), newOrientation = me.determineOrientation();
  if (oldWidth !== width && oldHeight !== height && currentOrientation !== newOrientation) {
    me.fireOrientationChangeEvent(newOrientation, currentOrientation);
  }
}, onOrientationChange:function() {
  var currentOrientation = this.getOrientation(), newOrientation = this.determineOrientation();
  if (newOrientation !== currentOrientation) {
    this.fireOrientationChangeEvent(newOrientation, currentOrientation);
  }
}, fireOrientationChangeEvent:function(newOrientation, oldOrientation) {
  var me = this, clsPrefix = Ext.baseCSSPrefix;
  Ext.getBody().replaceCls(clsPrefix + oldOrientation, clsPrefix + newOrientation);
  me.orientation = newOrientation;
  me.updateSize();
  me.fireEvent('orientationchange', me, newOrientation, me.windowWidth, me.windowHeight);
}, updateSize:function(width, height) {
  var me = this;
  me.windowWidth = width !== undefined ? width : me.getWindowWidth();
  me.windowHeight = height !== undefined ? height : me.getWindowHeight();
  return me;
}, waitUntil:function(condition, onSatisfied, onTimeout, delay, timeoutDuration) {
  if (!delay) {
    delay = 50;
  }
  if (!timeoutDuration) {
    timeoutDuration = 2000;
  }
  var scope = this, elapse = 0;
  Ext.defer(function repeat() {
    elapse += delay;
    if (condition.call(scope) === true) {
      if (onSatisfied) {
        onSatisfied.call(scope);
      }
    } else {
      if (elapse >= timeoutDuration) {
        if (onTimeout) {
          onTimeout.call(scope);
        }
      } else {
        Ext.defer(repeat, delay);
      }
    }
  }, delay);
}, maximize:function() {
  this.fireMaximizeEvent();
}, fireMaximizeEvent:function() {
  this.updateSize();
  this.fireEvent('maximize', this);
}, updateHeight:function(height, oldHeight) {
  Ext.getBody().setHeight(height);
  this.callParent([height, oldHeight]);
}, updateWidth:function(width, oldWidth) {
  Ext.getBody().setWidth(width);
  this.callParent([width, oldWidth]);
}, scrollToTop:function() {
  window.scrollTo(0, -1);
}, getWindowWidth:function() {
  return window.innerWidth;
}, getWindowHeight:function() {
  return window.innerHeight;
}, getWindowOuterHeight:function() {
  return window.outerHeight;
}, getWindowOrientation:function() {
  return window.orientation;
}, getOrientation:function() {
  return this.orientation;
}, getSize:function() {
  return {width:this.windowWidth, height:this.windowHeight};
}, determineOrientation:function() {
  var me = this, portrait = me.PORTRAIT, landscape = me.LANDSCAPE;
  if (!Ext.os.is.Android && me.supportsOrientation()) {
    if (me.getWindowOrientation() % 180 === 0) {
      return portrait;
    }
    return landscape;
  } else {
    if (me.getWindowHeight() >= me.getWindowWidth()) {
      return portrait;
    }
    return landscape;
  }
}, onItemFullscreenChange:function(item) {
  item.addCls(this.fullscreenItemCls);
  this.add(item);
}, setMenu:function(menu, config) {
  config = config || {};
  var me = this, side = config.side, menus;
  if (Ext.os.is.iOS && !me.hasiOSOrientationFix) {
    me.hasiOSOrientationFix = true;
    me.on('orientationchange', function() {
      window.scrollTo(0, 0);
    }, me);
  }
  if (!menu) {
    Ext.Logger.error('You must specify a side to dock the menu.');
  }
  if (!side) {
    Ext.Logger.error('You must specify a side to dock the menu.');
  }
  if (['left', 'right', 'top', 'bottom'].indexOf(side) == -1) {
    Ext.Logger.error('You must specify a valid side (left, right, top or botom) to dock the menu.');
  }
  menus = me.getMenus();
  if (!menus) {
    menus = {};
  }
  if (!me.addedSwipeListener) {
    me.attachSwipeListeners();
    me.addedSwipeListener = true;
  }
  if (!menu.isComponent) {
    if (!menu.xclass && !menu.xtype) {
      menu = me.getMenuCfg(menu, side);
    }
    menu = Ext.create(menu);
  }
  menus[side] = menu;
  menu.$reveal = Boolean(config.reveal);
  menu.$cover = config.cover !== false && !menu.$reveal;
  menu.$side = side;
  me.fixMenuSize(menu, side);
  if (side == 'left') {
    menu.setLeft(0);
    menu.setRight(null);
    menu.setTop(0);
    menu.setBottom(0);
  } else {
    if (side == 'right') {
      menu.setLeft(null);
      menu.setRight(0);
      menu.setTop(0);
      menu.setBottom(0);
    } else {
      if (side == 'top') {
        menu.setLeft(0);
        menu.setRight(0);
        menu.setTop(0);
        menu.setBottom(null);
      } else {
        if (side == 'bottom') {
          menu.setLeft(0);
          menu.setRight(0);
          menu.setTop(null);
          menu.setBottom(0);
        }
      }
    }
  }
  me.setMenus(menus);
  return menu;
}, attachSwipeListeners:function() {
  var me = this;
  me.element.on({tap:me.onTap, swipestart:me.onSwipeStart, edgeswipestart:me.onEdgeSwipeStart, edgeswipe:me.onEdgeSwipe, edgeswipeend:me.onEdgeSwipeEnd, scope:me});
}, getMenuCfg:function(menu, side) {
  return Ext.apply({xtype:'menu'}, menu);
}, removeMenu:function(side) {
  var menus = this.getMenus() || {}, menu = menus[side];
  if (menu) {
    this.hideMenu(side);
  }
  delete menus[side];
  this.setMenus(menus);
}, fixMenuSize:function(menu, side) {
  if (side == 'top' || side == 'bottom') {
    menu.setWidth('100%');
  } else {
    if (side == 'left' || side == 'right') {
      menu.setHeight('100%');
    }
  }
}, showMenu:function(side) {
  var me = this, menus = me.getMenus(), menu = menus[side], before, after, viewportBefore, viewportAfter, size;
  if (!menu || menu.isAnimating) {
    return;
  }
  me.hideOtherMenus(side);
  before = {translateX:0, translateY:0};
  after = {translateX:0, translateY:0};
  viewportBefore = {translateX:0, translateY:0};
  viewportAfter = {translateX:0, translateY:0};
  if (menu.$reveal) {
    Ext.getBody().insertFirst(menu.element);
  } else {
    Ext.Viewport.add(menu);
  }
  menu.show();
  menu.addCls('x-' + side);
  size = side == 'left' || side == 'right' ? menu.element.getWidth() : menu.element.getHeight();
  if (side == 'left') {
    before.translateX = -size;
    viewportAfter.translateX = size;
  } else {
    if (side == 'right') {
      before.translateX = size;
      viewportAfter.translateX = -size;
    } else {
      if (side == 'top') {
        before.translateY = -size;
        viewportAfter.translateY = size;
      } else {
        if (side == 'bottom') {
          before.translateY = size;
          viewportAfter.translateY = -size;
        }
      }
    }
  }
  if (menu.$reveal) {
    if (Ext.browser.getPreferredTranslationMethod() != 'scrollposition') {
      menu.translate(0, 0);
    }
  } else {
    menu.translate(before.translateX, before.translateY);
  }
  if (menu.$cover) {
    menu.getTranslatable().on('animationend', function() {
      menu.isAnimating = false;
    }, me, {single:true});
    menu.translate(after.translateX, after.translateY, {preserveEndState:true, duration:200});
  } else {
    me.translate(viewportBefore.translateX, viewportBefore.translateY);
    me.getTranslatable().on('animationend', function() {
      menu.isAnimating = false;
    }, me, {single:true});
    me.translate(viewportAfter.translateX, viewportAfter.translateY, {preserveEndState:true, duration:200});
  }
  menu.isAnimating = true;
}, hideMenu:function(side, animate) {
  var me = this, menus = this.getMenus(), menu = menus[side], after, viewportAfter, size;
  animate = animate !== false;
  if (!menu || (menu.isHidden() || menu.isAnimating)) {
    return;
  }
  after = {translateX:0, translateY:0};
  viewportAfter = {translateX:0, translateY:0};
  size = side == 'left' || side == 'right' ? menu.element.getWidth() : menu.element.getHeight();
  if (side == 'left') {
    after.translateX = -size;
  } else {
    if (side == 'right') {
      after.translateX = size;
    } else {
      if (side == 'top') {
        after.translateY = -size;
      } else {
        if (side == 'bottom') {
          after.translateY = size;
        }
      }
    }
  }
  if (menu.$cover) {
    if (animate) {
      menu.getTranslatable().on('animationend', function() {
        menu.isAnimating = false;
        menu.hide();
      }, me, {single:true});
      menu.translate(after.translateX, after.translateY, {preserveEndState:true, duration:200});
    } else {
      menu.translate(after.translateX, after.translateY);
      menu.hide();
    }
  } else {
    if (animate) {
      me.getTranslatable().on('animationend', function() {
        menu.isAnimating = false;
        menu.hide();
      }, me, {single:true});
      me.translate(viewportAfter.translateX, viewportAfter.translateY, {preserveEndState:true, duration:200});
    } else {
      me.translate(viewportAfter.translateX, viewportAfter.translateY);
      menu.hide();
    }
  }
}, hideAllMenus:function(animation) {
  var menus = this.getMenus(), side;
  for (side in menus) {
    this.hideMenu(side, animation);
  }
}, hideOtherMenus:function(side, animation) {
  var menus = this.getMenus(), menu;
  for (menu in menus) {
    if (side !== menu) {
      this.hideMenu(menu, animation);
    }
  }
}, toggleMenu:function(side) {
  var menus = this.getMenus(), menu;
  if (menus[side]) {
    menu = menus[side];
    if (menu.isHidden()) {
      this.showMenu(side);
    } else {
      this.hideMenu(side);
    }
  }
}, sideForDirection:function(direction) {
  if (direction === 'left') {
    return 'right';
  } else {
    if (direction === 'right') {
      return 'left';
    } else {
      if (direction == 'up') {
        return 'bottom';
      } else {
        if (direction == 'down') {
          return 'top';
        }
      }
    }
  }
}, sideForSwipeDirection:function(direction) {
  if (direction == 'up') {
    return 'top';
  } else {
    if (direction == 'down') {
      return 'bottom';
    }
  }
  return direction;
}, onTap:function(e) {
}, onSwipeStart:function(e) {
  var side = this.sideForSwipeDirection(e.direction);
  this.hideMenu(side);
}, onEdgeSwipeStart:function(e) {
  var me = this, side = me.sideForDirection(e.direction), menus = me.getMenus(), menu = menus[side], menuSide, checkMenu, size, after, viewportAfter, transformStyleName, setTransform;
  if (!menu || !menu.isHidden()) {
    return;
  }
  for (menuSide in menus) {
    checkMenu = menus[menuSide];
    if (checkMenu.isHidden() !== false) {
      return;
    }
  }
  me.$swiping = true;
  me.hideAllMenus(false);
  if (menu.$reveal) {
    Ext.getBody().insertFirst(menu.element);
  } else {
    Ext.Viewport.add(menu);
  }
  menu.show();
  size = side == 'left' || side == 'right' ? menu.element.getWidth() : menu.element.getHeight();
  after = {translateX:0, translateY:0};
  viewportAfter = {translateX:0, translateY:0};
  if (side == 'left') {
    after.translateX = -size;
  } else {
    if (side == 'right') {
      after.translateX = size;
    } else {
      if (side == 'top') {
        after.translateY = -size;
      } else {
        if (side == 'bottom') {
          after.translateY = size;
        }
      }
    }
  }
  transformStyleName = 'webkitTransform' in document.createElement('div').style ? 'webkitTransform' : 'transform';
  setTransform = menu.element.dom.style[transformStyleName];
  if (setTransform) {
    menu.element.dom.style[transformStyleName] = '';
  }
  if (menu.$reveal) {
    if (Ext.browser.getPreferredTranslationMethod() != 'scrollposition') {
      menu.translate(0, 0);
    }
  } else {
    menu.translate(after.translateX, after.translateY);
  }
  if (!menu.$cover) {
    if (setTransform) {
      me.innerElement.dom.style[transformStyleName] = '';
    }
    me.translate(viewportAfter.translateX, viewportAfter.translateY);
  }
}, onEdgeSwipe:function(e) {
  var me = this, side = me.sideForDirection(e.direction), menu = me.getMenus()[side], size, after, viewportAfter, movement, viewportMovement;
  if (!menu || !me.$swiping) {
    return;
  }
  size = side == 'left' || side == 'right' ? menu.element.getWidth() : menu.element.getHeight();
  movement = Math.min(e.distance - size, 0);
  viewportMovement = Math.min(e.distance, size);
  after = {translateX:0, translateY:0};
  viewportAfter = {translateX:0, translateY:0};
  if (side == 'left') {
    after.translateX = movement;
    viewportAfter.translateX = viewportMovement;
  } else {
    if (side == 'right') {
      after.translateX = -movement;
      viewportAfter.translateX = -viewportMovement;
    } else {
      if (side == 'top') {
        after.translateY = movement;
        viewportAfter.translateY = viewportMovement;
      } else {
        if (side == 'bottom') {
          after.translateY = -movement;
          viewportAfter.translateY = -viewportMovement;
        }
      }
    }
  }
  if (menu.$cover) {
    menu.translate(after.translateX, after.translateY);
  } else {
    me.translate(viewportAfter.translateX, viewportAfter.translateY);
  }
}, onEdgeSwipeEnd:function(e) {
  var me = this, side = me.sideForDirection(e.direction), menu = me.getMenus()[side], shouldRevert = false, size, velocity, movement, viewportMovement, after, viewportAfter;
  if (!menu) {
    return;
  }
  size = side == 'left' || side == 'right' ? menu.element.getWidth() : menu.element.getHeight();
  velocity = e.flick ? e.flick.velocity : 0;
  if (side == 'right') {
    if (velocity.x > 0) {
      shouldRevert = true;
    }
  } else {
    if (side == 'left') {
      if (velocity.x < 0) {
        shouldRevert = true;
      }
    } else {
      if (side == 'top') {
        if (velocity.y < 0) {
          shouldRevert = true;
        }
      } else {
        if (side == 'bottom') {
          if (velocity.y > 0) {
            shouldRevert = true;
          }
        }
      }
    }
  }
  movement = shouldRevert ? size : 0;
  viewportMovement = shouldRevert ? 0 : -size;
  after = {translateX:0, translateY:0};
  viewportAfter = {translateX:0, translateY:0};
  if (side == 'left') {
    after.translateX = -movement;
    viewportAfter.translateX = -viewportMovement;
  } else {
    if (side == 'right') {
      after.translateX = movement;
      viewportAfter.translateX = viewportMovement;
    } else {
      if (side == 'top') {
        after.translateY = -movement;
        viewportAfter.translateY = -viewportMovement;
      } else {
        if (side == 'bottom') {
          after.translateY = movement;
          viewportAfter.translateY = viewportMovement;
        }
      }
    }
  }
  if (menu.$cover) {
    menu.getTranslatable().on('animationend', function() {
      if (shouldRevert) {
        menu.hide();
      }
    }, me, {single:true});
    menu.translate(after.translateX, after.translateY, {preserveEndState:true, duration:200});
  } else {
    me.getTranslatable().on('animationend', function() {
      if (shouldRevert) {
        menu.hide();
      }
    }, me, {single:true});
    me.translate(viewportAfter.translateX, viewportAfter.translateY, {preserveEndState:true, duration:200});
  }
  me.$swiping = false;
}, privates:{addMeta:function(name, content) {
  var meta = document.createElement('meta');
  meta.setAttribute('name', name);
  meta.setAttribute('content', content);
  Ext.getHead().append(meta);
}, doAddListener:function(eventName, fn, scope, options, order, caller, manager) {
  var me = this;
  if (eventName === 'ready' && me.isReady && !me.isMaximizing) {
    fn.call(scope);
    return me;
  }
  me.callParent([eventName, fn, scope, options, order, caller, manager]);
}, toggleWindowListener:function(on, eventName, fn, capturing) {
  if (on) {
    this.addWindowListener(eventName, fn, capturing);
  } else {
    this.removeWindowListener(eventName, fn, capturing);
  }
}}});
Ext.define('Ext.viewport.Ios', {extend:Ext.viewport.Default, isFullscreen:function() {
  return this.isHomeScreen();
}, isHomeScreen:function() {
  return window.navigator.standalone === true;
}, constructor:function() {
  this.callParent(arguments);
  if (this.getAutoMaximize() && !this.isFullscreen()) {
    this.addWindowListener('touchstart', Ext.Function.bind(this.onTouchStart, this));
  }
}, maximize:function() {
  if (this.isFullscreen()) {
    return this.callParent();
  }
  var stretchHeights = this.stretchHeights, orientation = this.orientation, currentHeight = this.getWindowHeight(), height = stretchHeights[orientation];
  if (window.scrollY > 0) {
    this.scrollToTop();
    if (!height) {
      stretchHeights[orientation] = height = this.getWindowHeight();
    }
    this.setHeight(height);
    this.fireMaximizeEvent();
  } else {
    if (!height) {
      height = this.getScreenHeight();
    }
    this.setHeight(height);
    this.waitUntil(function() {
      this.scrollToTop();
      return currentHeight !== this.getWindowHeight();
    }, function() {
      if (!stretchHeights[orientation]) {
        height = stretchHeights[orientation] = this.getWindowHeight();
        this.setHeight(height);
      }
      this.fireMaximizeEvent();
    }, function() {
      Ext.Logger.error('Timeout waiting for window.innerHeight to change', this);
      height = stretchHeights[orientation] = this.getWindowHeight();
      this.setHeight(height);
      this.fireMaximizeEvent();
    }, 50, 1000);
  }
}, getScreenHeight:function() {
  return window.screen[this.orientation === this.PORTRAIT ? 'height' : 'width'];
}, onElementFocus:function() {
  if (this.getAutoMaximize() && !this.isFullscreen()) {
    clearTimeout(this.scrollToTopTimer);
  }
  this.callParent(arguments);
}, onElementBlur:function() {
  if (this.getAutoMaximize() && !this.isFullscreen()) {
    this.scrollToTopTimer = Ext.defer(this.scrollToTop, 500);
  }
  this.callParent(arguments);
}, onTouchStart:function() {
  if (this.focusedElement === null) {
    this.scrollToTop();
  }
}, scrollToTop:function() {
  window.scrollTo(0, 0);
}}, function() {
  if (!Ext.os.is.iOS) {
    return;
  }
  if (Ext.os.version.lt('3.2')) {
    this.override({constructor:function() {
      var stretchHeights = this.stretchHeights = {};
      stretchHeights[this.PORTRAIT] = 416;
      stretchHeights[this.LANDSCAPE] = 268;
      return this.callOverridden(arguments);
    }});
  }
  if (Ext.os.version.lt('5')) {
    this.override({fieldMaskClsTest:'-field-mask', doPreventZooming:function(e) {
      var target = e.target;
      if (target && target.nodeType === 1 && !this.isInputRegex.test(target.tagName) && target.className.indexOf(this.fieldMaskClsTest) == -1) {
        e.preventDefault();
      }
    }});
  }
  if (Ext.os.is.iPad) {
    this.override({isFullscreen:function() {
      return true;
    }});
  }
  if (Ext.os.version.gtEq('7')) {
    if (Ext.os.deviceType === 'Tablet' || !Ext.browser.is.Safari || window.navigator.standalone) {
      this.override({constructor:function() {
        var stretchHeights = {}, stretchWidths = {}, orientation = this.determineOrientation(), screenHeight = window.screen.height, screenWidth = window.screen.width, menuHeight = orientation === this.PORTRAIT ? screenHeight - window.innerHeight : screenWidth - window.innerHeight;
        stretchHeights[this.PORTRAIT] = screenHeight - menuHeight;
        stretchHeights[this.LANDSCAPE] = screenWidth - menuHeight;
        stretchWidths[this.PORTRAIT] = screenWidth;
        stretchWidths[this.LANDSCAPE] = screenHeight;
        this.stretchHeights = stretchHeights;
        this.stretchWidths = stretchWidths;
        this.callOverridden(arguments);
        this.on('ready', this.setViewportSizeToAbsolute, this);
        this.on('orientationchange', this.setViewportSizeToAbsolute, this);
      }, getWindowHeight:function() {
        return this.stretchHeights[this.orientation];
      }, getWindowWidth:function() {
        return this.stretchWidths[this.orientation];
      }, setViewportSizeToAbsolute:function() {
        this.setWidth(this.getWindowWidth());
        this.setHeight(this.getWindowHeight());
      }});
    }
    if (Ext.os.deviceType === 'Tablet') {
      this.override({constructor:function() {
        this.callOverridden(arguments);
        window.addEventListener('scroll', function() {
          if (window.scrollX !== 0) {
            window.scrollTo(0, window.scrollY);
          }
        }, false);
      }, setViewportSizeToAbsolute:function() {
        window.scrollTo(0, 0);
        this.callOverridden(arguments);
      }, onElementBlur:function() {
        this.callOverridden(arguments);
        if (window.scrollY !== 0) {
          window.scrollTo(0, 0);
        }
      }});
    }
  }
});
Ext.define('Ext.viewport.Android', {extend:Ext.viewport.Default, config:{translatable:{translationMethod:'csstransform'}}, constructor:function() {
  this.callParent(arguments);
  this.on({orientationchange:'hideKeyboardIfNeeded', scope:this, priority:1001});
  var me = this;
  Ext.onReady(function() {
    Ext.getBody().on('resize', me.onResize, me);
  });
}, getWindowWidth:function() {
  return this.element.getWidth();
}, getWindowHeight:function() {
  return this.element.getHeight();
}, getDummyInput:function() {
  var input = this.dummyInput, focusedElement = this.focusedElement, box = Ext.fly(focusedElement).getBox();
  if (!input) {
    this.dummyInput = input = document.createElement('input');
    input.style.position = 'absolute';
    input.style.opacity = '0';
    input.style.pointerEvents = 'none';
    document.body.appendChild(input);
  }
  input.style.left = box.left + 'px';
  input.style.top = box.top + 'px';
  input.style.display = '';
  return input;
}, doBlurInput:function(e) {
  var target = e.target, focusedElement = this.focusedElement, dummy;
  if (focusedElement && !this.isInputRegex.test(target.tagName)) {
    dummy = this.getDummyInput();
    delete this.focusedElement;
    dummy.focus();
    Ext.defer(function() {
      dummy.style.display = 'none';
    }, 100);
  }
}, hideKeyboardIfNeeded:function() {
  var focusedElement = this.focusedElement;
  if (focusedElement) {
    delete this.focusedElement;
    if (Ext.os.version.lt('4')) {
      focusedElement.style.display = 'none';
    } else {
      focusedElement.blur();
    }
    Ext.defer(function() {
      focusedElement.style.display = '';
    }, 1000);
  }
}, doFireOrientationChangeEvent:function() {
  this.orientationChanging = true;
  this.waitUntil(function() {
    return this.getWindowOuterHeight() !== this.windowOuterHeight;
  }, function() {
    this.windowOuterHeight = this.getWindowOuterHeight();
    this.updateSize();
    this.orientationChanging = false;
  }, function() {
    Ext.Logger.error("Timeout waiting for viewport's outerHeight to change before firing orientationchange", this);
  });
  return this;
}, determineOrientation:function() {
  return this.getWindowHeight() >= this.getWindowWidth() ? this.PORTRAIT : this.LANDSCAPE;
}, getActualWindowOuterHeight:function() {
  return Math.round(this.getWindowOuterHeight() / window.devicePixelRatio);
}, maximize:function() {
  var stretchHeights = this.stretchHeights, orientation = this.orientation, height;
  height = stretchHeights[orientation];
  if (!height) {
    stretchHeights[orientation] = height = this.getActualWindowOuterHeight();
  }
  if (!this.addressBarHeight) {
    this.addressBarHeight = height - this.getWindowHeight();
  }
  this.setHeight(height);
  var isHeightMaximized = Ext.Function.bind(this.isHeightMaximized, this, [height]);
  this.scrollToTop();
  this.waitUntil(isHeightMaximized, this.fireMaximizeEvent, this.fireMaximizeEvent);
}, isHeightMaximized:function(height) {
  this.scrollToTop();
  return this.getWindowHeight() === height;
}, supportsOrientation:function() {
  return false;
}, onResize:function() {
  this.waitUntil(function() {
    var oldWidth = this.windowWidth, oldHeight = this.windowHeight, width = this.getWindowWidth(), height = this.getWindowHeight(), currentOrientation = this.getOrientation(), newOrientation = this.determineOrientation();
    return oldWidth !== width && oldHeight !== height && currentOrientation !== newOrientation;
  }, function() {
    var currentOrientation = this.getOrientation(), newOrientation = this.determineOrientation();
    this.fireOrientationChangeEvent(newOrientation, currentOrientation);
  }, Ext.emptyFn, 250);
}, doPreventZooming:function(e) {
  if ('button' in e && e.button !== 0) {
    return;
  }
  var target = e.target;
  if (target && target.nodeType === 1 && !this.isInputRegex.test(target.tagName) && !this.focusedElement) {
    e.preventDefault();
  }
}}, function() {
  if (!Ext.os.is.Android) {
    return;
  }
  var version = Ext.os.version, userAgent = Ext.browser.userAgent, isBuggy = /(htc|desire|incredible|ADR6300)/i.test(userAgent) && version.lt('2.3');
  if (isBuggy) {
    this.override({constructor:function(config) {
      if (!config) {
        config = {};
      }
      config.autoMaximize = false;
      this.watchDogTick = Ext.Function.bind(this.watchDogTick, this);
      Ext.interval(this.watchDogTick, 1000);
      return this.callParent([config]);
    }, watchDogTick:function() {
      this.watchDogLastTick = Ext.Date.now();
    }, doPreventPanning:function() {
      var now = Ext.Date.now(), lastTick = this.watchDogLastTick, deltaTime = now - lastTick;
      if (deltaTime >= 2000) {
        return;
      }
      return this.callParent(arguments);
    }, doPreventZooming:function() {
      var now = Ext.Date.now(), lastTick = this.watchDogLastTick, deltaTime = now - lastTick;
      if (deltaTime >= 2000) {
        return;
      }
      return this.callParent(arguments);
    }});
  }
  if (version.match('2')) {
    this.override({onReady:function() {
      this.addWindowListener('resize', Ext.Function.bind(this.onWindowResize, this));
      this.callParent(arguments);
    }, scrollToTop:function() {
      document.body.scrollTop = 100;
    }, onWindowResize:function() {
      var oldWidth = this.windowWidth, oldHeight = this.windowHeight, width = this.getWindowWidth(), height = this.getWindowHeight();
      if (this.getAutoMaximize() && !this.isMaximizing && !this.orientationChanging && window.scrollY === 0 && oldWidth === width && height < oldHeight && (height >= oldHeight - this.addressBarHeight || !this.focusedElement)) {
        this.scrollToTop();
      }
    }});
  } else {
    if (version.gtEq('3.1')) {
      this.override({isHeightMaximized:function(height) {
        this.scrollToTop();
        return this.getWindowHeight() === height - 1;
      }});
    } else {
      if (version.match('3')) {
        this.override({isHeightMaximized:function() {
          this.scrollToTop();
          return true;
        }});
      }
    }
  }
  if (version.gtEq('4')) {
    this.override({doBlurInput:Ext.emptyFn});
  }
});
Ext.define('Ext.viewport.WindowsPhone', {requires:[], alternateClassName:'Ext.viewport.WP', extend:Ext.viewport.Default, config:{translatable:{translationMethod:'csstransform'}}, initialize:function() {
  var preventSelection = function(e) {
    var srcElement = e.srcElement.nodeName.toUpperCase(), selectableElements = ['INPUT', 'TEXTAREA'];
    if (selectableElements.indexOf(srcElement) == -1) {
      return false;
    }
  };
  document.body.addEventListener('onselectstart', preventSelection);
  this.addMeta('msapplication-tap-highlight', 'no');
  this.callParent();
}, supportsOrientation:function() {
  return false;
}, onResize:function() {
  this.waitUntil(function() {
    var oldWidth = this.windowWidth, oldHeight = this.windowHeight, width = this.getWindowWidth(), height = this.getWindowHeight(), currentOrientation = this.getOrientation(), newOrientation = this.determineOrientation();
    return oldWidth !== width && oldHeight !== height && currentOrientation !== newOrientation;
  }, function() {
    var currentOrientation = this.getOrientation(), newOrientation = this.determineOrientation();
    this.fireOrientationChangeEvent(newOrientation, currentOrientation);
  }, Ext.emptyFn, 250);
}});
Ext.define('Ext.viewport.Viewport', {singleton:true, setup:function(config) {
  var osName = Ext.os.name, viewportName;
  switch(osName) {
    case 'Android':
      viewportName = Ext.browser.name === 'ChromeMobile' ? 'Default' : 'Android';
      break;
    case 'iOS':
      viewportName = 'Ios';
      break;
    case 'Windows':
      viewportName = Ext.browser.name === 'IE' ? 'WindowsPhone' : 'Default';
      break;
    case 'WindowsPhone':
      viewportName = 'WindowsPhone';
      break;
    default:
      viewportName = 'Default';
      break;
  }
  Ext.Viewport = Ext.create('Ext.viewport.' + viewportName, config);
}});
Ext.define('Ext.overrides.app.Application', {override:'Ext.app.Application', initMainView:function() {
  var me = this, viewport, mainView;
  me.viewport = viewport = Ext.Viewport;
  me.callParent();
  mainView = me.getMainView();
  viewport.onAppLaunch();
  if (mainView) {
    viewport.add(mainView);
  }
}});
Ext.define('Ext.app.domain.View', {extend:Ext.app.EventDomain, isInstance:true, constructor:function(controller) {
  this.callParent(arguments);
  this.controller = controller;
  this.monitoredClasses = [Ext.Component];
}, match:function(target, selector, controller) {
  var out = false;
  if (selector === '#') {
    out = controller === target.getController();
  } else {
    out = target.is(selector);
  }
  return out;
}, destroy:function() {
  this.controller = null;
  this.callParent();
}});
Ext.define('Ext.app.ViewController', {extend:Ext.app.BaseController, mixins:[Ext.mixin.Factoryable], isViewController:true, factoryConfig:{type:'controller'}, config:{closeViewAction:'destroy'}, view:null, constructor:function() {
  this.compDomain = new Ext.app.domain.View(this);
  this.callParent(arguments);
}, beforeInit:Ext.emptyFn, init:Ext.emptyFn, initViewModel:Ext.emptyFn, destroy:function() {
  var me = this, domain = me.compDomain;
  if (domain) {
    domain.unlisten(me);
    domain.destroy();
  }
  me.compDomain = me.view = null;
  me.callParent();
}, closeView:function() {
  var view = this.getView(), action;
  if (view) {
    action = this.getCloseViewAction();
    view[action]();
  }
}, control:function(selectors, listeners) {
  var obj = selectors;
  if (Ext.isString(selectors)) {
    obj = {};
    obj[selectors] = listeners;
  }
  this.compDomain.listen(obj, this);
}, listen:function(to, controller) {
  var component = to.component;
  if (component) {
    to = Ext.apply({}, to);
    delete to.component;
    this.control(component);
  }
  this.callParent([to, controller]);
}, getReferences:function() {
  var view = this.view;
  return view && view.getReferences();
}, getView:function() {
  return this.view;
}, lookup:function(key) {
  var view = this.view;
  return view && view.lookup(key);
}, lookupReference:function(key) {
  return this.lookup(key);
}, getSession:function() {
  var view = this.view;
  return view && view.lookupSession();
}, getViewModel:function() {
  var view = this.view;
  return view && view.lookupViewModel();
}, getStore:function(name) {
  var viewModel = this.getViewModel();
  return viewModel ? viewModel.getStore(name) : null;
}, fireViewEvent:function(eventName, firstArg) {
  var view = this.view, result = false, args = arguments;
  if (view) {
    if (view !== firstArg) {
      args = Ext.Array.slice(args);
      args.splice(1, 0, view);
    }
    result = view.fireEvent.apply(view, args);
  }
  return result;
}, privates:{view:null, ensureId:function() {
  var id = this.getId();
  if (!id) {
    this.setId(Ext.id(null, 'controller-'));
  }
}, attachReference:function(component) {
  var view = this.view;
  if (view) {
    view.attachReference(component);
  }
}, clearReference:function(ref) {
  var view = this.view;
  if (view) {
    view.clearReference(ref);
  }
}, clearReferences:function() {
  var view = this.view;
  if (view) {
    view.clearReferences();
  }
}, setView:function(view) {
  this.view = view;
  if (!this.beforeInit.$nullFn) {
    this.beforeInit(view);
  }
}}});
Ext.define('Ext.util.Bag', {isBag:true, constructor:function() {
  this.items = [];
  this.map = {};
}, generation:0, length:0, add:function(item) {
  var me = this, id = me.getKey(item), map = me.map, items = me.items, idx = map[id], old;
  if (idx === undefined) {
    items.push(item);
    map[id] = me.length++;
    old = item;
  } else {
    old = items[idx];
    items[idx] = item;
  }
  ++me.generation;
  return old;
}, clear:function() {
  var me = this, needsClear = me.generation || me.length, ret = needsClear ? me.items : [];
  if (needsClear) {
    me.items = [];
    me.length = 0;
    me.map = {};
    ++me.generation;
  }
  return ret;
}, clone:function() {
  var me = this, ret = new me.self, len = me.length;
  if (len) {
    Ext.apply(ret.map, me.map);
    ret.items = me.items.slice();
    ret.length = me.length;
  }
  return ret;
}, contains:function(item) {
  var ret = false, map = this.map, key;
  if (item != null) {
    key = this.getKey(item);
    if (key in map) {
      ret = this.items[map[key]] === item;
    }
  }
  return ret;
}, containsKey:function(key) {
  return key in this.map;
}, destroy:function() {
  this.items = this.map = null;
  this.callParent();
}, getAt:function(index) {
  var out = null;
  if (index < this.length) {
    out = this.items[index];
  }
  return out;
}, getByKey:function(key) {
  var map = this.map, ret = null;
  if (key in map) {
    ret = this.items[map[key]];
  }
  return ret;
}, getCount:function() {
  return this.length;
}, getKey:function(item) {
  return item.id || item.getId();
}, remove:function(item) {
  var me = this, map = me.map, items = me.items, old = null, idx, id, last;
  if (me.length) {
    idx = map[id = me.getKey(item)];
    if (idx !== undefined) {
      delete map[id];
      old = items[idx];
      last = items.pop();
      if (idx < --me.length) {
        items[idx] = last;
        map[me.getKey(last)] = idx;
      }
      ++me.generation;
    }
  }
  return old;
}, removeByKey:function(key) {
  var item = this.getByKey(key);
  if (item) {
    this.remove(item);
  }
  return item || null;
}, sort:function(fn) {
  var me = this, items = me.items, n = items.length, item;
  if (n) {
    Ext.Array.sort(items, fn);
    me.map = {};
    while (n-- > 0) {
      item = items[n];
      me.map[me.getKey(item)] = n;
    }
    ++me.generation;
  }
}});
Ext.define('Ext.util.Scheduler', {mixins:[Ext.mixin.Observable], busyCounter:0, lastBusyCounter:0, destroyed:false, firing:null, notifyIndex:-1, nextId:0, orderedItems:null, passes:0, scheduledCount:0, validIdRe:null, config:{cycleLimit:5, preSort:null, tickDelay:5}, suspendOnNotify:true, constructor:function(config) {
  if (Ext.util.Scheduler.instances) {
    Ext.util.Scheduler.instances.push(this);
  } else {
    Ext.util.Scheduler.instances = [this];
  }
  this.id = Ext.util.Scheduler.count = (Ext.util.Scheduler.count || 0) + 1;
  this.mixins.observable.constructor.call(this, config);
  this.items = new Ext.util.Bag;
}, destroy:function() {
  var me = this, timer = me.timer;
  if (timer) {
    window.clearTimeout(timer);
    me.timer = null;
  }
  me.items.destroy();
  me.items = me.orderedItems = null;
  me.callParent();
  Ext.Array.remove(Ext.util.Scheduler.instances, this);
}, add:function(item) {
  var me = this, items = me.items;
  if (items === me.firing) {
    me.items = items = items.clone();
  }
  item.id = item.id || ++me.nextId;
  item.scheduler = me;
  items.add(item);
  if (!me.sortMap) {
    me.orderedItems = null;
  }
}, remove:function(item) {
  var me = this, items = me.items;
  if (me.destroyed) {
    return;
  }
  if (me.sortMap) {
    Ext.raise('Items cannot be removed during sort');
  }
  if (items === me.firing) {
    me.items = items = items.clone();
  }
  if (item.scheduled) {
    me.unscheduleItem(item);
    item.scheduled = false;
  }
  items.remove(item);
  me.orderedItems = null;
}, sort:function() {
  var me = this, items = me.items, sortMap = {}, preSort = me.getPreSort(), i, item;
  me.orderedItems = [];
  me.sortMap = sortMap;
  me.sortStack = [];
  if (preSort) {
    items.sort(preSort);
  }
  items = items.items;
  for (i = 0; i < items.length; ++i) {
    item = items[i];
    if (!sortMap[item.id]) {
      me.sortItem(item);
    }
  }
  me.sortMap = null;
  me.sortStack = null;
}, sortItem:function(item) {
  var me = this, sortMap = me.sortMap, orderedItems = me.orderedItems, itemId;
  if (!item.scheduler) {
    me.add(item);
  }
  itemId = item.id;
  if (item.scheduler !== me) {
    Ext.raise('Item ' + itemId + ' belongs to another Scheduler');
  }
  me.sortStack.push(item);
  if (sortMap[itemId] === 0) {
    for (var cycle = [], i = 0; i < me.sortStack.length; ++i) {
      cycle[i] = me.sortStack[i].getFullName();
    }
    Ext.raise('Dependency cycle detected: ' + cycle.join('\n --\x3e '));
  }
  if (!(itemId in sortMap)) {
    sortMap[itemId] = 0;
    if (!item.sort.$nullFn) {
      item.sort();
    }
    sortMap[itemId] = 1;
    item.order = me.orderedItems.length;
    orderedItems.push(item);
  }
  me.sortStack.pop();
  return me;
}, sortItems:function(items) {
  var me = this, sortItem = me.sortItem;
  if (items) {
    if (items instanceof Array) {
      Ext.each(items, sortItem, me);
    } else {
      Ext.Object.eachValue(items, sortItem, me);
    }
  }
  return me;
}, applyPreSort:function(preSort) {
  if (typeof preSort === 'function') {
    return preSort;
  }
  var parts = preSort.split(','), direction = [], length = parts.length, c, i, s;
  for (i = 0; i < length; ++i) {
    direction[i] = 1;
    s = parts[i];
    if ((c = s.charAt(0)) === '-') {
      direction[i] = -1;
    } else {
      if (c !== '+') {
        c = 0;
      }
    }
    if (c) {
      parts[i] = s.substring(1);
    }
  }
  return function(lhs, rhs) {
    var ret = 0, i, prop, v1, v2;
    for (i = 0; !ret && i < length; ++i) {
      prop = parts[i];
      v1 = lhs[prop];
      v2 = rhs[prop];
      ret = direction[i] * (v1 < v2 ? -1 : v2 < v1 ? 1 : 0);
    }
    return ret;
  };
}, notify:function() {
  var me = this, timer = me.timer, cyclesLeft = me.getCycleLimit(), globalEvents = Ext.GlobalEvents, suspend = me.suspendOnNotify, busyCounter, i, item, len, queue, firedEvent;
  if (timer) {
    window.clearTimeout(timer);
    me.timer = null;
  }
  if (me.firing) {
    Ext.raise('Notify cannot be called recursively');
  }
  if (suspend) {
    Ext.suspendLayouts();
  }
  while (me.scheduledCount) {
    if (cyclesLeft) {
      --cyclesLeft;
    } else {
      me.firing = null;
      if (me.onCycleLimitExceeded) {
        me.onCycleLimitExceeded();
      }
      break;
    }
    if (!firedEvent) {
      firedEvent = true;
      if (globalEvents.hasListeners.beforebindnotify) {
        globalEvents.fireEvent('beforebindnotify', me);
      }
    }
    ++me.passes;
    if (!(queue = me.orderedItems)) {
      me.sort();
      queue = me.orderedItems;
    }
    len = queue.length;
    if (len) {
      me.firing = me.items;
      for (i = 0; i < len; ++i) {
        item = queue[i];
        if (item.scheduled) {
          item.scheduled = false;
          --me.scheduledCount;
          me.notifyIndex = i;
          item.react();
          if (!me.scheduledCount) {
            break;
          }
        }
      }
    }
  }
  me.firing = null;
  me.notifyIndex = -1;
  if (suspend) {
    Ext.resumeLayouts(true);
  }
  if ((busyCounter = me.busyCounter) !== me.lastBusyCounter) {
    if (!(me.lastBusyCounter = busyCounter)) {
      me.fireEvent('idle', me);
    }
  }
}, onTick:function() {
  this.timer = null;
  this.notify();
}, scheduleItem:function(item) {
  var me = this;
  ++me.scheduledCount;
  if (!me.timer && !me.firing) {
    me.scheduleTick();
  }
}, scheduleTick:function() {
  var me = this;
  if (!me.destroyed && !me.timer) {
    me.timer = Ext.Function.defer(me.onTick, me.getTickDelay(), me);
  }
}, unscheduleItem:function(item) {
  if (this.scheduledCount) {
    --this.scheduledCount;
  }
}, adjustBusy:function(adjustment) {
  var me = this, busyCounter = me.busyCounter + adjustment;
  me.busyCounter = busyCounter;
  if (busyCounter) {
    if (!me.lastBusyCounter) {
      me.lastBusyCounter = busyCounter;
      me.fireEvent('busy', me);
    }
  } else {
    if (me.lastBusyCounter && !me.timer) {
      me.scheduleTick();
    }
  }
}, isBusy:function() {
  return !this.isIdle();
}, isIdle:function() {
  return !(this.busyCounter + this.lastBusyCounter);
}, debugHooks:{$enabled:false, onCycleLimitExceeded:function() {
  Ext.raise('Exceeded cycleLimit ' + this.getCycleLimit());
}, scheduleItem:function(item) {
  if (!item) {
    Ext.raise('scheduleItem: Invalid argument');
  }
  Ext.log('Schedule item: ' + item.getFullName() + ' - ' + (this.scheduledCount + 1));
  if (item.order <= this.notifyIndex) {
    Ext.log.warn('Suboptimal order: ' + item.order + ' \x3c ' + this.notifyIndex);
  }
  this.callParent([item]);
}, unscheduleItem:function(item) {
  if (!this.scheduledCount) {
    Ext.raise('Invalid scheduleCount');
  }
  this.callParent([item]);
  Ext.log('Unschedule item: ' + item.getFullName() + ' - ' + this.scheduledCount);
}}});
Ext.define('Ext.data.Batch', {mixins:{observable:Ext.mixin.Observable}, config:{pauseOnException:false}, current:-1, total:0, running:false, complete:false, exception:false, constructor:function(config) {
  var me = this;
  me.mixins.observable.constructor.call(me, config);
  me.operations = [];
  me.exceptions = [];
}, add:function(operation) {
  var me = this, i, len;
  if (Ext.isArray(operation)) {
    for (i = 0, len = operation.length; i < len; ++i) {
      me.add(operation[i]);
    }
  } else {
    me.total++;
    operation.setBatch(me);
    me.operations.push(operation);
  }
  return me;
}, sort:function() {
  this.operations.sort(this.sortFn);
}, sortFn:function(operation1, operation2) {
  var ret = operation1.order - operation2.order;
  if (ret) {
    return ret;
  }
  var entityType1 = operation1.entityType, entityType2 = operation2.entityType, rank;
  if (!entityType1 || !entityType2) {
    return 0;
  }
  if (!(rank = entityType1.rank)) {
    entityType1.schema.rankEntities();
    rank = entityType1.rank;
  }
  return (rank - entityType2.rank) * operation1.foreignKeyDirection;
}, start:function(index) {
  var me = this;
  if (!me.operations.length || me.running) {
    return me;
  }
  me.exceptions.length = 0;
  me.exception = false;
  me.running = true;
  return me.runOperation(Ext.isDefined(index) ? index : me.current + 1);
}, retry:function() {
  return this.start(this.current);
}, runNextOperation:function() {
  var me = this;
  if (me.running) {
    me.runOperation(me.current + 1);
  }
  return me;
}, pause:function() {
  this.running = false;
  return this;
}, getOperations:function() {
  return this.operations;
}, getExceptions:function() {
  return this.exceptions;
}, getCurrent:function() {
  var out = null, current = this.current;
  if (!(current === -1 || this.complete)) {
    out = this.operations[current];
  }
  return out;
}, getTotal:function() {
  return this.total;
}, isRunning:function() {
  return this.running;
}, isComplete:function() {
  return this.complete;
}, hasException:function() {
  return this.exception;
}, runOperation:function(index) {
  var me = this, operations = me.operations, operation = operations[index];
  if (operation === undefined) {
    me.running = false;
    me.complete = true;
    me.fireEvent('complete', me, operations[operations.length - 1]);
  } else {
    me.current = index;
    operation.setInternalCallback(me.onOperationComplete);
    operation.setInternalScope(me);
    operation.execute();
  }
  return me;
}, onOperationComplete:function(operation) {
  var me = this, exception = operation.hasException();
  if (exception) {
    me.exception = true;
    me.exceptions.push(operation);
    me.fireEvent('exception', me, operation);
  }
  if (exception && me.getPauseOnException()) {
    me.pause();
  } else {
    me.fireEvent('operationcomplete', me, operation);
    me.runNextOperation();
  }
}});
Ext.define('Ext.data.matrix.Slice', {constructor:function(side, id) {
  this.id = id;
  this.side = side;
  this.members = {};
}, attach:function(store) {
  var me = this;
  Ext.Assert.falsey(me.store, 'Store is already attached');
  me.store = store;
  store.matrix = me;
  store.on('load', me.onStoreLoad, me, {single:true});
}, commit:function() {
  var members = this.members, id;
  for (id in members) {
    members[id][2] = 0;
  }
}, onStoreLoad:function(store) {
  this.update(store.getData().items, 0);
}, update:function(recordsOrIds, state) {
  if (!(recordsOrIds instanceof Array)) {
    Ext.raise('Only array of records or record ids are supported');
  }
  var me = this, MatrixSlice = Ext.data.matrix.Slice, side = me.side, assocIndex = side.index, length = recordsOrIds.length, id = me.id, members = me.members, otherSide = side.inverse, otherSlices = otherSide.slices, assoc, call, i, item, otherId, otherSlice, record;
  for (i = 0; i < length; ++i) {
    call = record = null;
    item = recordsOrIds[i];
    otherId = item.isEntity ? (record = item).id : item;
    assoc = members[otherId];
    if (state < 0 && assoc && assoc[2] === 1) {
      delete members[otherId];
      otherSlice = otherSlices[otherId];
      if (otherSlice) {
        delete otherSlice.members[id];
      }
      call = 1;
    } else {
      if (!assoc) {
        assoc = [otherId, otherId, state];
        assoc[assocIndex] = id;
        members[otherId] = assoc;
        otherSlice = otherSlices[otherId];
        if (!otherSlice) {
          otherSlices[otherId] = otherSlice = new MatrixSlice(otherSide, otherId);
        }
        otherSlice.members[id] = assoc;
        call = 1;
      } else {
        if (state !== assoc[2] && state !== 0) {
          assoc[2] = state;
          otherSlice = otherSlices[otherId];
          call = 1;
        }
      }
    }
    if (call) {
      if (me.notify) {
        me.notify.call(me.scope, me, otherId, state);
      }
      if (otherSlice && otherSlice.notify) {
        otherSlice.notify.call(otherSlice.scope, otherSlice, id, state);
      }
    }
  }
}, updateId:function(newId) {
  var me = this, oldId = me.id, side = me.side, slices = side.slices, slice = slices[oldId], members = slice.members, index = side.index, otherSlices = side.inverse.slices, assoc, otherId, otherMembers;
  me.id = newId;
  slices[newId] = slice;
  delete slices[oldId];
  for (otherId in members) {
    assoc = members[otherId];
    assoc[index] = newId;
    otherMembers = otherSlices[otherId].members;
    otherMembers[newId] = otherMembers[oldId];
    delete otherMembers[oldId];
  }
}, destroy:function() {
  var me = this, store = me.store;
  if (store) {
    store.matrix = null;
    store.un('load', me.onStoreLoad, me);
  }
  me.notify = me.scope = me.store = me.side = me.members = null;
  me.callParent();
}});
Ext.define('Ext.data.matrix.Side', {constructor:function(matrix, index, role) {
  var me = this;
  me.matrix = matrix;
  me.index = index;
  me.role = role;
  me.slices = {};
}, commit:function() {
  var slices = this.slices, id;
  for (id in slices) {
    slices[id].commit();
  }
}, get:function(id1, id2) {
  var me = this, slices = me.slices, slice = slices[id1] || (slices[id1] = new Ext.data.matrix.Slice(me, id1));
  return id2 || id2 === 0 ? slice.members[id2] : slice;
}, update:function(id1, id2, state) {
  var slice = this.get(id1);
  return slice.update(id2, state);
}, updateId:function(oldId, newId) {
  var slice = this.get(oldId);
  if (slice) {
    slice.updateId(newId);
  }
}, destroy:function() {
  var me = this, slices = me.slices, id;
  for (id in slices) {
    slices[id].destroy();
  }
  me.inverse = me.matrix = me.role = me.slices = null;
  me.callParent();
}});
Ext.define('Ext.data.matrix.Matrix', {constructor:function(session, matrix) {
  var me = this, association = matrix.isManyToMany ? matrix : session.getSchema().getAssociation(matrix), Side = Ext.data.matrix.Side, left = new Side(me, 0, association.left), right = new Side(me, 1, association.right);
  Ext.Assert.truthy(association.isManyToMany, 'Association is not many-to-many');
  me.association = association;
  me.session = session;
  me.left = left;
  me.right = right;
  left.inverse = right;
  right.inverse = left;
}, commit:function() {
  this.left.commit();
  this.right.commit();
}, update:function(id1, id2, state) {
  return this.left.update(id1, id2, state);
}, updateId:function(record, oldId, newId) {
  var Type = record.self, left = this.left, right = this.right, matchSide;
  if (Type === left.role.cls) {
    matchSide = left;
  }
  if (Type === right.role.cls) {
    matchSide = right;
  }
  if (matchSide) {
    matchSide.updateId(oldId, newId);
  }
}, destroy:function() {
  var me = this;
  me.left.destroy();
  me.right.destroy();
  me.association = me.session = me.left = me.right = null;
  me.callParent();
}});
Ext.define('Ext.data.session.ChangesVisitor', {constructor:function(session) {
  var me = this, crud;
  me.session = session;
  crud = session.getCrudProperties();
  me.result = null;
  me.writerOptions = {};
  me.createKey = crud.create;
  me.readKey = crud.read;
  me.updateKey = crud.update;
  me.dropKey = crud.drop;
}, onDirtyRecord:function(record) {
  var me = this, crud = me.crud, created = record.phantom, dropped = record.dropped, updated = !created && !dropped, type = record.$className, prop = created || dropped ? 'allDataOptions' : 'partialDataOptions', writerOptions = me.writerOptions, name = record.entityName, options, bucket, entry, result;
  if (created && dropped) {
    return false;
  }
  crud = created ? me.createKey : dropped ? me.dropKey : me.updateKey;
  writerOptions = writerOptions[type] || (writerOptions[type] = {});
  if (dropped) {
    if (!(options = writerOptions.drop)) {
      writerOptions.drop = options = {all:record.getProxy().getWriter().getWriteAllFields()};
    }
    if (!options.all) {
      entry = record.id;
    }
  }
  if (!entry) {
    if (!(options = writerOptions[prop])) {
      options = record.getProxy().getWriter().getConfig(prop);
      writerOptions[prop] = options = Ext.Object.chain(options);
      me.setupOptions(options);
    }
    entry = record.getData(options);
  }
  result = me.result || (me.result = {});
  bucket = result[name] || (result[name] = {});
  bucket = bucket[crud] || (bucket[crud] = []);
  bucket.push(entry);
}, setupOptions:function(options) {
  options.serialize = true;
}, onMatrixChange:function(association, id1, id2, state) {
  var me = this, name = association.left.type, assocName = association.right.role, operation = state < 0 ? me.dropKey : me.createKey, bucket, result;
  result = me.result || (me.result = {});
  bucket = result[name] || (result[name] = {});
  bucket = bucket[assocName] || (bucket[assocName] = {});
  bucket = bucket[operation] || (bucket[operation] = {});
  bucket = bucket[id1] || (bucket[id1] = []);
  bucket.push(id2);
}});
Ext.define('Ext.data.session.ChildChangesVisitor', {extend:Ext.data.session.ChangesVisitor, constructor:function() {
  this.seen = {};
  this.callParent(arguments);
}, setupOptions:function(options) {
  this.callParent([options]);
  options.serialize = false;
}, onDirtyRecord:function(record) {
  if (this.callParent(arguments) !== false) {
    if (!record.$source && (record.dropped || !record.phantom)) {
      this.readEntity(record);
    }
  }
}, readEntity:function(record) {
  var me = this, readKey = me.readKey, name = record.entityName, id = record.id, seen = me.seen, seenKey = name + id, result, bucket;
  if (seen[seenKey]) {
    return;
  }
  seen[seenKey] = true;
  result = me.result || (me.result = {});
  bucket = result[name] || (result[name] = {});
  bucket = bucket[readKey] || (bucket[readKey] = []);
  bucket.push(Ext.apply({}, record.modified, record.data));
}});
Ext.define('Ext.data.session.BatchVisitor', {map:null, constructor:function(batch) {
  this.batch = batch;
}, getBatch:function(sort) {
  var map = this.map, batch = this.batch, bucket, entity, name, operation, proxy;
  if (map) {
    if (!batch) {
      batch = new Ext.data.Batch;
    }
    for (name in map) {
      bucket = map[name];
      entity = bucket.entity;
      proxy = entity.getProxy();
      delete bucket.entity;
      for (operation in bucket) {
        operation = proxy.createOperation(operation, {records:bucket[operation]});
        operation.entityType = entity;
        batch.add(operation);
      }
    }
  }
  if (batch && sort !== false) {
    batch.sort();
  }
  return batch;
}, onDirtyRecord:function(record) {
  var me = this, operation = record.phantom ? 'create' : record.dropped ? 'destroy' : 'update', name = record.$className, map = me.map || (me.map = {}), bucket = map[name] || (map[name] = {entity:record.self});
  bucket = bucket[operation] || (bucket[operation] = []);
  bucket.push(record);
}});
Ext.define('Ext.data.Session', {isSession:true, config:{schema:'default', parent:null, autoDestroy:true, crudProperties:{create:'C', read:'R', update:'U', drop:'D'}}, destroyed:false, crudOperations:[{type:'R', entityMethod:'readEntities'}, {type:'C', entityMethod:'createEntities'}, {type:'U', entityMethod:'updateEntities'}, {type:'D', entityMethod:'dropEntities'}], crudKeys:{C:1, R:1, U:1, D:1}, constructor:function(config) {
  var me = this;
  me.data = {};
  me.matrices = {};
  me.identifierCache = {};
  me.recordCreator = me.recordCreator.bind(me);
  me.initConfig(config);
}, destroy:function() {
  var me = this, matrices = me.matrices, data = me.data, entityName, entities, record, id;
  for (id in matrices) {
    matrices[id].destroy();
  }
  for (entityName in data) {
    entities = data[entityName];
    for (id in entities) {
      record = entities[id].record;
      if (record) {
        record.$source = record.session = null;
      }
    }
  }
  me.recordCreator = me.matrices = me.data = null;
  me.setSchema(null);
  me.callParent();
}, adopt:function(record) {
  var me = this, associations = record.associations, roleName;
  me.checkModelType(record.self);
  if (record.session && record.session !== me) {
    Ext.raise('Record already belongs to an existing session');
  }
  if (record.session !== me) {
    record.session = me;
    me.add(record);
    if (associations) {
      for (roleName in associations) {
        associations[roleName].adoptAssociated(record, me);
      }
    }
  }
}, commit:function() {
  var data = this.data, matrices = this.matrices, entityName, entities, id, record;
  for (entityName in data) {
    entities = data[entityName];
    for (id in entities) {
      record = entities[id].record;
      if (record) {
        record.commit();
      }
    }
  }
  for (id in matrices) {
    matrices[id].commit();
  }
}, createRecord:function(type, data) {
  this.checkModelType(type);
  var Model = type.$isClass ? type : this.getSchema().getEntity(type), parent = this.getParent(), id;
  if (data && parent) {
    id = Model.getIdFromData(data);
    if (parent.peekRecord(Model, id)) {
      Ext.raise('A parent session already contains an entry for ' + Model.entityName + ': ' + id);
    }
  }
  return new Model(data, this);
}, getChanges:function() {
  var visitor = new Ext.data.session.ChangesVisitor(this);
  this.visitData(visitor);
  return visitor.result;
}, getChangesForParent:function() {
  var visitor = new Ext.data.session.ChildChangesVisitor(this);
  this.visitData(visitor);
  return visitor.result;
}, getRecord:function(type, id, autoLoad) {
  var me = this, wasInstance = type.isModel, record, Model, parent, parentRec;
  if (wasInstance) {
    wasInstance = type;
    id = type.id;
    type = type.self;
  }
  record = me.peekRecord(type, id);
  if (!record) {
    Model = type.$isClass ? type : me.getSchema().getEntity(type);
    parent = me.getParent();
    if (parent) {
      parentRec = parent.peekRecord(Model, id);
    }
    if (parentRec) {
      if (parentRec.isLoading()) {
        wasInstance = false;
      } else {
        record = parentRec.copy(undefined, me);
        record.$source = parentRec;
      }
    }
    if (!record) {
      if (wasInstance) {
        record = wasInstance;
        me.adopt(record);
      } else {
        record = Model.createWithId(id, null, me);
        if (autoLoad !== false) {
          record.load(Ext.isObject(autoLoad) ? autoLoad : undefined);
        }
      }
    }
  }
  return record;
}, getSaveBatch:function(sort) {
  var visitor = new Ext.data.session.BatchVisitor;
  this.visitData(visitor);
  return visitor.getBatch(sort);
}, onInvalidAssociationEntity:function(entityType, id) {
  Ext.raise('Unable to read association entity: ' + this.getModelIdentifier(entityType, id));
}, onInvalidEntityCreate:function(entityType, id) {
  Ext.raise('Cannot create, record already not exists: ' + this.getModelIdentifier(entityType, id));
}, onInvalidEntityDrop:function(entityType, id) {
  Ext.raise('Cannot drop, record does not exist: ' + this.getModelIdentifier(entityType, id));
}, onInvalidEntityRead:function(entityType, id) {
  Ext.raise('Cannot read, record already not exists: ' + this.getModelIdentifier(entityType, id));
}, onInvalidEntityUpdate:function(entityType, id, dropped) {
  if (dropped) {
    Ext.raise('Cannot update, record dropped: ' + this.getModelIdentifier(entityType, id));
  } else {
    Ext.raise('Cannot update, record does not exist: ' + this.getModelIdentifier(entityType, id));
  }
}, peekRecord:function(type, id, deep) {
  this.checkModelType(type);
  var entityType = type.$isClass ? type : this.getSchema().getEntity(type), entityName = entityType.entityName, entry = this.data[entityName], ret, parent;
  entry = entry && entry[id];
  ret = entry && entry.record;
  if (!ret && deep) {
    parent = this.getParent();
    ret = parent && parent.peekRecord(type, id, deep);
  }
  return ret || null;
}, save:function() {
  if (!this.getParent()) {
    Ext.raise('Cannot commit session, no parent exists');
  }
  var visitor = new Ext.data.session.ChildChangesVisitor(this);
  this.visitData(visitor);
  this.getParent().update(visitor.result);
}, spawn:function() {
  return new this.self({schema:this.getSchema(), parent:this});
}, update:function(data) {
  var me = this, schema = me.getSchema(), crudOperations = me.crudOperations, len = crudOperations.length, crudKeys = me.crudKeys, entityName, entityType, entityInfo, i, operation, item, associations, key, role, associationData;
  me.getSchema().processKeyChecks(true);
  for (entityName in data) {
    entityType = schema.getEntity(entityName);
    if (!entityType) {
      Ext.raise('Invalid entity type: ' + entityName);
    }
    entityInfo = data[entityName];
    for (i = 0; i < len; ++i) {
      operation = crudOperations[i];
      item = entityInfo[operation.type];
      if (item) {
        me[operation.entityMethod](entityType, item);
      }
    }
  }
  for (entityName in data) {
    entityType = schema.getEntity(entityName);
    associations = entityType.associations;
    entityInfo = data[entityName];
    for (key in entityInfo) {
      if (crudKeys[key]) {
        continue;
      }
      role = associations[key];
      if (!role) {
        Ext.raise('Invalid association key for ' + entityName + ', "' + key + '"');
      }
      associationData = entityInfo[role.role];
      role.processUpdate(me, associationData);
    }
  }
}, privates:{add:function(record) {
  var me = this, id = record.id, entry = me.getEntry(record.self, id), associations, roleName;
  if (entry.record) {
    Ext.raise('Duplicate id ' + record.id + ' for ' + record.entityName);
  }
  entry.record = record;
  me.registerReferences(record);
  associations = record.associations;
  for (roleName in associations) {
    associations[roleName].checkMembership(me, record);
  }
}, afterErase:function(record) {
  this.evict(record);
}, applySchema:function(schema) {
  return Ext.data.schema.Schema.get(schema);
}, checkModelType:function(name) {
  if (name.$isClass) {
    name = name.entityName;
  }
  if (!name) {
    Ext.raise('Unable to use anonymous models in a Session');
  } else {
    if (!this.getSchema().getEntity(name)) {
      Ext.raise('Unknown entity type ' + name);
    }
  }
}, createEntities:function(entityType, items) {
  var len = items.length, i, data, rec, id;
  for (i = 0; i < len; ++i) {
    data = items[i];
    id = entityType.getIdFromData(data);
    rec = this.peekRecord(entityType, id);
    if (!rec) {
      rec = this.createRecord(entityType, data);
    } else {
      this.onInvalidEntityCreate(entityType, id);
    }
    rec.phantom = true;
  }
}, dropEntities:function(entityType, ids) {
  var len = ids.length, i, rec, id, extractId;
  if (len) {
    extractId = Ext.isObject(ids[0]);
  }
  for (i = 0; i < len; ++i) {
    id = ids[i];
    if (extractId) {
      id = entityType.getIdFromData(id);
    }
    rec = this.peekRecord(entityType, id);
    if (rec) {
      rec.drop();
    } else {
      this.onInvalidEntityDrop(entityType, id);
    }
  }
}, evict:function(record) {
  var entityName = record.entityName, entities = this.data[entityName], id = record.id, entry;
  if (entities) {
    delete entities[id];
  }
}, getEntityList:function(entityType, ids) {
  var len = ids.length, i, id, rec, invalid;
  for (i = 0; i < len; ++i) {
    id = ids[i];
    rec = this.peekRecord(entityType, id);
    if (rec) {
      ids[i] = rec;
    } else {
      invalid = true;
      ids[i] = null;
      this.onInvalidAssociationEntity(entityType, id);
    }
  }
  if (invalid) {
    ids = Ext.Array.clean(ids);
  }
  return ids;
}, getEntry:function(type, id) {
  if (type.isModel) {
    id = type.getId();
    type = type.self;
  }
  var entityType = type.$isClass ? type : this.getSchema().getEntity(type), entityName = entityType.entityName, data = this.data, entry;
  entry = data[entityName] || (data[entityName] = {});
  entry = entry[id] || (entry[id] = {});
  return entry;
}, getRefs:function(record, role, includeParent) {
  var entry = this.getEntry(record), refs = entry && entry.refs && entry.refs[role.role], parent = includeParent && this.getParent(), parentRefs, id, rec;
  if (parent) {
    parentRefs = parent.getRefs(record, role);
    if (parentRefs) {
      for (id in parentRefs) {
        rec = parentRefs[id];
        if (!refs || !refs[id]) {
          this.getRecord(rec.self, rec.id);
        }
      }
      refs = entry && entry.refs && entry.refs[role.role];
    }
  }
  return refs || null;
}, getIdentifier:function(entityType) {
  var parent = this.getParent(), cache, identifier, key, ret;
  if (parent) {
    ret = parent.getIdentifier(entityType);
  } else {
    cache = this.identifierCache;
    identifier = entityType.identifier;
    key = identifier.id || entityType.entityName;
    ret = cache[key];
    if (!ret) {
      if (identifier.clone) {
        ret = identifier.clone({cache:cache});
      } else {
        ret = identifier;
      }
      cache[key] = ret;
    }
  }
  return ret;
}, getMatrix:function(matrix, preventCreate) {
  var name = matrix.isManyToMany ? matrix.name : matrix, matrices = this.matrices, ret;
  ret = matrices[name];
  if (!ret && !preventCreate) {
    ret = matrices[name] = new Ext.data.matrix.Matrix(this, matrix);
  }
  return ret || null;
}, getMatrixSlice:function(role, id) {
  var matrix = this.getMatrix(role.association), side = matrix[role.side];
  return side.get(id);
}, getModelIdentifier:function(entityType, id) {
  return id + '@' + entityType.entityName;
}, onIdChanged:function(record, oldId, newId) {
  var me = this, matrices = me.matrices, entityName = record.entityName, id = record.id, bucket = me.data[entityName], entry = bucket[oldId], associations = record.associations, refs = entry.refs, setNoRefs = me._setNoRefs, association, fieldName, matrix, refId, role, roleName, roleRefs, key;
  if (bucket[newId]) {
    Ext.raise('Cannot change ' + entityName + ' id from ' + oldId + ' to ' + newId + ' id already exists');
  }
  delete bucket[oldId];
  bucket[newId] = entry;
  for (key in matrices) {
    matrices[key].updateId(record, oldId, newId);
  }
  if (refs) {
    for (roleName in refs) {
      roleRefs = refs[roleName];
      role = associations[roleName];
      association = role.association;
      if (!association.isManyToMany) {
        fieldName = association.field.name;
        for (refId in roleRefs) {
          roleRefs[refId].set(fieldName, id, setNoRefs);
        }
      }
    }
  }
  me.registerReferences(record, oldId);
}, processManyBlock:function(entityType, role, items, processor) {
  var me = this, id, record, records, store;
  if (items) {
    for (id in items) {
      record = me.peekRecord(entityType, id);
      if (record) {
        records = me.getEntityList(role.cls, items[id]);
        store = role.getAssociatedItem(record);
        me[processor](role, store, record, records);
      } else {
        me.onInvalidAssociationEntity(entityType, id);
      }
    }
  }
}, processManyCreate:function(role, store, record, records) {
  if (store) {
    store.add(records);
  } else {
    record[role.getterName](null, null, records);
  }
}, processManyDrop:function(role, store, record, records) {
  if (store) {
    store.remove(records);
  }
}, processManyRead:function(role, store, record, records) {
  if (store) {
    store.setRecords(records);
  } else {
    record[role.getterName](null, null, records);
  }
}, readEntities:function(entityType, items) {
  var len = items.length, i, data, rec, id;
  for (i = 0; i < len; ++i) {
    data = items[i];
    id = entityType.getIdFromData(data);
    rec = this.peekRecord(entityType, id);
    if (!rec) {
      rec = this.createRecord(entityType, data);
    } else {
      this.onInvalidEntityRead(entityType, id);
    }
    rec.phantom = false;
  }
}, recordCreator:function(data, Model) {
  var me = this, id = Model.getIdFromData(data), record = me.peekRecord(Model, id, true);
  if (!record) {
    record = new Model(data, me);
  } else {
    record = me.getRecord(Model, id);
  }
  return record;
}, registerReferences:function(record, oldId) {
  var entityName = record.entityName, id = record.id, recordData = record.data, remove = oldId || oldId === 0, entry, i, fk, len, reference, references, refs, roleName;
  len = (references = record.references).length;
  for (i = 0; i < len; ++i) {
    reference = references[i];
    fk = recordData[reference.name];
    if (fk || fk === 0) {
      reference = reference.reference;
      entityName = reference.type;
      roleName = reference.inverse.role;
      entry = this.getEntry(reference.cls, fk);
      refs = entry.refs || (entry.refs = {});
      refs = refs[roleName] || (refs[roleName] = {});
      refs[id] = record;
      if (remove) {
        delete refs[oldId];
      }
    }
  }
}, updateEntities:function(entityType, items) {
  var len = items.length, i, data, rec, id, modified;
  if (Ext.isArray(items)) {
    for (i = 0; i < len; ++i) {
      data = items[i];
      id = entityType.getIdFromData(data);
      rec = this.peekRecord(entityType, id);
      if (rec) {
        rec.set(data);
      } else {
        this.onInvalidEntityUpdate(entityType, id);
      }
    }
  } else {
    for (id in items) {
      data = items[id];
      rec = this.peekRecord(entityType, id);
      if (rec && !rec.dropped) {
        modified = rec.set(data);
      } else {
        this.onInvalidEntityUpdate(entityType, id, !!rec);
      }
    }
  }
}, updateReference:function(record, field, newValue, oldValue) {
  var reference = field.reference, entityName = reference.type, roleName = reference.inverse.role, id = record.id, entry, refs;
  if (oldValue || oldValue === 0) {
    refs = this.getEntry(entityName, oldValue).refs[roleName];
    delete refs[id];
  }
  if (newValue || newValue === 0) {
    entry = this.getEntry(entityName, newValue);
    refs = entry.refs || (entry.refs = {});
    refs = refs[roleName] || (refs[roleName] = {});
    refs[id] = record;
  }
}, visitData:function(visitor) {
  var me = this, data = me.data, matrices = me.matrices, all, assoc, id, id2, matrix, members, name, record, slice, slices, state;
  me.getSchema().processKeyChecks(true);
  for (name in data) {
    all = data[name];
    for (id in all) {
      record = all[id].record;
      if (record) {
        if (record.phantom || record.dirty || record.dropped) {
          if (visitor.onDirtyRecord) {
            visitor.onDirtyRecord(record);
          }
        } else {
          if (visitor.onCleanRecord) {
            visitor.onCleanRecord(record);
          }
        }
      }
    }
  }
  if (visitor.onMatrixChange) {
    for (name in matrices) {
      matrix = matrices[name].left;
      slices = matrix.slices;
      assoc = matrix.role.association;
      for (id in slices) {
        slice = slices[id];
        members = slice.members;
        for (id2 in members) {
          state = (record = members[id2])[2];
          if (state) {
            visitor.onMatrixChange(assoc, record[0], record[1], state);
          }
        }
      }
    }
  }
  return visitor;
}, _setNoRefs:{refs:false}}});
Ext.define('Ext.util.Schedulable', {'abstract':true, isSchedulable:true, scheduled:false, constructor:function() {
  this.getScheduler().add(this);
}, destroy:function() {
  var me = this, scheduler = me.getScheduler();
  if (scheduler) {
    scheduler.remove(me);
  }
  me.scheduler = null;
  me.schedule = me.react = Ext.emptyFn;
  me.callParent();
}, getFullName:function() {
  return this.name || this.id;
}, privates:{getScheduler:function() {
  return this.scheduler;
}, schedule:function() {
  var me = this, scheduler;
  if (!me.scheduled) {
    scheduler = me.getScheduler();
    if (scheduler) {
      me.scheduled = true;
      if (me.onSchedule) {
        me.onSchedule();
      }
      scheduler.scheduleItem(me);
    }
  }
}, unschedule:function() {
  var me = this, scheduler;
  if (me.scheduled) {
    scheduler = me.getScheduler();
    if (scheduler) {
      scheduler.unscheduleItem(me);
    }
    me.scheduled = false;
  }
}, sort:function() {
}}});
Ext.define('Ext.app.bind.BaseBinding', {extend:Ext.util.Schedulable, calls:0, kind:20, defaultOptions:{}, lastValue:undefined, constructor:function(owner, callback, scope, options) {
  var me = this;
  me.options = options;
  me.owner = owner;
  me.scope = scope;
  me.callback = callback;
  if (!callback) {
    Ext.raise('Callback is required');
  }
  me.lateBound = Ext.isString(callback);
  if (options && options.deep) {
    me.deep = true;
  }
  me.callParent();
}, destroy:function() {
  var me = this, owner = me.owner;
  me.callParent();
  if (owner) {
    owner.onBindDestroy(me);
  }
  me.scope = me.callback = me.owner = null;
}, isReadOnly:function() {
  return true;
}, privates:{getScheduler:function() {
  var owner = this.owner;
  return owner && owner.getScheduler();
}, getSession:function() {
  var owner = this.owner;
  return owner.isSession ? owner : owner.getSession();
}, notify:function(value) {
  var me = this, options = me.options || me.defaultOptions, previous = me.lastValue;
  if (!me.calls || me.deep || previous !== value || Ext.isArray(value)) {
    ++me.calls;
    me.lastValue = value;
    if (me.lateBound) {
      me.scope[me.callback](value, previous, me);
    } else {
      me.callback.call(me.scope, value, previous, me);
    }
    if (options.single) {
      me.destroy();
    }
  }
}}});
Ext.define('Ext.app.bind.Binding', {extend:Ext.app.bind.BaseBinding, constructor:function(stub, callback, scope, options) {
  var me = this;
  me.callParent([stub.owner, callback, scope, options]);
  me.stub = stub;
  me.depth = stub.depth;
  if (!stub.isLoading() && !stub.scheduled) {
    me.schedule();
  }
}, destroy:function(fromParent) {
  var me = this, stub = me.stub;
  if (stub && !fromParent) {
    stub.unbind(me);
    me.stub = null;
  }
  me.callParent();
}, bindValidation:function(callback, scope) {
  var stub = this.stub;
  return stub && stub.bindValidation(callback, scope);
}, bindValidationField:function(callback, scope) {
  var stub = this.stub;
  return stub && stub.bindValidationField(callback, scope);
}, getFullName:function() {
  return this.fullName || (this.fullName = '@(' + this.stub.getFullName() + ')');
}, getValue:function() {
  var me = this, stub = me.stub, ret = stub && stub.getValue();
  if (me.transform) {
    ret = me.transform(ret);
  }
  return ret;
}, isLoading:function() {
  var stub = this.stub;
  return stub && stub.isLoading();
}, isReadOnly:function() {
  var stub = this.stub, options = this.options;
  if (!(options && options.twoWay === false)) {
    if (stub) {
      return stub.isReadOnly();
    }
  }
  return true;
}, refresh:function() {
}, setValue:function(value) {
  if (this.isReadOnly()) {
    Ext.raise('Cannot setValue on a readonly binding');
  }
  this.stub.set(value);
}, privates:{getDataObject:function() {
  var stub = this.stub;
  return stub && stub.getDataObject();
}, getRawValue:function() {
  var me = this, stub = me.stub, ret = stub && stub.getRawValue();
  if (me.transform) {
    ret = me.transform(ret);
  }
  return ret;
}, isDescendantOf:function(item) {
  var stub = this.stub;
  return stub ? item === stub || stub.isDescendantOf(item) : false;
}, react:function() {
  this.notify(this.getValue());
}, schedule:function() {
  if (!this.stub.scheduled) {
    this.callParent();
  }
}, sort:function() {
  var stub = this.stub;
  stub.scheduler.sortItem(stub);
}}});
Ext.define('Ext.app.bind.AbstractStub', {extend:Ext.util.Schedulable, children:null, depth:0, generation:1, kind:10, parent:null, constructor:function(owner, name) {
  var me = this;
  me.owner = owner;
  me.name = name;
  me.callParent();
}, destroy:function() {
  var me = this, children = me.children, bindings = me.bindings, len, i, key;
  if (bindings) {
    for (i = 0, len = bindings.length; i < len; ++i) {
      bindings[i].destroy(true);
    }
  }
  for (key in children) {
    children[key].destroy();
  }
  me.callParent();
  me.bindings = me.children = me.owner = null;
}, add:function(child) {
  var me = this;
  (me.children || (me.children = {}))[child.name] = child;
  child.depth = me.depth + 1;
  child.parent = me;
}, getChild:function(path) {
  var pathArray = Ext.isString(path) ? path.split('.') : path;
  if (pathArray && pathArray.length) {
    return this.descend(pathArray, 0);
  }
  return this;
}, getFullName:function() {
  var me = this, name = me.fullName, parent = me.parent, s;
  if (!name) {
    name = me.name || me.id;
    if (parent && (s = parent.getFullName())) {
      name = (s.charAt(s.length - 1) !== ':' ? s + '.' : s) + name;
    }
    me.fullName = name;
  }
  return name;
}, getSession:function() {
  var owner = this.owner;
  return owner.isSession ? owner : owner.getSession();
}, bind:function(callback, scope, options) {
  var me = this, binding = new Ext.app.bind.Binding(me, callback, scope, options), bindings = me.bindings || (me.bindings = []);
  binding.depth = me.depth;
  bindings.push(binding);
  return binding;
}, getValue:function() {
  return this.isLoading() ? null : this.getRawValue();
}, graft:function(replacement) {
  var me = this, bindings = me.bindings, name = me.name, i;
  me.parent = me.bindings = null;
  me.destroy();
  replacement.depth = me.depth;
  replacement.bindings = bindings;
  replacement.generation = me.generation + 1;
  replacement.name = name;
  replacement.id = me.id;
  replacement.path = me.path;
  if (bindings) {
    for (i = bindings.length; i-- > 0;) {
      bindings[i].stub = replacement;
    }
  }
  return replacement;
}, isDescendantOf:function(item) {
  for (var parent = this; parent = parent.parent;) {
    if (parent === item) {
      return true;
    }
  }
  return false;
}, onSchedule:function() {
  for (var i, len, binding, bindings, p = this.parent; p; p = p.parent) {
    bindings = p.bindings;
    if (bindings) {
      for (i = 0, len = bindings.length; i < len; ++i) {
        binding = bindings[i];
        if (binding.deep && !binding.scheduled) {
          binding.schedule();
        }
      }
    }
  }
}, react:function() {
  var bindings = this.bindings, binding, i, len;
  if (bindings) {
    for (i = 0, len = bindings.length; i < len; ++i) {
      binding = bindings[i];
      if (!binding.scheduled) {
        binding.schedule();
      }
    }
  }
}, unbind:function(binding) {
  var bindings = this.bindings;
  if (bindings && bindings.length) {
    Ext.Array.remove(bindings, binding);
  }
}, privates:{collect:function() {
  var children = this.children, bindings = this.bindings, totalCount = 0, count = 0, child, key;
  if (children) {
    for (key in children) {
      child = children[key];
      count = child.collect();
      if (count === 0) {
        child.destroy();
        delete children[key];
      }
      totalCount += count;
    }
  }
  if (bindings) {
    totalCount += bindings.length;
  }
  return totalCount;
}, getScheduler:function() {
  var owner = this.owner;
  return owner && owner.getScheduler();
}, sort:function() {
  var parent = this.parent;
  if (parent) {
    this.scheduler.sortItem(parent);
  }
}}});
Ext.define('Ext.app.bind.Stub', {extend:Ext.app.bind.AbstractStub, isStub:true, dirty:true, formula:null, validationKey:'validation', statics:{trackHadValue:function(value, owner, path, stub) {
  var children = stub && stub.children, child, key, hadValue;
  hadValue = value !== undefined;
  if (!owner.hadValue[path]) {
    owner.hadValue[path] = hadValue;
  }
  if (stub) {
    stub.hadValue = hadValue;
  }
  if (value && (value.constructor === Object || value.isModel)) {
    if (value.isModel) {
      value = value.data;
    }
    for (key in value) {
      Ext.app.bind.Stub.trackHadValue(value[key], owner, path + '.' + key, children && children[key]);
    }
  }
}}, constructor:function(owner, name, parent) {
  var me = this, path = name;
  me.callParent([owner, name]);
  me.boundValue = null;
  if (parent) {
    parent.add(me);
    if (!parent.isRootStub) {
      path = parent.path + '.' + name;
    }
  }
  me.hadValue = owner.hadValue[path];
  me.path = path;
}, destroy:function() {
  var me = this, formula = me.formula, parent = me.parent, storeBinding = me.storeBinding;
  if (formula) {
    formula.destroy();
  }
  if (storeBinding) {
    storeBinding.destroy();
  }
  me.detachBound();
  me.parentValue = me.formula = me.storeBinding = null;
  me.callParent();
}, bindValidation:function(callback, scope) {
  var parent = this.parent;
  return parent && parent.descend([this.validationKey, this.name]).bind(callback, scope);
}, bindValidationField:function(callback, scope) {
  var parent = this.parent, name = this.name, lateBound = typeof callback === 'string', ret;
  if (parent) {
    ret = parent.bind(function(value) {
      var field = null;
      if (value && value.isModel) {
        field = value.getField(name);
      }
      if (lateBound) {
        scope[callback](field, null, this);
      } else {
        callback.call(scope, field, null, this);
      }
    });
  }
  return ret || null;
}, descend:function(path, index) {
  var me = this, children = me.children || (me.children = {}), pos = index || 0, name = path[pos++], ret;
  if (!(ret = children[name])) {
    ret = new Ext.app.bind.Stub(me.owner, name, me);
  }
  if (pos < path.length) {
    ret = ret.descend(path, pos);
  }
  return ret;
}, getChildValue:function(parentData) {
  var me = this, name = me.name, ret;
  if (!parentData && !Ext.isString(parentData)) {
    ret = me.hadValue ? null : undefined;
  } else {
    ret = me.inspectValue(parentData);
    if (!ret) {
      if (parentData.isEntity) {
        ret = parentData.data[name];
      } else {
        ret = parentData[name];
      }
    }
  }
  return ret;
}, getDataObject:function() {
  var me = this, parentData = me.parent.getDataObject(), name = me.name, ret = parentData ? parentData[name] : null, associations, association;
  if (!ret && parentData && parentData.isEntity) {
    associations = parentData.associations;
    if (associations && name in associations) {
      ret = parentData[associations[name].getterName]();
    }
  }
  if (!ret || !(ret.$className || Ext.isObject(ret))) {
    parentData[name] = ret = {};
    me.hadValue = me.owner.hadValue[me.path] = true;
    me.invalidate(true, true);
  }
  return ret;
}, getRawValue:function() {
  return this.getChildValue(this.getParentValue());
}, graft:function(replacement) {
  var me = this, parent = me.parent, children = me.children, name = me.name, i;
  replacement.parent = parent;
  replacement.children = children;
  if (parent) {
    parent.children[name] = replacement;
  }
  if (children) {
    for (i in children) {
      children[i].parent = replacement;
    }
  }
  me.children = null;
  return me.callParent([replacement]);
}, isLoading:function() {
  var me = this, parent = me.parent, loading = false, associations, parentValue, value, loadSet;
  if (parent && !(loading = parent.isLoading())) {
    parentValue = me.getParentValue();
    value = me.inspectValue(parentValue);
    if (value) {
      loading = value.isLoading();
    } else {
      if (parentValue && parentValue.isModel) {
        associations = parentValue.associations;
        if (!(associations && me.name in associations)) {
          loading = false;
          loadSet = true;
        }
      }
      if (!loadSet) {
        loading = !me.hadValue && me.getRawValue() === undefined;
      }
    }
  }
  return loading;
}, invalidate:function(deep, dirtyOnly) {
  var me = this, children = me.children, name;
  me.dirty = true;
  if (!dirtyOnly && !me.isLoading()) {
    if (!me.scheduled) {
      me.schedule();
    }
  }
  if (deep && children) {
    for (name in children) {
      children[name].invalidate(deep, dirtyOnly);
    }
  }
}, isReadOnly:function() {
  var formula = this.formula;
  return !!(formula && !formula.set);
}, set:function(value) {
  var me = this, parent = me.parent, name = me.name, formula = me.formula, parentData, associations, association, formulaStub;
  if (formula && !formula.settingValue && formula.set) {
    formula.setValue(value);
    return;
  } else {
    if (me.isLinkStub) {
      formulaStub = me.getLinkFormulaStub();
      formula = formulaStub ? formulaStub.formula : null;
      if (formula) {
        if (formulaStub.isReadOnly()) {
          Ext.raise('Cannot setValue on a readonly formula');
        }
        formula.setValue(value);
        return;
      }
    }
  }
  parentData = parent.getDataObject();
  if (parentData.isEntity) {
    associations = parentData.associations;
    if (associations && name in associations) {
      association = associations[name];
      parentData[association.setterName](value);
      me.invalidate(true);
    } else {
      parentData.set(name, value);
    }
  } else {
    if (value && value.constructor === Object || value !== parentData[name]) {
      if (!me.setByLink(value)) {
        if (value === undefined) {
          delete parentData[name];
        } else {
          parentData[name] = value;
          Ext.app.bind.Stub.trackHadValue(value, me.owner, me.path, me);
        }
        me.inspectValue(parentData);
        me.invalidate(true);
      }
    }
  }
}, onStoreLoad:function() {
  this.invalidate(true);
}, afterLoad:function(record) {
  this.invalidate(true);
}, afterCommit:function(record) {
  this.afterEdit(record, null);
}, afterEdit:function(record, modifiedFieldNames) {
  var children = this.children, len = modifiedFieldNames && modifiedFieldNames.length, associations = record.associations, key, i, child, scheduled;
  if (children) {
    if (len) {
      for (i = 0; i < len; ++i) {
        child = children[modifiedFieldNames[i]];
        if (child) {
          child.invalidate();
        }
      }
    } else {
      for (key in children) {
        if (!(associations && key in associations)) {
          children[key].invalidate();
        }
      }
    }
  }
  this.invalidate();
}, afterReject:function(record) {
  this.afterEdit(record, null);
}, setByLink:function(value) {
  var me = this, n = 0, i, link, path, stub;
  for (stub = me; stub; stub = stub.parent) {
    if (stub.isLinkStub) {
      link = stub;
      if (n) {
        for (path = [], i = 0, stub = me; stub !== link; stub = stub.parent) {
          ++i;
          path[n - i] = stub.name;
        }
      }
      break;
    }
    ++n;
  }
  if (!link || !(stub = link.getTargetStub())) {
    return false;
  }
  if (path) {
    stub = stub.descend(path);
  }
  stub.set(value);
  return true;
}, setFormula:function(formula) {
  var me = this, oldFormula = me.formula;
  if (oldFormula) {
    oldFormula.destroy();
  }
  me.formula = new Ext.app.bind.Formula(me, formula);
}, react:function() {
  var me = this, bound = this.boundValue, children = me.children, generation;
  if (bound) {
    if (bound.isValidation) {
      bound.refresh();
      generation = bound.generation;
      if (me.lastValidationGeneration === generation) {
        return;
      }
      me.lastValidationGeneration = generation;
    } else {
      if (bound.isModel) {
        if (children && children[me.validationKey]) {
          bound.isValid();
        }
      } else {
        if (bound.isStore) {
          if (bound.isLoading() && !bound.loadCount) {
            return;
          }
        }
      }
    }
  }
  this.callParent();
}, privates:{collect:function() {
  var me = this, result = me.callParent(), storeBinding = me.storeBinding ? 1 : 0, formula = me.formula ? 1 : 0;
  return result + storeBinding + formula;
}, getLinkFormulaStub:function() {
  var stub = this;
  while (stub.isLinkStub) {
    stub = stub.binding.stub;
  }
  return stub.formula ? stub : null;
}, getParentValue:function() {
  var me = this;
  if (me.dirty) {
    me.parentValue = me.parent.getValue();
    me.dirty = false;
  }
  return me.parentValue;
}, setStore:function(storeBinding) {
  this.storeBinding = storeBinding;
}, inspectValue:function(parentData) {
  var me = this, name = me.name, current = me.boundValue, boundValue = null, associations, raw, changed, associatedEntity;
  if (parentData && parentData.isEntity) {
    associations = parentData.associations;
    if (associations && name in associations) {
      boundValue = parentData[associations[name].getterName]();
      if (boundValue && boundValue.isStore) {
        boundValue.$associatedStore = true;
      }
    } else {
      if (name === me.validationKey) {
        boundValue = parentData.getValidation();
        me.lastValidationGeneration = null;
      }
    }
  } else {
    if (parentData) {
      raw = parentData[name];
      if (raw && (raw.isModel || raw.isStore)) {
        boundValue = raw;
      }
    }
  }
  changed = current !== boundValue;
  if (changed) {
    if (current) {
      me.detachBound();
    }
    if (boundValue) {
      if (boundValue.isModel) {
        boundValue.join(me);
      } else {
        associatedEntity = boundValue.associatedEntity;
        if (associatedEntity && !associatedEntity.phantom && !boundValue.complete && !boundValue.hasPendingLoad()) {
          boundValue.load();
        }
        boundValue.on('load', me.onStoreLoad, me, {single:true});
      }
    }
    me.boundValue = boundValue;
  }
  return boundValue;
}, detachBound:function() {
  var me = this, current = me.boundValue;
  if (current) {
    if (current.isModel) {
      current.unjoin(me);
    } else {
      current.un('load', me.onStoreLoad, me);
    }
  }
}, sort:function() {
  var me = this, formula = me.formula, scheduler = me.scheduler, storeBinding = me.storeBinding;
  me.callParent();
  if (storeBinding) {
    scheduler.sortItem(storeBinding);
  }
  if (formula) {
    scheduler.sortItem(formula);
  }
}}});
Ext.define('Ext.app.bind.LinkStub', {extend:Ext.app.bind.Stub, isLinkStub:true, binding:null, destroy:function() {
  var me = this, binding = me.binding, owner = me.owner;
  if (binding) {
    me.binding = null;
    binding.destroy();
    if (owner) {
      delete owner.linkData[me.name];
    }
  }
  me.target = null;
  me.callParent();
}, getFullName:function() {
  var me = this;
  return me.fullName || (me.fullName = '(' + me.callParent() + ' -\x3e ' + me.binding.getFullName() + ')');
}, getDataObject:function() {
  var binding = this.binding;
  return binding && binding.getDataObject();
}, getRawValue:function() {
  var binding = this.binding;
  return binding && binding.getRawValue();
}, getValue:function() {
  var binding = this.binding;
  return binding && binding.getValue();
}, getTargetStub:function() {
  var binding = this.binding;
  return binding && binding.stub;
}, isLoading:function() {
  var binding = this.binding;
  return binding ? binding.isLoading() : false;
}, link:function(bindDescriptor, target) {
  var me = this, binding = me.binding;
  if (binding) {
    binding.destroy();
  }
  target = me.target = target || me.owner;
  me.linkDescriptor = bindDescriptor;
  me.binding = target.bind(bindDescriptor, me.onChange, me);
  me.binding.deep = true;
}, onChange:function() {
  this.invalidate(true);
}, react:function() {
  var me = this, linkData = me.owner.linkData;
  linkData[me.name] = me.getValue();
  me.callParent();
}, privates:{collect:function() {
  var me = this, result = me.callParent(), binding = me.binding ? 1 : 0;
  return result + binding;
}, sort:function() {
  var binding = this.binding;
  if (binding) {
    this.scheduler.sortItem(binding);
  }
}}});
Ext.define('Ext.app.bind.RootStub', {extend:Ext.app.bind.AbstractStub, isRootStub:true, depth:0, createRootChild:function(name, direct) {
  var me = this, owner = me.owner, ownerData = owner.getData(), children = me.children, previous = children && children[name], parentStub = previous ? null : me, parentVM, stub;
  if (direct || ownerData.hasOwnProperty(name) || !(parentVM = owner.getParent())) {
    stub = new Ext.app.bind.Stub(owner, name, parentStub);
  } else {
    stub = new Ext.app.bind.LinkStub(owner, name, previous ? null : parentStub);
    stub.link('{' + name + '}', parentVM);
  }
  if (previous) {
    previous.graft(stub);
  }
  return stub;
}, createStubChild:function(name) {
  return this.createRootChild(name, true);
}, descend:function(path, index) {
  var me = this, children = me.children, pos = index || 0, name = path[pos++], ret = children && children[name] || me.createRootChild(name);
  if (pos < path.length) {
    ret = ret.descend(path, pos);
  }
  return ret;
}, getFullName:function() {
  return this.fullName || (this.fullName = this.owner.id + ':');
}, getDataObject:function() {
  return this.owner.data;
}, getRawValue:function() {
  return this.owner.data;
}, getValue:function() {
  return this.owner.data;
}, isDescendantOf:function() {
  return false;
}, isLoading:function() {
  return false;
}, set:function(value) {
  if (!value || value.constructor !== Object) {
    Ext.raise('Only an object can be set at the root');
  }
  var me = this, children = me.children || (me.children = {}), owner = me.owner, data = owner.data, parentVM = owner.getParent(), linkStub, stub, v, key;
  for (key in value) {
    if (key.indexOf('.') >= 0) {
      Ext.raise('Value names cannot contain dots');
    }
    if ((v = value[key]) !== undefined) {
      if (!(stub = children[key])) {
        stub = new Ext.app.bind.Stub(owner, key, me);
      } else {
        if (stub.isLinkStub) {
          if (!stub.getLinkFormulaStub()) {
            linkStub = stub;
            stub = new Ext.app.bind.Stub(owner, key);
            linkStub.graft(stub);
          }
        }
      }
      stub.set(v);
    } else {
      if (data.hasOwnProperty(key)) {
        delete data[key];
        stub = children[key];
        if (stub && !stub.isLinkStub && parentVM) {
          stub = me.createRootChild(key);
        }
        stub.invalidate(true);
      }
    }
  }
}, schedule:Ext.emptyFn, unschedule:Ext.emptyFn});
Ext.define('Ext.app.bind.Multi', {extend:Ext.app.bind.BaseBinding, isMultiBinding:true, missing:1, deep:true, constructor:function(descriptor, owner, callback, scope, options) {
  var me = this, trackStatics = options && options.trackStatics;
  me.callParent([owner, callback, scope, options]);
  me.bindings = [];
  me.literal = descriptor.$literal;
  if (descriptor.constructor === Object) {
    if (trackStatics) {
      me.staticKeys = [];
    }
    me.addObject(descriptor, me.lastValue = {}, me.staticKeys);
  } else {
    me.addArray(descriptor, me.lastValue = []);
  }
  if (!--me.missing && !me.scheduled) {
    me.schedule();
  }
}, destroy:function() {
  var me = this;
  me.bindings = Ext.destroy(me.bindings);
  me.callParent();
}, add:function(descriptor, data, property) {
  var me = this, owner = me.owner, bindings = me.bindings, method = me.literal ? descriptor.reference ? 'bindEntity' : 'bindExpression' : 'bind', binding, depth;
  ++me.missing;
  binding = owner[method](descriptor, function(value) {
    data[property] = value;
    if (binding.calls === 1) {
      --me.missing;
    }
    if (!me.missing && !me.scheduled) {
      me.schedule();
    }
  }, me, null);
  depth = binding.depth;
  if (!bindings.length || depth < me.depth) {
    me.depth = depth;
  }
  bindings.push(binding);
  return !this.isBindingStatic(binding);
}, addArray:function(multiBindDescr, array) {
  var me = this, n = multiBindDescr.length, hasDynamic = false, dynamic, b, i;
  for (i = 0; i < n; ++i) {
    b = multiBindDescr[i];
    if (b && (b.reference || Ext.isString(b))) {
      dynamic = me.add(b, array, i);
    } else {
      if (Ext.isArray(b)) {
        dynamic = me.addArray(b, array[i] = []);
      } else {
        if (b && b.constructor === Object) {
          dynamic = me.addObject(b, array[i] = {});
        } else {
          array[i] = b;
          dynamic = false;
        }
      }
    }
    hasDynamic = hasDynamic || dynamic;
  }
  return hasDynamic;
}, addObject:function(multiBindDescr, object, staticKeys) {
  var me = this, hasDynamic = false, dynamic, b, name;
  for (name in multiBindDescr) {
    b = multiBindDescr[name];
    if (b && (b.reference || Ext.isString(b))) {
      dynamic = me.add(b, object, name);
    } else {
      if (Ext.isArray(b)) {
        dynamic = me.addArray(b, object[name] = []);
      } else {
        if (b && b.constructor === Object) {
          dynamic = me.addObject(b, object[name] = {});
        } else {
          object[name] = b;
          dynamic = false;
        }
      }
    }
    if (staticKeys && !dynamic) {
      staticKeys.push(name);
    }
    hasDynamic = hasDynamic || dynamic;
  }
  return hasDynamic;
}, getFullName:function() {
  var me = this, fullName = me.fullName, bindings = me.bindings, length = bindings.length, i;
  if (!fullName) {
    fullName = '@[';
    for (i = 0; i < length; ++i) {
      if (i) {
        fullName += ',';
      }
      fullName += bindings[i].getFullName();
    }
    fullName += ']';
    me.fullName = fullName;
  }
  return fullName;
}, getRawValue:function() {
  return this.lastValue;
}, isDescendantOf:function() {
  return false;
}, isLoading:function() {
  for (var bindings = this.bindings, n = bindings.length; n-- > 0;) {
    if (bindings[n].isLoading()) {
      return true;
    }
  }
  return false;
}, isBindingStatic:function(binding) {
  return binding.isTemplateBinding && binding.isStatic;
}, isStatic:function() {
  var bindings = this.bindings, len = bindings.length, i, binding;
  for (i = 0; i < len; ++i) {
    binding = bindings[i];
    if (!this.isBindingStatic(binding)) {
      return false;
    }
  }
  return true;
}, pruneStaticKeys:function() {
  var value = Ext.apply({}, this.lastValue), keys = this.staticKeys, len = keys.length, i;
  for (i = 0; i < len; ++i) {
    delete value[keys[i]];
  }
  return value;
}, react:function() {
  this.notify(this.lastValue);
}, refresh:function() {
}, privates:{sort:function() {
  this.scheduler.sortItems(this.bindings);
}}});
Ext.define('Ext.app.bind.Formula', {extend:Ext.util.Schedulable, statics:{getFormulaParser:function(name) {
  var cache = this.formulaCache, parser, s;
  if (!cache) {
    cache = this.formulaCache = new Ext.util.LruCache({maxSize:20});
  }
  parser = cache.get(name);
  if (!parser) {
    s = '[^\\.a-z0-9_]' + name + '\\(\\s*([\'"])(.*?)\\1\\s*\\)';
    parser = new RegExp(s, 'gi');
    cache.add(name, parser);
  }
  return parser;
}}, isFormula:true, calculation:null, explicit:false, set:null, single:false, argumentNamesRe:/^function\s*\(\s*([^,\)\s]+)/, constructor:function(stub, formula) {
  var me = this, owner = stub.owner, bindTo, expressions, getter, options;
  me.owner = owner;
  me.stub = stub;
  me.callParent();
  if (formula instanceof Function) {
    me.get = getter = formula;
  } else {
    me.get = getter = formula.get;
    me.set = formula.set;
    expressions = formula.bind;
    if (formula.single) {
      me.single = formula.single;
    }
    if (expressions) {
      bindTo = expressions.bindTo;
      if (bindTo) {
        options = Ext.apply({}, expressions);
        delete options.bindTo;
        expressions = bindTo;
      }
    }
  }
  if (!getter) {
    Ext.raise('Must specify a getter method for a formula');
  }
  if (expressions) {
    me.explicit = true;
  } else {
    expressions = getter.$expressions || me.parseFormula(getter);
  }
  me.binding = owner.bind(expressions, me.onChange, me, options);
}, destroy:function() {
  var me = this, binding = me.binding, stub = me.stub;
  if (binding) {
    binding.destroy();
    me.binding = null;
  }
  if (stub) {
    stub.formula = null;
  }
  me.callParent();
  me.getterFn = me.owner = null;
}, getFullName:function() {
  return this.fullName || (this.fullName = this.stub.getFullName() + '\x3d' + this.callParent() + ')');
}, getRawValue:function() {
  return this.calculation;
}, onChange:function() {
  if (!this.scheduled) {
    this.schedule();
  }
}, parseFormula:function(formula) {
  var str = formula.toString(), expressions = {$literal:true}, match, getterProp, formulaRe, expr;
  match = this.argumentNamesRe.exec(str);
  getterProp = match ? match[1] : 'get';
  formulaRe = Ext.app.bind.Formula.getFormulaParser(getterProp);
  while (match = formulaRe.exec(str)) {
    expr = match[2];
    expressions[expr] = expr;
  }
  expressions.$literal = true;
  formula.$expressions = expressions;
  return expressions;
}, react:function() {
  var me = this, owner = me.owner, data = me.binding.lastValue, getterFn = me.getterFn, arg;
  if (me.explicit) {
    arg = data;
  } else {
    arg = owner.getFormulaFn(data);
  }
  me.settingValue = true;
  me.stub.set(me.calculation = me.get.call(owner, arg));
  me.settingValue = false;
  if (me.single) {
    me.destroy();
  }
}, setValue:function(value) {
  this.set.call(this.stub.owner, value);
}, privates:{getScheduler:function() {
  var owner = this.owner;
  return owner && owner.getScheduler();
}, sort:function() {
  var me = this, binding = me.binding;
  if (!binding.destroyed) {
    me.scheduler.sortItem(binding);
  }
}}});
Ext.define('Ext.app.bind.Template', {numberRe:/^(?:\d+(?:\.\d*)?)$/, stringRe:/^(?:["][^"]*["])$/, tokenRe:/\{[!]?(?:(?:(\d+)|([a-z_][\w\-\.]*))(?::([a-z_\.]+)(?:\(([^\)]*?)?\))?)?)\}/gi, formatRe:/^([a-z_]+)(?:\(([^\)]*?)?\))?$/i, buffer:null, slots:null, tokens:null, constructor:function(text) {
  var me = this, initters = me._initters, name;
  me.text = text;
  for (name in initters) {
    me[name] = initters[name];
  }
}, _initters:{apply:function(values, scope) {
  return this.parse().apply(values, scope);
}, getTokens:function() {
  return this.parse().getTokens();
}}, apply:function(values, scope) {
  var me = this, slots = me.slots, buffer = me.buffer, length = slots.length, i, slot, value;
  for (i = 0; i < length; ++i) {
    slot = slots[i];
    if (slot) {
      if ((value = values[slot.pos]) == null) {
        value = '';
      }
      if (slot.not) {
        value = !value;
      }
      if (slot.format) {
        value = slot.format(value, scope);
      }
      buffer[i] = value;
    }
  }
  return buffer.join('');
}, getTokens:function() {
  return this.tokens;
}, parse:function() {
  var me = this, text = me.text, buffer = [], slots = [], tokens = [], tokenMap = {}, last = 0, tokenRe = me.tokenRe, pos = 0, fmt, i, length, match, s, slot, token;
  for (i in me._initters) {
    delete me[i];
  }
  me.buffer = buffer;
  me.slots = slots;
  me.tokens = tokens;
  while (match = tokenRe.exec(text)) {
    length = match.index - last;
    if (length) {
      buffer[pos++] = text.substring(last, last + length);
      last += length;
    }
    last += (s = match[0]).length;
    slot = {fmt:fmt = match[3] || null, index:match[1] ? parseInt(match[1], 10) : null, not:s.charAt(1) === '!', token:match[2] || null};
    token = slot.token || String(slot.index);
    if (token in tokenMap) {
      slot.pos = tokenMap[token];
    } else {
      tokenMap[token] = slot.pos = tokens.length;
      tokens.push(token);
    }
    if (fmt) {
      if (fmt.substring(0, 5) === 'this.') {
        slot.fmt = fmt.substring(5);
      } else {
        if (!(fmt in Ext.util.Format)) {
          Ext.raise('Invalid format specified: "' + fmt + '"');
        }
        slot.scope = Ext.util.Format;
      }
      me.parseArgs(match[4], slot);
    }
    slots[pos++] = slot;
  }
  if (last < text.length) {
    buffer[pos++] = text.substring(last);
  }
  return me;
}, parseArgs:function(argsString, slot) {
  var me = this, numberRe = me.numberRe, stringRe = me.stringRe, arg, args, i, length;
  if (!argsString) {
    args = [];
  } else {
    if (argsString.indexOf(',') < 0) {
      args = [argsString];
    } else {
      args = argsString.split(',');
    }
  }
  slot = slot || {};
  length = args.length;
  slot.args = args;
  for (i = 0; i < length; ++i) {
    arg = args[i];
    if (arg === 'true') {
      args[i] = true;
    } else {
      if (arg === 'false') {
        args[i] = false;
      } else {
        if (arg === 'null') {
          args[i] = null;
        } else {
          if (numberRe.test(arg)) {
            args[i] = parseFloat(arg);
          } else {
            if (stringRe.test(arg)) {
              args[i] = arg.substring(1, arg.length - 1);
            } else {
              slot.fn = Ext.functionFactory('return [' + argsString + '];');
              slot.format = me._formatEval;
              break;
            }
          }
        }
      }
    }
  }
  if (!slot.format) {
    args.unshift(0);
    slot.format = me._formatArgs;
  }
  return slot;
}, parseFormat:function(fmt) {
  var me = this, match = me.formatRe.exec(fmt), slot = {fmt:fmt, scope:Ext.util.Format}, args;
  if (!match) {
    Ext.raise('Invalid format syntax: "' + slot + '"');
  }
  args = match[2];
  if (args) {
    slot.fmt = match[1];
    me.parseArgs(args, slot);
  } else {
    slot.args = [0];
    slot.format = me._formatArgs;
  }
  return slot;
}, _formatArgs:function(value, scope) {
  scope = this.scope || scope;
  this.args[0] = value;
  return scope[this.fmt].apply(scope, this.args);
}, _formatEval:function(value, scope) {
  var args = this.fn();
  args.unshift(value);
  scope = this.scope || scope;
  return scope[this.fmt].apply(scope, args);
}});
Ext.define('Ext.app.bind.TemplateBinding', {extend:Ext.app.bind.BaseBinding, isTemplateBinding:true, lastValue:undefined, value:undefined, constructor:function(template, owner, callback, scope, options) {
  var me = this, tpl = new Ext.app.bind.Template(template), tokens = tpl.getTokens();
  me.callParent([owner, callback, scope, options]);
  me.tpl = tpl;
  me.tokens = tokens;
  tokens.$literal = true;
  if (tokens.length) {
    me.multiBinding = new Ext.app.bind.Multi(tokens, owner, me.onBindData, me);
  } else {
    me.isStatic = true;
    me.onData(tpl.text);
  }
}, destroy:function() {
  var me = this;
  Ext.destroy(me.multiBinding);
  me.tpl = me.multiBinding = null;
  me.callParent();
}, getFullName:function() {
  var multi = this.multiBinding;
  return this.fullName || (this.fullName = '$' + (multi ? multi.getFullName() : this.callParent()));
}, getRawValue:function() {
  return this.value;
}, getTemplateScope:function() {
  return null;
}, isDescendantOf:function() {
  return false;
}, isLoading:function() {
  var multi = this.multiBinding;
  return multi ? multi.isLoading() : false;
}, onBindData:function(data) {
  this.onData(this.tpl.apply(data, this.getTemplateScope()));
}, onData:function(value) {
  var me = this, lastValue = me.value;
  if (lastValue !== (me.value = value)) {
    me.lastValue = lastValue;
    me.schedule();
  }
}, react:function() {
  this.notify(this.value);
}, refresh:function() {
  var multi = this.multiBinding;
  if (multi) {
    multi.refresh();
  }
}, privates:{sort:function() {
  var multi = this.multiBinding;
  if (multi) {
    this.scheduler.sortItem(multi);
  }
}}});
Ext.define('Ext.data.ChainedStore', {extend:Ext.data.AbstractStore, alias:'store.chained', config:{source:null, remoteFilter:false, remoteSort:false}, mixins:[Ext.data.LocalStore], constructor:function() {
  this.callParent(arguments);
  this.getData().addObserver(this);
}, updateRemoteFilter:function(remoteFilter, oldRemoteFilter) {
  if (remoteFilter) {
    Ext.raise('Remote filtering cannot be used with chained stores.');
  }
  this.callParent([remoteFilter, oldRemoteFilter]);
}, updateRemoteSort:function(remoteSort, oldRemoteSort) {
  if (remoteSort) {
    Ext.raise('Remote sorting cannot be used with chained stores.');
  }
  this.callParent([remoteSort, oldRemoteSort]);
}, remove:function() {
  var source = this.getSource();
  return source.remove.apply(source, arguments);
}, removeAll:function() {
  var source = this.getSource();
  return source.removeAll();
}, getData:function() {
  var me = this, data = me.data;
  if (!data) {
    me.data = data = me.constructDataCollection();
  }
  return data;
}, getSession:function() {
  return this.getSource().getSession();
}, applySource:function(source) {
  if (source) {
    var original = source, s;
    source = Ext.data.StoreManager.lookup(source);
    if (!source) {
      s = 'Invalid source {0}specified for Ext.data.ChainedStore';
      s = Ext.String.format(s, typeof original === 'string' ? '"' + original + '" ' : '');
      Ext.raise(s);
    }
  }
  return source;
}, updateSource:function(source, oldSource) {
  var me = this, data;
  if (oldSource) {
    oldSource.removeObserver(me);
  }
  if (source) {
    data = me.getData();
    data.setSource(source.getData());
    if (!me.isInitializing) {
      me.fireEvent('refresh', me);
      me.fireEvent('datachanged', me);
    }
    source.addObserver(me);
  }
}, getModel:function() {
  return this.getSource().getModel();
}, getProxy:function() {
  return null;
}, onCollectionAdd:function(collection, info) {
  var me = this, records = info.items, lastChunk = !info.next;
  if (me.ignoreCollectionAdd) {
    return;
  }
  me.fireEvent('add', me, records, info.at);
  if (lastChunk) {
    me.fireEvent('datachanged', me);
  }
}, onCollectionItemChange:function(collection, info) {
  var me = this, record = info.item, modifiedFieldNames = info.modified || null, type = info.meta;
  me.onUpdate(record, type, modifiedFieldNames, info);
  me.fireEvent('update', me, record, type, modifiedFieldNames, info);
}, onUpdate:Ext.emptyFn, onCollectionRemove:function(collection, info) {
  var me = this, records = info.items, lastChunk = !info.next;
  if (me.ignoreCollectionRemove) {
    return;
  }
  me.fireEvent('remove', me, records, info.at, false);
  if (lastChunk) {
    me.fireEvent('datachanged', me);
  }
}, onSourceBeforeLoad:function(source, operation) {
  this.fireEvent('beforeload', this, operation);
}, onSourceAfterLoad:function(source, records, successful, operation) {
  this.fireEvent('load', this, records, successful, operation);
}, onFilterEndUpdate:function() {
  this.callParent(arguments);
  this.callObservers('Filter');
}, onSourceBeforePopulate:function() {
  this.ignoreCollectionAdd = true;
  this.callObservers('BeforePopulate');
}, onSourceAfterPopulate:function() {
  var me = this;
  me.ignoreCollectionAdd = false;
  me.fireEvent('datachanged', me);
  me.fireEvent('refresh', me);
  this.callObservers('AfterPopulate');
}, onSourceBeforeClear:function() {
  this.ignoreCollectionRemove = true;
  this.callObservers('BeforeClear');
}, onSourceAfterClear:function() {
  this.ignoreCollectionRemove = false;
  this.callObservers('AfterClear');
}, onSourceBeforeRemoveAll:function() {
  this.ignoreCollectionRemove = true;
  this.callObservers('BeforeRemoveAll');
}, onSourceAfterRemoveAll:function(source, silent) {
  var me = this;
  me.ignoreCollectionRemove = false;
  if (!silent) {
    me.fireEvent('clear', me);
    me.fireEvent('datachanged', me);
  }
  this.callObservers('AfterRemoveAll', [silent]);
}, onSourceFilter:function() {
  var me = this;
  me.fireEvent('refresh', me);
  me.fireEvent('datachanged', me);
}, hasPendingLoad:function() {
  return this.getSource().hasPendingLoad();
}, isLoaded:function() {
  return this.getSource().isLoaded();
}, isLoading:function() {
  return this.getSource().isLoading();
}, onDestroy:function() {
  var me = this;
  me.observers = null;
  me.setSource(null);
  me.getData().destroy(true);
  me.data = null;
}, privates:{isMoving:function() {
  var source = this.getSource();
  return source.isMoving ? source.isMoving.apply(source, arguments) : false;
}, loadsSynchronously:function() {
  return this.getSource().loadsSynchronously();
}}});
Ext.define('Ext.app.ViewModel', {mixins:[Ext.mixin.Factoryable, Ext.mixin.Identifiable], alias:'viewmodel.default', isViewModel:true, factoryConfig:{name:'viewModel'}, collectTimeout:100, expressionRe:/^(?:\{[!]?(?:(\d+)|([a-z_][\w\-\.]*))\})$/i, $configStrict:false, config:{data:true, formulas:{$value:null, merge:function(newValue, currentValue, target, mixinClass) {
  return this.mergeNew(newValue, currentValue, target, mixinClass);
}}, links:null, parent:null, root:true, scheduler:null, schema:'default', session:null, stores:null, view:null}, constructor:function(config) {
  this.hadValue = {};
  this.bindings = {};
  this.initConfig(config);
}, destroy:function() {
  var me = this, scheduler = me._scheduler, stores = me.storeInfo, parent = me.getParent(), task = me.collectTask, children = me.children, bindings = me.bindings, key, store, autoDestroy;
  me.destroying = true;
  if (task) {
    task.cancel();
    me.collectTask = null;
  }
  if (children) {
    for (key in children) {
      children[key].destroy();
    }
  }
  if (stores) {
    for (key in stores) {
      store = stores[key];
      autoDestroy = store.autoDestroy;
      if (autoDestroy || !store.$wasInstance && autoDestroy !== false) {
        store.destroy();
      }
      Ext.destroy(store.$binding);
    }
  }
  if (parent) {
    parent.unregisterChild(me);
  }
  me.getRoot().destroy();
  for (key in bindings) {
    bindings[key].destroy();
  }
  if (scheduler && scheduler.$owner === me) {
    scheduler.$owner = null;
    scheduler.destroy();
  }
  me.hadValue = me.children = me.storeInfo = me._session = me._view = me._scheduler = me.bindings = me._root = me._parent = me.formulaFn = me.$formulaData = null;
  me.destroying = false;
  me.callParent();
}, bind:function(descriptor, callback, scope, options) {
  var me = this, binding, track;
  scope = scope || me;
  if (!options && descriptor.bindTo !== undefined && !Ext.isString(descriptor)) {
    options = descriptor;
    descriptor = options.bindTo;
  }
  if (!Ext.isString(descriptor)) {
    binding = new Ext.app.bind.Multi(descriptor, me, callback, scope, options);
    track = true;
  } else {
    if (me.expressionRe.test(descriptor)) {
      descriptor = descriptor.substring(1, descriptor.length - 1);
      binding = me.bindExpression(descriptor, callback, scope, options);
    } else {
      binding = new Ext.app.bind.TemplateBinding(descriptor, me, callback, scope, options);
      track = true;
    }
  }
  if (track) {
    me.bindings[binding.id] = binding;
  }
  return binding;
}, getSession:function() {
  var me = this, session = me._session, parent;
  if (!session && (parent = me.getParent())) {
    me.setSession(session = parent.getSession());
  }
  return session || null;
}, getStore:function(key) {
  var storeInfo = this.storeInfo, store;
  if (storeInfo) {
    store = storeInfo[key];
  }
  return store || null;
}, linkTo:function(key, reference) {
  var me = this, stub, create, id, modelType, linkStub, rec;
  if (key.indexOf('.') > -1) {
    Ext.raise('Links can only be at the top-level: "' + key + '"');
  }
  if (reference.isModel) {
    reference = {type:reference.entityName, id:reference.id};
  }
  modelType = reference.type || reference.reference;
  create = reference.create;
  if (modelType) {
    id = reference.id;
    if (!reference.create && Ext.isEmpty(id)) {
      Ext.raise('No id specified. To create a phantom model, specify "create: true" as part of the reference.');
    }
    if (create) {
      id = undefined;
    }
    rec = me.getRecord(modelType, id);
    if (Ext.isObject(create)) {
      rec.set(create);
      rec.commit();
      rec.phantom = true;
    }
    stub = me.getRoot().createStubChild(key);
    stub.set(rec);
  } else {
    stub = me.getStub(key);
    if (!stub.isLinkStub) {
      linkStub = new Ext.app.bind.LinkStub(me, stub.name);
      stub.graft(linkStub);
      stub = linkStub;
    }
    stub.link(reference);
  }
}, notify:function() {
  this.getScheduler().notify();
}, get:function(path) {
  return this.getStub(path).getValue();
}, set:function(path, value) {
  var me = this, obj, stub;
  me.getData();
  if (value === undefined && path && path.constructor === Object) {
    stub = me.getRoot();
    value = path;
  } else {
    if (path && path.indexOf('.') < 0) {
      obj = {};
      obj[path] = value;
      value = obj;
      stub = me.getRoot();
    } else {
      stub = me.getStub(path);
    }
  }
  stub.set(value);
}, privates:{registerChild:function(child) {
  var children = this.children;
  if (!children) {
    this.children = children = {};
  }
  children[child.getId()] = child;
}, unregisterChild:function(child) {
  var children = this.children;
  if (!this.destroying && children) {
    delete children[child.getId()];
  }
}, getRecord:function(type, id) {
  var session = this.getSession(), Model = type, hasId = id !== undefined, record;
  if (session) {
    if (hasId) {
      record = session.getRecord(type, id);
    } else {
      record = session.createRecord(type);
    }
  } else {
    if (!Model.$isClass) {
      Model = this.getSchema().getEntity(Model);
      if (!Model) {
        Ext.raise('Invalid model name: ' + type);
      }
    }
    if (hasId) {
      record = Model.createWithId(id);
      record.load();
    } else {
      record = new Model;
    }
  }
  return record;
}, notFn:function(v) {
  return !v;
}, bindExpression:function(descriptor, callback, scope, options) {
  var ch = descriptor.charAt(0), not = ch === '!', path = not ? descriptor.substring(1) : descriptor, stub = this.getStub(path), binding;
  binding = stub.bind(callback, scope, options);
  if (not) {
    binding.transform = this.notFn;
  }
  return binding;
}, applyScheduler:function(scheduler) {
  if (scheduler && !scheduler.isInstance) {
    scheduler = new Ext.util.Scheduler(scheduler);
    scheduler.$owner = this;
  }
  return scheduler;
}, getScheduler:function() {
  var me = this, scheduler = me._scheduler, parent;
  if (!scheduler) {
    if (!(parent = me.getParent())) {
      scheduler = new Ext.util.Scheduler({preSort:'kind,-depth'});
      scheduler.$owner = me;
    } else {
      scheduler = parent.getScheduler();
    }
    me.setScheduler(scheduler);
  }
  return scheduler;
}, getStub:function(bindDescr) {
  var root = this.getRoot();
  return bindDescr ? root.getChild(bindDescr) : root;
}, collect:function() {
  var me = this, parent = me.getParent(), task = me.collectTask;
  if (parent) {
    parent.collect();
    return;
  }
  if (!task) {
    task = me.collectTask = new Ext.util.DelayedTask(me.doCollect, me);
  }
  if (me.collectTimeout === 0) {
    me.doCollect();
  } else {
    task.delay(me.collectTimeout);
  }
}, doCollect:function() {
  var children = this.children, key;
  if (children) {
    for (key in children) {
      children[key].doCollect();
    }
  }
  this.getRoot().collect();
}, onBindDestroy:function(binding, fromChild) {
  var me = this, parent;
  if (me.destroying) {
    return;
  }
  if (!fromChild) {
    delete me.bindings[binding.id];
  }
  parent = me.getParent();
  if (parent) {
    parent.onBindDestroy(binding, true);
  } else {
    me.collect();
  }
}, applyData:function(newData, data) {
  var me = this, linkData, parent;
  me.getSession();
  if (!data) {
    parent = me.getParent();
    me.linkData = linkData = parent ? Ext.Object.chain(parent.getData()) : {};
    me.data = me._data = Ext.Object.chain(linkData);
  }
  if (newData && newData.constructor === Object) {
    me.getRoot().set(newData);
  }
}, applyParent:function(parent) {
  if (parent) {
    parent.registerChild(this);
  }
  return parent;
}, applyStores:function(stores) {
  var me = this, root = me.getRoot(), key, cfg, storeBind, stub, listeners, isStatic;
  me.storeInfo = {};
  me.listenerScopeFn = function() {
    return me.getView().getInheritedConfig('defaultListenerScope');
  };
  for (key in stores) {
    cfg = stores[key];
    if (cfg.isStore) {
      cfg.$wasInstance = true;
      me.setupStore(cfg, key);
      continue;
    } else {
      if (Ext.isString(cfg)) {
        cfg = {source:cfg};
      } else {
        cfg = Ext.apply({}, cfg);
      }
    }
    listeners = cfg.listeners;
    delete cfg.listeners;
    storeBind = me.bind(cfg, me.onStoreBind, me, {trackStatics:true});
    if (storeBind.isStatic()) {
      storeBind.destroy();
      me.createStore(key, cfg, listeners);
    } else {
      storeBind.$storeKey = key;
      storeBind.$listeners = listeners;
      stub = root.createStubChild(key);
      stub.setStore(storeBind);
    }
  }
}, onStoreBind:function(cfg, oldValue, binding) {
  var info = this.storeInfo, key = binding.$storeKey, store = info[key], proxy;
  if (!store) {
    this.createStore(key, cfg, binding.$listeners, binding);
  } else {
    cfg = Ext.merge({}, binding.pruneStaticKeys());
    proxy = cfg.proxy;
    delete cfg.type;
    delete cfg.model;
    delete cfg.fields;
    delete cfg.proxy;
    delete cfg.listeners;
    if (proxy) {
      delete proxy.reader;
      delete proxy.writer;
      store.getProxy().setConfig(proxy);
    }
    store.setConfig(cfg);
  }
}, createStore:function(key, cfg, listeners, binding) {
  var session = this.getSession(), store;
  cfg = Ext.apply({}, cfg);
  if (cfg.session) {
    cfg.session = session;
  }
  if (cfg.source) {
    cfg.type = cfg.type || 'chained';
  }
  cfg.listeners = listeners;
  store = Ext.Factory.store(cfg);
  store.$binding = binding;
  this.setupStore(store, key);
}, setupStore:function(store, key) {
  store.resolveListenerScope = this.listenerScopeFn;
  this.storeInfo[key] = store;
  this.set(key, store);
}, applyFormulas:function(formulas) {
  var me = this, root = me.getRoot(), name, stub;
  me.getData();
  for (name in formulas) {
    if (name.indexOf('.') >= 0) {
      Ext.raise('Formula names cannot contain dots: ' + name);
    }
    root.createStubChild(name);
    stub = me.getStub(name);
    stub.setFormula(formulas[name]);
  }
  return formulas;
}, applyLinks:function(links) {
  for (var link in links) {
    this.linkTo(link, links[link]);
  }
}, applySchema:function(schema) {
  return Ext.data.schema.Schema.get(schema);
}, applyRoot:function() {
  var root = new Ext.app.bind.RootStub(this), parent = this.getParent();
  if (parent) {
    root.depth = parent.getRoot().depth - 1000;
  }
  return root;
}, getFormulaFn:function(data) {
  var me = this, fn = me.formulaFn;
  if (!fn) {
    fn = me.formulaFn = function(name) {
      return me.$formulaData[name];
    };
  }
  me.$formulaData = data;
  return fn;
}}});
Ext.define('Ext.app.domain.Controller', {extend:Ext.app.EventDomain, singleton:true, type:'controller', prefix:'controller.', idMatchRe:/^\#/, constructor:function() {
  var me = this;
  me.callParent();
  me.monitor(Ext.app.BaseController);
}, match:function(target, selector) {
  var result = false, alias = target.alias;
  if (selector === '*') {
    result = true;
  } else {
    if (selector === '#') {
      result = !!target.isApplication;
    } else {
      if (this.idMatchRe.test(selector)) {
        result = target.getId() === selector.substring(1);
      } else {
        if (alias) {
          result = Ext.Array.indexOf(alias, this.prefix + selector) > -1;
        }
      }
    }
  }
  return result;
}});
Ext.define('Ext.direct.Manager', {singleton:true, mixins:[Ext.mixin.Observable], exceptions:{TRANSPORT:'xhr', PARSE:'parse', DATA:'data', LOGIN:'login', SERVER:'exception'}, providerClasses:{}, remotingMethods:{}, config:{varName:'Ext.REMOTING_API'}, apiNotFoundError:'Ext Direct API was not found at {0}', constructor:function() {
  var me = this;
  me.mixins.observable.constructor.call(me);
  me.transactions = new Ext.util.MixedCollection;
  me.providers = new Ext.util.MixedCollection;
}, addProvider:function(provider) {
  var me = this, args = arguments, relayers = me.relayers || (me.relayers = {}), i, len;
  if (args.length > 1) {
    for (i = 0, len = args.length; i < len; ++i) {
      me.addProvider(args[i]);
    }
    return;
  }
  if (!provider.isProvider) {
    provider = Ext.create('direct.' + provider.type + 'provider', provider);
  }
  me.providers.add(provider);
  provider.on('data', me.onProviderData, me);
  if (provider.relayedEvents) {
    relayers[provider.id] = me.relayEvents(provider, provider.relayedEvents);
  }
  if (!provider.isConnected()) {
    provider.connect();
  }
  return provider;
}, loadProvider:function(config, callback, scope) {
  var me = this, classes = me.providerClasses, type, url, varName, provider, i, len;
  if (Ext.isArray(config)) {
    for (i = 0, len = config.length; i < len; i++) {
      me.loadProvider(config[i], callback, scope);
    }
    return;
  }
  type = config.type;
  url = config.url;
  if (classes[type] && classes[type].checkConfig(config)) {
    provider = me.addProvider(config);
    me.fireEventArgs('providerload', [url, provider]);
    Ext.callback(callback, scope, [url, provider]);
    return;
  }
  varName = config.varName || me.getVarName();
  delete config.varName;
  if (!url) {
    Ext.raise('Need API discovery URL to load a Remoting provider!');
  }
  delete config.url;
  Ext.Loader.loadScript({url:url, scope:me, onLoad:function() {
    this.onApiLoadSuccess({url:url, varName:varName, config:config, callback:callback, scope:scope});
  }, onError:function() {
    this.onApiLoadFailure({url:url, callback:callback, scope:scope});
  }});
}, getProvider:function(id) {
  return id.isProvider ? id : this.providers.get(id);
}, removeProvider:function(provider) {
  var me = this, providers = me.providers, relayers = me.relayers, id;
  provider = provider.isProvider ? provider : providers.get(provider);
  if (provider) {
    provider.un('data', me.onProviderData, me);
    id = provider.id;
    if (relayers[id]) {
      relayers[id].destroy();
      delete relayers[id];
    }
    providers.remove(provider);
    return provider;
  }
  return null;
}, addTransaction:function(transaction) {
  this.transactions.add(transaction);
  return transaction;
}, removeTransaction:function(transaction) {
  var me = this;
  transaction = me.getTransaction(transaction);
  me.transactions.remove(transaction);
  return transaction;
}, getTransaction:function(transaction) {
  return typeof transaction === 'object' ? transaction : this.transactions.get(transaction);
}, onProviderData:function(provider, event) {
  var me = this, i, len;
  if (Ext.isArray(event)) {
    for (i = 0, len = event.length; i < len; ++i) {
      me.onProviderData(provider, event[i]);
    }
    return;
  }
  if (event.name && event.name !== 'event' && event.name !== 'exception') {
    me.fireEvent(event.name, event);
  } else {
    if (event.status === false) {
      me.fireEvent('exception', event);
    }
  }
  me.fireEvent('event', event, provider);
}, parseMethod:function(fn) {
  var current = Ext.global, i = 0, resolved, parts, len;
  if (Ext.isFunction(fn)) {
    resolved = fn;
  } else {
    if (Ext.isString(fn)) {
      resolved = this.remotingMethods[fn];
      if (!resolved) {
        parts = fn.split('.');
        len = parts.length;
        while (current && i < len) {
          current = current[parts[i]];
          ++i;
        }
        resolved = Ext.isFunction(current) ? current : null;
      }
    }
  }
  return resolved || null;
}, privates:{addProviderClass:function(type, cls) {
  this.providerClasses[type] = cls;
}, onApiLoadSuccess:function(options) {
  var me = this, url = options.url, varName = options.varName, api, provider, error;
  try {
    api = Ext.apply(options.config, eval(varName));
    provider = me.addProvider(api);
  } catch (e$23) {
    error = e$23 + '';
  }
  if (error) {
    me.fireEventArgs('providerloaderror', [url, error]);
    Ext.callback(options.callback, options.scope, [url, error]);
  } else {
    me.fireEventArgs('providerload', [url, provider]);
    Ext.callback(options.callback, options.scope, [url, provider]);
  }
}, onApiLoadFailure:function(options) {
  var url = options.url, error;
  error = Ext.String.format(this.apiNotFoundError, url);
  this.fireEventArgs('providerloaderror', [url, error]);
  Ext.callback(options.callback, options.scope, [url, error]);
}, registerMethod:function(name, method) {
  this.remotingMethods[name] = method;
}, clearAllMethods:function() {
  this.remotingMethods = {};
}}}, function() {
  Ext.Direct = Ext.direct.Manager;
});
Ext.define('Ext.data.PageMap', {extend:Ext.util.LruCache, config:{store:null, pageSize:0, rootProperty:''}, clear:function(initial) {
  var me = this;
  me.pageMapGeneration = (me.pageMapGeneration || 0) + 1;
  me.indexMap = {};
  me.callParent([initial]);
}, updatePageSize:function(value, oldValue) {
  if (oldValue != null) {
    throw 'pageMap page size may not be changed';
  }
}, forEach:function(fn, scope) {
  var me = this, pageNumbers = Ext.Object.getKeys(me.map), pageCount = pageNumbers.length, pageSize = me.getPageSize(), i, j, pageNumber, page, len;
  for (i = 0; i < pageCount; i++) {
    pageNumbers[i] = +pageNumbers[i];
  }
  Ext.Array.sort(pageNumbers, Ext.Array.numericSortFn);
  scope = scope || me;
  for (i = 0; i < pageCount; i++) {
    pageNumber = pageNumbers[i];
    page = me.getPage(pageNumber);
    len = page.length;
    for (j = 0; j < len; j++) {
      if (fn.call(scope, page[j], (pageNumber - 1) * pageSize + j) === false) {
        return;
      }
    }
  }
}, findBy:function(fn, scope) {
  var me = this, result = null;
  scope = scope || me;
  me.forEach(function(rec, index) {
    if (fn.call(scope, rec, index)) {
      result = rec;
      return false;
    }
  });
  return result;
}, findIndexBy:function(fn, scope) {
  var me = this, result = -1;
  scope = scope || me;
  me.forEach(function(rec, index) {
    if (fn.call(scope, rec)) {
      result = index;
      return false;
    }
  });
  return result;
}, find:function(property, value, start, startsWith, endsWith, ignoreCase) {
  if (Ext.isEmpty(value, false)) {
    return null;
  }
  var regex = Ext.String.createRegex(value, startsWith, endsWith, ignoreCase), root = this.getRootProperty();
  return this.findBy(function(item) {
    return item && regex.test((root ? item[root] : item)[property]);
  }, null, start);
}, findIndex:function(property, value, start, startsWith, endsWith, ignoreCase) {
  if (Ext.isEmpty(value, false)) {
    return null;
  }
  var regex = Ext.String.createRegex(value, startsWith, endsWith, ignoreCase), root = this.getRootProperty();
  return this.findIndexBy(function(item) {
    return item && regex.test((root ? item[root] : item)[property]);
  }, null, start);
}, getPageFromRecordIndex:function(index) {
  return Math.floor(index / this.getPageSize()) + 1;
}, addAll:function(records) {
  if (this.getCount()) {
    Ext.raise('Cannot addAll to a non-empty PageMap');
  }
  this.addPage(1, records);
}, addPage:function(pageNumber, records) {
  var me = this, pageSize = me.getPageSize(), lastPage = pageNumber + Math.floor((records.length - 1) / pageSize), storeIndex = (pageNumber - 1) * pageSize, indexMap = me.indexMap, page, i, len, startIdx;
  for (startIdx = 0; pageNumber <= lastPage; pageNumber++, startIdx += pageSize) {
    page = Ext.Array.slice(records, startIdx, startIdx + pageSize);
    for (i = 0, len = page.length; i < len; i++) {
      indexMap[page[i].internalId] = storeIndex++;
    }
    me.add(pageNumber, page);
    me.fireEvent('pageadd', me, pageNumber, page);
  }
}, getCount:function() {
  var result = this.callParent();
  if (result) {
    result = (result - 1) * this.getPageSize() + this.last.value.length;
  }
  return result;
}, getByInternalId:function(internalId) {
  var index = this.indexMap[internalId];
  if (index != null) {
    return this.getAt(index);
  }
}, indexOf:function(record) {
  var result = -1;
  if (record) {
    result = this.indexMap[record.internalId];
    if (result == null) {
      result = -1;
    }
  }
  return result;
}, insert:function() {
  Ext.raise('insert operation not suppported into buffered Store');
}, remove:function() {
  Ext.raise('remove operation not suppported from buffered Store');
}, removeAt:function() {
  Ext.raise('removeAt operation not suppported from buffered Store');
}, removeAtKey:function(page) {
  var me = this, thePage = me.getPage(page), len, i, result;
  if (thePage) {
    if (me.fireEvent('beforepageremove', me, page, thePage) !== false) {
      len = thePage.length;
      for (i = 0; i < len; i++) {
        delete me.indexMap[thePage[i].internalId];
      }
      result = me.callParent(arguments);
      me.fireEvent('pageremove', me, page, thePage);
      thePage.length = 0;
    }
  }
  return result;
}, getPage:function(pageNumber) {
  return this.get(pageNumber);
}, hasRange:function(start, end) {
  var me = this, pageNumber = me.getPageFromRecordIndex(start), endPageNumber = me.getPageFromRecordIndex(end);
  for (; pageNumber <= endPageNumber; pageNumber++) {
    if (!me.hasPage(pageNumber)) {
      return false;
    }
  }
  return (endPageNumber - 1) * me._pageSize + me.getPage(endPageNumber).length > end;
}, hasPage:function(pageNumber) {
  return !!this.get(pageNumber);
}, peekPage:function(pageNumber) {
  return this.map[pageNumber];
}, getAt:function(index) {
  return this.getRange(index, index + 1)[0];
}, getRange:function(start, end) {
  end--;
  if (!this.hasRange(start, end)) {
    Ext.raise('PageMap asked for range which it does not have');
  }
  var me = this, Array = Ext.Array, pageSize = me.getPageSize(), startPageNumber = me.getPageFromRecordIndex(start), endPageNumber = me.getPageFromRecordIndex(end), dataStart = (startPageNumber - 1) * pageSize, dataEnd = endPageNumber * pageSize - 1, pageNumber = startPageNumber, result = [], sliceBegin, sliceEnd, doSlice;
  for (; pageNumber <= endPageNumber; pageNumber++) {
    if (pageNumber === startPageNumber) {
      sliceBegin = start - dataStart;
      doSlice = sliceBegin > 0;
    } else {
      sliceBegin = 0;
      doSlice = false;
    }
    if (pageNumber === endPageNumber) {
      sliceEnd = pageSize - (dataEnd - end);
      doSlice = doSlice || sliceEnd < pageSize;
    }
    if (doSlice) {
      Array.push(result, Array.slice(me.getPage(pageNumber), sliceBegin, sliceEnd));
    } else {
      Array.push(result, me.getPage(pageNumber));
    }
  }
  return result;
}, destroy:function() {
  this.callParent();
  this.indexMap = {};
}});
Ext.define('Ext.data.BufferedStore', {extend:Ext.data.ProxyStore, alias:'store.buffered', isBufferedStore:true, buffered:true, config:{data:0, pageSize:25, remoteSort:true, remoteFilter:true, sortOnLoad:false, purgePageCount:5, trailingBufferZone:25, leadingBufferZone:200, defaultViewSize:100, viewSize:0, trackRemoved:false}, applyData:function(data) {
  var dataCollection = this.data || (this.data = this.createDataCollection());
  if (data && data !== true) {
    Ext.raise('Cannot load a buffered store with local data - the store is a map of remote data');
  }
  return dataCollection;
}, applyProxy:function(proxy) {
  proxy = this.callParent([proxy]);
  if (proxy && proxy.setEnablePaging) {
    proxy.setEnablePaging(true);
  }
  return proxy;
}, createFiltersCollection:function() {
  return new Ext.util.FilterCollection;
}, createSortersCollection:function() {
  return new Ext.util.SorterCollection;
}, updateRemoteFilter:function(remoteFilter, oldRemoteFilter) {
  if (remoteFilter === false) {
    Ext.raise('Buffered stores are always remotely filtered.');
  }
  this.callParent([remoteFilter, oldRemoteFilter]);
}, updateRemoteSort:function(remoteSort, oldRemoteSort) {
  if (remoteSort === false) {
    Ext.raise('Buffered stores are always remotely sorted.');
  }
  this.callParent([remoteSort, oldRemoteSort]);
}, updateTrackRemoved:function(value) {
  if (value !== false) {
    Ext.raise('Cannot use trackRemoved with a buffered store.');
  }
  this.callParent(arguments);
}, updateGroupField:function(field) {
  this.group(field);
}, getGrouper:function() {
  return this.grouper;
}, isGrouped:function() {
  return !!this.grouper;
}, createDataCollection:function() {
  var me = this, result = new Ext.data.PageMap({store:me, rootProperty:'data', pageSize:me.getPageSize(), maxSize:me.getPurgePageCount(), listeners:{clear:me.onPageMapClear, scope:me}});
  me.relayEvents(result, ['beforepageremove', 'pageadd', 'pageremove']);
  me.pageRequests = {};
  return result;
}, add:function() {
  Ext.raise('add method may not be called on a buffered store - the store is a map of remote data');
}, insert:function() {
  Ext.raise('insert method may not be called on a buffered store - the store is a map of remote data');
}, removeAll:function(silent) {
  var me = this, data = me.getData();
  if (data) {
    if (silent) {
      me.suspendEvent('clear');
    }
    data.clear();
    if (silent) {
      me.resumeEvent('clear');
    }
  }
}, flushLoad:function() {
  var me = this, options = me.pendingLoadOptions;
  me.clearLoadTask();
  if (!options) {
    return;
  }
  me.getData().clear();
  options.page = 1;
  options.start = 0;
  options.limit = me.getViewSize() || me.getDefaultViewSize();
  options.loadCallback = options.callback;
  options.callback = null;
  return me.loadToPrefetch(options);
}, reload:function(options) {
  var me = this, data = me.getData(), lastTotal = Number.MAX_VALUE, startIdx, endIdx, startPage, endPage, i, waitForReload, bufferZone, records;
  if (!options) {
    options = {};
  }
  if (me.loading || me.fireEvent('beforeload', me, options) === false) {
    return;
  }
  waitForReload = function() {
    var newCount = me.totalCount, oldRequestSize = endIdx - startIdx;
    if (endIdx >= newCount) {
      endIdx = newCount - 1;
      startIdx = Math.max(endIdx - oldRequestSize, 0);
    }
    if (me.rangeCached(startIdx, Math.min(endIdx, me.totalCount))) {
      me.loading = false;
      data.un('pageadd', waitForReload);
      records = data.getRange(startIdx, endIdx + 1);
      me.fireEvent('load', me, records, true);
      me.fireEvent('refresh', me);
    }
  };
  bufferZone = Math.ceil((me.getLeadingBufferZone() + me.getTrailingBufferZone()) / 2);
  if (me.lastRequestStart && me.preserveScrollOnReload) {
    startIdx = me.lastRequestStart;
    endIdx = me.lastRequestEnd;
    lastTotal = me.getTotalCount();
  } else {
    startIdx = options.start || 0;
    endIdx = startIdx + (options.count || me.getPageSize()) - 1;
  }
  data.clear(true);
  delete me.totalCount;
  startIdx = Math.max(startIdx - bufferZone, 0);
  endIdx = Math.min(endIdx + bufferZone, lastTotal);
  startPage = me.getPageFromRecordIndex(startIdx);
  endPage = me.getPageFromRecordIndex(endIdx);
  me.loading = true;
  options.waitForReload = waitForReload;
  data.on('pageadd', waitForReload);
  for (i = startPage; i <= endPage; i++) {
    me.prefetchPage(i, options);
  }
}, filter:function() {
  if (!this.getRemoteFilter()) {
    Ext.raise('Local filtering may not be used on a buffered store - the store is a map of remote data');
  }
  this.callParent(arguments);
}, filterBy:function(fn, scope) {
  Ext.raise('Local filtering may not be used on a buffered store - the store is a map of remote data');
}, loadData:function(data, append) {
  Ext.raise('LoadData may not be used on a buffered store - the store is a map of remote data');
}, loadPage:function(page, options) {
  var me = this;
  options = options || {};
  options.page = me.currentPage = page;
  options.start = (page - 1) * me.getPageSize();
  options.limit = me.getViewSize() || me.getDefaultViewSize();
  options.loadCallback = options.callback;
  options.callback = null;
  return me.loadToPrefetch(options);
}, clearData:function(isLoad) {
  var me = this, data = me.getData();
  if (data) {
    data.clear();
  }
}, getCount:function() {
  return this.totalCount || 0;
}, getRange:function(start, end, options) {
  var me = this, maxIndex = me.totalCount - 1, lastRequestStart = me.lastRequestStart, result = [], data = me.getData(), pageAddHandler, requiredStart, requiredEnd, requiredStartPage, requiredEndPage;
  options = Ext.apply({prefetchStart:start, prefetchEnd:end}, options);
  end = end >= me.totalCount ? maxIndex : end;
  requiredStart = start === 0 ? 0 : start - 1;
  requiredEnd = end === maxIndex ? end : end + 1;
  me.lastRequestStart = start;
  me.lastRequestEnd = end;
  if (me.rangeCached(requiredStart, requiredEnd)) {
    me.onRangeAvailable(options);
    result = data.getRange(start, end + 1);
  } else {
    me.fireEvent('cachemiss', me, start, end);
    requiredStartPage = me.getPageFromRecordIndex(requiredStart);
    requiredEndPage = me.getPageFromRecordIndex(requiredEnd);
    pageAddHandler = function(pageMap, page, records) {
      if (page >= requiredStartPage && page <= requiredEndPage && me.rangeCached(requiredStart, requiredEnd)) {
        me.fireEvent('cachefilled', me, start, end);
        data.un('pageadd', pageAddHandler);
        me.onRangeAvailable(options);
      }
    };
    data.on('pageadd', pageAddHandler);
    me.prefetchRange(start, end);
  }
  me.primeCache(start, end, start < lastRequestStart ? -1 : 1);
  return result;
}, getById:function(id) {
  var result = this.data.findBy(function(record) {
    return record.getId() === id;
  });
  return result;
}, getAt:function(index) {
  var data = this.getData();
  if (data.hasRange(index, index)) {
    return data.getAt(index);
  }
}, getByInternalId:function(internalId) {
  return this.data.getByInternalId(internalId);
}, contains:function(record) {
  return this.indexOf(record) > -1;
}, indexOf:function(record) {
  return this.getData().indexOf(record);
}, indexOfId:function(id) {
  return this.indexOf(this.getById(id));
}, group:function(grouper, direction) {
  var me = this, oldGrouper;
  if (grouper && typeof grouper === 'string') {
    oldGrouper = me.grouper;
    if (!oldGrouper) {
      me.grouper = new Ext.util.Grouper({property:grouper, direction:direction || 'ASC', root:'data'});
    } else {
      if (direction === undefined) {
        oldGrouper.toggle();
      } else {
        oldGrouper.setDirection(direction);
      }
    }
  } else {
    me.grouper = grouper ? me.getSorters().decodeSorter(grouper, 'Ext.util.Grouper') : null;
  }
  me.getData().clear();
  me.loadPage(1, {callback:function() {
    me.fireEvent('groupchange', me, me.getGrouper());
  }});
}, getPageFromRecordIndex:function(index) {
  return Math.floor(index / this.getPageSize()) + 1;
}, calculatePageCacheSize:function(rangeSizeRequested) {
  var me = this, purgePageCount = me.getPurgePageCount();
  return purgePageCount ? Math.max(me.getData().getMaxSize() || 0, Math.ceil((rangeSizeRequested + me.getTrailingBufferZone() + me.getLeadingBufferZone()) / me.getPageSize()) * 2 + purgePageCount) : 0;
}, loadToPrefetch:function(options) {
  var me = this, prefetchOptions = options, i, records, dataSetSize, startIdx = options.start, endIdx = options.start + options.limit - 1, rangeSizeRequested = me.getViewSize() || options.limit, loadEndIdx = Math.min(endIdx, options.start + rangeSizeRequested - 1), startPage = me.getPageFromRecordIndex(Math.max(startIdx - me.getTrailingBufferZone(), 0)), endPage = me.getPageFromRecordIndex(endIdx + me.getLeadingBufferZone()), data = me.getData(), callbackFn = function() {
    records = records || [];
    if (options.loadCallback) {
      options.loadCallback.call(options.scope || me, records, operation, true);
    }
    if (options.callback) {
      options.callback.call(options.scope || me, records, startIdx || 0, endIdx || 0, options);
    }
  }, fireEventsFn = function() {
    me.fireEvent('datachanged', me);
    me.fireEvent('refresh', me);
    me.fireEvent('load', me, records, true);
  }, waitForRequestedRange = function() {
    if (me.rangeCached(startIdx, loadEndIdx)) {
      me.loading = false;
      records = data.getRange(startIdx, loadEndIdx + 1);
      data.un('pageadd', waitForRequestedRange);
      if (me.hasListeners.guaranteedrange) {
        me.guaranteeRange(startIdx, loadEndIdx, options.callback, options.scope);
      }
      callbackFn();
      fireEventsFn();
    }
  }, operation;
  if (isNaN(me.pageSize) || !me.pageSize) {
    Ext.raise('Buffered store configured without a pageSize', me);
  }
  data.setMaxSize(me.calculatePageCacheSize(rangeSizeRequested));
  if (me.fireEvent('beforeload', me, options) !== false) {
    delete me.totalCount;
    me.loading = true;
    if (options.callback) {
      prefetchOptions = Ext.apply({}, options);
      delete prefetchOptions.callback;
    }
    me.on('prefetch', function(store, records, successful, op) {
      operation = op;
      if (successful) {
        if (dataSetSize = me.getTotalCount()) {
          data.on('pageadd', waitForRequestedRange);
          loadEndIdx = Math.min(loadEndIdx, dataSetSize - 1);
          endPage = me.getPageFromRecordIndex(Math.min(loadEndIdx + me.getLeadingBufferZone(), dataSetSize - 1));
          for (i = startPage + 1; i <= endPage; ++i) {
            me.prefetchPage(i, prefetchOptions);
          }
        } else {
          callbackFn();
          fireEventsFn();
        }
      } else {
        me.loading = false;
        callbackFn();
        me.fireEvent('load', me, records, false);
      }
    }, null, {single:true});
    me.prefetchPage(startPage, prefetchOptions);
  }
}, prefetch:function(options) {
  var me = this, pageSize = me.getPageSize(), data = me.getData(), operation, existingPageRequest;
  if (pageSize) {
    if (me.lastPageSize && pageSize != me.lastPageSize) {
      Ext.raise('pageSize cannot be dynamically altered');
    }
    if (!data.getPageSize()) {
      data.setPageSize(pageSize);
    }
  } else {
    me.pageSize = data.setPageSize(pageSize = options.limit);
  }
  me.lastPageSize = pageSize;
  if (!options.page) {
    options.page = me.getPageFromRecordIndex(options.start);
    options.start = (options.page - 1) * pageSize;
    options.limit = Math.ceil(options.limit / pageSize) * pageSize;
  }
  existingPageRequest = me.pageRequests[options.page];
  if (!existingPageRequest || existingPageRequest.getOperation().pageMapGeneration !== data.pageMapGeneration) {
    options = Ext.apply({action:'read', filters:me.getFilters().items, sorters:me.getSorters().items, grouper:me.getGrouper(), internalCallback:me.onProxyPrefetch, internalScope:me}, options);
    operation = me.createOperation('read', options);
    operation.pageMapGeneration = data.pageMapGeneration;
    if (me.fireEvent('beforeprefetch', me, operation) !== false) {
      me.pageRequests[options.page] = operation.execute();
      if (me.getProxy().isSynchronous) {
        delete me.pageRequests[options.page];
      }
    }
  }
  return me;
}, onPageMapClear:function() {
  var me = this, loadingFlag = me.wasLoading, reqs = me.pageRequests, data = me.getData(), page;
  data.clearListeners();
  data.on('clear', me.onPageMapClear, me);
  me.relayEvents(data, ['beforepageremove', 'pageadd', 'pageremove']);
  me.loading = true;
  me.totalCount = 0;
  for (page in reqs) {
    if (reqs.hasOwnProperty(page)) {
      reqs[page].getOperation().abort();
    }
  }
  me.fireEvent('clear', me);
  me.loading = loadingFlag;
}, prefetchPage:function(page, options) {
  var me = this, pageSize = me.getPageSize(), start = (page - 1) * pageSize, total = me.totalCount;
  if (total !== undefined && me.data.getCount() === total) {
    return;
  }
  me.prefetch(Ext.applyIf({page:page, start:start, limit:pageSize}, options));
}, onProxyPrefetch:function(operation) {
  if (this.destroyed) {
    return;
  }
  var me = this, resultSet = operation.getResultSet(), records = operation.getRecords(), successful = operation.wasSuccessful(), page = operation.getPage(), waitForReload = operation.waitForReload, oldTotal = me.totalCount, requests = me.pageRequests, key, op;
  if (operation.pageMapGeneration === me.getData().pageMapGeneration) {
    if (resultSet) {
      me.totalCount = resultSet.getTotal();
      if (me.totalCount !== oldTotal) {
        me.fireEvent('totalcountchange', me.totalCount);
      }
    }
    if (page !== undefined) {
      delete me.pageRequests[page];
    }
    me.loading = false;
    me.fireEvent('prefetch', me, records, successful, operation);
    if (successful) {
      if (me.totalCount === 0) {
        if (waitForReload) {
          for (key in requests) {
            op = requests[key].getOperation();
            if (op.waitForReload === waitForReload) {
              delete op.waitForReload;
            }
          }
          me.getData().un('pageadd', waitForReload);
          me.fireEvent('load', me, [], true);
          me.fireEvent('refresh', me);
        }
      } else {
        me.cachePage(records, operation.getPage());
      }
    }
    Ext.callback(operation.getCallback(), operation.getScope() || me, [records, operation, successful]);
  }
}, cachePage:function(records, page) {
  var me = this, len = records.length, i;
  if (!Ext.isDefined(me.totalCount)) {
    me.totalCount = records.length;
    me.fireEvent('totalcountchange', me.totalCount);
  }
  for (i = 0; i < len; i++) {
    records[i].join(me);
  }
  me.getData().addPage(page, records);
}, rangeCached:function(start, end) {
  return this.getData().hasRange(start, end);
}, pageCached:function(page) {
  return this.getData().hasPage(page);
}, pagePending:function(page) {
  return !!this.pageRequests[page];
}, rangeSatisfied:function(start, end) {
  return this.rangeCached(start, end);
}, onRangeAvailable:function(options) {
  var me = this, totalCount = me.getTotalCount(), start = options.prefetchStart, end = options.prefetchEnd > totalCount - 1 ? totalCount - 1 : options.prefetchEnd, range;
  end = Math.max(0, end);
  if (start > end) {
    Ext.log({level:'warn', msg:'Start (' + start + ') was greater than end (' + end + ') for the range of records requested (' + start + '-' + options.prefetchEnd + ')' + (this.storeId ? ' from store "' + this.storeId + '"' : '')});
  }
  range = me.getData().getRange(start, end + 1);
  if (options.fireEvent !== false) {
    me.fireEvent('guaranteedrange', range, start, end, options);
  }
  if (options.callback) {
    options.callback.call(options.scope || me, range, start, end, options);
  }
}, guaranteeRange:function(start, end, callback, scope, options) {
  options = Ext.apply({callback:callback, scope:scope}, options);
  this.getRange(start, end + 1, options);
}, prefetchRange:function(start, end) {
  var me = this, startPage, endPage, page, data = me.getData();
  if (!me.rangeCached(start, end)) {
    startPage = me.getPageFromRecordIndex(start);
    endPage = me.getPageFromRecordIndex(end);
    data.setMaxSize(me.calculatePageCacheSize(end - start + 1));
    for (page = startPage; page <= endPage; page++) {
      if (!me.pageCached(page)) {
        me.prefetchPage(page);
      }
    }
  }
}, primeCache:function(start, end, direction) {
  var me = this, leadingBufferZone = me.getLeadingBufferZone(), trailingBufferZone = me.getTrailingBufferZone(), pageSize = me.getPageSize(), totalCount = me.totalCount;
  if (direction === -1) {
    start = Math.max(start - leadingBufferZone, 0);
    end = Math.min(end + trailingBufferZone, totalCount - 1);
  } else {
    if (direction === 1) {
      start = Math.max(Math.min(start - trailingBufferZone, totalCount - pageSize), 0);
      end = Math.min(end + leadingBufferZone, totalCount - 1);
    } else {
      start = Math.min(Math.max(Math.floor(start - (leadingBufferZone + trailingBufferZone) / 2), 0), totalCount - me.pageSize);
      end = Math.min(Math.max(Math.ceil(end + (leadingBufferZone + trailingBufferZone) / 2), 0), totalCount - 1);
    }
  }
  me.prefetchRange(start, end);
}, sort:function(field, direction, mode) {
  if (arguments.length === 0) {
    this.clearAndLoad();
  } else {
    this.getSorters().addSort(field, direction, mode);
  }
}, onSorterEndUpdate:function() {
  var me = this, sorters = me.getSorters().getRange();
  if (sorters.length) {
    me.fireEvent('beforesort', me, sorters);
    me.clearAndLoad({callback:function() {
      me.fireEvent('sort', me, sorters);
    }});
  } else {
    me.fireEvent('sort', me, sorters);
  }
}, clearAndLoad:function(options) {
  this.getData().clear();
  this.loadPage(1, options);
}, privates:{isLast:function(record) {
  return this.indexOf(record) === this.getTotalCount() - 1;
}, isMoving:function() {
  return false;
}}});
Ext.define('Ext.data.NodeInterface', {statics:{decorate:function(modelClass) {
  var model = Ext.data.schema.Schema.lookupEntity(modelClass), proto = model.prototype, idName, idField, idType;
  if (!model.prototype.isObservable) {
    model.mixin(Ext.mixin.Observable.prototype.mixinId, Ext.mixin.Observable);
  }
  if (proto.isNode) {
    return;
  }
  idName = proto.idProperty;
  idField = model.getField(idName);
  idType = idField.type;
  model.override(this.getPrototypeBody());
  model.addFields([{name:'parentId', type:idType, defaultValue:null, allowNull:idField.allowNull}, {name:'index', type:'int', defaultValue:-1, persist:false, convert:null}, {name:'depth', type:'int', defaultValue:0, persist:false, convert:null}, {name:'expanded', type:'bool', defaultValue:false, persist:false, convert:null}, {name:'expandable', type:'bool', defaultValue:true, persist:false, convert:null}, {name:'checked', type:'auto', defaultValue:null, persist:false, convert:null}, {name:'leaf', 
  type:'bool', defaultValue:false}, {name:'cls', type:'string', defaultValue:'', persist:false, convert:null}, {name:'iconCls', type:'string', defaultValue:'', persist:false, convert:null}, {name:'icon', type:'string', defaultValue:'', persist:false, convert:null}, {name:'root', type:'boolean', defaultValue:false, persist:false, convert:null}, {name:'isLast', type:'boolean', defaultValue:false, persist:false, convert:null}, {name:'isFirst', type:'boolean', defaultValue:false, persist:false, convert:null}, 
  {name:'allowDrop', type:'boolean', defaultValue:true, persist:false, convert:null}, {name:'allowDrag', type:'boolean', defaultValue:true, persist:false, convert:null}, {name:'loaded', type:'boolean', defaultValue:false, persist:false, convert:null}, {name:'loading', type:'boolean', defaultValue:false, persist:false, convert:null}, {name:'href', type:'string', defaultValue:'', persist:false, convert:null}, {name:'hrefTarget', type:'string', defaultValue:'', persist:false, convert:null}, {name:'qtip', 
  type:'string', defaultValue:'', persist:false, convert:null}, {name:'qtitle', type:'string', defaultValue:'', persist:false, convert:null}, {name:'qshowDelay', type:'int', defaultValue:0, persist:false, convert:null}, {name:'children', type:'auto', defaultValue:null, persist:false, convert:null}, {name:'visible', type:'boolean', defaultValue:true, persist:false}, {name:'text', type:'string', persist:false}]);
}, getPrototypeBody:function() {
  var bubbledEvents = {idchanged:true, append:true, remove:true, move:true, insert:true, beforeappend:true, beforeremove:true, beforemove:true, beforeinsert:true, expand:true, collapse:true, beforeexpand:true, beforecollapse:true, sort:true}, silently = {silent:true};
  return {isNode:true, firstChild:null, lastChild:null, parentNode:null, previousSibling:null, nextSibling:null, constructor:function() {
    var me = this;
    me.mixins.observable.constructor.call(me);
    me.callParent(arguments);
    me.childNodes = [];
    return me;
  }, createNode:function(node) {
    var me = this, childType = me.childType, store, storeReader, nodeProxy, nodeReader, reader, typeProperty, T = me.self;
    if (!node.isModel) {
      if (childType) {
        T = me.schema.getEntity(childType);
      } else {
        store = me.getTreeStore();
        storeReader = store && store.getProxy().getReader();
        nodeProxy = me.getProxy();
        nodeReader = nodeProxy ? nodeProxy.getReader() : null;
        reader = !storeReader || nodeReader && nodeReader.initialConfig.typeProperty ? nodeReader : storeReader;
        if (reader) {
          typeProperty = reader.getTypeProperty();
          if (typeProperty) {
            T = reader.getChildType(me.schema, node, typeProperty);
          }
        }
      }
      node = new T(node);
    }
    if (!node.childNodes) {
      node.firstChild = node.lastChild = node.parentNode = node.previousSibling = node.nextSibling = null;
      node.childNodes = [];
    }
    return node;
  }, isLeaf:function() {
    return this.get('leaf') === true;
  }, setFirstChild:function(node) {
    this.firstChild = node;
  }, setLastChild:function(node) {
    this.lastChild = node;
  }, updateInfo:function(commit, info) {
    var me = this, dataObject = me.data, oldDepth = dataObject.depth, childInfo = {}, children = me.childNodes, childCount = children.length, phantom = me.phantom, fields = me.fields, modified = me.modified || (me.modified = {}), propName, newValue, field, currentValue, key, newParentId = info.parentId, settingIndexInNewParent, persistentField, i;
    if (!info) {
      Ext.raise('NodeInterface expects update info to be passed');
    }
    for (propName in info) {
      field = fields[me.fieldOrdinals[propName]];
      newValue = info[propName];
      persistentField = field && field.persist;
      currentValue = dataObject[propName];
      settingIndexInNewParent = persistentField && propName === 'index' && currentValue !== -1 && (newParentId && newParentId !== modified.parentId);
      if (!settingIndexInNewParent && me.isEqual(currentValue, newValue)) {
        continue;
      }
      dataObject[propName] = newValue;
      if (persistentField) {
        if (!settingIndexInNewParent && modified.hasOwnProperty(propName)) {
          if (me.isEqual(modified[propName], newValue)) {
            delete modified[propName];
            me.dirty = false;
            for (key in modified) {
              if (modified.hasOwnProperty(key)) {
                me.dirty = true;
                break;
              }
            }
          }
        } else {
          me.dirty = true;
          modified[propName] = currentValue;
        }
      }
    }
    if (commit) {
      me.commit();
      me.phantom = phantom;
    }
    if (me.data.depth !== oldDepth) {
      childInfo = {depth:me.data.depth + 1};
      for (i = 0; i < childCount; i++) {
        children[i].updateInfo(commit, childInfo);
      }
    }
  }, isLast:function() {
    return this.get('isLast');
  }, isFirst:function() {
    return this.get('isFirst');
  }, hasChildNodes:function() {
    return !this.isLeaf() && this.childNodes.length > 0;
  }, isExpandable:function() {
    var me = this;
    if (me.get('expandable')) {
      return !(me.isLeaf() || me.isLoaded() && !me.phantom && !me.hasChildNodes());
    }
    return false;
  }, triggerUIUpdate:function() {
    this.callJoined('afterEdit', []);
  }, appendChild:function(node, suppressEvents, commit) {
    var me = this, i, ln, index, oldParent, previousSibling, childInfo = {isLast:true, parentId:me.getId(), depth:(me.data.depth || 0) + 1}, result, treeStore = me.getTreeStore(), bulkUpdate = treeStore && treeStore.bulkUpdate;
    Ext.suspendLayouts();
    if (Ext.isArray(node)) {
      ln = node.length;
      result = new Array(ln);
      me.callTreeStore('beginFill');
      for (i = 0; i < ln; i++) {
        result[i] = me.appendChild(node[i], suppressEvents, commit);
      }
      me.callTreeStore('endFill', [result]);
    } else {
      node = me.createNode(node);
      if (suppressEvents !== true && me.fireEventArgs('beforeappend', [me, node]) === false) {
        Ext.resumeLayouts(true);
        return false;
      }
      index = me.childNodes.length;
      oldParent = node.parentNode;
      if (oldParent) {
        if (suppressEvents !== true && node.fireEventArgs('beforemove', [node, oldParent, me, index]) === false) {
          Ext.resumeLayouts(true);
          return false;
        }
        if (oldParent.removeChild(node, false, suppressEvents, oldParent.getTreeStore() === treeStore) === false) {
          Ext.resumeLayouts(true);
          return false;
        }
      }
      treeStore && treeStore.beginUpdate();
      index = me.childNodes.length;
      if (index === 0) {
        me.setFirstChild(node);
      }
      me.childNodes[index] = node;
      node.parentNode = me;
      node.nextSibling = null;
      me.setLastChild(node);
      previousSibling = me.childNodes[index - 1];
      if (previousSibling) {
        node.previousSibling = previousSibling;
        previousSibling.nextSibling = node;
        previousSibling.updateInfo(commit, {isLast:false});
        if (!bulkUpdate) {
          previousSibling.triggerUIUpdate();
        }
      } else {
        node.previousSibling = null;
      }
      childInfo.isFirst = index === 0;
      childInfo.index = index;
      node.updateInfo(commit, childInfo);
      if (me.isLeaf()) {
        me.set('leaf', false);
      }
      if (!me.isLoaded()) {
        if (bulkUpdate) {
          me.data.loaded = true;
        } else {
          me.set('loaded', true);
        }
      } else {
        if (me.childNodes.length === 1 && !bulkUpdate) {
          me.triggerUIUpdate();
        }
      }
      if (index && me.childNodes[index - 1].isExpanded() && !bulkUpdate) {
        me.childNodes[index - 1].cascadeBy(me.triggerUIUpdate);
      }
      if (treeStore) {
        treeStore.registerNode(me, !bulkUpdate);
        if (bulkUpdate) {
          treeStore.registerNode(node);
        }
      }
      if (suppressEvents !== true) {
        me.fireEventArgs('append', [me, node, index]);
        if (oldParent) {
          node.fireEventArgs('move', [node, oldParent, me, index]);
        }
      }
      me.callTreeStore('onNodeAppend', [node, index]);
      result = node;
      if (treeStore) {
        treeStore.endUpdate();
      }
    }
    Ext.resumeLayouts(true);
    return result;
  }, getOwnerTree:function() {
    var store = this.getTreeStore();
    if (store) {
      return store.ownerTree;
    }
  }, getTreeStore:function() {
    var root = this;
    while (root && !root.treeStore) {
      root = root.parentNode;
    }
    return root && root.treeStore;
  }, removeChild:function(node, erase, suppressEvents, isMove) {
    var me = this, index = me.indexOf(node), i, childCount, previousSibling, treeStore = me.getTreeStore(), bulkUpdate = treeStore && treeStore.bulkUpdate, removeContext;
    if (index === -1 || suppressEvents !== true && me.fireEventArgs('beforeremove', [me, node, !!isMove]) === false) {
      return false;
    }
    Ext.suspendLayouts();
    treeStore && treeStore.beginUpdate();
    Ext.Array.erase(me.childNodes, index, 1);
    if (me.firstChild === node) {
      me.setFirstChild(node.nextSibling);
    }
    if (me.lastChild === node) {
      me.setLastChild(node.previousSibling);
    }
    previousSibling = node.previousSibling;
    if (previousSibling) {
      node.previousSibling.nextSibling = node.nextSibling;
    }
    if (node.nextSibling) {
      node.nextSibling.previousSibling = node.previousSibling;
      if (index === 0) {
        node.nextSibling.updateInfo(false, {isFirst:true});
      }
      for (i = index, childCount = me.childNodes.length; i < childCount; i++) {
        me.childNodes[i].updateInfo(false, {index:i});
      }
    } else {
      if (previousSibling) {
        previousSibling.updateInfo(false, {isLast:true});
        if (!bulkUpdate) {
          if (previousSibling.isExpanded()) {
            previousSibling.cascadeBy(me.triggerUIUpdate);
          } else {
            previousSibling.triggerUIUpdate();
          }
        }
      }
    }
    if (!me.childNodes.length && !bulkUpdate) {
      me.triggerUIUpdate();
    }
    Ext.resumeLayouts(true);
    if (suppressEvents !== true) {
      removeContext = {parentNode:node.parentNode, previousSibling:node.previousSibling, nextSibling:node.nextSibling};
      me.callTreeStore('beforeNodeRemove', [[node], !!isMove]);
      node.previousSibling = node.nextSibling = node.parentNode = null;
      me.fireEventArgs('remove', [me, node, !!isMove, removeContext]);
      me.callTreeStore('onNodeRemove', [[node], !!isMove]);
    }
    if (erase) {
      node.erase(true);
    } else {
      node.clear();
    }
    if (!isMove) {
      node.set({parentId:null, lastParentId:me.getId()}, silently);
    }
    if (treeStore) {
      treeStore.endUpdate();
    }
    return node;
  }, copy:function(newId, deep) {
    var me = this, result = me.callParent([newId]), len = me.childNodes ? me.childNodes.length : 0, i;
    if (deep) {
      for (i = 0; i < len; i++) {
        result.appendChild(me.childNodes[i].copy(undefined, true));
      }
    }
    return result;
  }, clear:function(erase) {
    var me = this;
    me.parentNode = me.previousSibling = me.nextSibling = null;
    if (erase) {
      me.firstChild = me.lastChild = me.childNodes = null;
    }
  }, drop:function() {
    var me = this, childNodes = me.childNodes, parentNode = me.parentNode, len = childNodes ? childNodes.length : 0, i, node, treeStore;
    me.callParent();
    if (parentNode) {
      treeStore = me.getTreeStore();
      parentNode.removeChild(me);
    } else {
      if (me.get('root')) {
        treeStore = me.getTreeStore();
        treeStore.setRoot(null);
      }
    }
    treeStore && treeStore.beginUpdate();
    for (i = 0; i < len; i++) {
      node = childNodes[i];
      node.clear();
      node.drop();
    }
    treeStore && treeStore.endUpdate();
  }, erase:function(options) {
    var me = this, childNodes = me.childNodes, len = childNodes && childNodes.length, i, node;
    me.remove();
    me.clear(true);
    me.callParent([options]);
    for (i = 0; i < len; i++) {
      node = childNodes[i];
      node.parentNode = null;
      node.erase(options);
    }
  }, insertBefore:function(node, refNode, suppressEvents) {
    var me = this, index = me.indexOf(refNode), oldParent = node.parentNode, refIndex = index, childCount, previousSibling, i, treeStore = me.getTreeStore(), bulkUpdate = treeStore && treeStore.bulkUpdate;
    if (!refNode) {
      return me.appendChild(node);
    }
    if (node === refNode) {
      return false;
    }
    node = me.createNode(node);
    if (suppressEvents !== true && me.fireEventArgs('beforeinsert', [me, node, refNode]) === false) {
      return false;
    }
    if (oldParent === me && me.indexOf(node) < index) {
      refIndex--;
    }
    if (oldParent) {
      if (suppressEvents !== true && node.fireEventArgs('beforemove', [node, oldParent, me, index, refNode]) === false) {
        return false;
      }
      if (oldParent.removeChild(node, false, suppressEvents, oldParent.getTreeStore() === treeStore) === false) {
        return false;
      }
    }
    treeStore && treeStore.beginUpdate();
    if (refIndex === 0) {
      me.setFirstChild(node);
    }
    Ext.Array.splice(me.childNodes, refIndex, 0, node);
    node.parentNode = me;
    node.nextSibling = refNode;
    refNode.previousSibling = node;
    previousSibling = me.childNodes[refIndex - 1];
    if (previousSibling) {
      node.previousSibling = previousSibling;
      previousSibling.nextSibling = node;
    } else {
      node.previousSibling = null;
    }
    node.updateInfo(false, {parentId:me.getId(), index:refIndex, isFirst:refIndex === 0, isLast:false, depth:(me.data.depth || 0) + 1});
    for (i = refIndex + 1, childCount = me.childNodes.length; i < childCount; i++) {
      me.childNodes[i].updateInfo(false, {index:i});
    }
    if (!me.isLoaded()) {
      if (bulkUpdate) {
        me.data.loaded = true;
      } else {
        me.set('loaded', true);
      }
    } else {
      if (me.childNodes.length === 1 && !bulkUpdate) {
        me.triggerUIUpdate();
      }
    }
    if (treeStore) {
      treeStore.registerNode(me, !bulkUpdate);
    }
    if (suppressEvents !== true) {
      me.fireEventArgs('insert', [me, node, refNode]);
      if (oldParent) {
        node.fireEventArgs('move', [node, oldParent, me, refIndex, refNode]);
      }
    }
    me.callTreeStore('onNodeInsert', [node, refIndex]);
    if (treeStore) {
      treeStore.endUpdate();
    }
    return node;
  }, insertChild:function(index, node) {
    var sibling = this.childNodes[index];
    if (sibling) {
      return this.insertBefore(node, sibling);
    } else {
      return this.appendChild(node);
    }
  }, isLastVisible:function() {
    var me = this, result = me.data.isLast, next = me.nextSibling;
    if (!result && me.getTreeStore().isFiltered()) {
      while (next) {
        if (next.data.visible) {
          return false;
        }
        next = next.nextSibling;
      }
      return true;
    }
    return result;
  }, remove:function(erase, suppressEvents) {
    var me = this, parentNode = me.parentNode;
    if (parentNode) {
      parentNode.removeChild(me, erase, suppressEvents);
    } else {
      if (erase) {
        me.erase(true);
      }
    }
    return me;
  }, removeAll:function(erase, suppressEvents, fromParent) {
    var me = this, childNodes = me.childNodes, len = childNodes.length, node, treeStore, i;
    if (!len) {
      return;
    }
    if (!fromParent) {
      treeStore = me.getTreeStore();
      if (treeStore) {
        treeStore.beginUpdate();
        treeStore.suspendEvent('remove');
        me.callTreeStore('beforeNodeRemove', [childNodes, false]);
      }
    }
    for (i = 0; i < len; ++i) {
      node = childNodes[i];
      node.previousSibling = node.nextSibling = node.parentNode = null;
      me.fireEventArgs('remove', [me, node, false]);
      if (erase) {
        node.erase(true);
      } else {
        node.removeAll(false, suppressEvents, true);
      }
    }
    if (!fromParent && treeStore) {
      treeStore.resumeEvent('remove');
      me.callTreeStore('onNodeRemove', [childNodes, false]);
      treeStore.endUpdate();
    }
    me.firstChild = me.lastChild = null;
    childNodes.length = 0;
    if (!fromParent) {
      me.triggerUIUpdate();
    }
    return me;
  }, getChildAt:function(index) {
    return this.childNodes[index];
  }, replaceChild:function(newChild, oldChild, suppressEvents) {
    var s = oldChild ? oldChild.nextSibling : null;
    this.removeChild(oldChild, false, suppressEvents);
    this.insertBefore(newChild, s, suppressEvents);
    return oldChild;
  }, indexOf:function(child) {
    return Ext.Array.indexOf(this.childNodes, child);
  }, indexOfId:function(id) {
    var childNodes = this.childNodes, len = childNodes.length, i = 0;
    for (; i < len; ++i) {
      if (childNodes[i].getId() === id) {
        return i;
      }
    }
    return -1;
  }, getPath:function(field, separator) {
    field = field || this.idProperty;
    separator = separator || '/';
    var path = [this.get(field)], parent = this.parentNode;
    while (parent) {
      path.unshift(parent.get(field));
      parent = parent.parentNode;
    }
    return separator + path.join(separator);
  }, getDepth:function() {
    return this.get('depth');
  }, bubble:function(fn, scope, args) {
    var p = this;
    while (p) {
      if (fn.apply(scope || p, args || [p]) === false) {
        break;
      }
      p = p.parentNode;
    }
  }, cascadeBy:function(before, scope, args, after) {
    var me = this;
    if (arguments.length === 1 && !Ext.isFunction(before)) {
      after = before.after;
      scope = before.scope;
      args = before.args;
      before = before.before;
    }
    if (!before || before.apply(scope || me, args || [me]) !== false) {
      var childNodes = me.childNodes, length = childNodes.length, i;
      for (i = 0; i < length; i++) {
        childNodes[i].cascadeBy.call(childNodes[i], before, scope, args, after);
      }
      if (after) {
        after.apply(scope || me, args || [me]);
      }
    }
  }, eachChild:function(fn, scope, args) {
    var childNodes = this.childNodes, length = childNodes.length, i;
    for (i = 0; i < length; i++) {
      if (fn.apply(scope || this, args || [childNodes[i]]) === false) {
        break;
      }
    }
  }, findChild:function(attribute, value, deep) {
    return this.findChildBy(function() {
      return this.get(attribute) == value;
    }, null, deep);
  }, findChildBy:function(fn, scope, deep) {
    var cs = this.childNodes, len = cs.length, i = 0, n, res;
    for (; i < len; i++) {
      n = cs[i];
      if (fn.call(scope || n, n) === true) {
        return n;
      } else {
        if (deep) {
          res = n.findChildBy(fn, scope, deep);
          if (res !== null) {
            return res;
          }
        }
      }
    }
    return null;
  }, contains:function(node) {
    return node.isAncestor(this);
  }, isAncestor:function(node) {
    var p = this.parentNode;
    while (p) {
      if (p === node) {
        return true;
      }
      p = p.parentNode;
    }
    return false;
  }, sort:function(sortFn, recursive, suppressEvent) {
    var me = this, childNodes = me.childNodes, ln = childNodes.length, i, n, info = {isFirst:true};
    if (ln > 0) {
      if (!sortFn) {
        sortFn = me.getTreeStore().getSortFn();
      }
      Ext.Array.sort(childNodes, sortFn);
      me.setFirstChild(childNodes[0]);
      me.setLastChild(childNodes[ln - 1]);
      for (i = 0; i < ln; i++) {
        n = childNodes[i];
        n.previousSibling = childNodes[i - 1];
        n.nextSibling = childNodes[i + 1];
        info.isLast = i === ln - 1;
        info.index = i;
        n.updateInfo(false, info);
        info.isFirst = false;
        if (recursive && !n.isLeaf()) {
          n.sort(sortFn, true, true);
        }
      }
      if (suppressEvent !== true) {
        me.fireEventArgs('sort', [me, childNodes]);
        me.callTreeStore('onNodeSort', [childNodes]);
      }
    }
  }, isExpanded:function() {
    return this.get('expanded');
  }, isLoaded:function() {
    return this.get('loaded');
  }, isBranchLoaded:function() {
    var isBranchLoaded = !this.isLeaf() && this.isLoaded();
    if (isBranchLoaded) {
      this.cascadeBy(function(node) {
        if (!node.isLeaf()) {
          isBranchLoaded = isBranchLoaded || node.isBranchLoaded();
        }
        return isBranchLoaded;
      });
    }
    return isBranchLoaded;
  }, isLoading:function() {
    return this.get('loading');
  }, isRoot:function() {
    return !this.parentNode;
  }, isVisible:function() {
    var parent = this.parentNode;
    while (parent) {
      if (!parent.isExpanded()) {
        return false;
      }
      parent = parent.parentNode;
    }
    return true;
  }, expand:function(recursive, callback, scope) {
    var me = this, treeStore, resumeAddEvent;
    if (!me.isLeaf()) {
      if (me.isLoading()) {
        me.on('expand', function() {
          me.expand(recursive, callback, scope);
        }, me, {single:true});
      } else {
        if (!me.isExpanded()) {
          if (me.fireEventArgs('beforeexpand', [me]) !== false) {
            if (recursive) {
              if (me.parentNode && me.parentNode.isSynchronousRecursiveExpand) {
                me.isSynchronousRecursiveExpand = true;
              } else {
                treeStore = me.getTreeStore();
                if (treeStore.getProxy().isSynchronous || me.isBranchLoaded()) {
                  me.isSynchronousRecursiveExpand = true;
                  treeStore.suspendEvent('add');
                  resumeAddEvent = true;
                }
              }
            }
            me.callTreeStore('onBeforeNodeExpand', [me.onChildNodesAvailable, me, [recursive, callback, scope]]);
            if (resumeAddEvent) {
              treeStore.resumeEvent('add');
              treeStore.fireEvent('refresh', treeStore);
            }
            me.isSynchronousRecursiveExpand = false;
          }
        } else {
          if (recursive) {
            me.expandChildren(true, callback, scope);
          } else {
            Ext.callback(callback, scope || me, [me.childNodes]);
          }
        }
      }
    } else {
      Ext.callback(callback, scope || me);
    }
  }, onChildNodesAvailable:function(records, recursive, callback, scope) {
    var me = this, treeStore = me.getTreeStore(), bulkUpdate = treeStore && treeStore.bulkUpdate, ancestor, i, collapsedAncestors;
    Ext.suspendLayouts();
    for (ancestor = me.parentNode; ancestor; ancestor = ancestor.parentNode) {
      if (!ancestor.isExpanded()) {
        (collapsedAncestors || (collapsedAncestors = [])).unshift(ancestor);
      }
    }
    if (bulkUpdate) {
      me.data.expanded = true;
    } else {
      me.set('expanded', true);
    }
    if (collapsedAncestors) {
      for (i = 1; i < collapsedAncestors.length; i++) {
        ancestor = collapsedAncestors[i];
        if (bulkUpdate) {
          ancestor.data.expanded = true;
        } else {
          ancestor.set('expanded', true);
        }
      }
      collapsedAncestors[0].expand();
      for (i = 1; i < collapsedAncestors.length; i++) {
        ancestor = collapsedAncestors[i];
        ancestor.fireEventArgs('expand', [ancestor, ancestor.childNodes]);
      }
    } else {
      me.callTreeStore('onNodeExpand', [records, false]);
    }
    me.fireEventArgs('expand', [me, records]);
    if (recursive) {
      me.expandChildren(true, callback, scope);
    } else {
      Ext.callback(callback, scope || me, [me.childNodes]);
    }
    Ext.resumeLayouts(true);
  }, expandChildren:function(recursive, callback, scope, singleExpand) {
    var me = this, origCallback, i, allNodes, expandNodes, ln, node, treeStore;
    if (Ext.isBoolean(callback)) {
      origCallback = callback;
      callback = scope;
      scope = singleExpand;
      singleExpand = origCallback;
    }
    if (singleExpand === undefined) {
      treeStore = me.getTreeStore();
      singleExpand = treeStore && treeStore.singleExpand;
    }
    allNodes = me.childNodes;
    expandNodes = [];
    ln = singleExpand ? Math.min(allNodes.length, 1) : allNodes.length;
    for (i = 0; i < ln; ++i) {
      node = allNodes[i];
      if (!node.isLeaf()) {
        expandNodes[expandNodes.length] = node;
      }
    }
    ln = expandNodes.length;
    for (i = 0; i < ln; ++i) {
      expandNodes[i].expand(recursive);
    }
    if (callback) {
      Ext.callback(callback, scope || me, [me.childNodes]);
    }
  }, collapse:function(recursive, callback, scope) {
    var me = this, expanded = me.isExpanded(), treeStore = me.getTreeStore(), bulkUpdate = treeStore && treeStore.bulkUpdate, len = me.childNodes.length, i, collapseChildren;
    if (!me.isLeaf() && (!expanded && recursive || me.fireEventArgs('beforecollapse', [me]) !== false)) {
      Ext.suspendLayouts();
      if (me.isExpanded()) {
        if (recursive) {
          collapseChildren = function() {
            for (i = 0; i < len; i++) {
              me.childNodes[i].setCollapsed(true);
            }
          };
          if (callback) {
            callback = Ext.Function.createSequence(collapseChildren, Ext.Function.bind(callback, scope, [me.childNodes]));
          } else {
            callback = collapseChildren;
          }
        } else {
          if (callback) {
            callback = Ext.Function.bind(callback, scope, [me.childNodes]);
          }
        }
        if (bulkUpdate) {
          me.data.expanded = false;
        } else {
          me.set('expanded', false);
        }
        me.callTreeStore('onNodeCollapse', [me.childNodes, callback, scope]);
        me.fireEventArgs('collapse', [me, me.childNodes]);
        callback = null;
      } else {
        if (recursive) {
          for (i = 0; i < len; i++) {
            me.childNodes[i].setCollapsed(true);
          }
        }
      }
      Ext.resumeLayouts(true);
    }
    Ext.callback(callback, scope || me, [me.childNodes]);
  }, setCollapsed:function(recursive) {
    var me = this, len = me.childNodes.length, i;
    if (!me.isLeaf() && me.fireEventArgs('beforecollapse', [me]) !== false) {
      me.data.expanded = false;
      me.fireEventArgs('collapse', [me, me.childNodes]);
      if (recursive) {
        for (i = 0; i < len; i++) {
          me.childNodes[i].setCollapsed(true);
        }
      }
    }
  }, collapseChildren:function(recursive, callback, scope) {
    var me = this, i, allNodes = me.childNodes, ln = allNodes.length, collapseNodes = [], node;
    for (i = 0; i < ln; ++i) {
      node = allNodes[i];
      if (!node.isLeaf() && node.isLoaded() && node.isExpanded()) {
        collapseNodes.push(node);
      }
    }
    ln = collapseNodes.length;
    if (ln) {
      for (i = 0; i < ln; ++i) {
        node = collapseNodes[i];
        if (i === ln - 1) {
          node.collapse(recursive, callback, scope);
        } else {
          node.collapse(recursive);
        }
      }
    } else {
      Ext.callback(callback, scope);
    }
  }, fireEvent:function(eventName) {
    return this.fireEventArgs(eventName, Ext.Array.slice(arguments, 1));
  }, fireEventArgs:function(eventName, args) {
    var fireEventArgs = Ext.mixin.Observable.prototype.fireEventArgs, result, eventSource, topNode;
    if (bubbledEvents[eventName]) {
      for (eventSource = this; result !== false && eventSource; eventSource = (topNode = eventSource).parentNode) {
        if (eventSource.hasListeners && eventSource.hasListeners[eventName]) {
          result = fireEventArgs.call(eventSource, eventName, args);
        }
      }
      if (result !== false) {
        eventSource = topNode.getTreeStore();
        if (eventSource && eventSource.hasListeners && eventSource.hasListeners[eventName = 'node' + eventName]) {
          result = eventSource.fireEventArgs(eventName, args);
        }
      }
      return result;
    } else {
      return fireEventArgs.apply(this, arguments);
    }
  }, serialize:function(writerParam) {
    var writer = writerParam || new Ext.data.writer.Json({writeAllFields:true}), result = writer.getRecordData(this), childNodes = this.childNodes, len = childNodes.length, children, i;
    if (len > 0) {
      result.children = children = [];
      for (i = 0; i < len; i++) {
        children.push(childNodes[i].serialize(writer));
      }
    }
    return result;
  }, callTreeStore:function(funcName, args) {
    var me = this, target = me.getTreeStore(), fn = target && target[funcName];
    if (target && fn) {
      args = args || [];
      if (args[0] !== me) {
        args.unshift(me);
      }
      fn.apply(target, args);
    }
  }, privates:{join:function(store) {
    if (store.isTreeStore) {
      if (this.isRoot()) {
        this.treeStore = this.store = store;
      }
    } else {
      this.callParent([store]);
    }
  }, callJoined:function(funcName, args) {
    this.callParent([funcName, args]);
    this.callTreeStore(funcName, args);
  }}};
}}});
Ext.define('Ext.data.TreeModel', {extend:Ext.data.Model, mixins:[Ext.mixin.Queryable], getRefItems:function() {
  return this.childNodes;
}, getRefOwner:function() {
  return this.parentNode;
}, statics:{defaultProxy:'memory'}}, function() {
  Ext.data.NodeInterface.decorate(this);
});
Ext.define('Ext.data.Request', {config:{action:undefined, params:undefined, method:'GET', url:null, operation:null, proxy:null, disableCaching:false, headers:{}, callbackKey:null, rawRequest:null, jsonData:undefined, xmlData:undefined, withCredentials:false, username:null, password:null, binary:false, callback:null, scope:null, timeout:30000, records:null, directFn:null, args:null, useDefaultXhrHeader:null}, constructor:function(config) {
  this.initConfig(config);
}, getParam:function(key) {
  var params = this.getParams(), val;
  if (params) {
    return params[key];
  }
  return val;
}, setParam:function(key, value) {
  var params = this.getParams() || {};
  params[key] = value;
  this.setParams(params);
}});
Ext.define('Ext.data.TreeStore', {extend:Ext.data.Store, alias:'store.tree', isTreeStore:true, config:{root:null, rootVisible:false, defaultRootProperty:'children', parentIdProperty:null, clearOnLoad:true, clearRemovedOnLoad:true, nodeParam:'node', defaultRootId:'root', defaultRootText:'Root', folderSort:false}, lazyFill:false, fillCount:0, bulkUpdate:0, _silentOptions:{silent:true}, implicitModel:'Ext.data.TreeModel', constructor:function(config) {
  var me = this;
  me.byIdMap = {};
  me.callParent([config]);
  if (Ext.isDefined(me.nodeParameter)) {
    if (Ext.isDefined(Ext.global.console)) {
      Ext.global.console.warn('Ext.data.TreeStore: nodeParameter has been deprecated. Please use nodeParam instead.');
    }
    me.nodeParam = me.nodeParameter;
    delete me.nodeParameter;
  }
}, applyFields:function(fields, oldFields) {
  var me = this;
  if (fields) {
    if (me.defaultRootProperty !== me.self.prototype.config.defaultRootProperty) {
      fields = fields.concat({name:me.defaultRootProperty, type:'auto', defaultValue:null, persist:false});
    }
  }
  me.callParent([fields, oldFields]);
}, onSorterEndUpdate:function() {
  var me = this, sorterCollection = me.getSorters(), sorters = sorterCollection.getRange(), rootNode = me.getRoot(), folderSort = me.getFolderSort();
  me.fireEvent('beforesort', me, sorters);
  if (rootNode && (folderSort || sorters.length)) {
    if (me.getRemoteSort()) {
      if (sorters.length) {
        me.load({callback:function() {
          me.fireEvent('sort', me, sorters);
        }});
      }
    } else {
      rootNode.sort(this.getSortFn(), true);
      me.fireEvent('datachanged', me);
      me.fireEvent('refresh', me);
      me.fireEvent('sort', me, sorters);
    }
  } else {
    me.fireEvent('sort', me, sorters);
  }
}, updateFolderSort:function(folderSort) {
  this.needsFolderSort = folderSort;
  this.onSorterEndUpdate();
}, getSortFn:function() {
  return this._sortFn || (this._sortFn = this.createSortFn());
}, createSortFn:function() {
  var me = this, sortersSortFn = this.sorters.getSortFn();
  return function(node1, node2) {
    var node1FolderOrder, node2FolderOrder, result = 0;
    if (me.needsFolderSort) {
      node1FolderOrder = node1.data.leaf ? 1 : 0;
      node2FolderOrder = node2.data.leaf ? 1 : 0;
      result = node1FolderOrder - node2FolderOrder;
    }
    if (me.needsIndexSort && result === 0) {
      result = node1.data.index - node2.data.index;
    }
    return result || sortersSortFn(node1, node2);
  };
}, getTotalCount:function() {
  return this.getCount();
}, afterEdit:function(node, modifiedFieldNames) {
  var me = this;
  if (me.needsLocalFilter()) {
    me.doFilter(node);
  }
  me.callParent([node, modifiedFieldNames]);
}, afterReject:function(record) {
  var me = this;
  if (me.contains(record)) {
    me.onUpdate(record, Ext.data.Model.REJECT, null);
    me.fireEvent('update', me, record, Ext.data.Model.REJECT, null);
  }
}, afterCommit:function(record, modifiedFieldNames) {
  var me = this;
  if (!modifiedFieldNames) {
    modifiedFieldNames = null;
  }
  if (me.contains(record)) {
    me.onUpdate(record, Ext.data.Model.COMMIT, modifiedFieldNames);
    me.fireEvent('update', me, record, Ext.data.Model.COMMIT, modifiedFieldNames);
  }
}, fireChangeEvent:function(record) {
  return !!this.byIdMap[record.id];
}, updateRootVisible:function(rootVisible) {
  var rootNode = this.getRoot(), data;
  if (rootNode) {
    data = this.getData();
    if (rootVisible) {
      data.insert(0, rootNode);
    } else {
      data.remove(rootNode);
    }
  }
}, updateTrackRemoved:function(trackRemoved) {
  this.callParent(arguments);
  this.removedNodes = this.removed;
  this.removed = null;
}, onDestroyRecords:function(records, operation, success) {
  if (success) {
    this.removedNodes.length = 0;
  }
}, updateProxy:function(proxy) {
  var reader;
  if (proxy) {
    if (proxy.setIdParam) {
      proxy.setIdParam(this.getNodeParam());
    }
    reader = proxy.getReader();
    if (Ext.isEmpty(reader.getRootProperty())) {
      reader.setRootProperty(this.getDefaultRootProperty());
    }
  }
}, setProxy:function(proxy) {
  this.changingProxy = true;
  this.callParent([proxy]);
  this.changingProxy = false;
}, updateModel:function(model) {
  var isNode = model.prototype.isNode;
  Ext.data.NodeInterface.decorate(model);
  if (!isNode && !this.changingProxy) {
    this.getProxy().getReader().buildExtractors(true);
  }
}, onFilterEndUpdate:function(filters) {
  var me = this, length = filters.length, root = me.getRoot(), childNodes, childNode, filteredNodes, i;
  if (!me.getRemoteFilter()) {
    if (length) {
      me.doFilter(root);
    } else {
      root.cascadeBy({after:function(node) {
        node.set('visible', true, me._silentOptions);
      }});
    }
    if (length) {
      filteredNodes = [];
      childNodes = root.childNodes;
      for (i = 0, length = childNodes.length; i < length; i++) {
        childNode = childNodes[i];
        if (childNode.get('visible')) {
          filteredNodes.push(childNode);
        }
      }
    } else {
      filteredNodes = root.childNodes;
    }
    me.onNodeFilter(root, filteredNodes);
    root.fireEvent('filterchange', root, filteredNodes);
    me.fireEvent('filterchange', me, filters);
    me.suppressNextFilter = true;
    me.callParent([filters]);
    me.suppressNextFilter = false;
  } else {
    me.callParent([filters]);
  }
}, onNodeFilter:function(root, childNodes) {
  var me = this, data = me.getData(), toAdd = [];
  if (me.getRootVisible()) {
    if (childNodes.length) {
      toAdd.push(root);
    } else {
      root.set('visible', false, me._silentOptions);
    }
  }
  me.handleNodeExpand(root, childNodes, toAdd);
  me.suspendEvents();
  data.splice(0, data.getCount(), toAdd);
  me.resumeEvents();
  if (!me.suppressNextFilter) {
    me.fireEvent('datachanged', me);
    me.fireEvent('refresh', me);
  }
}, onBeforeNodeExpand:function(node, callback, scope, args) {
  var me = this, storeReader, nodeProxy, nodeReader, reader, children, callbackArgs;
  if (node.isLoaded()) {
    callbackArgs = [node.childNodes];
    if (args) {
      callbackArgs.push.apply(callbackArgs, args);
    }
    Ext.callback(callback, scope || node, callbackArgs);
  } else {
    if (node.isLoading()) {
      me.on('load', function() {
        callbackArgs = [node.childNodes];
        if (args) {
          callbackArgs.push.apply(callbackArgs, args);
        }
        Ext.callback(callback, scope || node, callbackArgs);
      }, me, {single:true, priority:1001});
    } else {
      storeReader = me.getProxy().getReader();
      nodeProxy = node.getProxy();
      nodeReader = nodeProxy ? nodeProxy.getReader() : null;
      reader = nodeReader && nodeReader.initialConfig.rootProperty ? nodeReader : storeReader;
      children = reader.getRoot(node.raw || node.data);
      if (children || node.phantom && !node.isRoot()) {
        if (children) {
          me.fillNode(node, reader.extractData(children, {model:node.childType, recordCreator:me.recordCreator}));
        }
        callbackArgs = [node.childNodes];
        if (args) {
          callbackArgs.push.apply(callbackArgs, args);
        }
        Ext.callback(callback, scope || node, callbackArgs);
      } else {
        me.read({node:node, onChildNodesAvailable:function() {
          delete me.lastOptions.onChildNodesAvailable;
          callbackArgs = [node.childNodes];
          if (args) {
            callbackArgs.push.apply(callbackArgs, args);
          }
          Ext.callback(callback, scope || node, callbackArgs);
        }});
        me.flushLoad();
      }
    }
  }
}, onNodeExpand:function(parent, records) {
  var me = this, insertIndex = me.indexOf(parent) + 1, toAdd = [];
  me.handleNodeExpand(parent, records, toAdd);
  if (!me.refreshCounter && parent.isRoot() && !parent.get('visible')) {
    me.loadRecords(toAdd);
  } else {
    me.insert(insertIndex, toAdd);
  }
}, handleNodeExpand:function(parent, records, toAdd) {
  var me = this, ln = records ? records.length : 0, i, record;
  if (parent !== this.getRoot() && !me.isVisible(parent)) {
    return;
  }
  if (ln) {
    for (i = 0; i < ln; i++) {
      record = records[i];
      if (record.get('visible')) {
        toAdd.push(record);
        if (record.isExpanded()) {
          if (record.isLoaded()) {
            me.handleNodeExpand(record, record.childNodes, toAdd);
          } else {
            record.set('expanded', false);
            record.expand();
          }
        }
      }
    }
  }
}, onNodeCollapse:function(parent, records, callback, scope) {
  var me = this, collapseIndex = me.indexOf(parent) + 1, lastNodeIndexPlus;
  if (me.needsLocalFilter()) {
    records = Ext.Array.filter(records, me.filterVisible);
  }
  if (records.length && me.data.contains(records[0])) {
    lastNodeIndexPlus = me.indexOfNextVisibleNode(parent);
    me.removeAt(collapseIndex, lastNodeIndexPlus - collapseIndex);
  }
  Ext.callback(callback, scope);
}, indexOfNextVisibleNode:function(node) {
  var result;
  while (node.parentNode) {
    for (result = node.nextSibling; result && !result.get('visible'); result = result.nextSibling) {
    }
    if (result) {
      return this.indexOf(result);
    }
    node = node.parentNode;
  }
  return this.getCount();
}, filterNew:function(item) {
  return !item.get('root') && this.callParent([item]);
}, filterRejects:function(item) {
  return !item.get('root') && this.callParent([item]);
}, getNewRecords:function() {
  return Ext.Array.filter(Ext.Object.getValues(this.byIdMap), this.filterNew, this);
}, getUpdatedRecords:function() {
  return Ext.Array.filter(Ext.Object.getValues(this.byIdMap), this.filterUpdated);
}, beforeNodeRemove:function(parentNode, childNodes) {
  if (!Ext.isArray(childNodes)) {
    childNodes = [childNodes];
  }
  var me = this, len = childNodes.length, i, startNode;
  for (i = 0; !startNode && i < len; i++) {
    if (childNodes[i].get('visible')) {
      startNode = childNodes[i];
    }
  }
  if (startNode) {
    me.startRemoveIndex = me.indexOf(childNodes[0]);
    me.lastRemoveIndexPlusOne = me.indexOfNextVisibleNode(childNodes[childNodes.length - 1]);
  } else {
    me.startRemoveIndex = -1;
    me.lastRemoveIndexPlusOne = 0;
  }
}, afterDrop:Ext.emptyFn, onNodeRemove:function(parentNode, childNodes, isMove) {
  var me = this, removed = me.removedNodes, len = childNodes.length, startRemoveIndex = me.startRemoveIndex, lastRemoveIndexPlusOne = me.lastRemoveIndexPlusOne, i;
  me.suspendAutoSync();
  if (startRemoveIndex !== -1) {
    me.removeIsMove = isMove;
    me.removeAt(startRemoveIndex, lastRemoveIndexPlusOne - startRemoveIndex);
    me.removeIsMove = false;
  }
  for (i = 0; i < len; i++) {
    childNodes[i].cascadeBy(function(node) {
      me.unregisterNode(node);
      if (removed && !isMove) {
        if (!node.phantom && !node.erasing && !me.loading) {
          node.removedFrom = me.indexOf(node);
          removed.push(node);
          me.needsSync = true;
        }
      }
    });
  }
  me.resumeAutoSync();
}, onNodeAppend:function(parent, node, index) {
  this.onNodeInsert(parent, node, index);
}, onNodeInsert:function(parent, node, index) {
  var me = this, data = node.raw || node.data, removed = me.removedNodes, refNode, sibling, storeReader, nodeProxy, nodeReader, reader, dataRoot;
  if (parent && me.needsLocalFilter()) {
    me.doFilter(parent);
  }
  me.beginUpdate();
  if (me.isVisible(node)) {
    if (index === 0 || !node.previousSibling) {
      refNode = parent;
    } else {
      for (sibling = node.previousSibling; sibling && !sibling.get('visible'); sibling = sibling.previousSibling) {
      }
      while (sibling.isExpanded() && sibling.lastChild) {
        sibling = sibling.lastChild;
      }
      refNode = sibling;
    }
    me.insert(me.indexOf(refNode) + 1, node);
    if (!node.isLeaf() && node.isExpanded()) {
      if (node.isLoaded()) {
        me.onNodeExpand(node, node.childNodes);
      } else {
        if (!me.fillCount) {
          node.set('expanded', false);
          node.expand();
        }
      }
    }
  }
  Ext.Array.remove(removed, node);
  me.needsSync = me.needsSync || node.phantom || node.dirty;
  if (!node.isLeaf() && !node.isLoaded() && !me.lazyFill) {
    storeReader = me.getProxy().getReader();
    nodeProxy = node.getProxy();
    nodeReader = nodeProxy ? nodeProxy.getReader() : null;
    reader = nodeReader && nodeReader.initialConfig.rootProperty ? nodeReader : storeReader;
    dataRoot = reader.getRoot(data);
    if (dataRoot) {
      me.fillNode(node, reader.extractData(dataRoot, {model:node.childType, recordCreator:me.recordCreator}));
    }
  }
  me.endUpdate();
}, registerNode:function(node, includeChildren) {
  var me = this, children, length, i;
  me.byIdMap[node.id] = node;
  if (includeChildren === true) {
    children = node.childNodes;
    length = children.length;
    for (i = 0; i < length; i++) {
      me.registerNode(children[i], true);
    }
  }
}, unregisterNode:function(node, includeChildren) {
  var me = this, children, length, i;
  delete me.byIdMap[node.id];
  if (includeChildren === true) {
    children = node.childNodes;
    length = children.length;
    for (i = 0; i < length; i++) {
      me.unregisterNode(children[i], true);
    }
  }
}, onNodeSort:function(node, childNodes) {
  var me = this;
  me.suspendAutoSync();
  if (me.indexOf(node) !== -1 && node.isExpanded() || node === me.getRoot() && !me.getRootVisible()) {
    Ext.suspendLayouts();
    me.onNodeCollapse(node, childNodes);
    me.onNodeExpand(node, childNodes);
    Ext.resumeLayouts(true);
  }
  me.resumeAutoSync(me.autoSync);
}, applyRoot:function(newRoot) {
  var me = this, Model = me.getModel(), idProperty = Model.prototype.idProperty, defaultRootId = me.getDefaultRootId();
  if (newRoot && !newRoot.isNode) {
    newRoot = Ext.apply({text:me.getDefaultRootText(), root:true, isFirst:true, isLast:true, depth:0, index:0, parentId:null, allowDrag:false}, newRoot);
    if (defaultRootId && newRoot[idProperty] === undefined) {
      newRoot[idProperty] = defaultRootId;
    }
    newRoot = new Model(newRoot);
  }
  return newRoot;
}, updateRoot:function(newRoot, oldRoot) {
  var me = this, oldOwner, initial = !oldRoot, toRemove;
  me.byIdMap = {};
  me.getTrackRemoved();
  me.suspendEvent('add', 'remove');
  if (oldRoot && oldRoot.isModel) {
    if (me.getRootVisible()) {
      toRemove = [oldRoot];
    } else {
      toRemove = oldRoot.childNodes;
    }
    me.beforeNodeRemove(null, toRemove);
    oldRoot.set('root', false);
    me.onNodeRemove(null, toRemove);
    oldRoot.fireEvent('remove', null, oldRoot, false);
    oldRoot.fireEvent('rootchange', null);
    oldRoot.clearListeners();
    oldRoot.store = oldRoot.treeStore = null;
  }
  me.getData().clear();
  if (newRoot) {
    if (newRoot.fireEventArgs('beforeappend', [null, newRoot]) === false) {
      newRoot = null;
    } else {
      oldOwner = newRoot.parentNode;
      if (oldOwner) {
        if (!oldOwner.removeChild(newRoot, false, false, oldOwner.getTreeStore() === me)) {
          return;
        }
      } else {
        if ((oldOwner = newRoot.getTreeStore()) && oldOwner !== me && newRoot === oldOwner.getRoot()) {
          oldOwner.setRoot(null);
        }
      }
      newRoot.store = newRoot.treeStore = me;
      newRoot.set('root', true);
      newRoot.updateInfo(true, {isFirst:true, isLast:true, depth:0, index:0, parentId:null});
      me.registerNode(newRoot, true);
      newRoot.fireEvent('append', null, newRoot, false);
      newRoot.fireEvent('rootchange', newRoot);
      me.onNodeAppend(null, newRoot, 0);
      newRoot.phantom = true;
    }
  }
  me.fireEvent('rootchange', newRoot, oldRoot);
  if (newRoot && (me.getAutoLoad() || newRoot.isExpanded())) {
    if (newRoot.isLoaded()) {
      me.onNodeExpand(newRoot, newRoot.childNodes);
      me.fireEvent('datachanged', me);
      me.fireEvent('refresh', me);
    } else {
      newRoot.data.expanded = false;
      newRoot.expand(false, function() {
        me.fireEvent('datachanged', me);
        me.fireEvent('refresh', me);
      });
    }
  } else {
    if (!initial) {
      me.fireEvent('datachanged', me);
      me.fireEvent('refresh', me);
    }
  }
  me.resumeEvent('add', 'remove');
}, getNodeById:function(id) {
  return this.byIdMap[id] || null;
}, findNode:function(property, value, startsWith, endsWith, ignoreCase) {
  if (Ext.isEmpty(value, false)) {
    return null;
  }
  if (value === this.model.idProperty && arguments.length < 3) {
    return this.byIdMap[value];
  }
  var regex = Ext.String.createRegex(value, startsWith, endsWith, ignoreCase), result = null;
  Ext.Object.eachValue(this.byIdMap, function(node) {
    if (node && regex.test(node.get(property))) {
      result = node;
      return false;
    }
  });
  return result;
}, load:function(options) {
  var node = options && options.node;
  if (!node & !(node = this.getRoot())) {
    node = this.setRoot({expanded:true});
    return;
  }
  if (node.isLoading()) {
    return;
  }
  return this.callParent([options]);
}, flushLoad:function() {
  var me = this, options = me.pendingLoadOptions, node, callback, scope, clearOnLoad = me.getClearOnLoad(), isReload, operation, doClear;
  me.clearLoadTask();
  if (!options) {
    return;
  }
  node = options.node || me.getRoot();
  isReload = node && node.isRoot() && node.isLoaded() && clearOnLoad;
  callback = options.callback;
  scope = options.scope;
  options.params = options.params || {};
  if (node.data.expanded && !isReload) {
    node.data.loaded = false;
    if (clearOnLoad) {
      node.data.expanded = false;
    }
    options.callback = function(loadedNodes, operation, success) {
      if (!clearOnLoad) {
        node.collapse();
      }
      node.expand();
      Ext.callback(callback, scope, [loadedNodes, operation, success]);
    };
  }
  options.id = node.getId();
  options = Ext.apply({filters:me.getFilters().items, sorters:me.getSorters().items, node:options.node || node, internalScope:me, internalCallback:me.onProxyLoad}, options);
  me.lastOptions = Ext.apply({}, options);
  options.isReload = isReload;
  operation = me.createOperation('read', options);
  if (me.fireEvent('beforeload', me, operation) !== false) {
    me.loading = true;
    if (isReload) {
      if (me.getClearRemovedOnLoad()) {
        me.removedNodes.length = 0;
      }
      me.unregisterNode(node, true);
      node.childNodes.length = 0;
      doClear = true;
    } else {
      if (clearOnLoad) {
        if (me.getTrackRemoved() && me.getClearRemovedOnLoad()) {
          me.clearRemoved(node);
        }
        node.removeAll(false);
      }
    }
    if (me.loading && node) {
      node.set('loading', true);
    }
    if (doClear) {
      me.clearData(true);
      if (me.getRootVisible()) {
        me.suspendEvents();
        me.add(node);
        me.resumeEvents();
      }
    }
    operation.execute();
  }
  return me;
}, onProxyLoad:function(operation) {
  var me = this, options = operation.initialConfig, successful = operation.wasSuccessful(), records = operation.getRecords(), node = options.node, isReload = options.isReload, scope = operation.getScope() || me, args = [records, operation, successful];
  if (me.destroyed) {
    return;
  }
  me.loading = false;
  node.set('loading', false);
  if (successful) {
    ++me.loadCount;
    if (!me.getClearOnLoad()) {
      records = me.cleanRecords(node, records);
    }
    if (me.getParentIdProperty()) {
      records = me.treeify(node, records);
    }
    if (isReload) {
      me.suspendEvent('add', 'update');
    }
    records = me.fillNode(node, records);
  }
  if (isReload) {
    me.resumeEvent('add', 'update');
    me.callObservers('BeforePopulate');
    me.fireEvent('datachanged', me);
    me.fireEvent('refresh', me);
    me.callObservers('AfterPopulate');
  } else {
    Ext.callback(options.onChildNodesAvailable, scope, args);
  }
  me.fireEvent('load', me, records, successful, operation, node);
}, clearRemoved:function(node) {
  var me = this, removed = me.removedNodes, id = node.getId(), removedLength = removed.length, i = removedLength, recordsToClear = {}, newRemoved = [], removedHash = {}, removedNode, targetNode, targetId;
  if (node === me.getRoot()) {
    me.removedNodes.length = 0;
    return;
  }
  for (; i--;) {
    removedNode = removed[i];
    removedHash[removedNode.getId()] = removedNode;
  }
  for (i = removedLength; i--;) {
    removedNode = removed[i];
    targetNode = removedNode;
    while (targetNode && targetNode.getId() !== id) {
      targetId = targetNode.get('parentId') || targetNode.get('lastParentId');
      targetNode = targetNode.parentNode || me.getNodeById(targetId) || removedHash[targetId];
    }
    if (targetNode) {
      recordsToClear[removedNode.getId()] = removedNode;
    }
  }
  for (i = 0; i < removedLength; i++) {
    removedNode = removed[i];
    if (!recordsToClear[removedNode.getId()]) {
      newRemoved.push(removedNode);
    }
  }
  me.removedNodes = newRemoved;
}, fillNode:function(node, newNodes) {
  var me = this, newNodeCount = newNodes ? newNodes.length : 0;
  ++me.bulkUpdate;
  if (newNodeCount) {
    me.setupNodes(newNodes);
  }
  if (me.bulkUpdate === 1) {
    node.set('loaded', true);
  } else {
    node.data.loaded = true;
  }
  if (newNodes.length) {
    node.appendChild(newNodes, undefined, true);
  }
  --me.bulkUpdate;
  return newNodes;
}, setupNodes:function(newNodes) {
  var me = this, sorters = me.getSorters(), needsIndexSort = false, newNodeCount = newNodes.length, performLocalSort = me.sortOnLoad && newNodeCount > 1 && !me.getRemoteSort() && me.getFolderSort() || sorters.length, node1, node2, i, filterFn;
  if (me.needsLocalFilter()) {
    filterFn = me.getFilters().getFilterFn();
    newNodes[0].set('visible', filterFn(newNodes[0]));
  }
  for (i = 1; i < newNodeCount; i++) {
    node1 = newNodes[i];
    node2 = newNodes[i - 1];
    if (filterFn) {
      node1.set('visible', filterFn(node1));
    }
    needsIndexSort = node1.data.index !== node2.data.index;
  }
  if (performLocalSort) {
    me.needsIndexSort = true;
    Ext.Array.sort(newNodes, me.getSortFn());
    me.needsIndexSort = false;
  } else {
    if (needsIndexSort) {
      Ext.Array.sort(newNodes, me.sortByIndex);
    }
  }
}, beginFill:function() {
  var me = this;
  if (!me.fillCount++) {
    me.beginUpdate();
    me.suspendEvent('add', 'update');
    me.suspendAutoSync();
    me.fillArray = [];
  }
}, endFill:function(parent, nodes) {
  var me = this, fillArray = me.fillArray, i, len, index;
  fillArray.push(nodes);
  if (!--me.fillCount) {
    me.resumeAutoSync();
    me.resumeEvent('add', 'update');
    for (i = 0, len = fillArray.length; i < len; i++) {
      index = me.indexOf(fillArray[i][0]);
      if (index !== -1) {
        me.fireEvent('add', me, fillArray[i], index);
      }
    }
    me.fillArray = null;
    me.endUpdate();
  }
}, sortByIndex:function(node1, node2) {
  return node1.data.index - node2.data.index;
}, onIdChanged:function(node, oldId, newId) {
  var childNodes = node.childNodes, len = childNodes && childNodes.length, i;
  this.callParent(arguments);
  delete this.byIdMap[oldId];
  this.byIdMap[newId] = node;
  for (i = 0; i < len; i++) {
    childNodes[i].set('parentId', newId);
  }
}, treeify:function(parentNode, records) {
  var me = this, loadParentNodeId = parentNode.getId(), parentIdProperty = me.getParentIdProperty(), len = records.length, result = [], nodeMap = {}, i, node, parentId, parent, id, children;
  for (i = 0; i < len; i++) {
    node = records[i];
    nodeMap[node.id] = node;
  }
  for (i = 0; i < len; i++) {
    node = records[i];
    parentId = node.data[parentIdProperty];
    if (!(parentId || parentId === 0) || parentId === loadParentNodeId) {
      result.push(node);
    } else {
      if (!nodeMap[parentId]) {
        Ext.raise('Ext.data.TreeStore, Invalid parentId "' + parentId + '"');
      }
      parent = nodeMap[parentId];
      parent.$children = parent.$children || [];
      parent.$children.push(node);
    }
  }
  for (id in nodeMap) {
    node = nodeMap[id];
    children = node.$children;
    if (children) {
      delete node.$children;
      me.setupNodes(children);
      node.appendChild(children);
    }
    me.registerNode(node);
  }
  me.setupNodes(result);
  return result;
}, cleanRecords:function(node, records) {
  var nodeHash = {}, childNodes = node.childNodes, i = 0, len = childNodes.length, out = [], rec;
  for (; i < len; ++i) {
    nodeHash[childNodes[i].getId()] = true;
  }
  for (i = 0, len = records.length; i < len; ++i) {
    rec = records[i];
    if (!nodeHash[rec.getId()]) {
      out.push(rec);
    }
  }
  return out;
}, removeAll:function() {
  this.suspendEvents();
  this.setRoot(null);
  this.resumeEvents();
  this.callParent();
}, doSort:function(sorterFn) {
  var me = this;
  if (me.getRemoteSort()) {
    me.load();
  } else {
    me.tree.sort(sorterFn, true);
    me.fireEvent('datachanged', me);
    me.fireEvent('refresh', me);
  }
  me.fireEvent('sort', me, me.sorters.getRange());
}, filterVisible:function(node) {
  return node.get('visible');
}, isVisible:function(node) {
  var parentNode = node.parentNode, visible = node.data.visible, root = this.getRoot();
  while (visible && parentNode) {
    visible = parentNode.data.expanded && parentNode.data.visible;
    parentNode = parentNode.parentNode;
  }
  return visible && !(node === root && !this.getRootVisible());
}, commitChanges:function() {
  var removed = this.removedNodes;
  if (removed) {
    removed.length = 0;
  }
  this.callParent();
}, getRootNode:function() {
  return this.getRoot();
}, setRootNode:function(root) {
  this.setRoot(root);
  return this.getRoot();
}, privates:{getRawRemovedRecords:function() {
  return this.removedNodes;
}, recordCreator:function(data, Model) {
  return new Model(data);
}, doFilter:function(node) {
  var root = this.getRoot(), filterFn = this.getFilters().getFilterFn();
  this.filterNodes(root, node, filterFn);
}, filterNodes:function(root, node, filterFn) {
  var match = false, childNodes = node.childNodes, len = childNodes && childNodes.length, i;
  if (len) {
    for (i = 0; i < len; ++i) {
      this.filterNodes(root, childNodes[i], filterFn);
    }
  }
  match = node === root || filterFn(node);
  node.set('visible', match, this._silentOptions);
  return match;
}, needsLocalFilter:function() {
  return !this.getRemoteFilter() && this.getFilters().length;
}, onRemoteFilterSet:function(filters, remoteFilter) {
  var data = this.getData();
  data.setFilters(null);
  if (filters) {
    filters.on('endupdate', this.onFilterEndUpdate, this);
  }
}, onRemoteSortSet:function(sorters, remoteSort) {
  var data = this.getData();
  data.setSorters(null);
  if (sorters) {
    sorters.on('endupdate', this.onSorterEndUpdate, this);
  }
}}, deprecated:{5:{properties:{tree:null}}}});
Ext.define('Ext.data.Validation', {extend:Ext.data.Model, isValidation:true, syncGeneration:0, attach:function(record) {
  this.record = record;
  delete this.data.id;
}, getValidation:function() {
  return null;
}, isValid:function() {
  var me = this;
  if (me.syncGeneration !== me.record.generation) {
    me.refresh();
  }
  return !me.dirty;
}, refresh:function(force) {
  var me = this, data = me.data, record = me.record, fields = record.fields, generation = record.generation, recordData = record.data, sep = record.validationSeparator, values = null, defaultMessage, currentValue, error, field, item, i, j, jLen, len, msg, val, name;
  if (force || me.syncGeneration !== generation) {
    me.syncGeneration = generation;
    for (i = 0, len = fields.length; i < len; ++i) {
      field = fields[i];
      name = field.name;
      val = recordData[name];
      defaultMessage = field.defaultInvalidMessage;
      error = 0;
      if (!(name in data)) {
        data[name] = currentValue = true;
      } else {
        currentValue = data[name];
      }
      if (field.validate !== Ext.emptyFn) {
        msg = field.validate(val, sep, null, record);
        if (msg !== true) {
          error = msg || defaultMessage;
        }
      }
      if (!error) {
        error = true;
      }
      if (error !== currentValue) {
        (values || (values = {}))[name] = error;
      }
    }
    if (values) {
      me.set(values);
    }
  }
}});
Ext.define('Ext.dom.Helper', function() {
  var afterbegin = 'afterbegin', afterend = 'afterend', beforebegin = 'beforebegin', beforeend = 'beforeend', bbValues = ['BeforeBegin', 'previousSibling'], aeValues = ['AfterEnd', 'nextSibling'], bb_ae_PositionHash = {beforebegin:bbValues, afterend:aeValues}, fullPositionHash = {beforebegin:bbValues, afterend:aeValues, afterbegin:['AfterBegin', 'firstChild'], beforeend:['BeforeEnd', 'lastChild']};
  return {singleton:true, alternateClassName:['Ext.DomHelper', 'Ext.core.DomHelper'], emptyTags:/^(?:br|frame|hr|img|input|link|meta|range|spacer|wbr|area|param|col)$/i, confRe:/^(?:tag|children|cn|html|tpl|tplData)$/i, endRe:/end/i, attributeTransform:{cls:'class', htmlFor:'for'}, closeTags:{}, detachedDiv:document.createElement('div'), decamelizeName:function() {
    var camelCaseRe = /([a-z])([A-Z])/g, cache = {};
    function decamel(match, p1, p2) {
      return p1 + '-' + p2.toLowerCase();
    }
    return function(s) {
      return cache[s] || (cache[s] = s.replace(camelCaseRe, decamel));
    };
  }(), generateMarkup:function(spec, buffer) {
    var me = this, specType = typeof spec, attr, val, tag, i, closeTags;
    if (specType === 'string' || specType === 'number') {
      buffer.push(spec);
    } else {
      if (Ext.isArray(spec)) {
        for (i = 0; i < spec.length; i++) {
          if (spec[i]) {
            me.generateMarkup(spec[i], buffer);
          }
        }
      } else {
        tag = spec.tag || 'div';
        buffer.push('\x3c', tag);
        for (attr in spec) {
          if (spec.hasOwnProperty(attr)) {
            val = spec[attr];
            if (val !== undefined && !me.confRe.test(attr)) {
              if (typeof val === 'object') {
                buffer.push(' ', attr, '\x3d"');
                me.generateStyles(val, buffer, true).push('"');
              } else {
                buffer.push(' ', me.attributeTransform[attr] || attr, '\x3d"', val, '"');
              }
            }
          }
        }
        if (me.emptyTags.test(tag)) {
          buffer.push('/\x3e');
        } else {
          buffer.push('\x3e');
          if (val = spec.tpl) {
            val.applyOut(spec.tplData, buffer);
          }
          if (val = spec.html) {
            buffer.push(val);
          }
          if (val = spec.cn || spec.children) {
            me.generateMarkup(val, buffer);
          }
          closeTags = me.closeTags;
          buffer.push(closeTags[tag] || (closeTags[tag] = '\x3c/' + tag + '\x3e'));
        }
      }
    }
    return buffer;
  }, generateStyles:function(styles, buffer, encode) {
    var a = buffer || [], name, val;
    for (name in styles) {
      if (styles.hasOwnProperty(name)) {
        val = styles[name];
        name = this.decamelizeName(name);
        if (encode && Ext.String.hasHtmlCharacters(val)) {
          val = Ext.String.htmlEncode(val);
        }
        a.push(name, ':', val, ';');
      }
    }
    return buffer || a.join('');
  }, markup:function(spec) {
    if (typeof spec === 'string') {
      return spec;
    }
    var buf = this.generateMarkup(spec, []);
    return buf.join('');
  }, applyStyles:function(el, styles) {
    Ext.fly(el).applyStyles(styles);
  }, createContextualFragment:function(html) {
    var div = this.detachedDiv, fragment = document.createDocumentFragment(), length, childNodes;
    div.innerHTML = html;
    childNodes = div.childNodes;
    length = childNodes.length;
    while (length--) {
      fragment.appendChild(childNodes[0]);
    }
    return fragment;
  }, createDom:function(o, parentNode) {
    var me = this, markup = me.markup(o), div = me.detachedDiv, child;
    div.innerHTML = markup;
    child = div.firstChild;
    return Ext.supports.ChildContentClearedWhenSettingInnerHTML ? child.cloneNode(true) : child;
  }, insertHtml:function(where, el, html) {
    var me = this, hashVal, range, rangeEl, setStart, frag;
    where = where.toLowerCase();
    if (el.insertAdjacentHTML) {
      if (me.ieInsertHtml) {
        frag = me.ieInsertHtml(where, el, html);
        if (frag) {
          return frag;
        }
      }
      hashVal = fullPositionHash[where];
      if (hashVal) {
        el.insertAdjacentHTML(hashVal[0], html);
        return el[hashVal[1]];
      }
    } else {
      if (el.nodeType === 3) {
        where = where === afterbegin ? beforebegin : where;
        where = where === beforeend ? afterend : where;
      }
      range = Ext.supports.CreateContextualFragment ? el.ownerDocument.createRange() : undefined;
      setStart = 'setStart' + (this.endRe.test(where) ? 'After' : 'Before');
      if (bb_ae_PositionHash[where]) {
        if (range) {
          range[setStart](el);
          frag = range.createContextualFragment(html);
        } else {
          frag = this.createContextualFragment(html);
        }
        el.parentNode.insertBefore(frag, where === beforebegin ? el : el.nextSibling);
        return el[(where === beforebegin ? 'previous' : 'next') + 'Sibling'];
      } else {
        rangeEl = (where === afterbegin ? 'first' : 'last') + 'Child';
        if (el.firstChild) {
          if (range) {
            try {
              range[setStart](el[rangeEl]);
              frag = range.createContextualFragment(html);
            } catch (e$24) {
              frag = this.createContextualFragment(html);
            }
          } else {
            frag = this.createContextualFragment(html);
          }
          if (where === afterbegin) {
            el.insertBefore(frag, el.firstChild);
          } else {
            el.appendChild(frag);
          }
        } else {
          el.innerHTML = html;
        }
        return el[rangeEl];
      }
    }
    Ext.raise({sourceClass:'Ext.DomHelper', sourceMethod:'insertHtml', htmlToInsert:html, targetElement:el, msg:'Illegal insertion point reached: "' + where + '"'});
  }, insertBefore:function(el, o, returnElement) {
    return this.doInsert(el, o, returnElement, beforebegin);
  }, insertAfter:function(el, o, returnElement) {
    return this.doInsert(el, o, returnElement, afterend);
  }, insertFirst:function(el, o, returnElement) {
    return this.doInsert(el, o, returnElement, afterbegin);
  }, append:function(el, o, returnElement) {
    return this.doInsert(el, o, returnElement, beforeend);
  }, overwrite:function(el, html, returnElement) {
    var me = this, newNode;
    el = Ext.getDom(el);
    html = me.markup(html);
    if (me.ieOverwrite) {
      newNode = me.ieOverwrite(el, html);
    }
    if (!newNode) {
      el.innerHTML = html;
      newNode = el.firstChild;
    }
    return returnElement ? Ext.get(newNode) : newNode;
  }, doInsert:function(el, o, returnElement, where) {
    var me = this, newNode;
    el = el.dom || Ext.getDom(el);
    if ('innerHTML' in el) {
      newNode = me.insertHtml(where, el, me.markup(o));
    } else {
      newNode = me.createDom(o, null);
      if (el.nodeType === 3) {
        where = where === afterbegin ? beforebegin : where;
        where = where === beforeend ? afterend : where;
      }
      if (bb_ae_PositionHash[where]) {
        el.parentNode.insertBefore(newNode, where === beforebegin ? el : el.nextSibling);
      } else {
        if (el.firstChild && where === afterbegin) {
          el.insertBefore(newNode, el.firstChild);
        } else {
          el.appendChild(newNode);
        }
      }
    }
    return returnElement ? Ext.get(newNode) : newNode;
  }, createTemplate:function(o) {
    var html = this.markup(o);
    return new Ext.Template(html);
  }, createHtml:function(spec) {
    return this.markup(spec);
  }};
});
Ext.define('Ext.data.proxy.Rest', {extend:Ext.data.proxy.Ajax, alternateClassName:'Ext.data.RestProxy', alias:'proxy.rest', defaultActionMethods:{create:'POST', read:'GET', update:'PUT', destroy:'DELETE'}, slashRe:/\/$/, periodRe:/\.$/, config:{appendId:true, format:null, batchActions:false, actionMethods:{create:'POST', read:'GET', update:'PUT', destroy:'DELETE'}}, buildUrl:function(request) {
  var me = this, operation = request.getOperation(), records = operation.getRecords(), record = records ? records[0] : null, format = me.getFormat(), url = me.getUrl(request), id, params;
  if (record && !record.phantom) {
    id = record.getId();
  } else {
    id = operation.getId();
  }
  if (me.getAppendId() && me.isValidId(id)) {
    if (!url.match(me.slashRe)) {
      url += '/';
    }
    url += encodeURIComponent(id);
    params = request.getParams();
    if (params) {
      delete params[me.getIdParam()];
    }
  }
  if (format) {
    if (!url.match(me.periodRe)) {
      url += '.';
    }
    url += format;
  }
  request.setUrl(url);
  return me.callParent([request]);
}, isValidId:function(id) {
  return id || id === 0;
}});
Ext.define('Ext.data.validator.Bound', {extend:Ext.data.validator.Validator, alias:'data.validator.bound', type:'bound', config:{min:undefined, max:undefined, emptyMessage:'Must be present', minOnlyMessage:null, maxOnlyMessage:null, bothOnlyMessage:null}, constructor:function() {
  var me = this;
  me.preventConfigure = true;
  me.callParent(arguments);
  delete me.preventConfigure;
  me.configure();
}, setConfig:function() {
  var me = this;
  me.preventConfigure = true;
  me.callParent(arguments);
  delete me.preventConfigure;
  me.configure();
}, configure:function() {
  var me = this, hasMin, hasMax, min, max;
  if (me.preventConfigure) {
    return;
  }
  min = me.getMin();
  max = me.getMax();
  hasMin = me.hasMin = min !== undefined;
  hasMax = me.hasMax = max !== undefined;
  if (hasMin && hasMax) {
    me._bothMsg = Ext.String.format(me.getBothMessage(), min, max);
  } else {
    if (hasMin) {
      me._minMsg = Ext.String.format(me.getMinOnlyMessage(), min);
    } else {
      if (hasMax) {
        me._maxMsg = Ext.String.format(me.getMaxOnlyMessage(), max);
      }
    }
  }
}, updateMin:function() {
  this.configure();
}, updateMax:function() {
  this.configure();
}, updateMinOnlyMessage:function(v) {
  this.configure();
}, updateMaxOnlyMessage:function() {
  this.configure();
}, updateBothMessage:function() {
  this.configure();
}, validate:function(value) {
  var me = this, hasMin = me.hasMin, hasMax = me.hasMax, min = me.getMin(), max = me.getMax(), msg = this.validateValue(value), len;
  if (msg !== true) {
    return msg;
  }
  value = me.getValue(value);
  if (hasMin && hasMax) {
    if (value < min || value > max) {
      msg = me._bothMsg;
    }
  } else {
    if (hasMin) {
      if (value < min) {
        msg = me._minMsg;
      }
    } else {
      if (hasMax) {
        if (value > max) {
          msg = me._maxMsg;
        }
      }
    }
  }
  return msg;
}, validateValue:function(value) {
  if (value === undefined || value === null) {
    return this.getEmptyMessage();
  }
  return true;
}, getValue:Ext.identityFn});
Ext.define('Ext.data.validator.Format', {extend:Ext.data.validator.Validator, alias:'data.validator.format', type:'format', config:{message:'Is in the wrong format', matcher:undefined}, constructor:function() {
  this.callParent(arguments);
  if (!this.getMatcher()) {
    Ext.raise('validator.Format must be configured with a matcher');
  }
}, validate:function(value) {
  var matcher = this.getMatcher(), result = matcher && matcher.test(value);
  return result ? result : this.getMessage();
}});
Ext.define('Ext.data.validator.Length', {extend:Ext.data.validator.Bound, alias:'data.validator.length', type:'length', config:{minOnlyMessage:'Length must be at least {0}', maxOnlyMessage:'Length must be no more than {0}', bothMessage:'Length must be between {0} and {1}'}, getValue:function(v) {
  return String(v).length;
}});
Ext.define('Ext.data.validator.Presence', {extend:Ext.data.validator.Validator, alias:'data.validator.presence', type:'presence', config:{message:'Must be present', allowEmpty:false}, validate:function(value) {
  var valid = !(value === undefined || value === null);
  if (valid && !this.getAllowEmpty()) {
    valid = !(value === '');
  }
  return valid ? true : this.getMessage();
}});
Ext.define('Ext.data.validator.Range', {extend:Ext.data.validator.Bound, alias:'data.validator.range', type:'range', config:{minOnlyMessage:'Must be must be at least {0}', maxOnlyMessage:'Must be no more than than {0}', bothMessage:'Must be between {0} and {1}', nanMessage:'Must be numeric'}, validateValue:function(value) {
  var msg = this.callParent([value]);
  if (msg === true && isNaN(value)) {
    msg = this.getNanMessage();
  }
  return msg;
}});
Ext.define('Ext.util.TaskRunner', {interval:10, timerId:null, constructor:function(interval) {
  var me = this;
  if (typeof interval == 'number') {
    me.interval = interval;
  } else {
    if (interval) {
      Ext.apply(me, interval);
    }
  }
  me.tasks = [];
  me.timerFn = Ext.Function.bind(me.onTick, me);
}, newTask:function(config) {
  var task = new Ext.util.TaskRunner.Task(config);
  task.manager = this;
  return task;
}, start:function(task) {
  var me = this, now = Ext.Date.now();
  if (!task.pending) {
    me.tasks.push(task);
    task.pending = true;
  }
  task.stopped = false;
  task.taskStartTime = now;
  task.taskRunTime = task.fireOnStart !== false ? 0 : task.taskStartTime;
  task.taskRunCount = 0;
  if (!me.firing) {
    if (task.fireOnStart !== false) {
      me.startTimer(0, now);
    } else {
      me.startTimer(task.interval, now);
    }
  }
  return task;
}, stop:function(task) {
  if (!task.stopped) {
    task.stopped = true;
    if (task.onStop) {
      task.onStop.call(task.scope || task, task);
    }
  }
  return task;
}, stopAll:function() {
  Ext.each(this.tasks, this.stop, this);
}, firing:false, nextExpires:1.0E99, onTick:function() {
  var me = this, tasks = me.tasks, now = Ext.Date.now(), nextExpires = 1.0E99, len = tasks.length, globalEvents = Ext.GlobalEvents, expires, newTasks, i, task, rt, remove, fireIdleEvent;
  me.timerId = null;
  me.firing = true;
  for (i = 0; i < len || i < (len = tasks.length); ++i) {
    task = tasks[i];
    if (!(remove = task.stopped)) {
      expires = task.taskRunTime + task.interval;
      if (expires <= now) {
        rt = 1;
        if (task.hasOwnProperty('fireIdleEvent')) {
          fireIdleEvent = task.fireIdleEvent;
        } else {
          fireIdleEvent = me.fireIdleEvent;
        }
        try {
          rt = task.run.apply(task.scope || task, task.args || [++task.taskRunCount]);
        } catch (taskError) {
          try {
            Ext.log({fn:task.run, prefix:'Error while running task', stack:taskError.stack, msg:taskError, level:'error'});
            if (task.onError) {
              rt = task.onError.call(task.scope || task, task, taskError);
            }
          } catch (ignore) {
          }
        }
        task.taskRunTime = now;
        if (rt === false || task.taskRunCount === task.repeat) {
          me.stop(task);
          remove = true;
        } else {
          remove = task.stopped;
          expires = now + task.interval;
        }
      }
      if (!remove && task.duration && task.duration <= now - task.taskStartTime) {
        me.stop(task);
        remove = true;
      }
    }
    if (remove) {
      task.pending = false;
      if (!newTasks) {
        newTasks = tasks.slice(0, i);
      }
    } else {
      if (newTasks) {
        newTasks.push(task);
      }
      if (nextExpires > expires) {
        nextExpires = expires;
      }
    }
  }
  if (newTasks) {
    me.tasks = newTasks;
  }
  me.firing = false;
  if (me.tasks.length) {
    me.startTimer(nextExpires - now, Ext.Date.now());
  }
  if (fireIdleEvent !== false && globalEvents.hasListeners.idle) {
    globalEvents.fireEvent('idle');
  }
}, startTimer:function(timeout, now) {
  var me = this, expires = now + timeout, timerId = me.timerId;
  if (timerId && me.nextExpires - expires > me.interval) {
    clearTimeout(timerId);
    timerId = null;
  }
  if (!timerId) {
    if (timeout < me.interval) {
      timeout = me.interval;
    }
    me.timerId = Ext.defer(me.timerFn, timeout);
    me.nextExpires = expires;
  }
}}, function() {
  var me = this, proto = me.prototype;
  proto.destroy = proto.stopAll;
  me.Task = new Ext.Class({isTask:true, stopped:true, fireOnStart:false, constructor:function(config) {
    Ext.apply(this, config);
  }, restart:function(interval) {
    if (interval !== undefined) {
      this.interval = interval;
    }
    this.manager.start(this);
  }, start:function(interval) {
    if (this.stopped) {
      this.restart(interval);
    }
  }, stop:function() {
    this.manager.stop(this);
  }});
  proto = me.Task.prototype;
  proto.destroy = proto.stop;
});
Ext.define('Ext.dom.Fly', {extend:Ext.dom.Element, alternateClassName:'Ext.dom.Element.Fly', validNodeTypes:{1:1, 9:1, 11:1}, isFly:true, constructor:function(dom) {
  this.dom = dom;
  this.el = this;
}, attach:function(dom) {
  var me = this;
  if (!dom) {
    return me.detach();
  }
  me.dom = dom;
  if (!Ext.cache[dom.id]) {
    me.getData().isSynchronized = false;
  }
  return me;
}, detach:function() {
  this.dom = null;
}, addListener:function() {
  Ext.raise('Cannot use addListener() on Ext.dom.Fly instances. ' + 'Please use Ext.get() to retrieve an Ext.dom.Element instance instead.');
} || null, removeListener:function() {
  Ext.raise('Cannot use removeListener() on Ext.dom.Fly instances. ' + 'Please use Ext.get() to retrieve an Ext.dom.Element instance instead.');
} || null}, function(Fly) {
  var flyweights = {};
  Fly.cache = flyweights;
  Ext.fly = function(dom, named) {
    var fly = null, fn = Ext.fly, nodeType, data;
    named = named || fn.caller && fn.caller.$name || '_global';
    dom = Ext.getDom(dom);
    if (dom) {
      nodeType = dom.nodeType;
      if (Fly.prototype.validNodeTypes[nodeType] || !nodeType && dom.window == dom) {
        fly = Ext.cache[dom.id];
        if (!fly || fly.dom !== dom) {
          fly = flyweights[named] || (flyweights[named] = new Fly);
          fly.dom = dom;
          data = fly.getData(true);
          if (data) {
            data.isSynchronized = false;
          }
        }
      }
    }
    return fly;
  };
});
Ext.define('Ext.dom.CompositeElementLite', {alternateClassName:['Ext.CompositeElementLite'], isComposite:true, isLite:true, statics:{importElementMethods:function() {
  var Element = Ext.dom.Element, prototype = this.prototype;
  Ext.Object.each(Element.prototype, function(name, member) {
    if (typeof member === 'function' && !prototype[name]) {
      prototype[name] = function() {
        return this.invoke(name, arguments);
      };
    }
  });
}}, constructor:function(elements, skipValidation) {
  if (skipValidation) {
    this.elements = elements || [];
  } else {
    this.elements = [];
    this.add(elements);
  }
}, getElement:function(el) {
  var fly = this._fly || (this._fly = new Ext.dom.Fly);
  return fly.attach(el);
}, transformElement:function(el) {
  return Ext.getDom(el);
}, getCount:function() {
  return this.elements.length;
}, add:function(els, root) {
  var elements = this.elements, i, ln;
  if (!els) {
    return this;
  }
  if (typeof els == 'string') {
    els = Ext.fly(root || document).query(els);
  } else {
    if (els.isComposite) {
      els = els.elements;
    } else {
      if (!Ext.isIterable(els)) {
        els = [els];
      }
    }
  }
  for (i = 0, ln = els.length; i < ln; ++i) {
    elements.push(this.transformElement(els[i]));
  }
  return this;
}, invoke:function(fn, args) {
  var me = this, elements = me.elements, ln = elements.length, prototype, element, i;
  if (i !== 0) {
    prototype = (me.isLite ? Ext.dom.Fly : Ext.dom.Element).prototype;
    for (i = 0; i < ln; i++) {
      element = elements[i];
      if (element) {
        prototype[fn].apply(me.getElement(element), args);
      }
    }
  }
  return me;
}, item:function(index) {
  var el = this.elements[index], out = null;
  if (el) {
    out = this.getElement(el);
  }
  return out;
}, slice:function(start, end) {
  return Ext.Array.slice(this.elements, start, end);
}, each:function(fn, scope) {
  var me = this, els = me.elements, len = els.length, i, e;
  for (i = 0; i < len; i++) {
    e = els[i];
    if (e) {
      e = this.getElement(e);
      if (fn.call(scope || e, e, me, i) === false) {
        break;
      }
    }
  }
  return me;
}, fill:function(els) {
  var me = this;
  me.elements = [];
  me.add(els);
  return me;
}, insert:function(index, nodes) {
  Ext.Array.insert(this.elements, index, nodes);
}, filter:function(selector) {
  var me = this, els = me.elements, len = els.length, out = [], i = 0, isFunc = typeof selector == 'function', add, el;
  for (; i < len; i++) {
    el = els[i];
    add = false;
    if (el) {
      el = me.getElement(el);
      if (isFunc) {
        add = selector.call(el, el, me, i) !== false;
      } else {
        add = el.is(selector);
      }
      if (add) {
        out.push(me.transformElement(el));
      }
    }
  }
  me.elements = out;
  return me;
}, indexOf:function(el) {
  return Ext.Array.indexOf(this.elements, this.transformElement(el));
}, replaceElement:function(el, replacement, domReplace) {
  var index = !isNaN(el) ? el : this.indexOf(el), d;
  if (index > -1) {
    replacement = Ext.getDom(replacement);
    if (domReplace) {
      d = this.elements[index];
      d.parentNode.insertBefore(replacement, d);
      Ext.removeNode(d);
    }
    Ext.Array.splice(this.elements, index, 1, replacement);
  }
  return this;
}, clear:function(removeDom) {
  var me = this, els = me.elements, i = els.length - 1;
  if (removeDom) {
    for (; i >= 0; i--) {
      Ext.removeNode(els[i]);
    }
  }
  this.elements = [];
}, addElements:function(els, root) {
  if (!els) {
    return this;
  }
  if (typeof els === 'string') {
    els = Ext.dom.Element.selectorFunction(els, root);
  }
  var yels = this.elements, eLen = els.length, e;
  for (e = 0; e < eLen; e++) {
    yels.push(Ext.get(els[e]));
  }
  return this;
}, first:function() {
  return this.item(0);
}, last:function() {
  return this.item(this.getCount() - 1);
}, contains:function(el) {
  return this.indexOf(el) != -1;
}, removeElement:function(keys, removeDom) {
  keys = [].concat(keys);
  var me = this, elements = me.elements, kLen = keys.length, val, el, k;
  for (k = 0; k < kLen; k++) {
    val = keys[k];
    if (el = elements[val] || elements[val = me.indexOf(val)]) {
      if (removeDom) {
        if (el.dom) {
          el.destroy();
        } else {
          Ext.removeNode(el);
        }
      }
      Ext.Array.erase(elements, val, 1);
    }
  }
  return me;
}, destroy:function() {
  return this.invoke('destroy', arguments);
  this.callParent();
}}, function(CompositeElementLite) {
  var prototype = CompositeElementLite.prototype;
  CompositeElementLite.importElementMethods();
  prototype.on = prototype.addListener;
});
Ext.define('Ext.dom.CompositeElement', {alternateClassName:'Ext.CompositeElement', extend:Ext.dom.CompositeElementLite, isLite:false, getElement:function(el) {
  return el;
}, transformElement:function(el) {
  return Ext.get(el);
}});
Ext.define('Ext.dom.GarbageCollector', {singleton:true, interval:30000, constructor:function() {
  var me = this;
  me.collect = Ext.Function.bind(me.collect, me);
  me.lastTime = Ext.now();
  me.resume();
}, collect:function() {
  var me = this, cache = Ext.cache, eid, dom, el, t, isGarbage, tagName;
  var collectedIds = [];
  for (eid in cache) {
    if (!cache.hasOwnProperty(eid)) {
      continue;
    }
    el = cache[eid];
    if (el.skipGarbageCollection) {
      continue;
    }
    dom = el.dom;
    if (!dom) {
      Ext.raise('Missing DOM node in element garbage collection: ' + eid);
    }
    try {
      isGarbage = Ext.isGarbage(dom);
    } catch (e$25) {
      delete cache[eid];
      collectedIds.push('#' + el.id);
      continue;
    }
    if (isGarbage) {
      if (el && el.dom) {
        tagName = el.dom.tagName;
        el.collect();
        collectedIds.push((tagName ? tagName : '') + '#' + el.id);
      }
    }
  }
  if (Ext.isIE9m) {
    t = {};
    for (eid in cache) {
      if (cache.hasOwnProperty(eid)) {
        t[eid] = cache[eid];
      }
    }
    Ext.cache = Ext.dom.Element.cache = t;
  }
  me.lastTime = Ext.now();
  return collectedIds;
}, pause:function() {
  clearTimeout(this.timerId);
}, resume:function() {
  var me = this, lastTime = me.lastTime;
  if (Ext.enableGarbageCollector && Ext.now() - lastTime > me.interval) {
    me.collect();
  }
  me.timerId = Ext.interval(me.collect, me.interval);
}});
Ext.define('Ext.event.gesture.Recognizer', {mixins:[Ext.mixin.Identifiable], priority:0, handledEvents:[], config:{onRecognized:Ext.emptyFn, callbackScope:null}, constructor:function(config) {
  this.initConfig(config);
  Ext.event.publisher.Gesture.instance.registerRecognizer(this);
}, onStart:Ext.emptyFn, onEnd:Ext.emptyFn, onTouchStart:Ext.emptyFn, onTouchMove:Ext.emptyFn, onTouchEnd:Ext.emptyFn, onTouchCancel:Ext.emptyFn, fail:function() {
  return false;
}, fire:function() {
  this.getOnRecognized().apply(this.getCallbackScope(), arguments);
}, reset:Ext.emptyFn, debugHooks:{$enabled:false, fail:function(msg) {
  Ext.log.info(this.$className + ' Gesture Failed: ' + msg);
  return false;
}}});
Ext.define('Ext.event.gesture.SingleTouch', {extend:Ext.event.gesture.Recognizer, inheritableStatics:{NOT_SINGLE_TOUCH:'Not Single Touch', TOUCH_MOVED:'Touch Moved', EVENT_CANCELED:'Event Canceled'}, onTouchStart:function(e) {
  if (e.touches.length > 1) {
    return this.fail(this.self.NOT_SINGLE_TOUCH);
  }
}, onTouchCancel:function() {
  return false;
}});
Ext.define('Ext.event.gesture.DoubleTap', {extend:Ext.event.gesture.SingleTouch, priority:300, inheritableStatics:{DIFFERENT_TARGET:'Different Target'}, config:{moveDistance:8, tapDistance:24, maxDuration:300}, handledEvents:['singletap', 'doubletap'], singleTapTimer:null, startTime:0, lastTapTime:0, onTouchStart:function(e) {
  var me = this, lastStartPoint;
  if (me.callParent(arguments) === false) {
    return false;
  }
  lastStartPoint = me.lastStartPoint = e.changedTouches[0].point;
  me.startPoint = me.startPoint || lastStartPoint;
  me.startTime = e.time;
  clearTimeout(me.singleTapTimer);
}, onTouchMove:function(e) {
  var me = this, point = e.changedTouches[0].point;
  if (Math.abs(point.getDistanceTo(me.lastStartPoint)) >= me.getMoveDistance()) {
    me.startPoint = null;
    return me.fail(me.self.TOUCH_MOVED);
  }
}, onTouchEnd:function(e) {
  var me = this, maxDuration = me.getMaxDuration(), time = e.time, target = e.target, lastTapTime = me.lastTapTime, lastTarget = me.lastTarget, point = e.changedTouches[0].point, duration;
  me.lastTapTime = time;
  me.lastTarget = target;
  if (lastTapTime) {
    duration = time - lastTapTime;
    if (duration <= maxDuration && Math.abs(point.getDistanceTo(me.startPoint)) <= me.getTapDistance()) {
      if (target !== lastTarget) {
        return me.fail(me.self.DIFFERENT_TARGET);
      }
      me.lastTarget = null;
      me.lastTapTime = 0;
      me.fire('doubletap', e, {touch:e.changedTouches[0], duration:duration});
      me.startPoint = null;
      return;
    }
  }
  if (time - me.startTime > maxDuration) {
    me.fireSingleTap(e);
  } else {
    me.setSingleTapTimer(e);
  }
}, setSingleTapTimer:function(e) {
  var me = this;
  me.singleTapTimer = Ext.defer(function() {
    me.fireSingleTap(e);
  }, me.getMaxDuration());
}, fireSingleTap:function(e, touch) {
  this.fire('singletap', e, {touch:touch});
  this.startPoint = null;
}, reset:function() {
  var me = this;
  me.startTime = me.lastTapTime = 0;
  me.lastStartPoint = me.startPoint = me.singleTapTimer = null;
}}, function(DoubleTap) {
  var gestures = Ext.manifest.gestures;
  DoubleTap.instance = new DoubleTap(gestures && gestures.doubleTap);
});
Ext.define('Ext.event.gesture.Drag', {extend:Ext.event.gesture.SingleTouch, priority:100, isStarted:false, startPoint:null, previousPoint:null, lastPoint:null, handledEvents:['dragstart', 'drag', 'dragend', 'dragcancel'], config:{minDistance:8}, constructor:function() {
  this.callParent(arguments);
  this.initInfo();
}, initInfo:function() {
  this.info = {touch:null, previous:{x:0, y:0}, x:0, y:0, delta:{x:0, y:0}, absDelta:{x:0, y:0}, flick:{velocity:{x:0, y:0}}, direction:{x:0, y:0}, time:0, previousTime:{x:0, y:0}};
}, onTouchStart:function(e) {
  if (this.callParent(arguments) === false) {
    if (this.isStarted && this.lastMoveEvent !== null) {
      this.lastMoveEvent.isStopped = false;
      this.onTouchEnd(this.lastMoveEvent);
    }
    return false;
  }
  this.startTime = e.time;
  this.startPoint = e.changedTouches[0].point;
}, tryDragStart:function(e) {
  var startPoint = this.startPoint, touch = e.changedTouches[0], point = touch.point, minDistance = this.getMinDistance(), info = this.info;
  if (Math.abs(point.getDistanceTo(startPoint)) >= minDistance) {
    this.isStarted = true;
    this.previousPoint = this.lastPoint = point;
    this.resetInfo('x', e, touch);
    this.resetInfo('y', e, touch);
    info.time = e.time;
    this.fire('dragstart', e, info);
  }
}, onTouchMove:function(e) {
  if (!this.isStarted) {
    this.tryDragStart(e);
  }
  if (!this.isStarted) {
    return;
  }
  var touch = e.changedTouches[0], point = touch.point;
  if (this.lastPoint) {
    this.previousPoint = this.lastPoint;
  }
  this.lastPoint = point;
  this.lastMoveEvent = e;
  this.updateInfo('x', e, touch);
  this.updateInfo('y', e, touch);
  this.info.time = e.time;
  this.fire('drag', e, this.info);
}, onAxisDragEnd:function(axis, info) {
  var duration = info.time - info.previousTime[axis];
  if (duration > 0) {
    info.flick.velocity[axis] = (info[axis] - info.previous[axis]) / duration;
  }
}, resetInfo:function(axis, e, touch) {
  var value = this.lastPoint[axis], startValue = this.startPoint[axis], delta = value - startValue, capAxis = axis.toUpperCase(), info = this.info;
  info.touch = touch;
  info.delta[axis] = delta;
  info.absDelta[axis] = Math.abs(delta);
  info.previousTime[axis] = this.startTime;
  info.previous[axis] = startValue;
  info[axis] = value;
  info.direction[axis] = 0;
  info['start' + capAxis] = this.startPoint[axis];
  info['previous' + capAxis] = info.previous[axis];
  info['page' + capAxis] = info[axis];
  info['delta' + capAxis] = info.delta[axis];
  info['absDelta' + capAxis] = info.absDelta[axis];
  info['previousDelta' + capAxis] = 0;
  info.startTime = this.startTime;
}, updateInfo:function(axis, e, touch) {
  var me = this, value = me.lastPoint[axis], previousValue = me.previousPoint[axis], startValue = me.startPoint[axis], delta = value - startValue, info = me.info, direction = info.direction, capAxis = axis.toUpperCase(), previousFlick = info.previous[axis];
  info.touch = touch;
  info.delta[axis] = delta;
  info.absDelta[axis] = Math.abs(delta);
  if (value !== previousFlick && value !== info[axis]) {
    info.previous[axis] = info[axis];
    info.previousTime[axis] = info.time;
  }
  info[axis] = value;
  if (value > previousValue) {
    direction[axis] = 1;
  } else {
    if (value < previousValue) {
      direction[axis] = -1;
    }
  }
  info['start' + capAxis] = startValue;
  info['previous' + capAxis] = info.previous[axis];
  info['page' + capAxis] = info[axis];
  info['delta' + capAxis] = info.delta[axis];
  info['absDelta' + capAxis] = info.absDelta[axis];
  info['previousDelta' + capAxis] = info.previous[axis] - startValue;
  info.startTime = me.startTime;
}, onTouchEnd:function(e) {
  this.doEnd(e);
}, onTouchCancel:function(e) {
  this.doEnd(e, true);
  return false;
}, doEnd:function(e, isCancel) {
  if (!this.isStarted) {
    this.tryDragStart(e);
  }
  if (this.isStarted) {
    var touch = e.changedTouches[0], point = touch.point, info = this.info;
    this.isStarted = false;
    this.lastPoint = point;
    this.updateInfo('x', e, touch);
    this.updateInfo('y', e, touch);
    info.time = e.time;
    this.onAxisDragEnd('x', info);
    this.onAxisDragEnd('y', info);
    this.fire(isCancel ? 'dragcancel' : 'dragend', e, info);
    this.startPoint = null;
    this.previousPoint = null;
    this.lastPoint = null;
    this.lastMoveEvent = null;
  }
}, reset:function() {
  var me = this;
  me.isStarted = me.lastPoint = me.startPoint = me.previousPoint = me.lastPoint = me.lastMoveEvent = null;
  me.initInfo();
}}, function(Drag) {
  var gestures = Ext.manifest.gestures;
  Drag.instance = new Drag(gestures && gestures.drag);
});
Ext.define('Ext.event.gesture.Swipe', {extend:Ext.event.gesture.SingleTouch, priority:500, handledEvents:['swipestart', 'swipe', 'swipecancel'], inheritableStatics:{MAX_OFFSET_EXCEEDED:'Max Offset Exceeded', MAX_DURATION_EXCEEDED:'Max Duration Exceeded', DISTANCE_NOT_ENOUGH:'Distance Not Enough'}, config:{minDistance:80, maxOffset:35, maxDuration:1000}, onTouchStart:function(e) {
  if (this.callParent(arguments) === false) {
    return false;
  }
  var touch = e.changedTouches[0];
  this.startTime = e.time;
  this.isHorizontal = true;
  this.isVertical = true;
  this.startX = touch.pageX;
  this.startY = touch.pageY;
}, onTouchMove:function(e) {
  var touch = e.changedTouches[0], x = touch.pageX, y = touch.pageY, deltaX = x - this.startX, deltaY = y - this.startY, absDeltaX = Math.abs(x - this.startX), absDeltaY = Math.abs(y - this.startY), duration = e.time - this.startTime, minDistance = this.getMinDistance(), time = e.time, direction, distance;
  if (time - this.startTime > this.getMaxDuration()) {
    return this.fail(this.self.MAX_DURATION_EXCEEDED);
  }
  if (this.isHorizontal && absDeltaY > this.getMaxOffset()) {
    this.isHorizontal = false;
  }
  if (this.isVertical && absDeltaX > this.getMaxOffset()) {
    this.isVertical = false;
  }
  if (!this.isVertical || !this.isHorizontal) {
    if (this.isHorizontal && absDeltaX < minDistance) {
      direction = deltaX < 0 ? 'left' : 'right';
      distance = absDeltaX;
    } else {
      if (this.isVertical && absDeltaY < minDistance) {
        direction = deltaY < 0 ? 'up' : 'down';
        distance = absDeltaY;
      }
    }
  }
  if (direction && !this.started) {
    this.started = true;
    this.fire('swipestart', e, {touch:touch, direction:direction, distance:distance, duration:duration});
  }
  if (!this.isHorizontal && !this.isVertical) {
    return this.fail(this.self.MAX_OFFSET_EXCEEDED);
  }
}, onTouchEnd:function(e) {
  if (this.onTouchMove(e) === false) {
    return false;
  }
  var touch = e.changedTouches[0], x = touch.pageX, y = touch.pageY, deltaX = x - this.startX, deltaY = y - this.startY, absDeltaX = Math.abs(deltaX), absDeltaY = Math.abs(deltaY), minDistance = this.getMinDistance(), duration = e.time - this.startTime, direction, distance;
  if (this.isVertical && absDeltaY < minDistance) {
    this.isVertical = false;
  }
  if (this.isHorizontal && absDeltaX < minDistance) {
    this.isHorizontal = false;
  }
  if (this.isHorizontal) {
    direction = deltaX < 0 ? 'left' : 'right';
    distance = absDeltaX;
  } else {
    if (this.isVertical) {
      direction = deltaY < 0 ? 'up' : 'down';
      distance = absDeltaY;
    } else {
      return this.fail(this.self.DISTANCE_NOT_ENOUGH);
    }
  }
  this.started = false;
  this.fire('swipe', e, {touch:touch, direction:direction, distance:distance, duration:duration});
}, onTouchCancel:function(e) {
  this.fire('swipecancel', e);
  return false;
}, reset:function() {
  var me = this;
  me.startTime = me.isHorizontal = me.isVertical = me.startX = me.startY = null;
}}, function(Swipe) {
  var gestures = Ext.manifest.gestures;
  Swipe.instance = new Swipe(gestures && gestures.swipe);
});
Ext.define('Ext.event.gesture.EdgeSwipe', {extend:Ext.event.gesture.Swipe, priority:800, handledEvents:['edgeswipe', 'edgeswipestart', 'edgeswipeend', 'edgeswipecancel'], inheritableStatics:{NOT_NEAR_EDGE:'Not Near Edge'}, config:{minDistance:60}, onTouchStart:function(e) {
  if (this.callParent(arguments) === false) {
    return false;
  }
  var touch = e.changedTouches[0];
  this.started = false;
  this.direction = null;
  this.isHorizontal = true;
  this.isVertical = true;
  this.startX = touch.pageX;
  this.startY = touch.pageY;
}, onTouchMove:function(e) {
  var touch = e.changedTouches[0], x = touch.pageX, y = touch.pageY, deltaX = x - this.startX, deltaY = y - this.startY, absDeltaY = Math.abs(y - this.startY), absDeltaX = Math.abs(x - this.startX), minDistance = this.getMinDistance(), maxOffset = this.getMaxOffset(), duration = e.time - this.startTime, elementWidth = Ext.Viewport && Ext.Element.getViewportWidth(), elementHeight = Ext.Viewport && Ext.Element.getViewportHeight(), direction, distance;
  if (this.isVertical && absDeltaX > maxOffset) {
    this.isVertical = false;
  }
  if (this.isHorizontal && absDeltaY > maxOffset) {
    this.isHorizontal = false;
  }
  if (this.isVertical && this.isHorizontal) {
    if (absDeltaY > absDeltaX) {
      this.isHorizontal = false;
    } else {
      this.isVertical = false;
    }
  }
  if (this.isHorizontal) {
    direction = deltaX < 0 ? 'left' : 'right';
    distance = deltaX;
  } else {
    if (this.isVertical) {
      direction = deltaY < 0 ? 'up' : 'down';
      distance = deltaY;
    }
  }
  direction = this.direction || (this.direction = direction);
  if (direction === 'up') {
    distance = deltaY * -1;
  } else {
    if (direction === 'left') {
      distance = deltaX * -1;
    }
  }
  this.distance = distance;
  if (!distance) {
    return this.fail(this.self.DISTANCE_NOT_ENOUGH);
  }
  if (!this.started) {
    if (direction === 'right' && this.startX > minDistance) {
      return this.fail(this.self.NOT_NEAR_EDGE);
    } else {
      if (direction === 'down' && this.startY > minDistance) {
        return this.fail(this.self.NOT_NEAR_EDGE);
      } else {
        if (direction === 'left' && elementWidth - this.startX > minDistance) {
          return this.fail(this.self.NOT_NEAR_EDGE);
        } else {
          if (direction === 'up' && elementHeight - this.startY > minDistance) {
            return this.fail(this.self.NOT_NEAR_EDGE);
          }
        }
      }
    }
    this.started = true;
    this.startTime = e.time;
    this.fire('edgeswipestart', e, {touch:touch, direction:direction, distance:distance, duration:duration});
  } else {
    this.fire('edgeswipe', e, {touch:touch, direction:direction, distance:distance, duration:duration});
  }
}, onTouchEnd:function(e) {
  var duration;
  if (this.onTouchMove(e) !== false) {
    duration = e.time - this.startTime;
    this.fire('edgeswipeend', e, {touch:e.changedTouches[0], direction:this.direction, distance:this.distance, duration:duration});
  }
}, onTouchCancel:function(e) {
  this.fire('edgeswipecancel', e, {touch:e.changedTouches[0]});
  return false;
}, reset:function() {
  var me = this;
  me.started = me.direction = me.isHorizontal = me.isVertical = me.startX = me.startY = me.startTime = me.distance = null;
}}, function(EdgeSwipe) {
  var gestures = Ext.manifest.gestures;
  EdgeSwipe.instance = new EdgeSwipe(gestures && gestures.edgeSwipe);
});
Ext.define('Ext.event.gesture.LongPress', {extend:Ext.event.gesture.SingleTouch, priority:400, inheritableStatics:{DURATION_NOT_ENOUGH:'Duration Not Enough'}, config:{moveDistance:8, minDuration:1000}, handledEvents:['longpress', 'taphold'], fireLongPress:function(e) {
  this.fire('longpress', e, {touch:e.changedTouches[0], duration:this.getMinDuration()});
  this.isLongPress = true;
}, onTouchStart:function(e) {
  if (this.callParent(arguments) === false) {
    return false;
  }
  this.startPoint = e.changedTouches[0].point;
  this.isLongPress = false;
  this.setLongPressTimer(e);
}, setLongPressTimer:function(e) {
  var me = this;
  me.timer = Ext.defer(function() {
    me.fireLongPress(e);
  }, me.getMinDuration());
}, onTouchMove:function(e) {
  var point = e.changedTouches[0].point;
  if (Math.abs(point.getDistanceTo(this.startPoint)) >= this.getMoveDistance()) {
    return this.fail(this.self.TOUCH_MOVED);
  }
}, onTouchEnd:function() {
  if (!this.isLongPress) {
    return this.fail(this.self.DURATION_NOT_ENOUGH);
  }
}, fail:function() {
  clearTimeout(this.timer);
  return this.callParent(arguments);
}, reset:function() {
  this.isLongPress = this.startPoint = null;
}, fire:function(eventName) {
  if (eventName === 'longpress') {
    var args = Array.prototype.slice.call(arguments);
    args[0] = 'taphold';
    this.fire.apply(this, args);
  }
  return this.callParent(arguments);
}}, function(LongPress) {
  var gestures = Ext.manifest.gestures;
  LongPress.instance = new LongPress(gestures && gestures.longPress);
});
Ext.define('Ext.event.gesture.MultiTouch', {extend:Ext.event.gesture.Recognizer, requiredTouchesCount:2, isTracking:false, isStarted:false, onTouchStart:function(e) {
  var requiredTouchesCount = this.requiredTouchesCount, touches = e.touches, touchesCount = touches.length;
  if (touchesCount === requiredTouchesCount) {
    this.start(e);
  } else {
    if (touchesCount > requiredTouchesCount) {
      this.end(e);
    }
  }
}, onTouchEnd:function(e) {
  this.end(e);
}, onTouchCancel:function(e) {
  this.end(e, true);
  return false;
}, start:function() {
  if (!this.isTracking) {
    this.isTracking = true;
    this.isStarted = false;
  }
}, end:function(e, isCancel) {
  if (this.isTracking) {
    this.isTracking = false;
    if (this.isStarted) {
      this.isStarted = false;
      this[isCancel ? 'fireCancel' : 'fireEnd'](e);
    }
  }
}, reset:function() {
  this.isTracking = this.isStarted = false;
}});
Ext.define('Ext.event.gesture.Pinch', {extend:Ext.event.gesture.MultiTouch, priority:600, handledEvents:['pinchstart', 'pinch', 'pinchend', 'pinchcancel'], startDistance:0, lastTouches:null, onTouchMove:function(e) {
  if (!this.isTracking) {
    return;
  }
  var touches = e.touches, firstPoint, secondPoint, distance;
  firstPoint = touches[0].point;
  secondPoint = touches[1].point;
  distance = firstPoint.getDistanceTo(secondPoint);
  if (distance === 0) {
    return;
  }
  if (!this.isStarted) {
    this.isStarted = true;
    this.startDistance = distance;
    this.fire('pinchstart', e, {touches:touches, distance:distance, scale:1});
  } else {
    this.fire('pinch', e, {touches:touches, distance:distance, scale:distance / this.startDistance});
  }
}, fireEnd:function(e) {
  this.fire('pinchend', e);
}, fireCancel:function(e) {
  this.fire('pinchcancel', e);
}, fail:function() {
  return this.callParent(arguments);
}, reset:function() {
  this.lastTouches = null;
  this.startDistance = 0;
  this.callParent();
}}, function(Pinch) {
  var gestures = Ext.manifest.gestures;
  Pinch.instance = new Pinch(gestures && gestures.pinch);
});
Ext.define('Ext.event.gesture.Rotate', {extend:Ext.event.gesture.MultiTouch, priority:700, handledEvents:['rotatestart', 'rotate', 'rotateend', 'rotatecancel'], startAngle:0, lastTouches:null, lastAngle:null, onTouchMove:function(e) {
  if (!this.isTracking) {
    return;
  }
  var touches = e.touches, lastAngle = this.lastAngle, firstPoint, secondPoint, angle, nextAngle, previousAngle, diff;
  firstPoint = touches[0].point;
  secondPoint = touches[1].point;
  angle = firstPoint.getAngleTo(secondPoint);
  if (lastAngle !== null) {
    diff = Math.abs(lastAngle - angle);
    nextAngle = angle + 360;
    previousAngle = angle - 360;
    if (Math.abs(nextAngle - lastAngle) < diff) {
      angle = nextAngle;
    } else {
      if (Math.abs(previousAngle - lastAngle) < diff) {
        angle = previousAngle;
      }
    }
  }
  this.lastAngle = angle;
  if (!this.isStarted) {
    this.isStarted = true;
    this.startAngle = angle;
    this.fire('rotatestart', e, {touches:touches, angle:angle, rotation:0});
  } else {
    this.fire('rotate', e, {touches:touches, angle:angle, rotation:angle - this.startAngle});
  }
  this.lastTouches = Ext.Array.clone(touches);
}, fireEnd:function(e) {
  this.lastAngle = null;
  this.fire('rotateend', e);
}, fireCancel:function(e) {
  this.lastAngle = null;
  this.fire('rotatecancel', e);
}, reset:function() {
  var me = this;
  me.lastTouches = me.lastAngle = me.startAngle = null;
  this.callParent();
}}, function(Rotate) {
  var gestures = Ext.manifest.gestures;
  Rotate.instance = new Rotate(gestures && gestures.rotate);
});
Ext.define('Ext.event.gesture.Tap', {extend:Ext.event.gesture.SingleTouch, priority:200, handledEvents:['tap', 'tapcancel'], config:{moveDistance:8}, onTouchStart:function(e) {
  if (this.callParent([e]) === false) {
    return false;
  }
  this.startPoint = e.changedTouches[0].point;
}, onTouchMove:function(e) {
  var touch = e.changedTouches[0], point = touch.point;
  if (Math.abs(point.getDistanceTo(this.startPoint)) >= this.getMoveDistance()) {
    this.fire('tapcancel', e, {touch:touch});
    return this.fail(this.self.TOUCH_MOVED);
  }
}, onTouchEnd:function(e) {
  this.fire('tap', e, {touch:e.changedTouches[0]});
}, onTouchCancel:function(e) {
  this.fire('tapcancel', e, {touch:e.changedTouches[0]});
  return false;
}, reset:function() {
  this.startPoint = null;
}}, function(Tap) {
  var gestures = Ext.manifest.gestures;
  Tap.instance = new Tap(gestures && gestures.tap);
});
Ext.define('Ext.event.publisher.Focus', {extend:Ext.event.publisher.Dom, type:'focus', handledEvents:['focusenter', 'focusleave', 'focusmove'], handledDomEvents:['focusin', 'focusout'], doDelegatedEvent:function(e, invokeAfter) {
  var me = this, relatedTarget;
  e = me.callParent([e, false]);
  if (e) {
    if (e.type === 'focusout') {
      if (e.relatedTarget == null) {
        me.processFocusIn(e, e.target, document.body, invokeAfter);
      }
    } else {
      relatedTarget = e.relatedTarget;
      me.processFocusIn(e, relatedTarget == null || !relatedTarget.tagName ? document.body : relatedTarget, e.target, invokeAfter);
    }
  }
}, processFocusIn:function(e, fromElement, toElement, invokeAfter) {
  var me = this, commonAncestor, node, targets = [], event, focusEnterEvent, fromFly, toFly;
  fromFly = Ext.fly(fromElement);
  toFly = Ext.fly(toElement);
  if (fromFly && fromFly.isFocusSuspended() || toFly && toFly.isFocusSuspended()) {
    return;
  }
  for (node = fromElement, commonAncestor = Ext.dom.Element.getCommonAncestor(toElement, fromElement, true); node && node !== commonAncestor; node = node.parentNode) {
    targets.push(node);
  }
  if (targets.length) {
    event = me.createSyntheticEvent('focusleave', e, fromElement, toElement);
    me.publish('focusleave', targets, event);
    if (event.isStopped) {
      return;
    }
  }
  targets.length = 0;
  for (node = toElement; node !== commonAncestor; node = node.parentNode) {
    targets.push(node);
  }
  focusEnterEvent = me.createSyntheticEvent('focusenter', e, toElement, fromElement);
  if (targets.length) {
    me.publish('focusenter', targets, focusEnterEvent);
    if (focusEnterEvent.isStopped) {
      return;
    }
  }
  targets = me.getPropagatingTargets(commonAncestor);
  if (targets.length) {
    event = me.createSyntheticEvent('focusmove', e, toElement, fromElement);
    me.publish('focusmove', targets, event);
    if (event.isStopped) {
      return;
    }
  }
  if (invokeAfter) {
    me.afterEvent(e);
  }
  Ext.GlobalEvents.fireEvent('focus', {event:focusEnterEvent, toElement:toElement, fromElement:fromElement});
}, createSyntheticEvent:function(eventName, browserEvent, target, relatedTarget) {
  var event = new Ext.event.Event(browserEvent);
  event.type = eventName;
  event.relatedTarget = relatedTarget;
  event.target = target;
  return event;
}}, function(Focus) {
  var focusTimeout;
  Focus.instance = new Focus;
  if (!Ext.supports.FocusinFocusoutEvents) {
    this.override({handledDomEvents:['focus', 'blur'], doDelegatedEvent:function(e, invokeAfter) {
      var me = this;
      e = me.callSuper([e, false]);
      if (e) {
        clearTimeout(focusTimeout);
        focusTimeout = 0;
        if (e.type === 'blur') {
          var blurredEl = e.target === window ? document.body : e.target;
          focusTimeout = setTimeout(function() {
            focusTimeout = 0;
            me.processFocusIn(e, blurredEl, document.body, invokeAfter);
            Focus.previousActiveElement = null;
          }, 0);
          if (e.target === window || e.target === document) {
            Focus.previousActiveElement = null;
          } else {
            Focus.previousActiveElement = e.target;
          }
        } else {
          me.processFocusIn(e, Focus.previousActiveElement || document.body, e.target === window ? document.body : e.target, invokeAfter);
        }
      }
    }});
  }
});
Ext.define('Ext.fx.runner.Css', {extend:Ext.Evented, prefixedProperties:{'transform':true, 'transform-origin':true, 'perspective':true, 'transform-style':true, 'transition':true, 'transition-property':true, 'transition-duration':true, 'transition-timing-function':true, 'transition-delay':true, 'animation':true, 'animation-name':true, 'animation-duration':true, 'animation-iteration-count':true, 'animation-direction':true, 'animation-timing-function':true, 'animation-delay':true}, lengthProperties:{'top':true, 
'right':true, 'bottom':true, 'left':true, 'width':true, 'height':true, 'max-height':true, 'max-width':true, 'min-height':true, 'min-width':true, 'margin-bottom':true, 'margin-left':true, 'margin-right':true, 'margin-top':true, 'padding-bottom':true, 'padding-left':true, 'padding-right':true, 'padding-top':true, 'border-bottom-width':true, 'border-left-width':true, 'border-right-width':true, 'border-spacing':true, 'border-top-width':true, 'border-width':true, 'outline-width':true, 'letter-spacing':true, 
'line-height':true, 'text-indent':true, 'word-spacing':true, 'font-size':true, 'translate':true, 'translateX':true, 'translateY':true, 'translateZ':true, 'translate3d':true}, durationProperties:{'transition-duration':true, 'transition-delay':true, 'animation-duration':true, 'animation-delay':true}, angleProperties:{rotate:true, rotateX:true, rotateY:true, rotateZ:true, skew:true, skewX:true, skewY:true}, lengthUnitRegex:/([a-z%]*)$/, DEFAULT_UNIT_LENGTH:'px', DEFAULT_UNIT_ANGLE:'deg', DEFAULT_UNIT_DURATION:'ms', 
formattedNameCache:{}, transformMethods3d:['translateX', 'translateY', 'translateZ', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'skewX', 'skewY', 'scaleX', 'scaleY', 'scaleZ'], transformMethodsNo3d:['translateX', 'translateY', 'rotate', 'skewX', 'skewY', 'scaleX', 'scaleY'], constructor:function() {
  var me = this;
  me.transformMethods = Ext.feature.has.Css3dTransforms ? me.transformMethods3d : me.transformMethodsNo3d;
  me.vendorPrefix = Ext.browser.getStyleDashPrefix();
  me.ruleStylesCache = {};
  me.callParent();
}, getStyleSheet:function() {
  var styleSheet = this.styleSheet, styleElement, styleSheets;
  if (!styleSheet) {
    styleElement = document.createElement('style');
    styleElement.type = 'text/css';
    (document.head || document.getElementsByTagName('head')[0]).appendChild(styleElement);
    styleSheets = document.styleSheets;
    this.styleSheet = styleSheet = styleSheets[styleSheets.length - 1];
  }
  return styleSheet;
}, applyRules:function(selectors) {
  var styleSheet = this.getStyleSheet(), ruleStylesCache = this.ruleStylesCache, rules = styleSheet.cssRules, selector, properties, ruleStyle, ruleStyleCache, rulesLength, name, value;
  for (selector in selectors) {
    properties = selectors[selector];
    ruleStyle = ruleStylesCache[selector];
    if (ruleStyle === undefined) {
      rulesLength = rules.length;
      styleSheet.insertRule(selector + '{}', rulesLength);
      ruleStyle = ruleStylesCache[selector] = rules.item(rulesLength).style;
    }
    ruleStyleCache = ruleStyle.$cache;
    if (!ruleStyleCache) {
      ruleStyleCache = ruleStyle.$cache = {};
    }
    for (name in properties) {
      value = this.formatValue(properties[name], name);
      name = this.formatName(name);
      if (ruleStyleCache[name] !== value) {
        ruleStyleCache[name] = value;
        if (value === null) {
          ruleStyle.removeProperty(name);
        } else {
          ruleStyle.setProperty(name, value, 'important');
        }
      }
    }
  }
  return this;
}, applyStyles:function(styles) {
  var id, element, elementStyle, properties, name, value;
  for (id in styles) {
    if (styles.hasOwnProperty(id)) {
      element = document.getElementById(id);
      if (!element) {
        continue;
      }
      elementStyle = element.style;
      properties = styles[id];
      for (name in properties) {
        if (properties.hasOwnProperty(name)) {
          value = this.formatValue(properties[name], name);
          name = this.formatName(name);
          if (value === null) {
            elementStyle.removeProperty(name);
          } else {
            elementStyle.setProperty(name, value, 'important');
          }
        }
      }
    }
  }
  return this;
}, formatName:function(name) {
  var cache = this.formattedNameCache, formattedName = cache[name];
  if (!formattedName) {
    if ((Ext.os.is.Tizen || !Ext.feature.has.CssTransformNoPrefix) && this.prefixedProperties[name]) {
      formattedName = this.vendorPrefix + name;
    } else {
      formattedName = name;
    }
    cache[name] = formattedName;
  }
  return formattedName;
}, formatValue:function(value, name) {
  var type = typeof value, lengthUnit = this.DEFAULT_UNIT_LENGTH, transformMethods, method, i, ln, transformValues, values, unit;
  if (value === null) {
    return '';
  }
  if (type == 'string') {
    if (this.lengthProperties[name]) {
      unit = value.match(this.lengthUnitRegex)[1];
      if (unit.length > 0) {
        if (unit !== lengthUnit) {
          Ext.Logger.error("Length unit: '" + unit + "' in value: '" + value + "' of property: '" + name + "' is not " + "valid for animation. Only 'px' is allowed");
        }
      } else {
        return value + lengthUnit;
      }
    }
    return value;
  } else {
    if (type == 'number') {
      if (value == 0) {
        return '0';
      }
      if (this.lengthProperties[name]) {
        return value + lengthUnit;
      }
      if (this.angleProperties[name]) {
        return value + this.DEFAULT_UNIT_ANGLE;
      }
      if (this.durationProperties[name]) {
        return value + this.DEFAULT_UNIT_DURATION;
      }
    } else {
      if (name === 'transform') {
        transformMethods = this.transformMethods;
        transformValues = [];
        for (i = 0, ln = transformMethods.length; i < ln; i++) {
          method = transformMethods[i];
          transformValues.push(method + '(' + this.formatValue(value[method], method) + ')');
        }
        return transformValues.join(' ');
      } else {
        if (Ext.isArray(value)) {
          values = [];
          for (i = 0, ln = value.length; i < ln; i++) {
            values.push(this.formatValue(value[i], name));
          }
          return values.length > 0 ? values.join(', ') : 'none';
        }
      }
    }
  }
  return value;
}});
Ext.define('Ext.fx.runner.CssTransition', {extend:Ext.fx.runner.Css, alternateClassName:'Ext.Animator', singleton:true, listenersAttached:false, constructor:function() {
  this.runningAnimationsData = {};
  return this.callParent(arguments);
}, attachListeners:function() {
  this.listenersAttached = true;
  Ext.getWin().on('transitionend', 'onTransitionEnd', this);
}, onTransitionEnd:function(e) {
  var target = e.target, id = target.id;
  if (id && this.runningAnimationsData.hasOwnProperty(id)) {
    this.refreshRunningAnimationsData(Ext.get(target), [e.browserEvent.propertyName]);
  }
}, onAnimationEnd:function(element, data, animation, isInterrupted, isReplaced) {
  var id = element.getId(), runningData = this.runningAnimationsData[id], endRules = {}, endData = {}, runningNameMap, toPropertyNames, i, ln, name;
  animation.un('stop', 'onAnimationStop', this);
  if (runningData) {
    runningNameMap = runningData.nameMap;
  }
  endRules[id] = endData;
  if (data.onBeforeEnd) {
    data.onBeforeEnd.call(data.scope || this, element, isInterrupted);
  }
  animation.fireEvent('animationbeforeend', animation, element, isInterrupted);
  this.fireEvent('animationbeforeend', this, animation, element, isInterrupted);
  if (isReplaced || !isInterrupted && !data.preserveEndState) {
    toPropertyNames = data.toPropertyNames;
    for (i = 0, ln = toPropertyNames.length; i < ln; i++) {
      name = toPropertyNames[i];
      if (runningNameMap && !runningNameMap.hasOwnProperty(name)) {
        endData[name] = null;
      }
    }
  }
  if (data.after) {
    Ext.merge(endData, data.after);
  }
  this.applyStyles(endRules);
  if (data.onEnd) {
    data.onEnd.call(data.scope || this, element, isInterrupted);
  }
  animation.fireEvent('animationend', animation, element, isInterrupted);
  this.fireEvent('animationend', this, animation, element, isInterrupted);
  Ext.AnimationQueue.stop(Ext.emptyFn, animation);
}, onAllAnimationsEnd:function(element) {
  var id = element.getId(), endRules = {};
  delete this.runningAnimationsData[id];
  endRules[id] = {'transition-property':null, 'transition-duration':null, 'transition-timing-function':null, 'transition-delay':null};
  this.applyStyles(endRules);
  this.fireEvent('animationallend', this, element);
}, hasRunningAnimations:function(element) {
  var id = element.getId(), runningAnimationsData = this.runningAnimationsData;
  return runningAnimationsData.hasOwnProperty(id) && runningAnimationsData[id].sessions.length > 0;
}, refreshRunningAnimationsData:function(element, propertyNames, interrupt, replace) {
  var id = element.getId(), runningAnimationsData = this.runningAnimationsData, runningData = runningAnimationsData[id];
  if (!runningData) {
    return;
  }
  var nameMap = runningData.nameMap, nameList = runningData.nameList, sessions = runningData.sessions, ln, j, subLn, name, i, session, map, list, hasCompletedSession = false;
  interrupt = Boolean(interrupt);
  replace = Boolean(replace);
  if (!sessions) {
    return this;
  }
  ln = sessions.length;
  if (ln === 0) {
    return this;
  }
  if (replace) {
    runningData.nameMap = {};
    nameList.length = 0;
    for (i = 0; i < ln; i++) {
      session = sessions[i];
      this.onAnimationEnd(element, session.data, session.animation, interrupt, replace);
    }
    sessions.length = 0;
  } else {
    for (i = 0; i < ln; i++) {
      session = sessions[i];
      map = session.map;
      list = session.list;
      for (j = 0, subLn = propertyNames.length; j < subLn; j++) {
        name = propertyNames[j];
        if (map[name]) {
          delete map[name];
          Ext.Array.remove(list, name);
          session.length--;
          if (--nameMap[name] == 0) {
            delete nameMap[name];
            Ext.Array.remove(nameList, name);
          }
        }
      }
      if (session.length == 0) {
        sessions.splice(i, 1);
        i--;
        ln--;
        hasCompletedSession = true;
        this.onAnimationEnd(element, session.data, session.animation, interrupt);
      }
    }
  }
  if (!replace && !interrupt && sessions.length == 0 && hasCompletedSession) {
    this.onAllAnimationsEnd(element);
  }
}, getRunningData:function(id) {
  var runningAnimationsData = this.runningAnimationsData;
  if (!runningAnimationsData.hasOwnProperty(id)) {
    runningAnimationsData[id] = {nameMap:{}, nameList:[], sessions:[]};
  }
  return runningAnimationsData[id];
}, getTestElement:function() {
  var testElement = this.testElement, iframe, iframeDocument, iframeStyle;
  if (!testElement) {
    iframe = document.createElement('iframe');
    iframe.setAttribute('data-sticky', true);
    iframe.setAttribute('tabIndex', -1);
    iframeStyle = iframe.style;
    iframeStyle.setProperty('visibility', 'hidden', 'important');
    iframeStyle.setProperty('width', '0px', 'important');
    iframeStyle.setProperty('height', '0px', 'important');
    iframeStyle.setProperty('position', 'absolute', 'important');
    iframeStyle.setProperty('border', '0px', 'important');
    iframeStyle.setProperty('zIndex', '-1000', 'important');
    document.body.appendChild(iframe);
    iframeDocument = iframe.contentDocument;
    iframeDocument.open();
    iframeDocument.writeln('\x3c/body\x3e');
    iframeDocument.close();
    this.testElement = testElement = iframeDocument.createElement('div');
    testElement.style.setProperty('position', 'absolute', 'important');
    iframeDocument.body.appendChild(testElement);
    this.testElementComputedStyle = window.getComputedStyle(testElement);
  }
  return testElement;
}, getCssStyleValue:function(name, value) {
  var testElement = this.getTestElement(), computedStyle = this.testElementComputedStyle, style = testElement.style;
  style.setProperty(name, value);
  if (Ext.browser.is.Firefox) {
    testElement.offsetHeight;
  }
  value = computedStyle.getPropertyValue(name);
  style.removeProperty(name);
  return value;
}, run:function(animations) {
  var me = this, isLengthPropertyMap = me.lengthProperties, fromData = {}, toData = {}, data = {}, element, elementId, from, to, before, fromPropertyNames, toPropertyNames, doApplyTo, message, runningData, elementData, i, j, ln, animation, propertiesLength, sessionNameMap, computedStyle, formattedName, name, toFormattedValue, computedValue, fromFormattedValue, isLengthProperty, runningNameMap, runningNameList, runningSessions, runningSession;
  if (!me.listenersAttached) {
    me.attachListeners();
  }
  animations = Ext.Array.from(animations);
  for (i = 0, ln = animations.length; i < ln; i++) {
    animation = animations[i];
    animation = Ext.factory(animation, Ext.fx.Animation);
    element = animation.getElement();
    Ext.AnimationQueue.start(Ext.emptyFn, animation);
    computedStyle = window.getComputedStyle(element.dom);
    elementId = element.getId();
    data = Ext.merge({}, animation.getData());
    if (animation.onBeforeStart) {
      animation.onBeforeStart.call(animation.scope || me, element);
    }
    animation.fireEvent('animationstart', animation);
    me.fireEvent('animationstart', me, animation);
    data[elementId] = data;
    before = data.before;
    from = data.from;
    to = data.to;
    data.fromPropertyNames = fromPropertyNames = [];
    data.toPropertyNames = toPropertyNames = [];
    for (name in to) {
      if (to.hasOwnProperty(name)) {
        to[name] = toFormattedValue = me.formatValue(to[name], name);
        formattedName = me.formatName(name);
        isLengthProperty = isLengthPropertyMap.hasOwnProperty(name);
        if (!isLengthProperty) {
          toFormattedValue = me.getCssStyleValue(formattedName, toFormattedValue);
        }
        if (from.hasOwnProperty(name)) {
          from[name] = fromFormattedValue = me.formatValue(from[name], name);
          if (!isLengthProperty) {
            fromFormattedValue = me.getCssStyleValue(formattedName, fromFormattedValue);
          }
          if (toFormattedValue !== fromFormattedValue) {
            fromPropertyNames.push(formattedName);
            toPropertyNames.push(formattedName);
          }
        } else {
          computedValue = computedStyle.getPropertyValue(formattedName);
          if (toFormattedValue !== computedValue) {
            toPropertyNames.push(formattedName);
          }
        }
      }
    }
    propertiesLength = toPropertyNames.length;
    if (propertiesLength === 0) {
      me.onAnimationEnd(element, data, animation);
      continue;
    }
    runningData = me.getRunningData(elementId);
    runningSessions = runningData.sessions;
    if (runningSessions.length > 0) {
      me.refreshRunningAnimationsData(element, Ext.Array.merge(fromPropertyNames, toPropertyNames), true, data.replacePrevious);
    }
    runningNameMap = runningData.nameMap;
    runningNameList = runningData.nameList;
    sessionNameMap = {};
    for (j = 0; j < propertiesLength; j++) {
      name = toPropertyNames[j];
      sessionNameMap[name] = true;
      if (!runningNameMap.hasOwnProperty(name)) {
        runningNameMap[name] = 1;
        runningNameList.push(name);
      } else {
        runningNameMap[name]++;
      }
    }
    runningSession = {element:element, map:sessionNameMap, list:toPropertyNames.slice(), length:propertiesLength, data:data, animation:animation};
    runningSessions.push(runningSession);
    animation.on('stop', 'onAnimationStop', me);
    elementData = Ext.apply({}, before);
    Ext.apply(elementData, from);
    if (runningNameList.length > 0) {
      fromPropertyNames = Ext.Array.difference(runningNameList, fromPropertyNames);
      toPropertyNames = Ext.Array.merge(fromPropertyNames, toPropertyNames);
      elementData['transition-property'] = fromPropertyNames;
    }
    fromData[elementId] = elementData;
    toData[elementId] = Ext.apply({}, to);
    toData[elementId]['transition-property'] = toPropertyNames;
    toData[elementId]['transition-duration'] = data.duration;
    toData[elementId]['transition-timing-function'] = data.easing;
    toData[elementId]['transition-delay'] = data.delay;
    animation.startTime = Date.now();
  }
  message = me.$className;
  me.applyStyles(fromData);
  doApplyTo = function(e) {
    if (e.data === message && e.source === window) {
      window.removeEventListener('message', doApplyTo, false);
      me.applyStyles(toData);
    }
  };
  if (window.requestAnimationFrame) {
    window.requestAnimationFrame(function() {
      window.addEventListener('message', doApplyTo, false);
      window.postMessage(message, '*');
    });
  } else {
    Ext.defer(function() {
      window.addEventListener('message', doApplyTo, false);
      window.postMessage(message, '*');
    }, 1);
  }
}, onAnimationStop:function(animation) {
  var runningAnimationsData = this.runningAnimationsData, id, runningData, sessions, i, ln, session;
  for (id in runningAnimationsData) {
    if (runningAnimationsData.hasOwnProperty(id)) {
      runningData = runningAnimationsData[id];
      sessions = runningData.sessions;
      for (i = 0, ln = sessions.length; i < ln; i++) {
        session = sessions[i];
        if (session.animation === animation) {
          this.refreshRunningAnimationsData(session.element, session.list.slice(), false);
        }
      }
    }
  }
}});
Ext.define('Ext.list.AbstractTreeItem', {extend:Ext.Widget, isTreeListItem:true, cachedConfig:{expandable:false, expanded:false, floated:false, iconCls:'', leaf:true, loading:false, selected:false, selectedParent:false}, config:{iconClsProperty:'iconCls', indent:null, owner:null, node:null, over:null, parentItem:null, text:{lazy:true, $value:''}, textProperty:'text'}, updateNode:function(node) {
  if (node) {
    var me = this, map = me.itemMap, childNodes, owner, len, i, item, child;
    me.element.dom.setAttribute('data-recordId', node.internalId);
    if (!map) {
      childNodes = node.childNodes;
      owner = me.getOwner();
      me.itemMap = map = {};
      for (i = 0, len = childNodes.length; i < len; ++i) {
        child = childNodes[i];
        item = owner.createItem(child, me);
        map[child.internalId] = item;
        me.insertItem(item, null);
      }
    }
    me.setExpanded(node.isExpanded());
    me.doNodeUpdate(node);
  }
}, updateSelected:function(selected) {
  if (!this.isConfiguring) {
    var parent = this.getParentItem();
    while (parent && !parent.isRootListItem) {
      parent.setSelectedParent(selected);
      parent = parent.getParentItem();
    }
  }
}, collapse:function() {
  this.getNode().collapse();
}, expand:function() {
  this.getNode().expand();
}, getToolElement:Ext.emptyFn, insertItem:Ext.emptyFn, isExpanded:function() {
  return this.getExpanded();
}, isSelectionEvent:Ext.emptyFn, isToggleEvent:Ext.emptyFn, nodeCollapse:function(node, collapsingForExpand) {
  var me = this, owner = me.getOwner(), animation = me.preventAnimation ? null : owner.getAnimation();
  me.nodeCollapseBegin(animation, collapsingForExpand);
  if (!animation) {
    me.nodeCollapseEnd(collapsingForExpand);
  }
}, nodeCollapseBegin:function(animation, collapsingForExpand) {
  var me = this, owner = me.getOwner();
  me.setExpanded(false);
  owner.fireEvent('itemcollapse', owner, me);
}, nodeCollapseEnd:function(collapsingForExpand) {
  if (!collapsingForExpand) {
    this.getOwner().updateLayout();
  }
}, nodeExpand:function(node) {
  var me = this, owner = me.getOwner(), floated = me.getFloated(), animation = !floated && owner.getAnimation();
  me.nodeExpandBegin(animation);
  if (!animation) {
    me.nodeExpandEnd();
  }
}, nodeExpandBegin:function(animation) {
  var me = this, owner = me.getOwner();
  me.setExpanded(true);
  owner.fireEvent('itemexpand', owner, me);
}, nodeExpandEnd:function() {
  this.getOwner().updateLayout();
}, nodeInsert:function(node, refNode) {
  var me = this, owner = me.getOwner(), map = me.itemMap, id = node.internalId, item = owner.getItem(node), refItem = null, oldParent;
  if (item) {
    oldParent = item.getParentItem();
    oldParent.removeItem(item);
    if (oldParent !== me) {
      oldParent.doUpdateExpandable();
      item.setParentItem(me);
    }
  } else {
    item = me.getOwner().createItem(node, me);
  }
  map[id] = item;
  if (refNode) {
    refItem = map[refNode.internalId];
  }
  me.insertItem(item, refItem);
  me.doUpdateExpandable();
  owner.fireEvent('iteminsert', owner, me, item, refItem);
  owner.updateLayout();
}, nodeRemove:function(node) {
  var me = this, map = me.itemMap, owner = me.getOwner(), id = node.internalId, item = map[id];
  if (item) {
    delete map[id];
    me.removeItem(item);
    item.destroy();
    me.doUpdateExpandable();
    owner.fireEvent('itemremove', owner, me, item);
    owner.updateLayout();
  }
}, nodeUpdate:function(node, modifiedFieldNames) {
  this.doNodeUpdate(node);
}, removeItem:Ext.emptyFn, updateFloated:function(floated) {
  var me = this, el = me.element, placeholder = me.placeholder, node, wasExpanded;
  if (floated) {
    placeholder = el.clone(false, true);
    placeholder.id += '-placeholder';
    me.placeholder = Ext.get(placeholder);
    me.wasExpanded = me.getExpanded();
    me.setExpanded(true);
    el.dom.parentNode.insertBefore(placeholder, el.dom);
    me.floater = me.createFloater();
  } else {
    if (placeholder) {
      wasExpanded = me.wasExpanded;
      node = me.getNode();
      me.setExpanded(wasExpanded);
      if (!wasExpanded && node.isExpanded()) {
        me.preventAnimation = true;
        node.collapse();
        me.preventAnimation = false;
      }
      me.floater.remove(me, false);
      placeholder.dom.parentNode.insertBefore(el.dom, placeholder.dom);
      placeholder.destroy();
      me.floater.destroy();
      me.placeholder = me.floater = null;
      me.floatedByHover = false;
    }
  }
}, destroy:function() {
  var me = this, map = me.itemMap, owner = me.getOwner(), key;
  if (map) {
    for (key in map) {
      map[key].destroy();
    }
    me.itemMap = null;
  }
  if (owner) {
    owner.removeItem(me.getNode());
  }
  me.setNode(null);
  me.setParentItem(null);
  me.setOwner(null);
  me.callParent();
}, privates:{doNodeUpdate:function(node) {
  var me = this, textProperty = this.getTextProperty(), iconClsProperty = this.getIconClsProperty();
  if (textProperty) {
    me.setText(node.data[textProperty]);
  }
  if (iconClsProperty) {
    me.setIconCls(node.data[iconClsProperty]);
  }
  me.setLoading(node.isLoading());
  me.setLeaf(node.isLeaf());
  me.doUpdateExpandable();
}, doUpdateExpandable:function() {
  var node = this.getNode();
  this.setExpandable(node.isExpandable());
}, onClick:function(e) {
  var me = this, owner = me.getOwner(), node = me.getNode(), info = {event:e, item:me, node:node, tree:owner, select:node.get('selectable') !== false && me.isSelectionEvent(e), toggle:me.isToggleEvent(e)};
  if (owner.fireEvent('itemclick', owner, info) !== false) {
    if (info.toggle) {
      me.toggleExpanded();
    }
    if (info.select) {
      owner.setSelection(me.getNode());
    }
  }
}, toggleExpanded:function() {
  if (this.isExpanded()) {
    this.collapse();
  } else {
    this.expand();
  }
}, updateIndent:function(value) {
  var items = this.itemMap, id;
  for (id in items) {
    items[id].setIndent(value);
  }
}}});
Ext.define('Ext.list.RootTreeItem', {extend:Ext.list.AbstractTreeItem, isRootListItem:true, element:{reference:'element', tag:'ul', cls:Ext.baseCSSPrefix + 'treelist-root-container'}, insertItem:function(item, refItem) {
  if (refItem) {
    item.element.insertBefore(refItem.element);
  } else {
    this.element.appendChild(item.element);
  }
}, isToggleEvent:function(e) {
  return false;
}});
Ext.define('Ext.list.TreeItem', {extend:Ext.list.AbstractTreeItem, xtype:'treelistitem', collapsedCls:Ext.baseCSSPrefix + 'treelist-item-collapsed', expandedCls:Ext.baseCSSPrefix + 'treelist-item-expanded', floatedCls:Ext.baseCSSPrefix + 'treelist-item-floated', floatedToolCls:Ext.baseCSSPrefix + 'treelist-item-tool-floated', leafCls:Ext.baseCSSPrefix + 'treelist-item-leaf', expandableCls:Ext.baseCSSPrefix + 'treelist-item-expandable', hideIconCls:Ext.baseCSSPrefix + 'treelist-item-hide-icon', loadingCls:Ext.baseCSSPrefix + 
'treelist-item-loading', selectedCls:Ext.baseCSSPrefix + 'treelist-item-selected', selectedParentCls:Ext.baseCSSPrefix + 'treelist-item-selected-parent', withIconCls:Ext.baseCSSPrefix + 'treelist-item-with-icon', hoverCls:Ext.baseCSSPrefix + 'treelist-item-over', rowHoverCls:Ext.baseCSSPrefix + 'treelist-row-over', isTreeListItem:true, config:{rowCls:null}, rowClsProperty:'rowCls', element:{reference:'element', tag:'li', cls:Ext.baseCSSPrefix + 'treelist-item', children:[{reference:'rowElement', 
cls:Ext.baseCSSPrefix + 'treelist-row', children:[{reference:'wrapElement', cls:Ext.baseCSSPrefix + 'treelist-item-wrap', children:[{reference:'iconElement', cls:Ext.baseCSSPrefix + 'treelist-item-icon'}, {reference:'textElement', cls:Ext.baseCSSPrefix + 'treelist-item-text'}, {reference:'expanderElement', cls:Ext.baseCSSPrefix + 'treelist-item-expander'}]}]}, {reference:'itemContainer', tag:'ul', cls:Ext.baseCSSPrefix + 'treelist-container'}, {reference:'toolElement', cls:Ext.baseCSSPrefix + 'treelist-item-tool'}]}, 
constructor:function(config) {
  this.callParent([config]);
  var toolDom = this.toolElement.dom;
  toolDom.parentNode.removeChild(toolDom);
}, getToolElement:function() {
  return this.toolElement;
}, insertItem:function(item, refItem) {
  if (refItem) {
    item.element.insertBefore(refItem.element);
  } else {
    this.itemContainer.appendChild(item.element);
  }
}, isSelectionEvent:function(e) {
  var owner = this.getOwner();
  return !this.isToggleEvent(e) || !owner.getExpanderOnly() || owner.getSelectOnExpander();
}, isToggleEvent:function(e) {
  var isExpand = false;
  if (this.getOwner().getExpanderOnly()) {
    isExpand = e.target === this.expanderElement.dom;
  } else {
    isExpand = !this.itemContainer.contains(e.target);
  }
  return isExpand;
}, nodeCollapseBegin:function(animation, collapsingForExpand) {
  var me = this, itemContainer = me.itemContainer, height;
  if (me.expanding) {
    me.stopAnimation(me.expanding);
  }
  height = animation && itemContainer.getHeight();
  me.callParent([animation, collapsingForExpand]);
  if (animation) {
    itemContainer.dom.style.display = 'block';
    me.collapsingForExpand = collapsingForExpand;
    me.collapsing = this.runAnimation(Ext.merge({from:{height:height}, to:{height:0}, callback:me.nodeCollapseDone, scope:me}, animation));
  }
}, nodeCollapseDone:function(animation) {
  var me = this, itemContainer = me.itemContainer;
  me.collapsing = null;
  itemContainer.dom.style.display = '';
  itemContainer.setHeight(null);
  me.nodeCollapseEnd(me.collapsingForExpand);
}, nodeExpandBegin:function(animation) {
  var me = this, itemContainer = me.itemContainer, height;
  if (me.collapsing) {
    me.stopAnimation(me.collapsing);
  }
  me.callParent([animation]);
  if (animation) {
    height = itemContainer.getHeight();
    itemContainer.setHeight(0);
    me.expanding = me.runAnimation(Ext.merge({to:{height:height}, callback:me.nodeExpandDone, scope:me}, animation));
  }
}, nodeExpandDone:function() {
  this.expanding = null;
  this.itemContainer.setHeight(null);
  this.nodeExpandEnd();
}, removeItem:function(item) {
  this.itemContainer.removeChild(item.element);
}, updateNode:function(node, oldNode) {
  this.syncIndent();
  this.callParent([node, oldNode]);
}, updateExpandable:function() {
  this.updateExpandCls();
}, updateExpanded:function() {
  this.updateExpandCls();
}, updateFloated:function(floated, wasFloated) {
  var me = this;
  me.callParent([floated, wasFloated]);
  me.element.toggleCls(me.floatedCls, floated);
  me.toolElement.toggleCls(me.floatedToolCls, floated);
}, updateIconCls:function(iconCls, oldIconCls) {
  var me = this, el = me.element;
  me.doIconCls(me.iconElement, iconCls, oldIconCls);
  me.doIconCls(me.toolElement, iconCls, oldIconCls);
  el.toggleCls(me.withIconCls, !!iconCls);
  el.toggleCls(me.hideIconCls, iconCls === null);
}, updateLeaf:function(leaf) {
  this.element.toggleCls(this.leafCls, leaf);
}, updateLoading:function(loading) {
  this.element.toggleCls(this.loadingCls, loading);
}, updateOver:function(over) {
  var me = this;
  me.element.toggleCls(me.hoverCls, !!over);
  me.rowElement.toggleCls(me.rowHoverCls, over > 1);
}, updateRowCls:function(value, oldValue) {
  this.rowElement.replaceCls(oldValue, value);
}, updateSelected:function(selected, oldSelected) {
  var me = this, cls = me.selectedCls, tool = me.getToolElement();
  me.callParent([selected, oldSelected]);
  me.element.toggleCls(cls, selected);
  if (tool) {
    tool.toggleCls(cls, selected);
  }
}, updateSelectedParent:function(selectedParent) {
  var me = this;
  me.element.toggleCls(me.selectedParentCls, selectedParent);
  var tool = me.getToolElement();
  if (tool) {
    tool.toggleCls(me.selectedCls, selectedParent);
  }
}, updateText:function(text) {
  this.textElement.update(text);
}, privates:{doNodeUpdate:function(node) {
  this.callParent([node]);
  this.setRowCls(node && node.data[this.rowClsProperty]);
}, doIconCls:function(element, iconCls, oldIconCls) {
  if (oldIconCls) {
    element.removeCls(oldIconCls);
  }
  if (iconCls) {
    element.addCls(iconCls);
  }
}, syncIndent:function() {
  var me = this, indent = me.getIndent(), node = me.getNode(), depth;
  if (node) {
    depth = node.data.depth - 1;
    me.wrapElement.dom.style.marginLeft = depth * indent + 'px';
  }
}, updateExpandCls:function() {
  if (!this.updatingExpandCls) {
    var me = this, expandable = me.getExpandable(), element = me.element, expanded = me.getExpanded(), expandedCls = me.expandedCls, collapsedCls = me.collapsedCls;
    me.updatingExpandCls = true;
    element.toggleCls(me.expandableCls, expandable);
    if (expandable) {
      element.toggleCls(expandedCls, expanded);
      element.toggleCls(collapsedCls, !expanded);
    } else {
      element.removeCls([expandedCls, collapsedCls]);
    }
    me.updatingExpandCls = false;
  }
}, updateIndent:function(value, oldValue) {
  this.syncIndent();
  this.callParent([value, oldValue]);
}}});
Ext.define('Ext.overrides.list.TreeItem', {override:'Ext.list.TreeItem', createFloater:function() {
  var me = this, owner = me.getOwner(), ui = owner.getUi(), cls = Ext.baseCSSPrefix + 'treelist', floater;
  if (ui) {
    cls += ' ' + cls + '-' + ui;
  }
  me.floater = floater = new Ext.Container({cls:cls + ' ' + Ext.baseCSSPrefix + 'treelist-floater', width:200, top:0, listeners:{element:'element', click:function(e) {
    return owner.onClick(e);
  }}});
  Ext.Viewport.add(floater);
  floater.add(me);
  floater.alignTo(me.getToolElement(), 'tl-tr');
  return floater;
}, runAnimation:function(animation) {
  return this.itemContainer.animate(animation);
}, stopAnimation:function(animation) {
  animation.end();
}});
Ext.define('Ext.list.Tree', {extend:Ext.Widget, xtype:'treelist', expanderFirstCls:Ext.baseCSSPrefix + 'treelist-expander-first', expanderOnlyCls:Ext.baseCSSPrefix + 'treelist-expander-only', highlightPathCls:Ext.baseCSSPrefix + 'treelist-highlight-path', microCls:Ext.baseCSSPrefix + 'treelist-micro', uiPrefix:Ext.baseCSSPrefix + 'treelist-', element:{reference:'element', cls:Ext.baseCSSPrefix + 'treelist ' + Ext.baseCSSPrefix + 'unselectable', listeners:{click:'onClick', mouseenter:'onMouseEnter', 
mouseleave:'onMouseLeave', mouseover:'onMouseOver'}, children:[{reference:'toolsElement', cls:Ext.baseCSSPrefix + 'treelist-toolstrip', listeners:{click:'onToolStripClick', mouseover:'onToolStripMouseOver'}}]}, cachedConfig:{animation:{duration:500, easing:'ease'}, expanderFirst:true, expanderOnly:true}, config:{defaults:{xtype:'treelistitem'}, highlightPath:null, iconSize:null, indent:null, micro:null, overItem:null, selection:null, selectOnExpander:false, singleExpand:null, store:null, ui:null}, 
twoWayBindable:{selection:1}, publishes:{selection:1}, defaultBindProperty:'store', constructor:function(config) {
  this.callParent([config]);
  this.publishState('selection', this.getSelection());
}, beforeLayout:function() {
  this.syncIconSize();
}, destroy:function() {
  var me = this;
  me.destroying = true;
  me.unfloatAll();
  me.activeFloater = null;
  me.setSelection(null);
  me.setStore(null);
  me.callParent();
}, updateOverItem:function(over, wasOver) {
  var map = {}, state = 2, c, node;
  for (c = over; c; c = this.getItem(node.parentNode)) {
    node = c.getNode();
    map[node.internalId] = true;
    c.setOver(state);
    state = 1;
  }
  if (wasOver) {
    for (c = wasOver; c; c = this.getItem(node.parentNode)) {
      node = c.getNode();
      if (map[node.internalId]) {
        break;
      }
      c.setOver(0);
    }
  }
}, applySelection:function(selection, oldSelection) {
  var store = this.getStore();
  if (!store) {
    selection = null;
  }
  if (selection && selection.get('selectable') === false) {
    selection = oldSelection;
  }
  return selection;
}, updateSelection:function(selection, oldSelection) {
  var me = this, item;
  if (!me.destroying) {
    item = me.getItem(oldSelection);
    if (item) {
      item.setSelected(false);
    }
    item = me.getItem(selection);
    if (item) {
      item.setSelected(true);
    }
    me.fireEvent('selectionchange', me, selection);
  }
}, applyStore:function(store) {
  return store && Ext.StoreManager.lookup(store, 'tree');
}, updateStore:function(store, oldStore) {
  var me = this, root;
  if (oldStore) {
    if (oldStore.getAutoDestroy()) {
      oldStore.destroy();
    } else {
      me.storeListeners.destroy();
    }
    me.removeRoot();
    me.storeListeners = null;
  }
  if (store) {
    me.storeListeners = store.on({destroyable:true, scope:me, nodeappend:me.onNodeAppend, nodecollapse:me.onNodeCollapse, nodeexpand:me.onNodeExpand, nodeinsert:me.onNodeInsert, noderemove:me.onNodeRemove, rootchange:me.onRootChange, update:me.onNodeUpdate});
    root = store.getRoot();
    if (root) {
      me.createRootItem(root);
    }
  }
  if (!me.destroying) {
    me.updateLayout();
  }
}, updateExpanderFirst:function(expanderFirst) {
  this.element.toggleCls(this.expanderFirstCls, expanderFirst);
}, updateExpanderOnly:function(value) {
  this.element.toggleCls(this.expanderOnlyCls, !value);
}, updateHighlightPath:function(updatePath) {
  this.element.toggleCls(this.highlightPathCls, updatePath);
}, updateMicro:function(micro) {
  var me = this;
  if (!micro) {
    me.unfloatAll();
    me.activeFloater = null;
  }
  me.element.toggleCls(me.microCls, micro);
}, updateUi:function(ui, oldValue) {
  var el = this.element, uiPrefix = this.uiPrefix;
  if (oldValue) {
    el.removeCls(uiPrefix + oldValue);
  }
  if (ui) {
    el.addCls(uiPrefix + ui);
  }
  delete this.iconSize;
  this.syncIconSize();
}, getItem:function(node) {
  var map = this.itemMap, ret;
  if (node && map) {
    ret = map[node.internalId];
  }
  return ret || null;
}, getItemConfig:function(node, parent) {
  return Ext.apply({parentItem:parent.isRootListItem ? null : parent, owner:this, node:node, indent:this.getIndent()}, this.getDefaults());
}, privates:{checkForOutsideClick:function(e) {
  var floater = this.activeFloater;
  if (!floater.element.contains(e.target)) {
    this.unfloatAll();
  }
}, collapsingForExpand:false, createItem:function(node, parent) {
  var item = Ext.create(this.getItemConfig(node, parent)), toolEl;
  if (parent.isRootListItem) {
    toolEl = item.getToolElement();
    if (toolEl) {
      this.toolsElement.appendChild(toolEl);
      toolEl.dom.setAttribute('data-recordId', node.internalId);
      toolEl.isTool = true;
    }
  }
  return this.itemMap[node.internalId] = item;
}, createRootItem:function(root) {
  var me = this, item;
  me.itemMap = {};
  me.rootItem = item = new Ext.list.RootTreeItem({indent:me.getIndent(), node:root, owner:me});
  me.element.appendChild(item.element);
  me.itemMap[root.internalId] = item;
}, floatItem:function(item, byHover) {
  var me = this, floater;
  if (item.getFloated()) {
    return;
  }
  me.unfloatAll();
  me.activeFloater = floater = item;
  me.floatedByHover = byHover;
  item.setFloated(true);
  if (byHover) {
    item.getToolElement().on('mouseleave', me.checkForMouseLeave, me);
    floater.element.on('mouseleave', me.checkForMouseLeave, me);
  } else {
    Ext.on('mousedown', me.checkForOutsideClick, me);
  }
}, onClick:function(e) {
  var item = e.getTarget('[data-recordId]'), id;
  if (item) {
    id = item.getAttribute('data-recordId');
    item = this.itemMap[id];
    if (item) {
      item.onClick(e);
    }
  }
}, onMouseEnter:function(e) {
  this.onMouseOver(e);
}, onMouseLeave:function() {
  this.setOverItem(null);
}, onMouseOver:function(e) {
  var comp = Ext.Component.fromElement(e.getTarget());
  this.setOverItem(comp && comp.isTreeListItem && comp);
}, checkForMouseLeave:function(e) {
  var floater = this.activeFloater, relatedTarget = e.getRelatedTarget();
  if (floater) {
    if (relatedTarget !== floater.getToolElement().dom && !floater.element.contains(relatedTarget)) {
      this.unfloatAll();
    }
  }
}, onNodeAppend:function(parentNode, node) {
  if (parentNode) {
    var item = this.itemMap[parentNode.internalId];
    if (item) {
      item.nodeInsert(node, null);
    }
  }
}, onNodeCollapse:function(node) {
  var item = this.itemMap[node.internalId];
  if (item) {
    item.nodeCollapse(node, this.collapsingForExpand);
  }
}, onNodeExpand:function(node) {
  var me = this, item = me.itemMap[node.internalId], childNodes, len, i, parentNode, child;
  if (item) {
    if (!item.isRootItem && me.getSingleExpand()) {
      me.collapsingForExpand = true;
      parentNode = (item.getParentItem() || me.rootItem).getNode();
      childNodes = parentNode.childNodes;
      for (i = 0, len = childNodes.length; i < len; ++i) {
        child = childNodes[i];
        if (child !== node) {
          child.collapse();
        }
      }
      me.collapsing = false;
    }
    item.nodeExpand(node);
  }
}, onNodeInsert:function(parentNode, node, refNode) {
  var item = this.itemMap[parentNode.internalId];
  if (item) {
    item.nodeInsert(node, refNode);
  }
}, onNodeRemove:function(parentNode, node, isMove) {
  if (parentNode && !isMove) {
    var item = this.itemMap[parentNode.internalId];
    if (item) {
      item.nodeRemove(node);
    }
  }
}, onNodeUpdate:function(store, node, type, modifiedFieldNames) {
  var item = this.itemMap[node.internalId];
  if (item) {
    item.nodeUpdate(node, modifiedFieldNames);
  }
}, onRootChange:function(root) {
  this.removeRoot();
  if (root) {
    this.createRootItem(root);
  }
  this.updateLayout();
}, removeItem:function(node) {
  var map = this.itemMap;
  if (map) {
    delete map[node.internalId];
  }
}, removeRoot:function() {
  var me = this, rootItem = me.rootItem;
  if (rootItem) {
    me.element.removeChild(rootItem.element);
    me.rootItem = me.itemMap = Ext.destroy(rootItem);
  }
}, onToolStripClick:function(e) {
  var item = e.getTarget('[data-recordId]'), id;
  if (item) {
    id = item.getAttribute('data-recordId');
    item = this.itemMap[id];
    if (item) {
      if (item === this.activeFloater) {
        this.unfloatAll();
      } else {
        this.floatItem(item, false);
      }
    }
  }
}, onToolStripMouseOver:function(e) {
  var item = e.getTarget('[data-recordId]'), id;
  if (item) {
    id = item.getAttribute('data-recordId');
    item = this.itemMap[id];
    if (item) {
      this.floatItem(item, true);
    }
  }
}, syncIconSize:function() {
  var me = this, size = me.iconSize || (me.iconSize = parseInt(me.element.getStyle('background-position'), 10));
  me.setIconSize(size);
}, unfloatAll:function() {
  var me = this, floater = me.activeFloater;
  if (floater) {
    floater.setFloated(false);
    me.activeFloater = null;
    if (me.floatedByHover) {
      floater.element.un('mouseleave', me.checkForMouseLeave, me);
    } else {
      Ext.un('mousedown', me.checkForOutsideClick, me);
    }
  }
}, defaultIconSize:22, updateIconSize:function(value) {
  this.setIndent(value || this.defaultIconSize);
}, updateIndent:function(value) {
  var rootItem = this.rootItem;
  if (rootItem) {
    rootItem.setIndent(value);
  }
}}});
Ext.define('Ext.overrides.list.Tree', {override:'Ext.list.Tree', constructor:function(config) {
  var me = this, el;
  me.callParent([config]);
  el = me.element;
  if (el.isPainted()) {
    me.syncIconSize();
  } else {
    el.on({scope:me, painted:me.syncIconSize, single:true});
  }
}});
Ext.define('Ext.mixin.Selectable', {extend:Ext.Mixin, mixinConfig:{id:'selectable', after:{updateStore:'updateStore'}}, config:{disableSelection:null, mode:'SINGLE', allowDeselect:false, lastSelected:null, lastFocused:null, deselectOnContainerClick:true, selection:null, twoWayBindable:{selection:1}, publishes:{selection:1}}, modes:{SINGLE:true, SIMPLE:true, MULTI:true}, selectableEventHooks:{add:'onSelectionStoreAdd', remove:'onSelectionStoreRemove', update:'onSelectionStoreUpdate', clear:{fn:'onSelectionStoreClear', 
priority:1000}, load:'refreshSelection', refresh:'refreshSelection'}, constructor:function() {
  this.selected = new Ext.util.MixedCollection;
  this.callParent(arguments);
}, initSelectable:function() {
  this.publishState('selection', this.getSelection());
}, applyMode:function(mode) {
  mode = mode ? mode.toUpperCase() : 'SINGLE';
  return this.modes[mode] ? mode : 'SINGLE';
}, updateStore:function(newStore, oldStore) {
  var me = this, bindEvents = Ext.apply({}, me.selectableEventHooks, {scope:me});
  if (oldStore && Ext.isObject(oldStore) && oldStore.isStore) {
    if (oldStore.autoDestroy) {
      oldStore.destroy();
    } else {
      oldStore.un(bindEvents);
    }
  }
  if (newStore) {
    newStore.on(bindEvents);
    me.refreshSelection();
  }
}, selectAll:function(silent) {
  var me = this, selections = me.getStore().getRange();
  me.select(selections, true, silent);
}, deselectAll:function(supress) {
  var me = this, selections = me.getStore().getRange();
  me.deselect(selections, supress);
  me.selected.clear();
  me.setLastSelected(null);
  me.setLastFocused(null);
}, updateSelection:function(selection) {
  if (this.changingSelection) {
    return;
  }
  if (selection) {
    this.select(selection);
  } else {
    this.deselectAll();
  }
}, selectWithEvent:function(record) {
  var me = this, isSelected = me.isSelected(record);
  switch(me.getMode()) {
    case 'MULTI':
    case 'SIMPLE':
      if (isSelected) {
        me.deselect(record);
      } else {
        me.select(record, true);
      }
      break;
    case 'SINGLE':
      if (me.getAllowDeselect() && isSelected) {
        me.deselect(record);
      } else {
        me.select(record, false);
      }
      break;
  }
}, selectRange:function(startRecord, endRecord, keepExisting) {
  var me = this, store = me.getStore(), records = [], tmp, i;
  if (me.getDisableSelection()) {
    return;
  }
  if (startRecord > endRecord) {
    tmp = endRecord;
    endRecord = startRecord;
    startRecord = tmp;
  }
  for (i = startRecord; i <= endRecord; i++) {
    records.push(store.getAt(i));
  }
  this.doMultiSelect(records, keepExisting);
}, select:function(records, keepExisting, suppressEvent) {
  var me = this, record;
  if (me.getDisableSelection()) {
    return;
  }
  if (typeof records === 'number') {
    records = [me.getStore().getAt(records)];
  }
  if (!records) {
    return;
  }
  if (me.getMode() == 'SINGLE' && records) {
    record = records.length ? records[0] : records;
    me.doSingleSelect(record, suppressEvent);
  } else {
    me.doMultiSelect(records, keepExisting, suppressEvent);
  }
}, doSingleSelect:function(record, suppressEvent) {
  var me = this, selected = me.selected;
  if (me.getDisableSelection()) {
    return;
  }
  if (me.isSelected(record)) {
    return;
  }
  if (selected.getCount() > 0) {
    me.deselect(me.getLastSelected(), suppressEvent);
  }
  selected.add(record);
  me.setLastSelected(record);
  me.onItemSelect(record, suppressEvent);
  me.setLastFocused(record);
  if (!suppressEvent) {
    me.fireSelectionChange([record]);
  }
}, doMultiSelect:function(records, keepExisting, suppressEvent) {
  if (records === null || this.getDisableSelection()) {
    return;
  }
  records = !Ext.isArray(records) ? [records] : records;
  var me = this, selected = me.selected, ln = records.length, change = false, i = 0, record;
  if (!keepExisting && selected.getCount() > 0) {
    change = true;
    me.deselect(me.getSelections(), true);
  }
  for (; i < ln; i++) {
    record = records[i];
    if (keepExisting && me.isSelected(record)) {
      continue;
    }
    change = true;
    me.setLastSelected(record);
    selected.add(record);
    if (!suppressEvent) {
      me.setLastFocused(record);
    }
    me.onItemSelect(record, suppressEvent);
  }
  if (change && !suppressEvent) {
    this.fireSelectionChange(records);
  }
}, deselect:function(records, suppressEvent) {
  var me = this;
  if (me.getDisableSelection()) {
    return;
  }
  records = Ext.isArray(records) ? records : [records];
  var selected = me.selected, change = false, i = 0, store = me.getStore(), ln = records.length, record;
  for (; i < ln; i++) {
    record = records[i];
    if (typeof record === 'number') {
      record = store.getAt(record);
    }
    if (selected.remove(record)) {
      if (me.getLastSelected() == record) {
        me.setLastSelected(selected.last());
      }
      change = true;
    }
    if (record) {
      me.onItemDeselect(record, suppressEvent);
    }
  }
  if (change && !suppressEvent) {
    me.fireSelectionChange(records);
  }
}, updateLastFocused:function(newRecord, oldRecord) {
  this.onLastFocusChanged(oldRecord, newRecord);
}, fireSelectionChange:function(records) {
  var me = this;
  me.changingSelection = true;
  me.setSelection(me.getLastSelected() || null);
  me.changingSelection = false;
  me.fireAction('selectionchange', [me, records], 'getSelections');
}, getSelections:function() {
  return this.selected.getRange();
}, isSelected:function(record) {
  record = Ext.isNumber(record) ? this.getStore().getAt(record) : record;
  return this.selected.indexOf(record) !== -1;
}, hasSelection:function() {
  return this.selected.getCount() > 0;
}, refreshSelection:function() {
  var me = this, selections = me.getSelections();
  me.deselectAll(true);
  if (selections.length) {
    me.select(selections, false, true);
  }
}, onSelectionStoreRemove:function(store, records) {
  var me = this, selected = me.selected, ln = records.length, removed, record, i;
  if (me.getDisableSelection()) {
    return;
  }
  for (i = 0; i < ln; i++) {
    record = records[i];
    if (selected.remove(record)) {
      if (me.getLastSelected() == record) {
        me.setLastSelected(null);
      }
      if (me.getLastFocused() == record) {
        me.setLastFocused(null);
      }
      removed = removed || [];
      removed.push(record);
    }
  }
  if (removed) {
    me.fireSelectionChange([removed]);
  }
}, onSelectionStoreClear:function(store) {
  var records = store.getData().items;
  this.onSelectionStoreRemove(store, records);
}, getSelectionCount:function() {
  return this.selected.getCount();
}, onSelectionStoreAdd:Ext.emptyFn, onSelectionStoreUpdate:Ext.emptyFn, onItemSelect:Ext.emptyFn, onItemDeselect:Ext.emptyFn, onLastFocusChanged:Ext.emptyFn, onEditorKey:Ext.emptyFn}, function() {
});
Ext.define('Ext.util.TaskManager', {extend:Ext.util.TaskRunner, alternateClassName:['Ext.TaskManager'], singleton:true});
Ext.define('Ext.util.TextMetrics', {statics:{shared:null, measure:function(el, text, fixedWidth) {
  var me = this, shared = me.shared;
  if (!shared) {
    shared = me.shared = new me(el, fixedWidth);
  }
  shared.bind(el);
  shared.setFixedWidth(fixedWidth || 'auto');
  return shared.getSize(text);
}, destroy:function() {
  var me = this;
  Ext.destroy(me.shared);
  me.shared = null;
}}, constructor:function(bindTo, fixedWidth) {
  var me = this, measure = Ext.getBody().createChild({'data-sticky':true, role:'presentation', cls:Ext.baseCSSPrefix + 'textmetrics'});
  measure.setVisibilityMode(1);
  me.measure = measure;
  if (bindTo) {
    me.bind(bindTo);
  }
  measure.position('absolute');
  measure.setLocalXY(-1000, -1000);
  measure.hide();
  if (fixedWidth) {
    measure.setWidth(fixedWidth);
  }
}, getSize:function(text) {
  var measure = this.measure, size;
  measure.setHtml(text);
  size = measure.getSize();
  measure.setHtml('');
  return size;
}, bind:function(el) {
  var me = this;
  me.el = Ext.get(el);
  me.measure.setStyle(me.el.getStyle(['font-size', 'font-style', 'font-weight', 'font-family', 'line-height', 'text-transform', 'letter-spacing', 'word-break']));
}, setFixedWidth:function(width) {
  this.measure.setWidth(width);
}, getWidth:function(text) {
  this.measure.dom.style.width = 'auto';
  return this.getSize(text).width;
}, getHeight:function(text) {
  return this.getSize(text).height;
}, destroy:function() {
  var me = this;
  me.el = me.measure = Ext.destroy(me.measure);
  me.callParent();
}}, function() {
  Ext.Element.override({getTextWidth:function(text, min, max) {
    return Ext.Number.constrain(Ext.util.TextMetrics.measure(this.dom, Ext.valueFrom(text, this.dom.innerHTML, true)).width, min || 0, max || 1000000);
  }});
});
Ext.define('Ext.util.LineSegment', {constructor:function(point1, point2) {
  var Point = Ext.util.Point;
  this.point1 = Point.from(point1);
  this.point2 = Point.from(point2);
}, intersects:function(lineSegment) {
  var point1 = this.point1, point2 = this.point2, point3 = lineSegment.point1, point4 = lineSegment.point2, x1 = point1.x, x2 = point2.x, x3 = point3.x, x4 = point4.x, y1 = point1.y, y2 = point2.y, y3 = point3.y, y4 = point4.y, d = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4), xi, yi;
  if (d == 0) {
    return null;
  }
  xi = ((x3 - x4) * (x1 * y2 - y1 * x2) - (x1 - x2) * (x3 * y4 - y3 * x4)) / d;
  yi = ((y3 - y4) * (x1 * y2 - y1 * x2) - (y1 - y2) * (x3 * y4 - y3 * x4)) / d;
  if (xi < Math.min(x1, x2) || xi > Math.max(x1, x2) || xi < Math.min(x3, x4) || xi > Math.max(x3, x4) || yi < Math.min(y1, y2) || yi > Math.max(y1, y2) || yi < Math.min(y3, y4) || yi > Math.max(y3, y4)) {
    return null;
  }
  return new Ext.util.Point(xi, yi);
}, getLength:function() {
  return Math.abs(this.point1.getDistanceTo(this.point2));
}, getAngleToX:function() {
  var point1 = this.point1, point2 = this.point2, deltaY = point2.y - point1.y, deltaX = point2.x - point1.x;
  return Math.atan2(deltaY, deltaX);
}, getInBetweenPoint:function(distance) {
  var point1 = this.point1, angle = this.getAngleToX(), x = point1.x + Math.cos(angle) * distance, y = point1.y + Math.sin(angle) * distance;
  return new Ext.util.Point(x, y);
}, toString:function() {
  return this.point1.toString() + ' ' + this.point2.toString();
}});
Ext.define('Ext.Panel', {extend:Ext.Container, xtype:'panel', alternateClassName:'Ext.panel.Panel', defaultBindProperty:'title', isPanel:true, config:{baseCls:Ext.baseCSSPrefix + 'panel', border:false, bodyPadding:null, bodyBorder:null, header:null, icon:null, iconCls:null, title:null, tools:null}, manageBorders:true, getElementConfig:function() {
  return {reference:'element', classList:['x-container', 'x-unsized'], children:[{reference:'innerElement', className:'x-inner'}, {reference:'tipElement', className:'x-anchor', hidden:true}]};
}, addBodyCls:function(cls) {
  this.innerElement.addCls(cls);
  return this;
}, removeBodyCls:function(cls) {
  this.innerElement.removeCls(cls);
  return this;
}, applyBodyPadding:function(bodyPadding) {
  if (bodyPadding === true) {
    bodyPadding = 5;
  }
  if (bodyPadding) {
    bodyPadding = Ext.dom.Element.unitizeBox(bodyPadding);
  }
  return bodyPadding;
}, addTool:function(tool) {
  var header = this.ensureHeader(), items;
  if (header) {
    items = header.createTools(Ext.Array.from(tool), this);
    if (items && items.length) {
      items = header.add(items);
    }
  }
  return items;
}, applyHeader:function(newHeader, oldHeader) {
  var me = this, header = oldHeader;
  if (newHeader === false) {
    if (header) {
      me.remove(header);
      header = null;
    }
  } else {
    if (newHeader) {
      if (header) {
        if (newHeader !== true) {
          header.setConfig(newHeader);
        }
      } else {
        header = me.add(me.createHeader(newHeader));
      }
    }
  }
  return header || null;
}, applyTools:function(tools) {
  var header = this.ensureHeader(), items;
  if (header) {
    header.clearTools();
    items = header.createTools(tools, this);
    if (items && items.length) {
      header.add(items);
    }
  }
}, createHeader:function(config) {
  var me = this, ret = {xtype:'panelheader', docked:'top', ui:me.getUi()}, icon, title;
  if (config && config !== true) {
    Ext.merge(ret, config);
  }
  if (me.initialized) {
    title = me.getTitle();
    if (title != null) {
      if (typeof title === 'string') {
        title = {text:title};
      }
      Ext.merge(ret, {title:title});
    }
    icon = me.getIconCls();
    if (icon != null) {
      ret.iconCls = icon;
    } else {
      icon = me.getIcon();
      if (icon != null) {
        ret.icon = icon;
      }
    }
  }
  return ret;
}, updateBorder:function(border, oldBorder) {
  this.callParent([border, oldBorder]);
  if (this.getBodyBorder() === null) {
    this.setBodyBorderEnabled(border !== false);
  }
}, updateBodyPadding:function(newBodyPadding) {
  this.innerElement.setStyle('padding', newBodyPadding);
}, updateBodyBorder:function(bodyBorder) {
  var border = bodyBorder === null ? this.getBorder() : bodyBorder;
  this.setBodyBorderEnabled(bodyBorder !== false);
}, updateIcon:function(icon) {
  var header = this.ensureHeader();
  if (header) {
    header.setIcon(icon);
  }
}, updateIconCls:function(icon) {
  var header = this.ensureHeader();
  if (header) {
    header.setIconCls(icon);
  }
}, updateTitle:function(title) {
  var header = this.ensureHeader();
  if (header) {
    header.setTitle(title);
  }
}, updateUi:function(ui, oldUi) {
  var me = this, suffix = 'x-panel-inner-', innerElement = me.innerElement, header = !me.isConfiguring && me.ensureHeader();
  if (oldUi) {
    innerElement.removeCls(suffix + oldUi);
  }
  if (ui) {
    innerElement.addCls(suffix + ui);
  }
  if (header) {
    me.getTitle();
    header.setUi(ui);
  }
  me.callParent([ui, oldUi]);
}, alignTo:function(component, alignment) {
  var alignmentInfo = this.getAlignmentInfo(component, alignment);
  if (alignmentInfo.isAligned) {
    return;
  }
  var tipElement = this.tipElement;
  tipElement.hide();
  if (this.currentTipPosition) {
    tipElement.removeCls('x-anchor-' + this.currentTipPosition);
  }
  this.callParent(arguments);
  var LineSegment = Ext.util.LineSegment, alignToElement = component.isComponent ? component.renderElement : component, element = this.renderElement, alignToBox = alignToElement.getBox(), box = element.getBox(), left = box.left, top = box.top, right = box.right, bottom = box.bottom, centerX = left + box.width / 2, centerY = top + box.height / 2, leftTopPoint = {x:left, y:top}, rightTopPoint = {x:right, y:top}, leftBottomPoint = {x:left, y:bottom}, rightBottomPoint = {x:right, y:bottom}, boxCenterPoint = 
  {x:centerX, y:centerY}, alignToCenterX = alignToBox.left + alignToBox.width / 2, alignToCenterY = alignToBox.top + alignToBox.height / 2, alignToBoxCenterPoint = {x:alignToCenterX, y:alignToCenterY}, centerLineSegment = new LineSegment(boxCenterPoint, alignToBoxCenterPoint), offsetLeft = 0, offsetTop = 0, tipSize, tipWidth, tipHeight, tipPosition, tipX, tipY;
  tipElement.setVisibility(false);
  tipElement.show();
  tipSize = tipElement.getSize();
  tipWidth = tipSize.width;
  tipHeight = tipSize.height;
  if (centerLineSegment.intersects(new LineSegment(leftTopPoint, rightTopPoint))) {
    tipX = Math.min(Math.max(alignToCenterX, left + tipWidth), right - tipWidth);
    tipY = top;
    offsetTop = tipHeight + 10;
    tipPosition = 'top';
  } else {
    if (centerLineSegment.intersects(new LineSegment(leftTopPoint, leftBottomPoint))) {
      tipX = left;
      tipY = Math.min(Math.max(alignToCenterY + tipWidth / 2, tipWidth * 1.6), bottom - tipWidth / 2.2);
      offsetLeft = tipHeight + 10;
      tipPosition = 'left';
    } else {
      if (centerLineSegment.intersects(new LineSegment(leftBottomPoint, rightBottomPoint))) {
        tipX = Math.min(Math.max(alignToCenterX, left + tipWidth), right - tipWidth);
        tipY = bottom;
        offsetTop = -tipHeight - 10;
        tipPosition = 'bottom';
      } else {
        if (centerLineSegment.intersects(new LineSegment(rightTopPoint, rightBottomPoint))) {
          tipX = right;
          tipY = Math.max(Math.min(alignToCenterY - tipHeight, bottom - tipWidth * 1.3), tipWidth / 2);
          offsetLeft = -tipHeight - 10;
          tipPosition = 'right';
        }
      }
    }
  }
  if (tipX || tipY) {
    this.currentTipPosition = tipPosition;
    tipElement.addCls('x-anchor-' + tipPosition);
    tipElement.setLeft(tipX - left);
    tipElement.setTop(tipY - top);
    tipElement.setVisibility(true);
    this.setLeft(this.getLeft() + offsetLeft);
    this.setTop(this.getTop() + offsetTop);
  }
}, privates:{ensureHeader:function() {
  var me = this, header;
  me.getViewModel();
  me.getItems();
  header = me.getHeader();
  if (!header && header !== false) {
    me.setHeader(true);
    header = me.getHeader();
  }
  return header;
}, setBodyBorderEnabled:function(enabled) {
  this.innerElement.setStyle('border-width', enabled ? '' : '0');
}}});
Ext.define('Ext.Button', {extend:Ext.Component, xtype:'button', isButton:true, cachedConfig:{pressedCls:Ext.baseCSSPrefix + 'button-pressing', badgeCls:Ext.baseCSSPrefix + 'badge', hasBadgeCls:Ext.baseCSSPrefix + 'hasbadge', labelCls:Ext.baseCSSPrefix + 'button-label', iconCls:null, textAlign:null}, config:{badgeText:null, text:null, icon:false, iconAlign:'left', pressedDelay:0, handler:null, scope:null, autoEvent:null, ui:null, baseCls:Ext.baseCSSPrefix + 'button'}, defaultBindProperty:'text', template:[{tag:'span', 
reference:'badgeElement', hidden:true}, {tag:'span', className:Ext.baseCSSPrefix + 'button-icon', reference:'iconElement'}, {tag:'span', reference:'textElement', hidden:true}], initialize:function() {
  this.callParent();
  this.element.on({scope:this, tap:'onTap', touchstart:'onPress', touchend:'onRelease'});
}, updateBadgeText:function(badgeText) {
  var element = this.element, badgeElement = this.badgeElement;
  if (badgeText) {
    badgeElement.show();
    badgeElement.setText(badgeText);
  } else {
    badgeElement.hide();
  }
  element[badgeText ? 'addCls' : 'removeCls'](this.getHasBadgeCls());
}, updateText:function(text) {
  var textElement = this.textElement;
  if (textElement) {
    if (text) {
      textElement.show();
      textElement.setHtml(text);
    } else {
      textElement.hide();
    }
    this.refreshIconAlign();
  }
}, updateHtml:function(html) {
  var textElement = this.textElement;
  if (html) {
    textElement.show();
    textElement.setHtml(html);
  } else {
    textElement.hide();
  }
}, updateBadgeCls:function(badgeCls, oldBadgeCls) {
  this.badgeElement.replaceCls(oldBadgeCls, badgeCls);
}, updateHasBadgeCls:function(hasBadgeCls, oldHasBadgeCls) {
  var element = this.element;
  if (element.hasCls(oldHasBadgeCls)) {
    element.replaceCls(oldHasBadgeCls, hasBadgeCls);
  }
}, updateLabelCls:function(labelCls, oldLabelCls) {
  this.textElement.replaceCls(oldLabelCls, labelCls);
}, updatePressedCls:function(pressedCls, oldPressedCls) {
  var element = this.element;
  if (element.hasCls(oldPressedCls)) {
    element.replaceCls(oldPressedCls, pressedCls);
  }
}, updateIcon:function(icon) {
  var me = this, element = me.iconElement;
  if (icon) {
    me.showIconElement();
    element.setStyle('background-image', 'url(' + icon + ')');
    me.refreshIconAlign();
  } else {
    element.setStyle('background-image', '');
    if (!me.getIconCls()) {
      me.hideIconElement();
    }
  }
}, updateIconCls:function(iconCls, oldIconCls) {
  var me = this, element = me.iconElement;
  if (iconCls) {
    me.showIconElement();
    element.replaceCls(oldIconCls, iconCls);
    me.refreshIconAlign();
  } else {
    element.removeCls(oldIconCls);
    if (!me.getIcon()) {
      me.hideIconElement();
    }
  }
}, updateIconAlign:function(alignment, oldAlignment) {
  var element = this.element, baseCls = Ext.baseCSSPrefix + 'iconalign-';
  if (!this.getText()) {
    alignment = 'center';
  }
  element.removeCls(baseCls + 'center');
  element.removeCls(baseCls + oldAlignment);
  if (this.getIcon() || this.getIconCls()) {
    element.addCls(baseCls + alignment);
  }
}, _textAlignCls:{left:Ext.baseCSSPrefix + 'text-align-left', right:Ext.baseCSSPrefix + 'text-align-right', center:''}, updateTextAlign:function(textAlign, oldValue) {
  var textAlignClasses = this._textAlignCls, add = textAlignClasses[textAlign || 'center'], remove = textAlignClasses[oldValue || 'center'];
  this.replaceCls(remove, add);
}, refreshIconAlign:function() {
  this.updateIconAlign(this.getIconAlign());
}, applyAutoEvent:function(autoEvent) {
  var me = this;
  if (typeof autoEvent == 'string') {
    autoEvent = {name:autoEvent, scope:me.scope || me};
  }
  return autoEvent;
}, updateAutoEvent:function(autoEvent) {
  var name = autoEvent.name, scope = autoEvent.scope;
  this.setHandler(function() {
    scope.fireEvent(name, scope, this);
  });
  this.setScope(scope);
}, hideIconElement:function() {
  var el = this.iconElement;
  el.removeCls(Ext.baseCSSPrefix + 'shown');
  el.addCls(Ext.baseCSSPrefix + 'hidden');
  this.element.addCls(Ext.baseCSSPrefix + 'button-no-icon');
}, showIconElement:function() {
  var el = this.iconElement;
  el.addCls(Ext.baseCSSPrefix + 'shown');
  el.removeCls(Ext.baseCSSPrefix + 'hidden');
  this.element.removeCls(Ext.baseCSSPrefix + 'button-no-icon');
}, applyUi:function(config) {
  if (config && Ext.isString(config)) {
    var array = config.split('-');
    if (array && (array[1] == 'back' || array[1] == 'forward')) {
      return array;
    }
  }
  return config;
}, getUi:function() {
  var ui = this._ui;
  if (Ext.isArray(ui)) {
    return ui.join('-');
  }
  return ui;
}, applyPressedDelay:function(delay) {
  if (Ext.isNumber(delay)) {
    return delay;
  }
  return delay ? 100 : 0;
}, onPress:function() {
  var me = this, element = me.element, pressedDelay = me.getPressedDelay(), pressedCls = me.getPressedCls();
  if (!me.getDisabled()) {
    if (pressedDelay > 0) {
      me.pressedTimeout = Ext.defer(function() {
        delete me.pressedTimeout;
        if (element) {
          element.addCls(pressedCls);
        }
      }, pressedDelay);
    } else {
      element.addCls(pressedCls);
    }
  }
}, onRelease:function(e) {
  this.fireAction('release', [this, e], 'doRelease');
}, doRelease:function(me, e) {
  if (!me.getDisabled()) {
    if (me.hasOwnProperty('pressedTimeout')) {
      clearTimeout(me.pressedTimeout);
      delete me.pressedTimeout;
    } else {
      me.element.removeCls(me.getPressedCls());
    }
  }
}, onTap:function(e) {
  if (this.getDisabled()) {
    return false;
  }
  this.fireAction('tap', [this, e], 'doTap');
}, doTap:function(me, e) {
  var handler = me.getHandler();
  if (!handler) {
    return;
  }
  if (e && e.preventDefault) {
    e.preventDefault();
  }
  Ext.callback(handler, me.getScope(), [me, e], 0, me);
}});
Ext.define('Ext.Sheet', {extend:Ext.Panel, xtype:'sheet', config:{baseCls:Ext.baseCSSPrefix + 'sheet', modal:true, centered:true, stretchX:null, stretchY:null, enter:'bottom', exit:'bottom', showAnimation:{type:'slideIn', duration:250, easing:'ease-out'}, hideAnimation:{type:'slideOut', duration:250, easing:'ease-in'}, border:null}, manageBorders:false, isInputRegex:/^(input|textarea|select|a)$/i, beforeInitialize:function() {
  var me = this;
  if (Ext.os.is.iOS) {
    this.element.dom.addEventListener('touchstart', function(e) {
      if (!me.isInputRegex.test(e.target.tagName)) {
        e.preventDefault();
      }
    }, true);
  }
}, applyHideAnimation:function(config) {
  var exit = this.getExit(), direction = exit;
  if (exit === null) {
    return null;
  }
  if (config === true) {
    config = {type:'slideOut'};
  }
  if (Ext.isString(config)) {
    config = {type:config};
  }
  var anim = Ext.factory(config, Ext.fx.Animation);
  if (anim) {
    if (exit == 'bottom') {
      direction = 'down';
    }
    if (exit == 'top') {
      direction = 'up';
    }
    anim.setDirection(direction);
  }
  return anim;
}, applyShowAnimation:function(config) {
  var enter = this.getEnter(), direction = enter;
  if (enter === null) {
    return null;
  }
  if (config === true) {
    config = {type:'slideIn'};
  }
  if (Ext.isString(config)) {
    config = {type:config};
  }
  var anim = Ext.factory(config, Ext.fx.Animation);
  if (anim) {
    if (enter == 'bottom') {
      direction = 'down';
    }
    if (enter == 'top') {
      direction = 'up';
    }
    anim.setBefore({display:null});
    anim.setReverse(true);
    anim.setDirection(direction);
  }
  return anim;
}, updateStretchX:function(newStretchX) {
  this.getLeft();
  this.getRight();
  if (newStretchX) {
    this.setLeft(0);
    this.setRight(0);
  }
}, updateStretchY:function(newStretchY) {
  this.getTop();
  this.getBottom();
  if (newStretchY) {
    this.setTop(0);
    this.setBottom(0);
  }
}});
Ext.define('Ext.Decorator', {extend:Ext.Component, isDecorator:true, config:{component:{}}, statics:{generateProxySetter:function(name) {
  return function(value) {
    var component = this.getComponent();
    component[name].call(component, value);
    return this;
  };
}, generateProxyGetter:function(name) {
  return function() {
    var component = this.getComponent();
    return component[name].call(component);
  };
}}, onClassExtended:function(Class, members) {
  if (!members.hasOwnProperty('proxyConfig')) {
    return;
  }
  var ExtClass = Ext.Class, proxyConfig = members.proxyConfig, config = members.config;
  members.config = config ? Ext.applyIf(config, proxyConfig) : proxyConfig;
  var name, nameMap, setName, getName;
  for (name in proxyConfig) {
    if (proxyConfig.hasOwnProperty(name)) {
      nameMap = Ext.Config.get(name).names;
      setName = nameMap.set;
      getName = nameMap.get;
      members[setName] = this.generateProxySetter(setName);
      members[getName] = this.generateProxyGetter(getName);
    }
  }
}, applyComponent:function(config) {
  return Ext.factory(config, Ext.Component);
}, updateComponent:function(newComponent, oldComponent) {
  var me = this;
  if (oldComponent) {
    if (me.isRendered() && oldComponent.setRendered(false)) {
      oldComponent.fireEventedAction('renderedchange', [me, oldComponent, false], me.doUnsetComponent, me, false);
    } else {
      me.doUnsetComponent(oldComponent);
    }
  }
  if (newComponent) {
    if (me.isRendered() && newComponent.setRendered(true)) {
      newComponent.fireEventedAction('renderedchange', [me, newComponent, true], me.doSetComponent, me, false);
    } else {
      me.doSetComponent(newComponent);
    }
  }
}, doUnsetComponent:function(component) {
  var dom = component.renderElement.dom;
  if (dom) {
    component.setLayoutSizeFlags(0);
    this.innerElement.dom.removeChild(dom);
  }
}, doSetComponent:function(component) {
  var dom = component.renderElement.dom;
  if (dom) {
    component.setLayoutSizeFlags(this.getSizeFlags());
    this.innerElement.dom.appendChild(dom);
  }
}, setRendered:function(rendered) {
  var component;
  if (this.callParent(arguments)) {
    component = this.getComponent();
    if (component) {
      component.setRendered(rendered);
    }
    return true;
  }
  return false;
}, setDisabled:function(disabled) {
  this.callParent(arguments);
  this.getComponent().setDisabled(disabled);
}, destroy:function() {
  Ext.destroy(this.getComponent());
  this.callParent();
}});
Ext.define('Ext.Img', {extend:Ext.Component, xtype:['image', 'img'], alternateClassName:'Ext.Image', config:{src:null, baseCls:Ext.baseCSSPrefix + 'img', imageCls:Ext.baseCSSPrefix + 'img-image', backgroundCls:Ext.baseCSSPrefix + 'img-background', mode:'background'}, beforeInitialize:function() {
  var me = this;
  me.onLoad = Ext.Function.bind(me.onLoad, me);
  me.onError = Ext.Function.bind(me.onError, me);
}, initialize:function() {
  var me = this;
  me.callParent();
  me.relayEvents(me.renderElement, '*');
  me.element.on({tap:'onTap', scope:me});
}, hide:function() {
  this.callParent(arguments);
  this.hiddenSrc = this.hiddenSrc || this.getSrc();
  this.setSrc(null);
}, show:function() {
  this.callParent(arguments);
  if (this.hiddenSrc) {
    this.setSrc(this.hiddenSrc);
    delete this.hiddenSrc;
  }
}, updateMode:function(mode) {
  var me = this, imageCls = me.getImageCls(), backgroundCls = me.getBackgroundCls();
  if (mode === 'background') {
    if (me.imageElement) {
      me.imageElement.destroy();
      delete me.imageElement;
      me.updateSrc(me.getSrc());
    }
    me.replaceCls(imageCls, backgroundCls);
  } else {
    me.imageElement = me.element.createChild({tag:'img'});
    me.replaceCls(backgroundCls, imageCls);
  }
}, updateImageCls:function(newCls, oldCls) {
  this.replaceCls(oldCls, newCls);
}, updateBackgroundCls:function(newCls, oldCls) {
  this.replaceCls(oldCls, newCls);
}, onTap:function(e) {
  this.fireEvent('tap', this, e);
}, onAfterRender:function() {
  this.updateSrc(this.getSrc());
}, applySrc:function(src) {
  return src && Ext.resolveResource(src);
}, updateSrc:function(newSrc) {
  var me = this, dom;
  if (me.getMode() === 'background') {
    dom = this.imageObject || new Image;
  } else {
    dom = me.imageElement.dom;
  }
  this.imageObject = dom;
  dom.setAttribute('src', Ext.isString(newSrc) ? newSrc : '');
  dom.addEventListener('load', me.onLoad, false);
  dom.addEventListener('error', me.onError, false);
}, detachListeners:function() {
  var dom = this.imageObject;
  if (dom) {
    dom.removeEventListener('load', this.onLoad, false);
    dom.removeEventListener('error', this.onError, false);
  }
}, onLoad:function(e) {
  this.detachListeners();
  if (this.getMode() === 'background') {
    this.element.dom.style.backgroundImage = 'url("' + this.imageObject.src + '")';
  }
  this.fireEvent('load', this, e);
}, onError:function(e) {
  this.detachListeners();
  if (this.getMode() === 'background') {
    this.element.dom.style.backgroundImage = 'url("' + this.imageObject.src + '")';
  }
  this.fireEvent('error', this, e);
}, updateWidth:function(width) {
  var sizingElement = this.getMode() === 'background' ? this.element : this.imageElement;
  sizingElement.setWidth(width);
  this.callParent(arguments);
}, updateHeight:function(height) {
  var sizingElement = this.getMode() === 'background' ? this.element : this.imageElement;
  sizingElement.setHeight(height);
  this.callParent(arguments);
}, destroy:function() {
  var me = this;
  me.detachListeners();
  me.imageObject = me.imageElement = Ext.destroy(me.imageObject, me.imageElement);
  me.callParent();
}});
Ext.define('Ext.Label', {extend:Ext.Component, xtype:'label', config:{baseCls:Ext.baseCSSPrefix + 'label'}});
Ext.define('Ext.Menu', {extend:Ext.Sheet, xtype:'menu', config:{baseCls:Ext.baseCSSPrefix + 'menu', left:0, right:0, bottom:0, height:'auto', width:'auto', defaultType:'button', showAnimation:null, hideAnimation:null, centered:false, modal:true, hidden:true, hideOnMaskTap:true, translatable:{translationMethod:null}}, constructor:function() {
  this.config.translatable.translationMethod = 'csstransform';
  this.callParent(arguments);
}, updateUi:function(newUi, oldUi) {
  this.callParent(arguments);
  if (newUi != oldUi && Ext.theme.is.Blackberry) {
    if (newUi == 'context') {
      this.innerElement.swapCls('x-vertical', 'x-horizontal');
    } else {
      if (newUi == 'application') {
        this.innerElement.swapCls('x-horizontal', 'x-vertical');
      }
    }
  }
}, updateHideOnMaskTap:function(hide) {
  var mask = this.getModal();
  if (mask) {
    mask[hide ? 'on' : 'un'].call(mask, 'tap', function() {
      Ext.Viewport.hideMenu(this.$side);
    }, this);
  }
}, updateHidden:function() {
  if (this.initialized) {
    this.callParent(arguments);
  }
}});
Ext.define('Ext.Title', {extend:Ext.Component, xtype:'title', config:{baseCls:'x-title', title:''}, updateTitle:function(newTitle) {
  this.setHtml(newTitle);
}});
Ext.define('Ext.Spacer', {extend:Ext.Component, alias:'widget.spacer', config:{}, constructor:function(config) {
  config = config || {};
  if (!config.width) {
    config.flex = 1;
  }
  this.callParent([config]);
}});
Ext.define('Ext.Toolbar', {extend:Ext.Container, xtype:'toolbar', isToolbar:true, config:{baseCls:Ext.baseCSSPrefix + 'toolbar', title:null, defaultType:'button', defaultButtonUI:null, minHeight:null, layout:{type:'hbox', align:'center'}}, hasCSSMinHeight:true, constructor:function(config) {
  config = config || {};
  if (config.docked == 'left' || config.docked == 'right') {
    config.layout = {type:'vbox', align:'stretch'};
  }
  this.callParent([config]);
}, applyTitle:function(title) {
  if (typeof title == 'string') {
    title = {title:title, centered:Ext.theme.is.Tizen ? false : true};
  }
  return Ext.factory(title, Ext.Title, this.getTitle());
}, updateTitle:function(newTitle, oldTitle) {
  if (newTitle) {
    this.add(newTitle);
  }
  if (oldTitle) {
    oldTitle.destroy();
  }
}, showTitle:function() {
  var title = this.getTitle();
  if (title) {
    title.show();
  }
}, hideTitle:function() {
  var title = this.getTitle();
  if (title) {
    title.hide();
  }
}, onItemAdd:function(item, index) {
  var defaultButtonUI = this.getDefaultButtonUI();
  if (defaultButtonUI) {
    if (item.isSegmentedButton) {
      if (item.getDefaultUI() == null) {
        item.setDefaultUI(defaultButtonUI);
      }
    } else {
      if (item.isButton && item.getUi() == null) {
        item.setUi(defaultButtonUI);
      }
    }
  }
  this.callParent([item, index]);
}, factoryItem:function(config) {
  if (config === '-\x3e') {
    config = {xtype:'component', flex:1};
  }
  return this.callParent([config]);
}});
Ext.define('Ext.theme.neptune.Toolbar', {override:'Ext.Toolbar', config:{defaultButtonUI:'action'}});
Ext.define('Ext.theme.triton.Toolbar', {override:'Ext.Toolbar', config:{defaultButtonUI:null}});
Ext.define('Ext.field.Input', {extend:Ext.Component, xtype:'input', tag:'input', cachedConfig:{cls:Ext.baseCSSPrefix + 'form-field', focusCls:Ext.baseCSSPrefix + 'field-focus', maskCls:Ext.baseCSSPrefix + 'field-mask', useMask:'auto', type:'text', checked:false}, config:{baseCls:Ext.baseCSSPrefix + 'field-input', name:null, value:null, isFocused:false, tabIndex:null, placeHolder:null, minValue:null, maxValue:null, stepValue:null, maxLength:null, autoComplete:null, autoCapitalize:null, autoCorrect:null, 
readOnly:null, maxRows:null, pattern:null, startValue:false, fastFocus:false}, getTemplate:function() {
  var items = [{reference:'input', tag:this.tag}, {reference:'mask', classList:[this.config.maskCls]}, {reference:'clearIcon', cls:'x-clear-icon'}];
  return items;
}, initElement:function() {
  var me = this;
  me.callParent();
  me.input.on({scope:me, keyup:'onKeyUp', keydown:'onKeyDown', focus:'onFocus', blur:'onBlur', input:'onInput', paste:'onPaste', tap:'onInputTap'});
  if (Ext.browser.is.AndroidStock) {
    me.input.dom.addEventListener('mousedown', function(e) {
      if (document.activeElement != e.target) {
        e.preventDefault();
      }
    });
    me.input.dom.addEventListener('touchend', function() {
      me.focus();
    });
  }
  me.mask.on({scope:me, tap:'onMaskTap'});
  if (me.clearIcon) {
    me.clearIcon.on({tap:'onClearIconTap', touchstart:'onClearIconPress', touchend:'onClearIconRelease', scope:me});
  }
  if (Ext.browser.is.ie && Ext.browser.version.major >= 10) {
    me.input.on({scope:me, keypress:'onKeyPress'});
  }
}, updateFastFocus:function(newValue) {
  if (newValue) {
    if (this.getFastFocus() && Ext.os.is.iOS) {
      this.input.on({scope:this, touchstart:'onTouchStart'});
    }
  } else {
    this.input.un({scope:this, touchstart:'onTouchStart'});
  }
}, useManualMaxLength:function() {
  return Boolean(Ext.os.is.Android && !Ext.browser.is.Chrome);
}, applyUseMask:function(useMask) {
  if (useMask === 'auto') {
    useMask = Ext.os.is.iOS && Ext.os.version.lt('5');
  }
  return Boolean(useMask);
}, updateUseMask:function(newUseMask) {
  this.mask[newUseMask ? 'show' : 'hide']();
}, updatePattern:function(pattern) {
  this.updateFieldAttribute('pattern', pattern);
}, updateFieldAttribute:function(attribute, newValue) {
  var input = this.input;
  if (!Ext.isEmpty(newValue, true)) {
    input.dom.setAttribute(attribute, newValue);
  } else {
    input.dom.removeAttribute(attribute);
  }
}, updateCls:function(newCls, oldCls) {
  this.input.addCls(Ext.baseCSSPrefix + 'input-el');
  this.input.replaceCls(oldCls, newCls);
}, updateType:function(newType, oldType) {
  var prefix = Ext.baseCSSPrefix + 'input-';
  this.input.replaceCls(prefix + oldType, prefix + newType);
  this.updateFieldAttribute('type', newType);
}, updateName:function(newName) {
  this.updateFieldAttribute('name', newName);
}, getValue:function() {
  var input = this.input;
  if (input) {
    this._value = input.dom.value;
  }
  return this._value;
}, applyValue:function(value) {
  return Ext.isEmpty(value) ? '' : value;
}, updateValue:function(newValue) {
  var input = this.input;
  if (input && input.dom.value !== newValue) {
    input.dom.value = newValue;
  }
}, setValue:function(newValue) {
  var oldValue = this._value;
  this.updateValue(this.applyValue(newValue));
  newValue = this.getValue();
  if (String(newValue) != String(oldValue) && this.initialized) {
    this.onChange(this, newValue, oldValue);
  }
  return this;
}, applyTabIndex:function(tabIndex) {
  if (tabIndex !== null && typeof tabIndex != 'number') {
    throw new Error('Ext.field.Field: [applyTabIndex] trying to pass a value which is not a number');
  }
  return tabIndex;
}, updateTabIndex:function(newTabIndex) {
  this.updateFieldAttribute('tabIndex', newTabIndex);
}, testAutoFn:function(value) {
  return [true, 'on'].indexOf(value) !== -1;
}, applyMaxLength:function(maxLength) {
  if (maxLength !== null && typeof maxLength != 'number') {
    throw new Error('Ext.field.Text: [applyMaxLength] trying to pass a value which is not a number');
  }
  return maxLength;
}, updateMaxLength:function(newMaxLength) {
  if (!this.useManualMaxLength()) {
    this.updateFieldAttribute('maxlength', newMaxLength);
  }
}, updatePlaceHolder:function(newPlaceHolder) {
  this.updateFieldAttribute('placeholder', newPlaceHolder);
}, applyAutoComplete:function(autoComplete) {
  return this.testAutoFn(autoComplete);
}, updateAutoComplete:function(newAutoComplete) {
  var value = newAutoComplete ? 'on' : 'off';
  this.updateFieldAttribute('autocomplete', value);
}, applyAutoCapitalize:function(autoCapitalize) {
  return this.testAutoFn(autoCapitalize);
}, updateAutoCapitalize:function(newAutoCapitalize) {
  var value = newAutoCapitalize ? 'on' : 'off';
  this.updateFieldAttribute('autocapitalize', value);
}, applyAutoCorrect:function(autoCorrect) {
  return this.testAutoFn(autoCorrect);
}, updateAutoCorrect:function(newAutoCorrect) {
  var value = newAutoCorrect ? 'on' : 'off';
  this.updateFieldAttribute('autocorrect', value);
}, updateMinValue:function(newMinValue) {
  this.updateFieldAttribute('min', newMinValue);
}, updateMaxValue:function(newMaxValue) {
  this.updateFieldAttribute('max', newMaxValue);
}, updateStepValue:function(newStepValue) {
  this.updateFieldAttribute('step', newStepValue);
}, checkedRe:/^(true|1|on)/i, getChecked:function() {
  var el = this.input, checked;
  if (el) {
    checked = el.dom.checked;
    this._checked = checked;
  }
  return checked;
}, applyChecked:function(checked) {
  return !!this.checkedRe.test(String(checked));
}, setChecked:function(newChecked) {
  this.updateChecked(this.applyChecked(newChecked));
  this._checked = newChecked;
}, updateChecked:function(newChecked) {
  this.input.dom.checked = newChecked;
}, updateReadOnly:function(readOnly) {
  this.updateFieldAttribute('readonly', readOnly ? true : null);
}, applyMaxRows:function(maxRows) {
  if (maxRows !== null && typeof maxRows !== 'number') {
    throw new Error('Ext.field.Input: [applyMaxRows] trying to pass a value which is not a number');
  }
  return maxRows;
}, updateMaxRows:function(newRows) {
  this.updateFieldAttribute('rows', newRows);
}, updateDisabled:function(disabled) {
  this.callParent(arguments);
  if (Ext.browser.is.Safari && !Ext.os.is.BlackBerry) {
    this.input.dom.tabIndex = disabled ? -1 : 0;
  }
  this.input.dom.disabled = Ext.browser.is.Safari && !Ext.os.is.BlackBerry ? false : disabled;
  if (!disabled) {
    this.blur();
  }
}, isDirty:function() {
  if (this.getDisabled()) {
    return false;
  }
  return String(this.getValue()) !== String(this.originalValue);
}, reset:function() {
  this.setValue(this.originalValue);
}, onInputTap:function(e) {
  this.fireAction('inputtap', [this, e], 'doInputTap');
}, doInputTap:function(me, e) {
  if (me.getDisabled()) {
    return false;
  }
  if (this.getFastFocus() && Ext.os.is.iOS) {
    me.focus();
  }
}, onMaskTap:function(e) {
  this.fireAction('masktap', [this, e], 'doMaskTap');
}, doMaskTap:function(me, e) {
  if (me.getDisabled()) {
    return false;
  }
  me.focus();
}, showMask:function() {
  if (this.getUseMask()) {
    this.mask.setStyle('display', 'block');
  }
}, hideMask:function() {
  if (this.getUseMask()) {
    this.mask.setStyle('display', 'none');
  }
}, focus:function() {
  var me = this, el = me.input;
  if (el && el.dom.focus) {
    el.dom.focus();
  }
  return me;
}, blur:function() {
  var me = this, el = this.input;
  if (el && el.dom.blur) {
    el.dom.blur();
  }
  return me;
}, select:function() {
  var me = this, el = me.input;
  if (el && el.dom.setSelectionRange) {
    el.dom.setSelectionRange(0, 9999);
  }
  return me;
}, onFocus:function(e) {
  this.fireAction('focus', [e], 'doFocus');
}, doFocus:function(e) {
  var me = this;
  me.hideMask();
  if (!me.getIsFocused()) {
    me.setStartValue(me.getValue());
  }
  me.setIsFocused(true);
}, onTouchStart:function(e) {
  if (document.activeElement != e.target) {
    e.preventDefault();
  }
}, onBlur:function(e) {
  this.fireAction('blur', [e], 'doBlur');
}, doBlur:function(e) {
  var me = this, value = me.getValue(), startValue = me.getStartValue();
  me.showMask();
  me.setIsFocused(false);
  if (String(value) != String(startValue)) {
    me.onChange(me, value, startValue);
  }
}, onClearIconTap:function(e) {
  this.fireEvent('clearicontap', this, e);
  if (Ext.os.is.Android) {
    this.focus();
  }
}, onClearIconPress:function() {
  this.clearIcon.addCls(Ext.baseCSSPrefix + 'pressing');
}, onClearIconRelease:function() {
  this.clearIcon.removeCls(Ext.baseCSSPrefix + 'pressing');
}, onClick:function(e) {
  this.fireEvent('click', e);
}, onChange:function(me, value, startValue) {
  if (this.useManualMaxLength()) {
    this.trimValueToMaxLength();
  }
  this.fireEvent('change', me, value, startValue);
}, onPaste:function(e) {
  if (this.useManualMaxLength()) {
    this.trimValueToMaxLength();
  }
  this.fireEvent('paste', e);
}, onKeyUp:function(e) {
  if (this.useManualMaxLength()) {
    this.trimValueToMaxLength();
  }
  this.fireEvent('keyup', e);
}, onKeyDown:function() {
  this.ignoreInput = true;
}, onInput:function(e) {
  var me = this;
  me.fireEvent('input', me, me.input.dom.value);
  if (me.ignoreInput) {
    me.ignoreInput = false;
    return;
  }
  Ext.defer(function() {
    if (!me.ignoreInput) {
      me.fireEvent('keyup', e);
      me.ignoreInput = false;
    }
  }, 10);
}, onKeyPress:function(e) {
  if (e.browserEvent.keyCode == 13) {
    this.fireEvent('keyup', e);
  }
}, onMouseDown:function(e) {
  this.fireEvent('mousedown', e);
}, trimValueToMaxLength:function() {
  var maxLength = this.getMaxLength();
  if (maxLength) {
    var value = this.getValue();
    if (value.length > this.getMaxLength()) {
      this.setValue(value.slice(0, maxLength));
    }
  }
}});
Ext.define('Ext.field.Field', {extend:Ext.Decorator, alternateClassName:'Ext.form.Field', xtype:'field', isField:true, isFormField:true, config:{baseCls:Ext.baseCSSPrefix + 'field', label:null, labelAlign:'left', labelWidth:'30%', labelWrap:false, clearIcon:null, required:false, inputType:null, name:null, value:null, tabIndex:null}, cachedConfig:{labelCls:null, requiredCls:Ext.baseCSSPrefix + 'field-required', inputCls:null}, noWrapCls:Ext.baseCSSPrefix + 'form-label-nowrap', getElementConfig:function() {
  var prefix = Ext.baseCSSPrefix;
  return {reference:'element', className:Ext.baseCSSPrefix + 'container', children:[{reference:'label', cls:prefix + 'form-label', children:[{reference:'labelspan', tag:'span'}]}, {reference:'innerElement', cls:prefix + 'component-outer'}]};
}, updateLabel:function(newLabel, oldLabel) {
  var renderElement = this.renderElement, prefix = Ext.baseCSSPrefix;
  if (newLabel) {
    this.labelspan.setHtml(newLabel);
    renderElement.addCls(prefix + 'field-labeled');
  } else {
    renderElement.removeCls(prefix + 'field-labeled');
  }
}, updateLabelAlign:function(newLabelAlign, oldLabelAlign) {
  var renderElement = this.renderElement, prefix = Ext.baseCSSPrefix;
  if (newLabelAlign) {
    renderElement.addCls(prefix + 'label-align-' + newLabelAlign);
    if (newLabelAlign == 'top' || newLabelAlign == 'bottom') {
      this.label.setWidth('100%');
    } else {
      this.updateLabelWidth(this.getLabelWidth());
    }
  }
  if (oldLabelAlign) {
    renderElement.removeCls(prefix + 'label-align-' + oldLabelAlign);
  }
}, updateLabelCls:function(newLabelCls, oldLabelCls) {
  if (newLabelCls) {
    this.label.addCls(newLabelCls);
  }
  if (oldLabelCls) {
    this.label.removeCls(oldLabelCls);
  }
}, updateLabelWidth:function(newLabelWidth) {
  var labelAlign = this.getLabelAlign();
  if (newLabelWidth) {
    if (labelAlign == 'top' || labelAlign == 'bottom') {
      this.label.setWidth('100%');
    } else {
      this.label.setWidth(newLabelWidth);
    }
  }
}, updateLabelWrap:function(newLabelWrap, oldLabelWrap) {
  this.toggleCls(this.noWrapCls, !newLabelWrap);
}, updateRequired:function(newRequired) {
  this.renderElement.toggleCls(this.getRequiredCls(), newRequired);
}, updateRequiredCls:function(newRequiredCls, oldRequiredCls) {
  if (this.getRequired()) {
    this.renderElement.replaceCls(oldRequiredCls, newRequiredCls);
  }
}, initialize:function() {
  var me = this;
  me.callParent();
  me.doInitValue();
}, doInitValue:function() {
  this.originalValue = this.getInitialConfig().value;
}, reset:function() {
  this.setValue(this.originalValue);
  return this;
}, resetOriginalValue:function() {
  this.originalValue = this.getValue();
}, isDirty:function() {
  return false;
}});
Ext.define('Ext.field.Text', {extend:Ext.field.Field, xtype:'textfield', alternateClassName:'Ext.form.Text', config:{ui:'text', clearIcon:true, placeHolder:null, maxLength:null, autoComplete:null, autoCapitalize:null, autoCorrect:null, readOnly:null, component:{xtype:'input', type:'text', fastFocus:false}, bubbleEvents:['action']}, defaultBindProperty:'value', twoWayBindable:{value:1}, publishes:{value:1}, focusedCls:Ext.baseCSSPrefix + 'field-focused', clearableCls:Ext.baseCSSPrefix + 'field-clearable', 
emptyCls:Ext.baseCSSPrefix + 'empty', initialize:function() {
  var me = this;
  me.callParent();
  me.getComponent().on({scope:this, keyup:'onKeyUp', input:'onInput', focus:'onFocus', blur:'onBlur', paste:'onPaste', mousedown:'onMouseDown', clearicontap:'onClearIconTap'});
  me.originalValue = me.getValue() || '';
  me.getComponent().originalValue = me.originalValue;
  me.syncEmptyCls();
}, syncEmptyCls:function() {
  var val = this._value, empty = val ? val.length : false;
  this.toggleCls(this.emptyCls, !empty);
}, applyValue:function(value) {
  return Ext.isEmpty(value) ? '' : value;
}, updateValue:function(value, oldValue) {
  var me = this, component = me.getComponent(), valueValid = value !== undefined && value !== null && value !== '';
  if (component) {
    component.setValue(value);
  }
  me.toggleClearIcon(valueValid && me.isDirty());
  me.syncEmptyCls();
  if (me.initialized) {
    me.fireEvent('change', me, value, oldValue);
  }
}, updatePlaceHolder:function(newPlaceHolder) {
  this.getComponent().setPlaceHolder(newPlaceHolder);
}, updateMaxLength:function(newMaxLength) {
  this.getComponent().setMaxLength(newMaxLength);
}, updateAutoComplete:function(newAutoComplete) {
  this.getComponent().setAutoComplete(newAutoComplete);
}, updateAutoCapitalize:function(newAutoCapitalize) {
  this.getComponent().setAutoCapitalize(newAutoCapitalize);
}, updateAutoCorrect:function(newAutoCorrect) {
  this.getComponent().setAutoCorrect(newAutoCorrect);
}, updateReadOnly:function(newReadOnly) {
  this.toggleClearIcon(!newReadOnly);
  this.getComponent().setReadOnly(newReadOnly);
}, updateInputType:function(newInputType) {
  var component = this.getComponent();
  if (component) {
    component.setType(newInputType);
  }
}, updateName:function(newName) {
  var component = this.getComponent();
  if (component) {
    component.setName(newName);
  }
}, updateTabIndex:function(newTabIndex) {
  var component = this.getComponent();
  if (component) {
    component.setTabIndex(newTabIndex);
  }
}, updateInputCls:function(newInputCls, oldInputCls) {
  var component = this.getComponent();
  if (component) {
    component.replaceCls(oldInputCls, newInputCls);
  }
}, updateDisabled:function(disabled, oldDisabled) {
  this.callParent([disabled, oldDisabled]);
  var component = this.getComponent();
  if (component) {
    component.setDisabled(disabled);
  }
  this.toggleClearIcon(!disabled);
}, showClearIcon:function() {
  var me = this, value = me.getValue(), valueValid = value !== undefined && value !== null && value !== '';
  if (me.getClearIcon() && !me.getDisabled() && !me.getReadOnly() && valueValid) {
    me.element.addCls(me.clearableCls);
  }
  return me;
}, hideClearIcon:function() {
  if (this.getClearIcon()) {
    this.element.removeCls(this.clearableCls);
  }
}, onKeyUp:function(e) {
  this.fireAction('keyup', [this, e], 'doKeyUp');
}, doKeyUp:function(me, e) {
  var value = me.getValue(), valueValid = value !== undefined && value !== null && value !== '';
  me.toggleClearIcon(valueValid);
  if (e.browserEvent.keyCode === 13) {
    me.fireAction('action', [me, e], 'doAction');
  }
}, doAction:function() {
  this.blur();
}, onClearIconTap:function(input, e) {
  this.fireAction('clearicontap', [this, input, e], 'doClearIconTap');
}, doClearIconTap:function(me, e) {
  me.setValue('');
}, onInput:function(component, value) {
  this.setValue(value);
}, onFocus:function(e) {
  var me = this;
  me.addCls(me.focusedCls);
  me.isFocused = true;
  me.fireEvent('focus', me, e);
}, onBlur:function(e) {
  var me = this;
  me.removeCls(me.focusedCls);
  me.isFocused = false;
  me.fireEvent('blur', me, e);
  Ext.defer(function() {
    me.isFocused = false;
  }, 50);
}, onPaste:function(e) {
  this.fireEvent('paste', this, e);
}, onMouseDown:function(e) {
  this.fireEvent('mousedown', this, e);
}, focus:function() {
  this.getComponent().focus();
  return this;
}, blur:function() {
  this.getComponent().blur();
  return this;
}, select:function() {
  this.getComponent().select();
  return this;
}, resetOriginalValue:function() {
  var me = this, comp;
  me.callParent();
  component = me.getComponent();
  if (component && component.hasOwnProperty('originalValue')) {
    me.getComponent().originalValue = me.originalValue;
  }
  me.reset();
}, reset:function() {
  var me = this;
  me.getComponent().reset();
  me.getValue();
  me.toggleClearIcon(me.isDirty());
}, isDirty:function() {
  var component = this.getComponent();
  if (component) {
    return component.isDirty();
  }
  return false;
}, privates:{toggleClearIcon:function(state) {
  if (state) {
    this.showClearIcon();
  } else {
    this.hideClearIcon();
  }
}}});
Ext.define('Ext.field.TextAreaInput', {extend:Ext.field.Input, xtype:'textareainput', tag:'textarea'});
Ext.define('Ext.field.TextArea', {extend:Ext.field.Text, xtype:'textareafield', alternateClassName:'Ext.form.TextArea', config:{ui:'textarea', autoCapitalize:false, component:{xtype:'textareainput'}, maxRows:null}, updateMaxRows:function(newRows) {
  this.getComponent().setMaxRows(newRows);
}, updateHeight:function(height, oldHeight) {
  this.callParent([height, oldHeight]);
  this.getComponent().input.setHeight(height);
}, updateWidth:function(width, oldWidth) {
  this.callParent([width, oldWidth]);
  this.getComponent().input.setWidth(width);
}, doKeyUp:function(me) {
  this.toggleClearIcon(this.getValue());
}});
Ext.define('Ext.MessageBox', {extend:Ext.Sheet, xtype:'messagebox', config:{baseCls:Ext.baseCSSPrefix + 'msgbox', iconCls:null, showAnimation:{type:'popIn', duration:250, easing:'ease-out'}, hideAnimation:{type:'popOut', duration:250, easing:'ease-out'}, zIndex:999, defaultTextHeight:75, title:null, buttons:null, message:null, prompt:null, modal:true, layout:{type:'vbox', pack:'center'}}, statics:{OK:{text:'OK', itemId:'ok', ui:'action'}, YES:{text:'Yes', itemId:'yes', ui:'action'}, NO:{text:'No', 
itemId:'no'}, CANCEL:{text:'Cancel', itemId:'cancel'}, INFO:Ext.baseCSSPrefix + 'msgbox-info', WARNING:Ext.baseCSSPrefix + 'msgbox-warning', QUESTION:Ext.baseCSSPrefix + 'msgbox-question', ERROR:Ext.baseCSSPrefix + 'msgbox-error', OKCANCEL:[{text:'Cancel', itemId:'cancel'}, {text:'OK', itemId:'ok', ui:'action'}], YESNOCANCEL:[{text:'Cancel', itemId:'cancel'}, {text:'No', itemId:'no'}, {text:'Yes', itemId:'yes', ui:'action'}], YESNO:[{text:'No', itemId:'no'}, {text:'Yes', itemId:'yes', ui:'action'}]}, 
constructor:function(config) {
  config = config || {};
  if (config.hasOwnProperty('multiline') || config.hasOwnProperty('multiLine')) {
    config.prompt = config.prompt || {};
    Ext.applyIf(config.prompt, {multiLine:config.multiline || config.multiLine});
    delete config.multiline;
    delete config.multiLine;
  }
  this.defaultAllowedConfig = {};
  var allowedConfigs = ['ui', 'showAnimation', 'hideAnimation', 'title', 'message', 'prompt', 'iconCls', 'buttons', 'defaultTextHeight'], ln = allowedConfigs.length, i, allowedConfig;
  for (i = 0; i < ln; i++) {
    allowedConfig = allowedConfigs[i];
    this.defaultAllowedConfig[allowedConfig] = this.defaultConfig[allowedConfig];
  }
  this.callParent([config]);
}, applyTitle:function(config) {
  if (typeof config == 'string') {
    config = {title:config};
  }
  Ext.applyIf(config, {docked:'top', ui:Ext.filterPlatform('blackberry') ? 'light' : null, cls:this.getBaseCls() + '-title'});
  if (Ext.theme.is.Tizen) {
    Ext.applyIf(config, {centered:false});
  }
  return Ext.factory(config, Ext.Toolbar, this.getTitle());
}, updateTitle:function(newTitle) {
  if (newTitle) {
    this.add(newTitle);
  }
}, updateButtons:function(newButtons) {
  var me = this;
  newButtons = !newButtons || newButtons.length === 0 ? false : newButtons;
  if (newButtons) {
    if (me.buttonsToolbar) {
      me.buttonsToolbar.show();
      me.buttonsToolbar.removeAll();
      me.buttonsToolbar.setItems(newButtons);
    } else {
      var layout = {type:'hbox', pack:'center'};
      var isFlexed = Ext.theme.is.MountainView || Ext.theme.is.Blackberry;
      me.buttonsToolbar = Ext.create('Ext.Toolbar', {docked:'bottom', defaultType:'button', defaults:{flex:isFlexed ? 1 : undefined, ui:Ext.theme.is.Blackberry ? 'action' : undefined}, layout:layout, ui:me.getUi(), cls:me.getBaseCls() + '-buttons', items:newButtons});
      me.add(me.buttonsToolbar);
    }
  } else {
    if (me.buttonsToolbar) {
      me.buttonsToolbar.hide();
    }
  }
}, applyMessage:function(config) {
  config = {html:config, cls:this.getBaseCls() + '-text'};
  return Ext.factory(config, Ext.Component, this._message);
}, updateMessage:function(newMessage) {
  if (newMessage) {
    this.add(newMessage);
  }
}, getMessage:function() {
  if (this._message) {
    return this._message.getHtml();
  }
  return null;
}, applyIconCls:function(config) {
  config = {xtype:'component', docked:'left', width:40, height:40, baseCls:Ext.baseCSSPrefix + 'icon', hidden:config ? false : true, cls:config};
  return Ext.factory(config, Ext.Component, this._iconCls);
}, updateIconCls:function(newIconCls, oldIconCls) {
  this.getTitle();
  this.getButtons();
  if (newIconCls) {
    this.add(newIconCls);
  } else {
    this.remove(oldIconCls);
  }
}, getIconCls:function() {
  var icon = this._iconCls, iconCls;
  if (icon) {
    iconCls = icon.getCls();
    return iconCls ? iconCls[0] : null;
  }
  return null;
}, applyPrompt:function(prompt) {
  if (prompt) {
    var config = {label:false};
    if (Ext.isObject(prompt)) {
      Ext.apply(config, prompt);
    }
    if (config.multiLine) {
      config.height = Ext.isNumber(config.multiLine) ? parseFloat(config.multiLine) : this.getDefaultTextHeight();
      return Ext.factory(config, Ext.field.TextArea, this.getPrompt());
    } else {
      return Ext.factory(config, Ext.field.Text, this.getPrompt());
    }
  }
  return prompt;
}, updatePrompt:function(newPrompt, oldPrompt) {
  if (newPrompt) {
    this.add(newPrompt);
  }
  if (oldPrompt) {
    this.remove(oldPrompt);
  }
}, onClick:function(button) {
  if (button) {
    var config = button.config.userConfig || {}, initialConfig = button.getInitialConfig(), prompt = this.getPrompt();
    if (typeof config.fn == 'function') {
      button.disable();
      this.on({hiddenchange:function() {
        config.fn.call(config.scope || null, initialConfig.itemId || initialConfig.text, prompt ? prompt.getValue() : null, config);
        button.enable();
      }, single:true, scope:this});
    }
    if (config.input) {
      config.input.dom.blur();
    }
  }
  this.hide();
}, show:function(initialConfig) {
  Ext.util.InputBlocker.blockInputs();
  if (!this.getParent() && Ext.Viewport) {
    Ext.Viewport.add(this);
  }
  if (!initialConfig) {
    return this.callParent();
  }
  var config = Ext.apply({}, initialConfig), buttons = initialConfig.buttons || Ext.MessageBox.OK || [], buttonBarItems = [], userConfig = initialConfig;
  Ext.each(buttons, function(buttonConfig) {
    if (!buttonConfig) {
      return;
    }
    buttonBarItems.push(Ext.apply({userConfig:userConfig, scope:this, handler:'onClick'}, buttonConfig));
  }, this);
  config.buttons = buttonBarItems;
  config.prompt = config.prompt || null;
  if (config.multiLine) {
    config.prompt = config.prompt || {};
    config.prompt.multiLine = config.multiLine;
    delete config.multiLine;
  }
  delete config.value;
  delete config.fn;
  delete config.scope;
  config = Ext.merge({}, this.defaultAllowedConfig, config);
  this.setConfig(config);
  var prompt = this.getPrompt();
  if (prompt) {
    prompt.setValue(initialConfig.value || '');
  }
  this.callParent();
  return this;
}, alert:function(title, message, fn, scope) {
  return this.show({title:title || null, message:message || null, buttons:Ext.MessageBox.OK, prompt:false, fn:function() {
    if (fn) {
      Ext.callback(fn, scope, arguments);
    }
  }, scope:scope});
}, confirm:function(title, message, fn, scope) {
  return this.show({title:title || null, message:message || null, buttons:Ext.MessageBox.YESNO, prompt:false, scope:scope, fn:function() {
    if (fn) {
      Ext.callback(fn, scope, arguments);
    }
  }});
}, prompt:function(title, message, fn, scope, multiLine, value, prompt) {
  return this.show({title:title || null, message:message || null, buttons:Ext.MessageBox.OKCANCEL, scope:scope, prompt:prompt || true, multiLine:multiLine, value:value, fn:function() {
    if (fn) {
      Ext.callback(fn, scope, arguments);
    }
  }});
}}, function(MessageBox) {
  Ext.onInternalReady(function() {
    Ext.Msg = new MessageBox;
  });
});
Ext.define('Ext.TitleBar', {extend:Ext.Container, xtype:'titlebar', defaultBindProperty:'title', isToolbar:true, config:{baseCls:Ext.baseCSSPrefix + 'toolbar', cls:Ext.baseCSSPrefix + 'navigation-bar', ui:'dark', title:null, titleAlign:'center', defaultType:'button', minHeight:null, layout:{type:'hbox'}, items:[], maxButtonWidth:'40%'}, hasCSSMinHeight:true, beforeInitialize:function() {
  this.applyItems = this.applyInitialItems;
}, initialize:function() {
  delete this.applyItems;
  this.add(this.initialItems);
  delete this.initialItems;
  this.on({painted:'refreshTitlePosition', single:true});
}, applyInitialItems:function(items) {
  var me = this, titleAlign = me.getTitleAlign(), defaults = me.getDefaults() || {};
  me.initialItems = items;
  me.leftBox = me.add({xtype:'container', style:'position: relative', layout:{type:'hbox', align:'center'}, listeners:{resize:'refreshTitlePosition', scope:me}});
  me.spacer = me.add({xtype:'component', style:'position: relative', flex:1, listeners:{resize:'refreshTitlePosition', scope:me}});
  me.rightBox = me.add({xtype:'container', style:'position: relative', layout:{type:'hbox', align:'center'}, listeners:{resize:'refreshTitlePosition', scope:me}});
  switch(titleAlign) {
    case 'left':
      me.titleComponent = me.leftBox.add({xtype:'title', cls:Ext.baseCSSPrefix + 'title-align-left', hidden:defaults.hidden});
      me.refreshTitlePosition = Ext.emptyFn;
      break;
    case 'right':
      me.titleComponent = me.rightBox.add({xtype:'title', cls:Ext.baseCSSPrefix + 'title-align-right', hidden:defaults.hidden});
      me.refreshTitlePosition = Ext.emptyFn;
      break;
    default:
      me.titleComponent = me.add({xtype:'title', hidden:defaults.hidden, centered:true});
      break;
  }
  me.doAdd = me.doBoxAdd;
  me.remove = me.doBoxRemove;
  me.doInsert = me.doBoxInsert;
}, doBoxAdd:function(item) {
  if (item.config.align == 'right') {
    this.rightBox.add(item);
  } else {
    this.leftBox.add(item);
  }
}, doBoxRemove:function(item, destroy) {
  if (item.config.align == 'right') {
    this.rightBox.remove(item, destroy);
  } else {
    this.leftBox.remove(item, destroy);
  }
}, doBoxInsert:function(index, item) {
  if (item.config.align == 'right') {
    this.rightBox.insert(index, item);
  } else {
    this.leftBox.insert(index, item);
  }
}, calculateMaxButtonWidth:function() {
  var maxButtonWidth = this.getMaxButtonWidth();
  if (Ext.isString(maxButtonWidth)) {
    maxButtonWidth = parseInt(maxButtonWidth.replace('%', ''), 10);
  }
  maxButtonWidth = Math.round(this.element.getWidth() / 100 * maxButtonWidth);
  return maxButtonWidth;
}, refreshTitlePosition:function() {
  if (this.destroyed) {
    return;
  }
  var titleElement = this.titleComponent.renderElement;
  titleElement.setWidth(null);
  titleElement.setLeft(null);
  var leftBox = this.leftBox, leftButton = leftBox.down('button'), singleButton = leftBox.getItems().getCount() == 1, leftBoxWidth, maxButtonWidth;
  if (leftButton && singleButton) {
    if (leftButton.getWidth() == null) {
      leftButton.renderElement.setWidth('auto');
    }
    leftBoxWidth = leftBox.renderElement.getWidth();
    maxButtonWidth = this.calculateMaxButtonWidth();
    if (leftBoxWidth > maxButtonWidth) {
      leftButton.renderElement.setWidth(maxButtonWidth);
    }
  }
  var spacerBox = this.spacer.renderElement.getBox();
  if (Ext.browser.is.IE) {
    titleElement.setWidth(spacerBox.width);
  }
  var titleBox = titleElement.getBox(), widthDiff = titleBox.width - spacerBox.width, titleLeft = titleBox.left, titleRight = titleBox.right, halfWidthDiff, leftDiff, rightDiff;
  if (widthDiff > 0) {
    halfWidthDiff = widthDiff / 2;
    titleLeft += halfWidthDiff;
    titleRight -= halfWidthDiff;
    titleElement.setWidth(spacerBox.width);
  }
  leftDiff = spacerBox.left - titleLeft;
  rightDiff = titleRight - spacerBox.right;
  if (leftDiff > 0) {
    titleElement.setLeft(leftDiff);
  } else {
    if (rightDiff > 0) {
      titleElement.setLeft(-rightDiff);
    }
  }
  titleElement.repaint();
}, updateTitle:function(newTitle) {
  this.getItems();
  this.titleComponent.setTitle(newTitle);
  if (this.isPainted()) {
    this.refreshTitlePosition();
  }
}});
Ext.define('Ext.dataview.component.DataItem', {extend:Ext.Container, xtype:'dataitem', config:{baseCls:Ext.baseCSSPrefix + 'data-item', defaultType:'component', record:null, itemCls:null, dataMap:{}, dataview:null, width:'100%', items:[{xtype:'component'}]}, updateBaseCls:function(newBaseCls, oldBaseCls) {
  var me = this;
  me.callParent(arguments);
}, updateItemCls:function(newCls, oldCls) {
  if (oldCls) {
    this.removeCls(oldCls);
  }
  if (newCls) {
    this.addCls(newCls);
  }
}, doMapData:function(dataMap, data, item) {
  var componentName, component, setterMap, setterName;
  for (componentName in dataMap) {
    setterMap = dataMap[componentName];
    component = this[componentName]();
    if (component) {
      for (setterName in setterMap) {
        if (data && component[setterName] && data[setterMap[setterName]] !== undefined && data[setterMap[setterName]] !== null) {
          component[setterName](data[setterMap[setterName]]);
        }
      }
    }
  }
  if (item) {
    item.updateData(data);
  }
}, updateRecord:function(newRecord) {
  if (!newRecord) {
    return;
  }
  this._record = newRecord;
  var me = this, dataview = me.dataview || this.getDataview(), data = dataview.prepareData(newRecord.getData(true), dataview.getStore().indexOf(newRecord), newRecord), items = me.getItems(), item = items.first(), dataMap = me.getDataMap();
  if (!item) {
    return;
  }
  if (dataMap) {
    this.doMapData(dataMap, data, item);
  }
  me.fireEvent('updatedata', me, data);
}});
Ext.define('Ext.dataview.component.Container', {extend:Ext.Container, constructor:function() {
  this.itemCache = [];
  this.callParent(arguments);
}, doInitialize:function() {
  this.innerElement.on({touchstart:'onItemTouchStart', touchend:'onItemTouchEnd', tap:'onItemTap', taphold:'onItemTapHold', touchmove:'onItemTouchMove', singletap:'onItemSingleTap', doubletap:'onItemDoubleTap', swipe:'onItemSwipe', delegate:'\x3e .' + Ext.baseCSSPrefix + 'data-item', scope:this});
}, initialize:function() {
  this.callParent();
  this.doInitialize();
}, onItemTouchStart:function(e) {
  var me = this, target = e.currentTarget, item = Ext.getCmp(target.id);
  item.on({touchmove:'onItemTouchMove', scope:me, single:true});
  me.fireEvent('itemtouchstart', me, item, me.indexOf(item), e);
}, onItemTouchMove:function(e) {
  var me = this, target = e.currentTarget, item = Ext.getCmp(target.id);
  me.fireEvent('itemtouchmove', me, item, me.indexOf(item), e);
}, onItemTouchEnd:function(e) {
  var me = this, target = e.currentTarget, item = Ext.getCmp(target.id);
  item.un({touchmove:'onItemTouchMove', scope:me});
  me.fireEvent('itemtouchend', me, item, me.indexOf(item), e);
}, onItemTap:function(e) {
  var me = this, target = e.currentTarget, item = Ext.getCmp(target.id);
  me.fireEvent('itemtap', me, item, me.indexOf(item), e);
}, onItemTapHold:function(e) {
  var me = this, target = e.currentTarget, item = Ext.getCmp(target.id);
  me.fireEvent('itemtaphold', me, item, me.indexOf(item), e);
}, onItemSingleTap:function(e) {
  var me = this, target = e.currentTarget, item = Ext.getCmp(target.id);
  me.fireEvent('itemsingletap', me, item, me.indexOf(item), e);
}, onItemDoubleTap:function(e) {
  var me = this, target = e.currentTarget, item = Ext.getCmp(target.id);
  me.fireEvent('itemdoubletap', me, item, me.indexOf(item), e);
}, onItemSwipe:function(e) {
  var me = this, target = e.currentTarget, item = Ext.getCmp(target.id);
  me.fireEvent('itemswipe', me, item, me.indexOf(item), e);
}, moveItemsToCache:function(from, to) {
  var me = this, dataview = me.dataview, maxItemCache = dataview.getMaxItemCache(), items = me.getViewItems(), itemCache = me.itemCache, cacheLn = itemCache.length, pressedCls = dataview.getPressedCls(), selectedCls = dataview.getSelectedCls(), i = to - from, item;
  for (; i >= 0; i--) {
    item = items[from + i];
    if (cacheLn !== maxItemCache) {
      me.remove(item, false);
      item.removeCls([pressedCls, selectedCls]);
      itemCache.push(item);
      cacheLn++;
    } else {
      item.destroy();
    }
  }
  if (me.getViewItems().length == 0) {
    this.dataview.showEmptyText();
  }
}, moveItemsFromCache:function(records) {
  var me = this, dataview = me.dataview, store = dataview.getStore(), ln = records.length, xtype = dataview.getDefaultType(), itemConfig = dataview.getItemConfig(), itemCache = me.itemCache, cacheLn = itemCache.length, items = [], i, item, record;
  if (ln) {
    dataview.hideEmptyText();
  }
  for (i = 0; i < ln; i++) {
    records[i]._tmpIndex = store.indexOf(records[i]);
  }
  Ext.Array.sort(records, function(record1, record2) {
    return record1._tmpIndex > record2._tmpIndex ? 1 : -1;
  });
  for (i = 0; i < ln; i++) {
    record = records[i];
    if (cacheLn) {
      cacheLn--;
      item = itemCache.pop();
      this.updateListItem(record, item);
    } else {
      item = me.getDataItemConfig(xtype, record, itemConfig);
    }
    item = this.insert(record._tmpIndex, item);
    delete record._tmpIndex;
  }
  return items;
}, getViewItems:function() {
  return this.getInnerItems();
}, updateListItem:function(record, item) {
  if (item.updateRecord) {
    if (item.getRecord() === record) {
      item.updateRecord(record);
    } else {
      item.setRecord(record);
    }
  }
}, getDataItemConfig:function(xtype, record, itemConfig) {
  var dataview = this.dataview, dataItemConfig = {xtype:xtype, record:record, itemCls:dataview.getItemCls(), defaults:itemConfig, dataview:dataview};
  return Ext.merge(dataItemConfig, itemConfig);
}, doRemoveItemCls:function(cls) {
  var items = this.getViewItems(), ln = items.length, i = 0;
  for (; i < ln; i++) {
    items[i].removeCls(cls);
  }
}, doAddItemCls:function(cls) {
  var items = this.getViewItems(), ln = items.length, i = 0;
  for (; i < ln; i++) {
    items[i].addCls(cls);
  }
}, updateAtNewIndex:function(oldIndex, newIndex, record) {
  this.moveItemsToCache(oldIndex, oldIndex);
  this.moveItemsFromCache([record]);
}, destroy:function() {
  var me = this, itemCache = me.itemCache, ln = itemCache.length, i = 0;
  for (; i < ln; i++) {
    itemCache[i].destroy();
  }
  this.callParent();
}});
Ext.define('Ext.dataview.element.Container', {extend:Ext.Component, doInitialize:function() {
  this.element.on({touchstart:'onItemTouchStart', touchend:'onItemTouchEnd', tap:'onItemTap', taphold:'onItemTapHold', touchmove:'onItemTouchMove', singletap:'onItemSingleTap', doubletap:'onItemDoubleTap', swipe:'onItemSwipe', delegate:'\x3e div', scope:this});
}, initialize:function() {
  this.callParent();
  this.doInitialize();
}, updateBaseCls:function(newBaseCls, oldBaseCls) {
  var me = this;
  me.callParent([newBaseCls + '-container', oldBaseCls]);
}, onItemTouchStart:function(e) {
  var me = this, target = e.currentTarget, index = me.getViewItems().indexOf(target);
  Ext.get(target).on({touchmove:'onItemTouchMove', scope:me, single:true});
  me.fireEvent('itemtouchstart', me, Ext.get(target), index, e);
}, onItemTouchEnd:function(e) {
  var me = this, target = e.currentTarget, index = me.getViewItems().indexOf(target);
  Ext.get(target).un({touchmove:'onItemTouchMove', scope:me});
  me.fireEvent('itemtouchend', me, Ext.get(target), index, e);
}, onItemTouchMove:function(e) {
  var me = this, target = e.currentTarget, index = me.getViewItems().indexOf(target);
  me.fireEvent('itemtouchmove', me, Ext.get(target), index, e);
}, onItemTap:function(e) {
  var me = this, target = e.currentTarget, index = me.getViewItems().indexOf(target);
  me.fireEvent('itemtap', me, Ext.get(target), index, e);
}, onItemTapHold:function(e) {
  var me = this, target = e.currentTarget, index = me.getViewItems().indexOf(target);
  me.fireEvent('itemtaphold', me, Ext.get(target), index, e);
}, onItemDoubleTap:function(e) {
  var me = this, target = e.currentTarget, index = me.getViewItems().indexOf(target);
  me.fireEvent('itemdoubletap', me, Ext.get(target), index, e);
}, onItemSingleTap:function(e) {
  var me = this, target = e.currentTarget, index = me.getViewItems().indexOf(target);
  me.fireEvent('itemsingletap', me, Ext.get(target), index, e);
}, onItemSwipe:function(e) {
  var me = this, target = e.currentTarget, index = me.getViewItems().indexOf(target);
  me.fireEvent('itemswipe', me, Ext.get(target), index, e);
}, updateListItem:function(record, item) {
  var me = this, dataview = me.dataview, store = dataview.getStore(), index = store.indexOf(record), data = dataview.prepareData(record.getData(true), index, record);
  item.innerHTML = this.renderItemTpl(index, data, store);
}, addListItem:function(index, record) {
  var me = this, dataview = me.dataview, store = dataview.getStore(), data = dataview.prepareData(record.getData(true), index, record), element = me.element, childNodes = element.dom.childNodes, ln = childNodes.length, wrapElement;
  wrapElement = Ext.Element.create(this.getItemElementConfig(index, data, store));
  if (!ln || index == ln) {
    wrapElement.appendTo(element);
  } else {
    wrapElement.insertBefore(childNodes[index]);
  }
}, getItemElementConfig:function(index, data, store) {
  var dataview = this.dataview, itemCls = dataview.getItemCls(), cls = dataview.getBaseCls() + '-item';
  if (itemCls) {
    cls += ' ' + itemCls;
  }
  return {cls:cls, html:this.renderItemTpl(index, data, store)};
}, renderItemTpl:function(index, data, store) {
  var dataview = this.dataview, itemTpl = dataview.getItemTpl(), parent;
  store = store || dataview.getStore();
  parent = store.getData().items;
  data.xcount = typeof data.xcount === 'number' ? data.xcount : store.getCount();
  data.xindex = typeof data.xindex === 'number' ? data.xindex : index;
  return itemTpl.apply(data, parent, index + 1, parent.length);
}, doRemoveItemCls:function(cls) {
  var elements = this.getViewItems(), ln = elements.length, i = 0;
  for (; i < ln; i++) {
    Ext.fly(elements[i]).removeCls(cls);
  }
}, doAddItemCls:function(cls) {
  var elements = this.getViewItems(), ln = elements.length, i = 0;
  for (; i < ln; i++) {
    Ext.fly(elements[i]).addCls(cls);
  }
}, moveItemsToCache:function(from, to) {
  var me = this, items = me.getViewItems(), i = to - from, item;
  for (; i >= 0; i--) {
    item = items[from + i];
    Ext.get(item).destroy();
  }
  if (me.getViewItems().length == 0) {
    this.dataview.showEmptyText();
  }
}, moveItemsFromCache:function(records) {
  var me = this, dataview = me.dataview, store = dataview.getStore(), ln = records.length, i, record;
  if (ln) {
    dataview.hideEmptyText();
  }
  for (i = 0; i < ln; i++) {
    records[i]._tmpIndex = store.indexOf(records[i]);
  }
  Ext.Array.sort(records, function(record1, record2) {
    return record1._tmpIndex > record2._tmpIndex ? 1 : -1;
  });
  for (i = 0; i < ln; i++) {
    record = records[i];
    me.addListItem(record._tmpIndex, record);
    delete record._tmpIndex;
  }
}, getViewItems:function() {
  return Array.prototype.slice.call(this.element.dom.childNodes);
}, updateAtNewIndex:function(oldIndex, newIndex, record) {
  this.moveItemsToCache(oldIndex, oldIndex);
  this.moveItemsFromCache([record]);
}, destroy:function() {
  var elements = this.getViewItems(), ln = elements.length, i = 0;
  for (; i < ln; i++) {
    Ext.get(elements[i]).destroy();
  }
  this.callParent();
}});
Ext.define('Ext.dataview.DataView', {extend:Ext.Container, alternateClassName:'Ext.DataView', mixins:[Ext.mixin.Selectable], xtype:'dataview', config:{store:null, data:null, baseCls:Ext.baseCSSPrefix + 'dataview', emptyText:null, deferEmptyText:true, itemTpl:'\x3cdiv\x3e{text}\x3c/div\x3e', pressedCls:'x-item-pressed', itemCls:null, selectedCls:'x-item-selected', triggerEvent:'itemtap', triggerCtEvent:'tap', deselectOnContainerClick:true, scrollable:true, inline:null, pressedDelay:100, loadingText:'Loading...', 
useComponents:null, itemConfig:{}, maxItemCache:20, defaultType:'dataitem', scrollToTopOnRefresh:true}, defaultBindProperty:'store', constructor:function(config) {
  var me = this;
  me.hasLoadedStore = false;
  me.mixins.selectable.constructor.apply(me, arguments);
  me.indexOffset = 0;
  me.callParent(arguments);
  var layout = this.getLayout();
  if (layout && !layout.isAuto) {
    Ext.Logger.error('The base layout for a DataView must always be an Auto Layout');
  }
  me.initSelectable();
}, updateItemCls:function(newCls, oldCls) {
  var container = this.container;
  if (container) {
    if (oldCls) {
      container.doRemoveItemCls(oldCls);
    }
    if (newCls) {
      container.doAddItemCls(newCls);
    }
  }
}, storeEventHooks:{beforeload:'onBeforeLoad', groupchange:'onStoreGroupChange', load:'onLoad', refresh:'refresh', add:'onStoreAdd', remove:'onStoreRemove', clear:'onStoreClear', update:'onStoreUpdate'}, initialize:function() {
  this.callParent();
  var me = this, container, triggerEvent = me.getTriggerEvent();
  me.on(me.getTriggerCtEvent(), me.onContainerTrigger, me);
  container = me.container = this.add(new (Ext.dataview[me.getUseComponents() ? 'component' : 'element'].Container)({baseCls:this.getBaseCls()}));
  container.dataview = me;
  if (triggerEvent) {
    me.on(triggerEvent, me.onItemTrigger, me);
  }
  container.on({itemtouchstart:'onItemTouchStart', itemtouchend:'onItemTouchEnd', itemtap:'onItemTap', itemtaphold:'onItemTapHold', itemtouchmove:'onItemTouchMove', itemsingletap:'onItemSingleTap', itemdoubletap:'onItemDoubleTap', itemswipe:'onItemSwipe', scope:me});
  if (me.getStore()) {
    if (me.isPainted()) {
      me.refresh();
    } else {
      me.on({painted:'refresh', single:true});
    }
  }
}, applyInline:function(config) {
  if (Ext.isObject(config)) {
    config = Ext.apply({}, config);
  }
  return config;
}, updateInline:function(newInline, oldInline) {
  var me = this, baseCls = me.getBaseCls();
  if (oldInline) {
    me.removeCls([baseCls + '-inlineblock', baseCls + '-nowrap']);
  }
  if (newInline) {
    me.addCls(baseCls + '-inlineblock');
    if (Ext.isObject(newInline) && newInline.wrap === false) {
      me.addCls(baseCls + '-nowrap');
    } else {
      me.removeCls(baseCls + '-nowrap');
    }
  }
}, prepareData:function(data, index, record) {
  return data;
}, onContainerTrigger:function(e) {
  var me = this;
  if (e.target != me.element.dom) {
    return;
  }
  if (me.getDeselectOnContainerClick() && me.getStore()) {
    me.deselectAll();
  }
}, onItemTrigger:function(me, index) {
  if (!this.destroyed) {
    this.selectWithEvent(this.getStore().getAt(index));
  }
}, doAddPressedCls:function(record) {
  var me = this, item = me.getItemAt(me.getStore().indexOf(record));
  if (Ext.isElement(item)) {
    item = Ext.get(item);
  }
  if (item) {
    if (item.isComponent) {
      item.renderElement.addCls(me.getPressedCls());
    } else {
      item.addCls(me.getPressedCls());
    }
  }
}, onItemTouchStart:function(container, target, index, e) {
  var me = this, store = me.getStore(), record = store && store.getAt(index);
  me.fireAction('itemtouchstart', [me, index, target, record, e], 'doItemTouchStart');
}, doItemTouchStart:function(me, index, target, record) {
  var pressedDelay = me.getPressedDelay();
  if (record) {
    if (pressedDelay > 0) {
      me.pressedTimeout = Ext.defer(me.doAddPressedCls, pressedDelay, me, [record]);
    } else {
      me.doAddPressedCls(record);
    }
  }
}, onItemTouchEnd:function(container, target, index, e) {
  var me = this, store = me.getStore(), record = store && store.getAt(index);
  if (this.hasOwnProperty('pressedTimeout')) {
    clearTimeout(this.pressedTimeout);
    delete this.pressedTimeout;
  }
  if (record && target) {
    if (target.isComponent) {
      target.renderElement.removeCls(me.getPressedCls());
    } else {
      target.removeCls(me.getPressedCls());
    }
  }
  me.fireEvent('itemtouchend', me, index, target, record, e);
}, onItemTouchMove:function(container, target, index, e) {
  var me = this, store = me.getStore(), record = store && store.getAt(index);
  if (me.hasOwnProperty('pressedTimeout')) {
    clearTimeout(me.pressedTimeout);
    delete me.pressedTimeout;
  }
  if (record && target) {
    if (target.isComponent) {
      target.renderElement.removeCls(me.getPressedCls());
    } else {
      target.removeCls(me.getPressedCls());
    }
  }
  me.fireEvent('itemtouchmove', me, index, target, record, e);
}, onItemTap:function(container, target, index, e) {
  var me = this, store = me.getStore(), record = store && store.getAt(index);
  me.fireEvent('itemtap', me, index, target, record, e);
}, onItemTapHold:function(container, target, index, e) {
  var me = this, store = me.getStore(), record = store && store.getAt(index);
  me.fireEvent('itemtaphold', me, index, target, record, e);
}, onItemSingleTap:function(container, target, index, e) {
  var me = this, store = me.getStore(), record = store && store.getAt(index);
  me.fireEvent('itemsingletap', me, index, target, record, e);
}, onItemDoubleTap:function(container, target, index, e) {
  var me = this, store = me.getStore(), record = store && store.getAt(index);
  me.fireEvent('itemdoubletap', me, index, target, record, e);
}, onItemSwipe:function(container, target, index, e) {
  var me = this, store = me.getStore(), record = store && store.getAt(index);
  me.fireEvent('itemswipe', me, index, target, record, e);
}, onItemSelect:function(record, suppressEvent) {
  var me = this;
  if (suppressEvent) {
    me.doItemSelect(me, record);
  } else {
    me.fireAction('select', [me, record], 'doItemSelect');
  }
}, doItemSelect:function(me, record) {
  if (me.container && !me.destroyed) {
    var item = me.getItemAt(me.getStore().indexOf(record));
    if (Ext.isElement(item)) {
      item = Ext.get(item);
    }
    if (item) {
      if (item.isComponent) {
        item.renderElement.removeCls(me.getPressedCls());
        item.renderElement.addCls(me.getSelectedCls());
      } else {
        item.removeCls(me.getPressedCls());
        item.addCls(me.getSelectedCls());
      }
    }
  }
}, onItemDeselect:function(record, suppressEvent) {
  var me = this;
  if (me.container && !me.destroyed) {
    if (suppressEvent) {
      me.doItemDeselect(me, record);
    } else {
      me.fireAction('deselect', [me, record, suppressEvent], 'doItemDeselect');
    }
  }
}, doItemDeselect:function(me, record) {
  var item = me.getItemAt(me.getStore().indexOf(record));
  if (Ext.isElement(item)) {
    item = Ext.get(item);
  }
  if (item) {
    if (item.isComponent) {
      item.renderElement.removeCls([me.getPressedCls(), me.getSelectedCls()]);
    } else {
      item.removeCls([me.getPressedCls(), me.getSelectedCls()]);
    }
  }
}, updateData:function(data) {
  var store = this.getStore();
  if (!store) {
    this.setStore(Ext.create('Ext.data.Store', {data:data, autoDestroy:true}));
  } else {
    store.add(data);
  }
}, applyStore:function(store) {
  var me = this, bindEvents = Ext.apply({}, me.storeEventHooks, {scope:me}), proxy, reader;
  if (store) {
    store = Ext.data.StoreManager.lookup(store);
    if (store && Ext.isObject(store) && store.isStore) {
      store.on(bindEvents);
      proxy = store.getProxy();
      if (proxy) {
        reader = proxy.getReader();
        if (reader) {
          reader.on('exception', 'handleException', this);
        }
      }
    } else {
      Ext.Logger.warn('The specified Store cannot be found', this);
    }
  }
  return store;
}, handleException:function() {
  this.setMasked(false);
}, updateStore:function(newStore, oldStore) {
  var me = this, bindEvents = Ext.apply({}, me.storeEventHooks, {scope:me}), proxy, reader;
  if (oldStore && Ext.isObject(oldStore) && oldStore.isStore) {
    oldStore.un(bindEvents);
    if (!me.destroyed) {
      me.onStoreClear();
    }
    if (oldStore.getAutoDestroy()) {
      oldStore.destroy();
    } else {
      proxy = oldStore.getProxy();
      if (proxy) {
        reader = proxy.getReader();
        if (reader) {
          reader.un('exception', 'handleException', this);
        }
      }
    }
  }
  if (newStore) {
    if (newStore.isLoaded()) {
      this.hasLoadedStore = true;
    }
    if (newStore.isLoading()) {
      me.onBeforeLoad();
    }
    if (me.container) {
      me.refresh();
    }
  }
}, onBeforeLoad:function() {
  var me = this, loadingText = me.getLoadingText();
  if (loadingText && me.isPainted()) {
    me.setMasked({xtype:'loadmask', message:loadingText});
  }
  me.hideEmptyText();
}, updateEmptyText:function(newEmptyText, oldEmptyText) {
  var me = this, store;
  if (oldEmptyText && me.emptyTextCmp) {
    me.remove(me.emptyTextCmp, true);
    delete me.emptyTextCmp;
  }
  if (newEmptyText) {
    me.emptyTextCmp = me.add({xtype:'component', cls:me.getBaseCls() + '-emptytext', html:newEmptyText, hidden:true});
    store = me.getStore();
    if (store && me.hasLoadedStore && !store.getCount()) {
      me.showEmptyText();
    }
  }
}, onLoad:function(store) {
  this.hasLoadedStore = true;
  this.setMasked(false);
  if (!store.getCount()) {
    this.showEmptyText();
  }
}, refresh:function() {
  var me = this, container = me.container;
  if (!me.getStore()) {
    if (!me.hasLoadedStore && !me.getDeferEmptyText()) {
      me.showEmptyText();
    }
    return;
  }
  if (me.initialized && container) {
    me.fireAction('refresh', [me], 'doRefresh');
  }
}, applyItemTpl:function(config) {
  return Ext.isObject(config) && config.isTemplate ? config : new Ext.XTemplate(config);
}, onAfterRender:function() {
  var me = this;
  me.updateStore(me.getStore());
}, getItemAt:function(index) {
  return this.getViewItems()[index - this.indexOffset];
}, getItemIndex:function(item) {
  var index = this.getViewItems().indexOf(item);
  return index === -1 ? index : this.indexOffset + index;
}, getViewItems:function() {
  return this.container.getViewItems();
}, doRefresh:function(me) {
  var container = me.container, store = me.getStore(), records = store.getRange(), items = me.getViewItems(), recordsLn = records.length, itemsLn = items.length, deltaLn = recordsLn - itemsLn, scroller = me.getScrollable(), i, item;
  if (this.getScrollToTopOnRefresh() && scroller) {
    scroller.scrollTo(0, 0);
  }
  if (recordsLn < 1) {
    me.onStoreClear();
    return;
  } else {
    me.hideEmptyText();
  }
  if (deltaLn < 0) {
    container.moveItemsToCache(itemsLn + deltaLn, itemsLn - 1);
    items = me.getViewItems();
    itemsLn = items.length;
  } else {
    if (deltaLn > 0) {
      container.moveItemsFromCache(store.getRange(itemsLn));
    }
  }
  for (i = 0; i < itemsLn; i++) {
    item = items[i];
    container.updateListItem(records[i], item);
  }
  if (this.hasSelection()) {
    var selection = this.getSelection(), selectionLn = this.getSelectionCount(), record;
    for (i = 0; i < selectionLn; i++) {
      record = selection[i];
      this.doItemSelect(this, record);
    }
  }
}, showEmptyText:function() {
  if (this.getEmptyText() && (this.hasLoadedStore || !this.getDeferEmptyText())) {
    this.emptyTextCmp.show();
  }
}, hideEmptyText:function() {
  if (this.getEmptyText()) {
    this.emptyTextCmp.hide();
  }
}, destroy:function() {
  var store = this.getStore(), proxy = store && store.getProxy(), reader = proxy && proxy.getReader();
  if (reader) {
    reader.clearListeners();
  }
  this.callParent();
  this.setStore(null);
}, onStoreClear:function() {
  var me = this, container = me.container, items = me.getViewItems();
  container.moveItemsToCache(0, items.length - 1);
  this.showEmptyText();
}, onStoreGroupChange:Ext.emptyFn, onStoreAdd:function(store, records) {
  if (records) {
    this.hideEmptyText();
    this.container.moveItemsFromCache(records);
  }
}, onStoreRemove:function(store, records, indices) {
  var container = this.container, ln = records.length, i;
  for (i = 0; i < ln; i++) {
    container.moveItemsToCache(indices[i], indices[i]);
  }
}, onStoreUpdate:function(store, record, type, modifiedFieldNames, info) {
  var me = this, container = me.container, item;
  if (info.indexChanged) {
    container.updateAtNewIndex(info.oldIndex, info.newIndex, record);
    if (me.isSelected(record)) {
      me.doItemSelect(me, record);
    }
  } else {
    item = me.getViewItems()[me.getStore().indexOf(record)];
    if (item) {
      container.updateListItem(record, item);
    }
  }
}});
Ext.define('Ext.dataview.IndexBar', {extend:Ext.Component, alternateClassName:'Ext.IndexBar', config:{baseCls:Ext.baseCSSPrefix + 'indexbar', direction:'vertical', letters:['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z'], ui:'alphabet', listPrefix:null}, itemCls:Ext.baseCSSPrefix + '', updateDirection:function(newDirection, oldDirection) {
  var baseCls = this.getBaseCls();
  this.element.replaceCls(baseCls + '-' + oldDirection, baseCls + '-' + newDirection);
}, getElementConfig:function() {
  if (Ext.theme.is.Blackberry) {
    return {reference:'wrapper', classList:['x-centered', 'x-indexbar-wrapper'], children:[{reference:'indicator', classList:['x-indexbar-indicator'], hidden:true, children:[{reference:'indicatorInner', classList:['x-indexbar-indicator-inner']}]}, this.callParent()]};
  } else {
    return {reference:'wrapper', classList:['x-centered', 'x-indexbar-wrapper'], children:[this.callParent()]};
  }
}, updateLetters:function(letters) {
  this.innerElement.setHtml('');
  if (letters) {
    var ln = letters.length, i;
    for (i = 0; i < ln; i++) {
      this.innerElement.createChild({html:letters[i]});
    }
  }
}, updateListPrefix:function(listPrefix) {
  if (listPrefix && listPrefix.length) {
    this.innerElement.createChild({html:listPrefix}, 0);
  }
}, initialize:function() {
  this.callParent();
  this.innerElement.on({touchstart:this.onTouchStart, touchend:this.onTouchEnd, dragend:this.onDragEnd, drag:this.onDrag, scope:this});
}, onTouchStart:function(e) {
  e.stopPropagation();
  this.innerElement.addCls(this.getBaseCls() + '-pressed');
  this.pageBox = this.innerElement.getBox();
  this.onDrag(e);
}, onTouchEnd:function(e) {
  this.onDragEnd();
}, onDragEnd:function() {
  this.innerElement.removeCls(this.getBaseCls() + '-pressed');
  if (this.indicator) {
    this.indicator.hide();
  }
}, onDrag:function(e) {
  var point = Ext.util.Point.fromEvent(e), target, isValidTarget, pageBox = this.pageBox;
  if (!pageBox) {
    pageBox = this.pageBox = this.el.getBox();
  }
  if (this.getDirection() === 'vertical') {
    if (point.y > pageBox.bottom || point.y < pageBox.top) {
      return;
    }
    target = Ext.Element.fromPoint(pageBox.left + pageBox.width / 2, point.y);
    isValidTarget = target.getParent() == this.element;
    if (this.indicator) {
      this.indicator.show();
      var halfIndicatorHeight = this.indicator.getHeight() / 2, y = point.y - this.element.getY();
      y = Math.min(Math.max(y, halfIndicatorHeight), this.element.getHeight() - halfIndicatorHeight);
      if (this.indicatorInner && isValidTarget) {
        this.indicatorInner.setHtml(target.getHtml().toUpperCase());
      }
      this.indicator.setTop(y - halfIndicatorHeight);
    }
  } else {
    if (point.x > pageBox.right || point.x < pageBox.left) {
      return;
    }
    target = Ext.Element.fromPoint(point.x, pageBox.top + pageBox.height / 2);
    isValidTarget = target.getParent() == this.element;
  }
  if (target && isValidTarget) {
    this.fireEvent('index', this, target.dom.innerHTML, target);
  }
}, destroy:function() {
  var me = this, elements = Array.prototype.slice.call(me.innerElement.dom.childNodes), ln = elements.length, i = 0;
  for (; i < ln; i++) {
    Ext.removeNode(elements[i]);
  }
  this.callParent();
}});
Ext.define('Ext.dataview.ListItemHeader', {extend:Ext.Component, xtype:'listitemheader', config:{baseCls:Ext.baseCSSPrefix + 'list-header'}});
Ext.define('Ext.dataview.component.ListItem', {extend:Ext.dataview.component.DataItem, xtype:'listitem', config:{baseCls:Ext.baseCSSPrefix + 'list-item', dataMap:null, body:{xtype:'component', cls:'x-list-item-body'}, disclosure:{xtype:'component', cls:'x-list-disclosure', hidden:true, docked:'right'}, header:{xtype:'component', cls:'x-list-header', html:' '}, tpl:null, items:null}, applyBody:function(body) {
  if (body && !body.isComponent) {
    body = Ext.factory(body, Ext.Component, this.getBody());
  }
  return body;
}, updateBody:function(body, oldBody) {
  if (body) {
    this.add(body);
  } else {
    if (oldBody) {
      oldBody.destroy();
    }
  }
}, applyHeader:function(header) {
  if (header && !header.isComponent) {
    header = Ext.factory(header, Ext.Component, this.getHeader());
  }
  return header;
}, updateHeader:function(header, oldHeader) {
  if (oldHeader) {
    oldHeader.destroy();
  }
}, applyDisclosure:function(disclosure) {
  if (disclosure && !disclosure.isComponent) {
    disclosure = Ext.factory(disclosure, Ext.Component, this.getDisclosure());
  }
  return disclosure;
}, updateDisclosure:function(disclosure, oldDisclosure) {
  if (disclosure) {
    this.add(disclosure);
  } else {
    if (oldDisclosure) {
      oldDisclosure.destroy();
    }
  }
}, updateTpl:function(tpl) {
  this.getBody().setTpl(tpl);
}, updateRecord:function(record) {
  var me = this, dataview = me.dataview || this.getDataview(), data = record && dataview.prepareData(record.getData(true), dataview.getStore().indexOf(record), record), dataMap = me.getDataMap(), body = this.getBody(), disclosure = this.getDisclosure();
  me._record = record;
  if (dataMap) {
    me.doMapData(dataMap, data, body);
  } else {
    if (body) {
      body.updateData(data || null);
    }
  }
  if (disclosure && record && dataview.getOnItemDisclosure()) {
    var disclosureProperty = dataview.getDisclosureProperty();
    disclosure[data.hasOwnProperty(disclosureProperty) && data[disclosureProperty] === false ? 'hide' : 'show']();
  }
  me.fireEvent('updatedata', me, data);
}, destroy:function() {
  Ext.destroy(this.getHeader());
  this.callParent();
}});
Ext.define('Ext.dataview.component.SimpleListItem', {extend:Ext.Component, xtype:'simplelistitem', config:{baseCls:Ext.baseCSSPrefix + 'list-item', disclosure:{xtype:'component', cls:'x-list-disclosure', hidden:true}, header:{xtype:'component', cls:'x-list-header', html:' '}, dataview:null, record:null}, initialize:function() {
  this.element.addCls(this.getBaseCls() + '-tpl');
}, applyHeader:function(header) {
  if (header && !header.isComponent) {
    header = Ext.factory(header, Ext.Component, this.getHeader());
  }
  return header;
}, updateHeader:function(header, oldHeader) {
  if (oldHeader) {
    oldHeader.destroy();
  }
}, applyDisclosure:function(disclosure) {
  if (disclosure && !disclosure.isComponent) {
    disclosure = Ext.factory(disclosure, Ext.Component, this.getDisclosure());
  }
  return disclosure;
}, updateDisclosure:function(disclosure, oldDisclosure) {
  if (disclosure) {
    this.element.appendChild(disclosure.renderElement);
  } else {
    if (oldDisclosure) {
      oldDisclosure.destroy();
    }
  }
}, updateRecord:function(record) {
  var me = this, dataview = me.dataview || this.getDataview(), data = record && dataview.prepareData(record.getData(true), dataview.getStore().indexOf(record), record), disclosure = this.getDisclosure();
  me.updateData(data || null);
  if (disclosure && record && dataview.getOnItemDisclosure()) {
    var disclosureProperty = dataview.getDisclosureProperty();
    disclosure[data.hasOwnProperty(disclosureProperty) && data[disclosureProperty] === false ? 'hide' : 'show']();
  }
}, destroy:function() {
  Ext.destroy(this.getHeader(), this.getDisclosure());
  this.callParent();
}});
Ext.define('Ext.util.PositionMap', {config:{minimumHeight:null}, constructor:function(config) {
  var me = this;
  me.map = [];
  me.adjustments = {};
  me.offset = 0;
  me.initConfig(config);
}, populate:function(count, offset) {
  var me = this, map = me.map = me.map || [], minimumHeight = me.getMinimumHeight(), i, previousIndex, ln;
  me.adjustments = {indices:[], heights:{}};
  if (minimumHeight === null) {
    return;
  }
  offset = offset || 0;
  count++;
  map.length = count;
  map[0] = 0;
  for (i = offset + 1, ln = count - 1; i <= ln; i++) {
    previousIndex = i - 1;
    map[i] = map[previousIndex] + minimumHeight;
  }
  me.offset = 0;
  for (i = 1, ln = count - 1; i <= ln; i++) {
    previousIndex = i - 1;
    this.offset += map[i] - map[previousIndex] - minimumHeight;
  }
}, setItemHeight:function(index, height) {
  height = Math.max(height, this.getMinimumHeight());
  if (height !== this.getItemHeight(index)) {
    var adjustments = this.adjustments;
    adjustments.indices.push(parseInt(index, 10));
    adjustments.heights[index] = height;
  }
}, update:function() {
  var adjustments = this.adjustments, indices = adjustments.indices, heights = adjustments.heights, map = this.map, ln = indices.length, minimumHeight = this.getMinimumHeight(), difference = 0, i, j, height, index, nextIndex, currentHeight;
  if (!adjustments.indices.length) {
    return false;
  }
  Ext.Array.sort(indices, function(a, b) {
    return a - b;
  });
  for (i = 0; i < ln; i++) {
    index = indices[i];
    nextIndex = indices[i + 1] || map.length - 1;
    currentHeight = map[index + 1] !== undefined ? map[index + 1] - map[index] + difference : minimumHeight;
    height = heights[index];
    difference += height - currentHeight;
    for (j = index + 1; j <= nextIndex; j++) {
      map[j] += difference;
    }
  }
  this.offset += difference;
  this.adjustments = {indices:[], heights:{}};
  return true;
}, getItemHeight:function(index) {
  return this.map[index + 1] - this.map[index];
}, getTotalHeight:function() {
  return (this.map.length - 1) * this.getMinimumHeight() + this.offset;
}, findIndex:function(pos) {
  return this.map.length ? this.binarySearch(this.map, pos) : 0;
}, binarySearch:function(sorted, value) {
  var start = 0, end = sorted.length;
  if (value < sorted[0]) {
    return 0;
  }
  if (value > sorted[end - 1]) {
    return end - 1;
  }
  while (start + 1 < end) {
    var mid = start + end >> 1, val = sorted[mid];
    if (val == value) {
      return mid;
    } else {
      if (val < value) {
        start = mid;
      } else {
        end = mid;
      }
    }
  }
  return start;
}});
Ext.define('Ext.dataview.List', {alternateClassName:'Ext.List', extend:Ext.dataview.DataView, xtype:'list', mixins:[Ext.mixin.Hookable], config:{container:{lazy:true, $value:{xtype:'container', scrollable:{}}}, layout:'fit', indexBar:false, icon:null, preventSelectionOnDisclose:true, baseCls:Ext.baseCSSPrefix + 'list', pinHeaders:true, grouped:null, onItemDisclosure:null, disclosureProperty:'disclosure', defaultType:undefined, itemMap:{}, itemHeight:null, variableHeights:false, refreshHeightOnUpdate:true, 
infinite:false, useSimpleItems:true, scrollable:null, bufferSize:20, minimumBufferDistance:5, striped:false}, topRenderedIndex:0, topVisibleIndex:0, visibleCount:0, constructor:function(config) {
  this.callParent([config]);
  var layout = this.getLayout();
  if (layout && !layout.isFit) {
    Ext.Logger.error('The base layout for a DataView must always be a Fit Layout');
  }
}, beforeInitialize:function() {
  var me = this, container = me.container, baseCls = me.getBaseCls(), scrollViewElement, pinnedHeader;
  Ext.apply(me, {listItems:[], headerItems:[], updatedItems:[], headerMap:[], recordMap:{}, scrollDockItems:{top:[], bottom:[]}});
  me.translationMethod = 'csstransform';
  if (!container) {
    container = me.container = me.createContainer();
  }
  me.add(container);
  scrollViewElement = me.scrollViewElement = container.bodyElement;
  me.scrollElement = container.innerElement;
  pinnedHeader = me.pinnedHeader = Ext.factory({xtype:'listitemheader', html:'\x26nbsp;', translatable:{translationMethod:me.translationMethod}, cls:[baseCls + '-header', baseCls + '-header-swap']});
  pinnedHeader.translate(0, -10000);
  pinnedHeader.$position = -10000;
  scrollViewElement.insertFirst(pinnedHeader.renderElement);
  container.getScrollable().on({scroll:'onScroll', refresh:'onScrollerRefresh', scope:me});
}, createContainer:function() {
  var config = Ext.merge({scrollable:{autoRefresh:this.getInfinite() ? null : true}}, this.getContainer());
  return Ext.create(config);
}, getScrollable:function() {
  return this.container.getScrollable();
}, initialize:function() {
  var me = this, container = me.container, scrollViewElement = me.scrollViewElement, indexBar = me.getIndexBar(), triggerEvent = me.getTriggerEvent(), triggerCtEvent = me.getTriggerCtEvent();
  if (indexBar) {
    scrollViewElement.appendChild(indexBar.renderElement);
  }
  if (triggerEvent) {
    me.on(triggerEvent, me.onItemTrigger, me);
  }
  if (triggerCtEvent) {
    me.on(triggerCtEvent, me.onContainerTrigger, me);
  }
  container.element.on({delegate:'.' + me.getBaseCls() + '-disclosure', tap:'handleItemDisclosure', scope:me});
  container.element.on({resize:'onContainerResize', scope:me});
  container.innerElement.on({touchstart:'onItemTouchStart', touchend:'onItemTouchEnd', tap:'onItemTap', taphold:'onItemTapHold', singletap:'onItemSingleTap', doubletap:'onItemDoubleTap', swipe:'onItemSwipe', delegate:'.' + Ext.baseCSSPrefix + 'list-item', scope:me});
  if (me.getStore()) {
    if (me.isPainted()) {
      me.refresh();
    } else {
      me.on({painted:'refresh', single:true});
    }
  }
}, getRefItems:function(deep) {
  var result = [], candidates = this.callParent([deep]), len = candidates.length, i, candidate;
  for (i = 0; i < len; i++) {
    candidate = candidates[i];
    if (!candidate.hasOwnProperty('$position') || candidate.$position > -1) {
      result[result.length] = candidate;
    }
  }
  return result;
}, onScroll:function(scroller, x, y) {
  var me = this, pinnedHeader = me.pinnedHeader, store = me.getStore(), storeCount = store && store.getCount(), grouped = me.isGrouping(), infinite = me.getInfinite();
  if (x) {
    x = -x;
  }
  if (y) {
    y = -y;
  }
  if (!storeCount) {
    me.showEmptyText();
    me.showEmptyScrollDock();
    pinnedHeader.$position = -10000;
    pinnedHeader.translate(0, -10000);
  } else {
    if (infinite && me.itemsCount) {
      me.handleItemUpdates(y);
      me.handleItemHeights();
      me.handleItemTransforms();
      if (!me.onIdleBound) {
        Ext.AnimationQueue.onIdle(me.onAnimationIdle, me);
        me.onIdleBound = true;
      }
    }
  }
  if (grouped && me.groups && me.groups.length && me.getPinHeaders()) {
    me.handlePinnedHeader(y);
  }
  me.onScrollBinder(x, y);
}, onScrollerRefresh:function(scroller) {
  var position = scroller.getPosition();
  this.onScroll(scroller, position.x, position.y);
}, onScrollBinder:function() {
}, handleItemUpdates:function(y) {
  var me = this, listItems = me.listItems, itemsCount = listItems.length, info = me.getListItemInfo(), itemMap = me.getItemMap(), bufferSize = me.getBufferSize(), lastIndex = me.getStore().getCount() - 1, minimumBufferDistance = me.getMinimumBufferDistance(), currentTopVisibleIndex = me.topVisibleIndex, topRenderedIndex = me.topRenderedIndex, updateCount, i, item, topVisibleIndex, bufferDistance, itemIndex;
  me.topVisibleIndex = topVisibleIndex = Math.max(0, itemMap.findIndex(-y) || 0);
  if (currentTopVisibleIndex !== topVisibleIndex) {
    if (currentTopVisibleIndex > topVisibleIndex) {
      bufferDistance = topVisibleIndex - topRenderedIndex;
      if (bufferDistance < minimumBufferDistance) {
        updateCount = Math.min(itemsCount, minimumBufferDistance - bufferDistance);
        if (updateCount == itemsCount) {
          me.topRenderedIndex = topRenderedIndex = Math.max(0, topVisibleIndex - (bufferSize - minimumBufferDistance));
          for (i = 0; i < updateCount; i++) {
            itemIndex = topRenderedIndex + i;
            item = listItems[i];
            me.updateListItem(item, itemIndex, info);
          }
        } else {
          for (i = 0; i < updateCount; i++) {
            itemIndex = topRenderedIndex - i - 1;
            if (itemIndex < 0) {
              break;
            }
            item = listItems.pop();
            listItems.unshift(item);
            me.updateListItem(item, itemIndex, info);
            me.topRenderedIndex--;
          }
        }
      }
    } else {
      bufferDistance = bufferSize - (topVisibleIndex - topRenderedIndex);
      if (bufferDistance < minimumBufferDistance) {
        updateCount = Math.min(itemsCount, minimumBufferDistance - bufferDistance);
        if (updateCount == itemsCount) {
          me.topRenderedIndex = topRenderedIndex = Math.min(lastIndex - itemsCount, topVisibleIndex - minimumBufferDistance);
          for (i = 0; i < updateCount; i++) {
            itemIndex = topRenderedIndex + i;
            item = listItems[i];
            me.updateListItem(item, itemIndex, info);
          }
        } else {
          for (i = 0; i < updateCount; i++) {
            itemIndex = topRenderedIndex + itemsCount + i;
            if (itemIndex > lastIndex) {
              break;
            }
            item = listItems.shift();
            listItems.push(item);
            me.updateListItem(item, itemIndex, info);
            me.topRenderedIndex++;
          }
        }
      }
    }
  }
}, onAnimationIdle:function() {
  var me = this, info = me.getListItemInfo(), bufferSize = me.getBufferSize(), topVisibleIndex = me.topVisibleIndex, topRenderedIndex = me.topRenderedIndex, lastIndex = me.getStore().getCount() - 1, listItems = me.listItems, itemsCount = listItems.length, topBufferDistance, bottomBufferDistance, i, ln, item, itemIndex;
  topBufferDistance = topVisibleIndex - topRenderedIndex;
  bottomBufferDistance = topRenderedIndex + bufferSize - topVisibleIndex;
  if (topBufferDistance < bottomBufferDistance) {
    if (topVisibleIndex > 0) {
      ln = bottomBufferDistance - topBufferDistance;
      for (i = 0; i < ln; i++) {
        itemIndex = topRenderedIndex - i - 1;
        if (itemIndex < 0) {
          break;
        }
        item = listItems.pop();
        listItems.unshift(item);
        me.updateListItem(item, itemIndex, info);
        me.topRenderedIndex--;
      }
    }
  } else {
    ln = topBufferDistance - bottomBufferDistance;
    for (i = 0; i < ln; i++) {
      itemIndex = topRenderedIndex + itemsCount + i;
      if (itemIndex > lastIndex) {
        break;
      }
      item = listItems.shift();
      listItems.push(item);
      me.updateListItem(item, itemIndex, info);
      me.topRenderedIndex++;
    }
  }
  me.handleItemHeights();
  me.handleItemTransforms();
  me.onIdleBound = false;
}, handleItemHeights:function() {
  var me = this, updatedItems = me.updatedItems, ln = updatedItems.length, itemMap = me.getItemMap(), useSimpleItems = me.getUseSimpleItems(), minimumHeight = itemMap.getMinimumHeight(), headerIndices = me.headerIndices, headerMap = me.headerMap, variableHeights = me.getVariableHeights(), itemIndex, i, j, jln, item, height, scrollDockHeight;
  for (i = 0; i < ln; i++) {
    item = updatedItems[i];
    itemIndex = item.$dataIndex;
    if (itemIndex !== null) {
      if (variableHeights) {
        height = useSimpleItems ? item.element.getHeight() : item.element.getFirstChild().getHeight();
        height = Math.max(height, minimumHeight);
      } else {
        height = minimumHeight;
      }
      item.$ownItemHeight = height;
      jln = me.scrollDockItems.top.length;
      if (item.isFirst) {
        me.totalScrollDockTopHeight = 0;
        for (j = 0; j < jln; j++) {
          scrollDockHeight = me.scrollDockItems.top[j].$scrollDockHeight;
          height += scrollDockHeight;
          me.totalScrollDockTopHeight += scrollDockHeight;
        }
      }
      jln = me.scrollDockItems.bottom.length;
      if (item.isLast) {
        for (j = 0; j < jln; j++) {
          scrollDockHeight = me.scrollDockItems.bottom[j].$scrollDockHeight;
          height += scrollDockHeight;
        }
      }
      if (headerIndices && headerIndices[itemIndex]) {
        height += me.headerHeight;
      }
      itemMap.setItemHeight(itemIndex, height);
      item.$height = height;
    }
  }
  itemMap.update();
  headerMap.length = 0;
  for (i in headerIndices) {
    if (headerIndices.hasOwnProperty(i)) {
      headerMap.push(itemMap.map[i]);
    }
  }
  me.updatedItems.length = 0;
  me.refreshScroller(true);
}, handleItemTransforms:function() {
  var me = this, listItems = me.listItems, itemsCount = listItems.length, itemMap = me.getItemMap(), scrollDockItems = me.scrollDockItems, grouped = me.isGrouping(), item, transY, i, jln, j;
  for (i = 0; i < itemsCount; i++) {
    item = listItems[i];
    transY = itemMap.map[item.$dataIndex];
    if (!item.$hidden && item.$position !== transY) {
      item.$position = transY;
      jln = scrollDockItems.top.length;
      if (item.isFirst && jln) {
        for (j = 0; j < jln; j++) {
          scrollDockItems.top[j].translate(0, transY);
          transY += scrollDockItems.top[j].$scrollDockHeight;
        }
      }
      if (grouped && me.headerIndices && me.headerIndices[item.$dataIndex]) {
        item.getHeader().translate(0, transY);
        transY += me.headerHeight;
      }
      item.translate(0, transY);
      transY += item.$ownItemHeight;
      jln = scrollDockItems.bottom.length;
      if (item.isLast && jln) {
        for (j = 0; j < jln; j++) {
          scrollDockItems.bottom[j].translate(0, transY);
          transY += scrollDockItems.bottom[j].$scrollDockHeight;
        }
      }
    }
  }
}, handlePinnedHeader:function(y) {
  var me = this, pinnedHeader = me.pinnedHeader, itemMap = me.getItemMap(), groups = me.groups, headerMap = me.headerMap, headerHeight = me.headerHeight, store = me.getStore(), totalScrollDockTopHeight = me.totalScrollDockTopHeight, record, closestHeader, pushedHeader, transY, headerString;
  closestHeader = itemMap.binarySearch(headerMap, -y);
  record = groups.getAt(closestHeader).getAt(0);
  if (record) {
    pushedHeader = y + headerMap[closestHeader + 1] - headerHeight;
    if (y >= 0 || closestHeader === 0 && totalScrollDockTopHeight + y >= 0 || closestHeader === 0 && -y <= headerMap[closestHeader]) {
      transY = -10000;
    } else {
      if (pushedHeader < 0) {
        transY = pushedHeader;
      } else {
        transY = Math.max(0, y);
      }
    }
    headerString = store.getGrouper().getGroupString(record);
    if (pinnedHeader.$currentHeader != headerString) {
      pinnedHeader.setHtml(headerString);
      pinnedHeader.$currentHeader = headerString;
    }
    if (pinnedHeader.$position != transY) {
      pinnedHeader.translate(0, transY);
      pinnedHeader.$position = transY;
    }
  }
}, createItem:function(config) {
  var me = this, container = me.container, listItems = me.listItems, infinite = me.getInfinite(), scrollElement = me.scrollElement, item, header, itemCls;
  config.$initParent = me;
  item = Ext.factory(config);
  delete config.$initParent;
  item.dataview = me;
  item.$height = config.minHeight;
  if (!infinite) {
    itemCls = me.getBaseCls() + '-item-relative';
    item.addCls(itemCls);
  }
  header = item.getHeader && item.getHeader();
  if (header) {
    if (!infinite) {
      header.addCls(itemCls);
    } else {
      header.setTranslatable({translationMethod:this.translationMethod});
      header.translate(0, -10000);
      scrollElement.insertFirst(header.renderElement);
    }
  }
  container.doAdd(item);
  listItems.push(item);
  return item;
}, setItemsCount:function(itemsCount, itemConfig) {
  var me = this, listItems = me.listItems, config = itemConfig || me.getListItemConfig(), difference = itemsCount - listItems.length, i;
  for (i = 0; i < difference; i++) {
    me.createItem(config);
  }
  for (i = difference; i < 0; i++) {
    listItems.pop().destroy();
  }
  me.itemsCount = itemsCount;
  me.updateAllListItems();
  if (Ext.browser.is.AndroidStock && me.container.element && itemsCount === 0 && difference !== 0) {
    me.container.element.redraw();
  }
  return me.listItems;
}, updateListItem:function(item, index, info) {
  var me = this, recordMap = me.recordMap, oldRecord = item.getRecord(), store = info.store, record = store.getAt(index), headerIndices = me.headerIndices, footerIndices = me.footerIndices, header = item.getHeader && item.getHeader(), scrollDockItems = me.scrollDockItems, updatedItems = me.updatedItems, infinite = me.getInfinite(), storeCount = store.getCount(), grouper = store.getGrouper(), itemCls = [], headerCls = [], itemRemoveCls = [info.headerCls, info.footerCls, info.firstCls, info.lastCls, 
  info.selectedCls, info.stripeCls], headerRemoveCls = [info.headerCls, info.footerCls, info.firstCls, info.lastCls], ln, i, scrollDockItem, viewModel;
  if (infinite) {
    item.$position = -10000;
  }
  if (!record) {
    item.setRecord(null);
    if (oldRecord) {
      delete recordMap[oldRecord.internalId];
    }
    if (infinite) {
      item.translate(0, -10000);
    } else {
      item.hide();
    }
    if (header) {
      if (infinite) {
        header.translate(0, -10000);
      } else {
        header.hide();
      }
    }
    item.$hidden = true;
    return;
  } else {
    if (item.$hidden) {
      if (!infinite) {
        item.show();
      }
      item.$hidden = false;
    }
  }
  if (infinite) {
    updatedItems.push(item);
  }
  if (item.isFirst && index !== 0) {
    ln = scrollDockItems.top.length;
    for (i = 0; i < ln; i++) {
      scrollDockItem = scrollDockItems.top[i];
      if (infinite) {
        scrollDockItem.translate(0, -10000);
      }
    }
    item.isFirst = false;
  }
  if (item.isLast && index !== storeCount - 1) {
    ln = scrollDockItems.bottom.length;
    for (i = 0; i < ln; i++) {
      scrollDockItem = scrollDockItems.bottom[i];
      if (infinite) {
        scrollDockItem.translate(0, -10000);
      }
    }
    item.isLast = false;
  }
  if (item.$dataIndex !== index) {
    item.$dataIndex = index;
    me.fireEvent('itemindexchange', me, record, index, item);
  }
  if (oldRecord === record) {
    item.updateRecord(record);
  } else {
    if (oldRecord) {
      delete recordMap[oldRecord.internalId];
    }
    recordMap[record.internalId] = item;
    item.setRecord(record);
    viewModel = item.getViewModel();
    if (viewModel) {
      viewModel.set('record', record);
    }
  }
  if (me.isSelected(record)) {
    itemCls.push(info.selectedCls);
  }
  if (info.grouped) {
    if (headerIndices[index]) {
      itemCls.push(info.headerCls);
      headerCls.push(info.headerCls);
      header.setHtml(grouper.getGroupString(record));
      if (!infinite) {
        header.renderElement.insertBefore(item.renderElement);
      }
      header.show();
    } else {
      if (infinite) {
        header.translate(0, -10000);
      } else {
        header.hide();
      }
    }
    if (footerIndices[index]) {
      itemCls.push(info.footerCls);
      headerCls.push(info.footerCls);
    }
  }
  if (header && !info.grouped) {
    if (infinite) {
      header.translate(0, -10000);
    } else {
      header.hide();
    }
  }
  if (index === 0) {
    item.isFirst = true;
    itemCls.push(info.firstCls);
    headerCls.push(info.firstCls);
    if (!info.grouped) {
      itemCls.push(info.headerCls);
      headerCls.push(info.headerCls);
    }
    if (!infinite) {
      for (i = 0, ln = scrollDockItems.top.length; i < ln; i++) {
        scrollDockItem = scrollDockItems.top[i];
        if (info.grouped) {
          scrollDockItem.renderElement.insertBefore(header.renderElement);
        } else {
          scrollDockItem.renderElement.insertBefore(item.renderElement);
        }
      }
    }
  }
  if (index === storeCount - 1) {
    item.isLast = true;
    itemCls.push(info.lastCls);
    headerCls.push(info.lastCls);
    if (!info.grouped) {
      itemCls.push(info.footerCls);
      headerCls.push(info.footerCls);
    }
    if (!infinite) {
      for (i = 0, ln = scrollDockItems.bottom.length; i < ln; i++) {
        scrollDockItem = scrollDockItems.bottom[i];
        scrollDockItem.renderElement.insertAfter(item.renderElement);
      }
    }
  }
  if (info.striped && index % 2 === 1) {
    itemCls.push(info.stripeCls);
  }
  item.renderElement.replaceCls(itemRemoveCls, itemCls);
  if (header) {
    header.renderElement.replaceCls(headerRemoveCls, headerCls);
  }
}, updateAllListItems:function() {
  var me = this, store, items, info, topRenderedIndex, i, ln;
  if (!me.initialized) {
    return;
  }
  store = me.getStore();
  items = me.listItems;
  info = me.getListItemInfo();
  topRenderedIndex = me.topRenderedIndex;
  if (store) {
    for (i = 0, ln = items.length; i < ln; i++) {
      me.updateListItem(items[i], topRenderedIndex + i, info);
    }
  }
  if (me.isPainted()) {
    if (me.getInfinite() && store && store.getCount()) {
      me.handleItemHeights();
    }
    me.refreshScroller();
  }
}, doRefresh:function() {
  var me = this, infinite = me.getInfinite(), scroller = me.container.getScrollable(), storeCount = me.getStore().getCount();
  if (infinite) {
    me.getItemMap().populate(storeCount, this.topRenderedIndex);
  }
  if (me.getGrouped()) {
    me.refreshHeaderIndices();
  }
  if (storeCount) {
    me.hideScrollDockItems();
    me.hideEmptyText();
    if (!infinite) {
      me.setItemsCount(storeCount);
      if (me.getScrollToTopOnRefresh()) {
        scroller.scrollTo(0, 0);
      }
    } else {
      if (me.getScrollToTopOnRefresh()) {
        me.topRenderedIndex = 0;
        me.topVisibleIndex = 0;
        scroller.scrollTo(null, 0);
      }
      me.updateAllListItems();
    }
  } else {
    me.onStoreClear();
  }
}, updateStore:function(store, oldStore) {
  var me = this, container = me.container;
  me.callParent([store, oldStore]);
  if (me._fireResizeOnNextLoad && me.hasLoadedStore) {
    me._fireResizeOnNextLoad = false;
    me.onContainerResize(container, {height:container.element.getHeight()});
  }
}, onLoad:function(store) {
  var me = this, container = me.container;
  me.callParent([store]);
  if (me._fireResizeOnNextLoad) {
    me._fireResizeOnNextLoad = false;
    me.onContainerResize(container, {height:container.element.getHeight()});
  }
}, onContainerResize:function(container, size) {
  var me = this, store = me.getStore(), currentVisibleCount, newVisibleCount, minHeight, listItems, itemMap, itemConfig;
  if (!me.headerHeight) {
    me.headerHeight = parseInt(me.pinnedHeader.renderElement.getHeight(), 10);
  }
  if (me.getInfinite()) {
    itemMap = me.getItemMap();
    minHeight = itemMap.getMinimumHeight();
    if (!store || !store.getCount() && !store.isLoaded()) {
      me._fireResizeOnNextLoad = true;
      return;
    }
    if (!minHeight) {
      listItems = me.listItems;
      if (!listItems.length) {
        itemConfig = me.getListItemConfig();
        me.createItem(itemConfig);
        me.updateListItem(listItems[0], 0, me.getListItemInfo());
        me.visibleCount++;
      }
      minHeight = listItems[0].element.getHeight();
      itemMap.setMinimumHeight(minHeight);
      me.getItemMap().populate(me.getStore().getCount(), me.topRenderedIndex);
    }
    currentVisibleCount = me.visibleCount;
    newVisibleCount = Math.ceil(size.height / minHeight);
    if (newVisibleCount != currentVisibleCount) {
      me.visibleCount = newVisibleCount;
      me.setItemsCount(newVisibleCount + me.getBufferSize(), itemConfig);
      me.fireEvent('updatevisiblecount', this, newVisibleCount, currentVisibleCount);
    }
  } else {
    if (me.listItems.length && me.getGrouped() && me.getPinHeaders()) {
      me.updateHeaderMap();
    }
  }
}, refreshScroller:function(skipOnRefresh) {
  var me = this, scroller = me.container.getScrollable(), infinite = me.getInfinite(), height, scrollSize;
  if (infinite) {
    height = me.getItemMap().getTotalHeight();
    scrollSize = scroller.getSize();
    if (height != scrollSize.y) {
      scroller.setSize({x:scroller.isTouchScroller ? scrollSize.x : null, y:height});
    }
    if (!skipOnRefresh) {
      me.onScrollerRefresh(scroller);
    }
  } else {
    if (me.getGrouped() && me.getPinHeaders()) {
      me.updateHeaderMap();
    }
    scroller.refresh();
  }
}, updateHeaderMap:function() {
  var me = this, headerMap = me.headerMap, headerIndices = me.headerIndices, header, i;
  headerMap.length = 0;
  for (i in headerIndices) {
    if (headerIndices.hasOwnProperty(i)) {
      header = me.getItemAt(i).getHeader();
      headerMap.push(header.renderElement.dom.offsetTop);
    }
  }
}, applyVariableHeights:function(value) {
  if (!this.getInfinite()) {
    return true;
  }
  return value;
}, applyDefaultType:function(defaultType) {
  if (!defaultType) {
    defaultType = this.getUseSimpleItems() ? 'simplelistitem' : 'listitem';
  }
  return defaultType;
}, applyItemMap:function(itemMap) {
  return Ext.factory(itemMap, Ext.util.PositionMap, this.getItemMap());
}, updateItemHeight:function(itemHeight) {
  this.getItemMap().setMinimumHeight(itemHeight);
}, applyIndexBar:function(indexBar) {
  return Ext.factory(indexBar, Ext.dataview.IndexBar, this.getIndexBar());
}, updatePinHeaders:function(pinnedHeaders) {
  if (this.isPainted()) {
    this.pinnedHeader.translate(0, pinnedHeaders ? this.pinnedHeader.$position : -10000);
  }
}, updateItemTpl:function(newTpl) {
  var me = this, listItems = me.listItems, ln = listItems.length || 0, i, listItem;
  for (i = 0; i < ln; i++) {
    listItem = listItems[i];
    listItem.setTpl(newTpl);
  }
  me.updateAllListItems();
}, updateItemCls:function(newCls, oldCls) {
  var items = this.listItems, ln = items.length, i, item;
  for (i = 0; i < ln; i++) {
    item = items[i];
    item.removeCls(oldCls);
    item.addCls(newCls);
  }
}, updateIndexBar:function(indexBar, oldIndexBar) {
  var me = this, scrollViewElement = me.scrollViewElement;
  if (oldIndexBar) {
    oldIndexBar.un({index:'onIndex', scope:me});
    if (!indexBar) {
      me.element.removeCls(me.getBaseCls() + '-indexed');
    }
    if (scrollViewElement) {
      scrollViewElement.removeChild(oldIndexBar.renderElement);
    }
  }
  if (indexBar) {
    indexBar.on({index:'onIndex', scope:me});
    if (!oldIndexBar) {
      me.element.addCls(me.getBaseCls() + '-indexed');
    }
    if (scrollViewElement) {
      scrollViewElement.appendChild(indexBar.renderElement);
    }
  }
}, updateGrouped:function(grouped) {
  if (this.initialized) {
    this.handleGroupChange();
  }
}, onStoreGroupChange:function() {
  if (this.initialized) {
    this.handleGroupChange();
  }
}, onStoreAdd:function() {
  this.doRefresh();
}, onStoreRemove:function() {
  this.doRefresh();
}, onStoreUpdate:function(store, record, type, modifiedFieldNames, info) {
  var me = this, index, item;
  if (me.getInfinite() || info.indexChanged) {
    me.doRefresh();
  } else {
    index = store.indexOf(record);
    item = me.listItems[index];
    if (item) {
      me.updateListItem(item, index, me.getListItemInfo());
    }
  }
}, onStoreClear:function() {
  var me = this, scroller = me.container.getScrollable(), infinite = me.getInfinite();
  if (me.pinnedHeader) {
    me.pinnedHeader.translate(0, -10000);
  }
  me.getItemMap().populate(0, 0);
  if (!infinite) {
    me.setItemsCount(0);
  } else {
    me.topRenderedIndex = 0;
    me.topVisibleIndex = 0;
    me.updateAllListItems();
  }
  scroller.scrollTo(null, 0);
  me.refreshScroller();
}, showEmptyScrollDock:function() {
  var me = this, infinite = me.getInfinite(), scrollDockItems = me.scrollDockItems, offset = 0, i, ln, item;
  for (i = 0, ln = scrollDockItems.top.length; i < ln; i++) {
    item = scrollDockItems.top[i];
    if (infinite) {
      item.translate(0, offset);
      offset += item.$scrollDockHeight;
    } else {
      this.scrollElement.appendChild(item.renderElement);
    }
  }
  for (i = 0, ln = scrollDockItems.bottom.length; i < ln; i++) {
    item = scrollDockItems.bottom[i];
    if (infinite) {
      item.translate(0, offset);
      offset += item.$scrollDockHeight;
    } else {
      this.scrollElement.appendChild(item.renderElement);
    }
  }
}, hideScrollDockItems:function() {
  var me = this, infinite = me.getInfinite(), scrollDockItems = me.scrollDockItems, i, ln, item;
  if (!infinite) {
    return;
  }
  for (i = 0, ln = scrollDockItems.top.length; i < ln; i++) {
    item = scrollDockItems.top[i];
    item.translate(0, -10000);
  }
  for (i = 0, ln = scrollDockItems.bottom.length; i < ln; i++) {
    item = scrollDockItems.bottom[i];
    item.translate(0, -10000);
  }
}, getItem:function(record) {
  var item;
  if (record) {
    item = this.recordMap[record.internalId];
  }
  return item || null;
}, getItemAt:function(index) {
  var listItems = this.listItems, ln = listItems.length, i, listItem;
  for (i = 0; i < ln; i++) {
    listItem = listItems[i];
    if (listItem.$dataIndex == index) {
      return listItem;
    }
  }
}, getItemIndex:function(item) {
  return item.$dataIndex;
}, getViewItems:function() {
  return this.listItems;
}, getListItemInfo:function() {
  var me = this, baseCls = me.getBaseCls();
  return {store:me.getStore(), grouped:me.isGrouping(), baseCls:baseCls, selectedCls:me.getSelectedCls(), headerCls:baseCls + '-header-wrap', footerCls:baseCls + '-footer-wrap', firstCls:baseCls + '-item-first', lastCls:baseCls + '-item-last', stripeCls:baseCls + '-item-odd', striped:me.getStriped(), itemMap:me.getItemMap(), defaultItemHeight:me.getItemHeight()};
}, getListItemConfig:function() {
  var me = this, minimumHeight = me.getItemMap().getMinimumHeight(), config = {xtype:me.getDefaultType(), tpl:me.getItemTpl(), minHeight:minimumHeight, cls:me.getItemCls()};
  if (me.getInfinite()) {
    config.translatable = {translationMethod:this.translationMethod};
  }
  if (!me.getVariableHeights()) {
    config.height = minimumHeight;
  }
  return Ext.merge(config, me.getItemConfig());
}, refreshHeaderIndices:function() {
  var me = this, store = me.getStore(), storeLn = store && store.getCount(), groups = store.getGrouper() ? store.getGroups() : null, grouped = me.getGrouped(), headerIndices = me.headerIndices = {}, footerIndices = me.footerIndices = {}, i, previousIndex, firstGroupedRecord, storeIndex, groupLn;
  if (!grouped || !groups) {
    return footerIndices;
  }
  groupLn = groups.length;
  me.groups = groups;
  for (i = 0; i < groupLn; i++) {
    firstGroupedRecord = groups.getAt(i).getAt(0);
    storeIndex = store.indexOf(firstGroupedRecord);
    headerIndices[storeIndex] = true;
    previousIndex = storeIndex - 1;
    if (previousIndex >= 0) {
      footerIndices[previousIndex] = true;
    }
  }
  footerIndices[storeLn - 1] = true;
  return headerIndices;
}, onIndex:function(indexBar, index) {
  var me = this, key = index.toLowerCase(), store = me.getStore(), groups = store.getGroups(), ln = groups.length, group, groupKey, i, closest;
  for (i = 0; i < ln; i++) {
    group = groups.getAt(i);
    groupKey = group.getGroupKey().toLowerCase();
    if (groupKey >= key) {
      closest = group;
      break;
    } else {
      closest = group;
    }
  }
  if (closest) {
    this.scrollToRecord(closest.getAt(0));
  }
}, scrollToRecord:function(record, animate, overscroll) {
  var me = this, scroller = me.container.getScrollable(), store = me.getStore(), index = store.indexOf(record), header;
  scroller.stopAnimation();
  var elementHeight = scroller.getElement().getHeight(), scrollHeight = scroller.getSize().y, maxOffset = scrollHeight - elementHeight, offset, item;
  if (me.getInfinite()) {
    offset = me.getItemMap().map[index];
  } else {
    item = me.listItems[index];
    header = item.getHeader && item.getHeader();
    if (header && header.isPainted()) {
      offset = header.renderElement.dom.offsetTop;
    } else {
      offset = item.renderElement.dom.offsetTop;
    }
  }
  if (!overscroll) {
    offset = Math.min(offset, maxOffset);
  }
  scroller.scrollTo(0, offset, !!animate);
}, onItemAdd:function(item) {
  var me = this, config = item.config;
  if (config.scrollDock) {
    if (config.scrollDock == 'bottom') {
      me.scrollDockItems.bottom.push(item);
    } else {
      me.scrollDockItems.top.push(item);
    }
    if (me.getInfinite()) {
      item.on({resize:'onScrollDockItemResize', scope:this});
      item.addCls(me.getBaseCls() + '-scrolldockitem');
      item.setTranslatable({translationMethod:this.translationMethod});
      item.translate(0, -10000);
      item.$scrollDockHeight = 0;
    }
    me.container.doAdd(item);
  } else {
    me.callParent(arguments);
  }
}, getScrollDockedItems:function() {
  return this.scrollDockItems.bottom.slice().concat(this.scrollDockItems.top.slice());
}, onScrollDockItemResize:function(dockItem, size) {
  var me = this, items = me.listItems, ln = items.length, i, item;
  Ext.getCmp(dockItem.id).$scrollDockHeight = size.height;
  for (i = 0; i < ln; i++) {
    item = items[i];
    if (item.isLast) {
      me.updatedItems.push(item);
      if (me.isPainted()) {
        me.refreshScroller();
      }
      break;
    }
  }
}, onItemTouchStart:function(e) {
  this.container.innerElement.on({touchmove:'onItemTouchMove', delegate:'.' + Ext.baseCSSPrefix + 'list-item', single:true, scope:this});
  this.callParent(this.parseEvent(e));
}, onItemTouchMove:function(e) {
  this.callParent(this.parseEvent(e));
}, onItemTouchEnd:function(e) {
  this.container.innerElement.un({touchmove:'onItemTouchMove', delegate:'.' + Ext.baseCSSPrefix + 'list-item', scope:this});
  this.callParent(this.parseEvent(e));
}, onItemTap:function(e) {
  this.callParent(this.parseEvent(e));
}, onItemTapHold:function(e) {
  this.callParent(this.parseEvent(e));
}, onItemSingleTap:function(e) {
  this.callParent(this.parseEvent(e));
}, onItemDoubleTap:function(e) {
  this.callParent(this.parseEvent(e));
}, onItemSwipe:function(e) {
  this.callParent(this.parseEvent(e));
}, parseEvent:function(e) {
  var me = this, target = Ext.fly(e.currentTarget).findParent('.' + Ext.baseCSSPrefix + 'list-item', 8), item = Ext.getCmp(target.id);
  return [me, item, item.$dataIndex, e];
}, applyOnItemDisclosure:function(config) {
  if (Ext.isFunction(config)) {
    return {scope:this, handler:config};
  }
  return config;
}, handleItemDisclosure:function(e) {
  var me = this, item = Ext.getCmp(Ext.get(e.currentTarget).up('.x-list-item').id), index = item.$dataIndex, record = me.getStore().getAt(index);
  me.fireAction('disclose', [me, record, item, index, e], 'doDisclose');
}, doDisclose:function(me, record, item, index, e) {
  var onItemDisclosure = me.getOnItemDisclosure();
  if (onItemDisclosure && onItemDisclosure.handler) {
    onItemDisclosure.handler.call(onItemDisclosure.scope || me, record, item, index, e);
  }
}, onItemTrigger:function(me, index, target, record, e) {
  if (!(this.getPreventSelectionOnDisclose() && Ext.fly(e.target).hasCls(this.getBaseCls() + '-disclosure'))) {
    this.callParent(arguments);
  }
}, destroy:function() {
  var me = this, items = me.listItems, ln = items.length, i;
  if (me.pinnedHeader) {
    me.pinnedHeader.destroy();
    me.pinnedHeader = null;
  }
  me.callParent();
  if (me.onIdleBound) {
    Ext.AnimationQueue.unIdle(me.onAnimationIdle, me);
  }
  for (i = 0; i < ln; i++) {
    items[i].destroy();
  }
  me.recordMap = me.listItems = null;
}, privates:{handleGroupChange:function() {
  var me = this, grouped = me.isGrouping(), baseCls = this.getBaseCls(), infinite = me.getInfinite(), pinnedHeader = me.pinnedHeader, cls = baseCls + '-grouped', unCls = baseCls + '-ungrouped';
  if (pinnedHeader) {
    pinnedHeader.translate(0, -10000);
  }
  if (grouped) {
    me.addCls(cls);
    me.removeCls(unCls);
  } else {
    me.addCls(unCls);
    me.removeCls(cls);
  }
  if (infinite) {
    me.refreshHeaderIndices();
    me.handleItemHeights();
  }
  me.updateAllListItems();
  if (infinite) {
    me.handleItemTransforms();
  }
}, isGrouping:function() {
  return Boolean(this.getGrouped() && this.getStore().getGrouper());
}}});
Ext.define('Ext.field.Checkbox', {extend:Ext.field.Field, alternateClassName:'Ext.form.Checkbox', xtype:'checkboxfield', qsaLeftRe:/[\[]/g, qsaRightRe:/[\]]/g, isCheckbox:true, defaultBindProperty:'checked', twoWayBindable:{checked:1}, publishes:{checked:1}, config:{ui:'checkbox', value:'', checked:false, tabIndex:-1, component:{xtype:'input', type:'checkbox', useMask:true, cls:Ext.baseCSSPrefix + 'input-checkbox'}}, initialize:function() {
  var me = this, component = me.getComponent();
  me.callParent();
  component.on({scope:me, order:'before', masktap:'onMaskTap'});
  component.doMaskTap = Ext.emptyFn;
  me.label.on({scope:me, tap:'onMaskTap'});
  me.publishState('checked', me.getChecked());
}, doInitValue:function() {
  var me = this, initialConfig = me.getInitialConfig();
  if (initialConfig.hasOwnProperty('value')) {
    me.originalState = initialConfig.value;
  }
  if (initialConfig.hasOwnProperty('checked')) {
    me.originalState = initialConfig.checked;
  }
  me.callParent(arguments);
}, updateInputType:function(newInputType) {
  var component = this.getComponent();
  if (component) {
    component.setType(newInputType);
  }
}, updateName:function(newName) {
  var component = this.getComponent();
  if (component) {
    component.setName(newName);
  }
}, getSubmitValue:function() {
  return this.getChecked() ? Ext.isEmpty(this._value) ? true : this._value : null;
}, updateChecked:function(checked, oldChecked) {
  var me = this, eventName;
  me.getComponent().setChecked(checked);
  if (me.initialized) {
    eventName = checked ? 'check' : 'uncheck';
    me.fireEvent(eventName, me);
    me.fireEvent('change', me, checked, oldChecked);
  }
}, onMaskTap:function(component, e) {
  var me = this, dom = me.getComponent().input.dom;
  if (me.getDisabled()) {
    return false;
  }
  dom.checked = !dom.checked;
  me.setChecked(dom.checked);
  return false;
}, isChecked:function() {
  return this.getChecked();
}, check:function() {
  return this.setChecked(true);
}, uncheck:function() {
  return this.setChecked(false);
}, getSameGroupFields:function() {
  var me = this, component = me.up('formpanel') || me.up('fieldset'), name = me.getName(), replaceLeft = me.qsaLeftRe, replaceRight = me.qsaRightRe, baseCls = me.getBaseCls().split(' ').join('.'), components = [], elements, element, i, ln;
  if (!component) {
    Ext.Logger.warn('Ext.field.Radio components must always be descendants of an Ext.form.Panel or Ext.form.FieldSet.');
    component = Ext.Viewport;
  }
  name = name.replace(replaceLeft, '\\[');
  name = name.replace(replaceRight, '\\]');
  elements = Ext.query('[name\x3d' + name + ']', component.element.dom);
  ln = elements.length;
  for (i = 0; i < ln; i++) {
    element = elements[i];
    element = Ext.fly(element).up('.' + baseCls);
    if (element && element.id) {
      components.push(Ext.getCmp(element.id));
    }
  }
  return components;
}, getGroupValues:function() {
  var values = [];
  this.getSameGroupFields().forEach(function(field) {
    if (field.getChecked()) {
      values.push(field.getValue());
    }
  });
  return values;
}, setGroupValues:function(values) {
  this.getSameGroupFields().forEach(function(field) {
    field.setChecked(values.indexOf(field.getValue()) !== -1);
  });
  return this;
}, resetGroupValues:function() {
  this.getSameGroupFields().forEach(function(field) {
    field.setChecked(field.originalState);
  });
  return this;
}, reset:function() {
  this.setChecked(this.originalState);
  return this;
}});
Ext.define('Ext.field.Picker', {extend:Ext.field.Text, config:{component:{useMask:true}, clearIcon:false, usePicker:'auto', defaultPhonePickerConfig:null, defaultTabletPickerConfig:null, pickerSlotAlign:'center'}, initialize:function() {
  var me = this, component = me.getComponent();
  me.callParent();
  component.on({scope:me, masktap:'onMaskTap'});
  component.doMaskTap = Ext.emptyFn;
}, updateDefaultPhonePickerConfig:function(newConfig) {
  var phonePicker = this.phonePicker;
  if (phonePicker) {
    phonePicker.setConfig(newConfig);
  }
}, updateDefaultTabletPickerConfig:function(newConfig) {
  var tabletPicker = this.tabletPicker;
  if (tabletPicker) {
    tabletPicker.setConfig(newConfig);
  }
}, applyUsePicker:function(usePicker) {
  if (usePicker === 'auto') {
    usePicker = Ext.os.deviceType === 'Phone';
  }
  return Boolean(usePicker);
}, syncEmptyCls:Ext.emptyFn, onMaskTap:function() {
  if (!this.getDisabled()) {
    this.onFocus();
  }
  return false;
}, updateDisabled:function(disabled) {
  var component = this.getComponent();
  if (component) {
    component.setDisabled(disabled);
  }
  Ext.Component.prototype.updateDisabled.apply(this, arguments);
}, setDisabled:function() {
  Ext.Component.prototype.setDisabled.apply(this, arguments);
}, onFocus:function(e) {
  if (this.getDisabled()) {
    return false;
  }
  var component = this.getComponent();
  this.fireEvent('focus', this, e);
  if (Ext.os.is.Android4) {
    component.input.dom.focus();
  }
  component.input.dom.blur();
  this.isFocused = true;
  this.showPicker();
}, destroy:function() {
  var me = this;
  me.callParent();
  me.tabletPicker = me.phonePicker = Ext.destroy(me.tabletPicker, me.phonePicker);
}});
Ext.define('Ext.picker.Slot', {extend:Ext.dataview.DataView, xtype:'pickerslot', isSlot:true, config:{title:null, showTitle:true, cls:Ext.baseCSSPrefix + 'picker-slot', name:null, value:null, flex:1, align:'left', displayField:'text', valueField:'value', itemTpl:null, scrollable:{x:false, indicators:false, momentumEasing:{minVelocity:2}, slotSnapEasing:{duration:100}}, verticallyCenterItems:true}, constructor:function() {
  this.selectedIndex = 0;
  this.callParent(arguments);
}, applyTitle:function(title) {
  if (title) {
    title = Ext.create('Ext.Component', {cls:Ext.baseCSSPrefix + 'picker-slot-title', docked:'top', html:title});
  }
  return title;
}, updateTitle:function(newTitle, oldTitle) {
  if (newTitle) {
    this.add(newTitle);
    this.setupBar();
  }
  if (oldTitle) {
    this.remove(oldTitle);
  }
}, updateShowTitle:function(showTitle) {
  var title = this.getTitle(), mode = showTitle ? 'show' : 'hide';
  if (title) {
    title.on(mode, this.setupBar, this, {single:true, delay:50});
    title[showTitle ? 'show' : 'hide']();
  }
}, updateDisplayField:function(newDisplayField) {
  if (!this.config.itemTpl) {
    this.setItemTpl('\x3cdiv class\x3d"' + Ext.baseCSSPrefix + 'picker-item {cls} \x3ctpl if\x3d"extra"\x3e' + Ext.baseCSSPrefix + 'picker-invalid\x3c/tpl\x3e"\x3e{' + newDisplayField + '}\x3c/div\x3e');
  }
}, updateAlign:function(newAlign, oldAlign) {
  var element = this.element;
  element.addCls(Ext.baseCSSPrefix + 'picker-' + newAlign);
  element.removeCls(Ext.baseCSSPrefix + 'picker-' + oldAlign);
}, applyData:function(data) {
  var parsedData = [], ln = data && data.length, i, item, obj;
  if (data && Ext.isArray(data) && ln) {
    for (i = 0; i < ln; i++) {
      item = data[i];
      obj = {};
      if (Ext.isArray(item)) {
        obj[this.valueField] = item[0];
        obj[this.displayField] = item[1];
      } else {
        if (Ext.isString(item)) {
          obj[this.valueField] = item;
          obj[this.displayField] = item;
        } else {
          if (Ext.isObject(item)) {
            obj = item;
          }
        }
      }
      parsedData.push(obj);
    }
  }
  return data;
}, initialize:function() {
  this.callParent();
  var scroller = this.getScrollable();
  this.on({scope:this, painted:'onPainted', itemtap:'doItemTap'});
  this.element.on({scope:this, touchstart:'onTouchStart', touchend:'onTouchEnd'});
  scroller.on({scope:this, scrollend:'onScrollEnd'});
}, onPainted:function() {
  this.setupBar();
}, getPicker:function() {
  if (!this.picker) {
    this.picker = this.getParent();
  }
  return this.picker;
}, setupBar:function() {
  if (!this.rendered) {
    return;
  }
  var element = this.element, containerElement = this.container.element, picker = this.getPicker(), bar = picker.bar, value = this.getValue(), showTitle = this.getShowTitle(), title = this.getTitle(), scroller = this.getScrollable(), titleHeight = 0, barHeight, padding;
  barHeight = bar.dom.getBoundingClientRect().height;
  if (showTitle && title) {
    titleHeight = title.element.getHeight();
  }
  padding = Math.ceil((element.getHeight() - titleHeight - barHeight) / 2);
  if (this.getVerticallyCenterItems()) {
    containerElement.setStyle({padding:padding + 'px 0 ' + padding + 'px'});
  }
  scroller.refresh();
  scroller.setSlotSnapSize(barHeight);
  this.setValue(value);
}, doItemTap:function(list, index, item, e) {
  var me = this;
  me.selectedIndex = index;
  me.selectedNode = item;
  me.scrollToItem(item, true);
}, scrollToItem:function(item, animated) {
  var y = item.getY(), parentEl = item.parent(), parentY = parentEl.getY(), scroller = this.getScrollable(), difference;
  difference = y - parentY;
  scroller.scrollTo(0, difference, animated);
}, onTouchStart:function() {
  this.element.addCls(Ext.baseCSSPrefix + 'scrolling');
}, onTouchEnd:function() {
  this.element.removeCls(Ext.baseCSSPrefix + 'scrolling');
}, onScrollEnd:function(scroller, x, y) {
  var me = this, index = Math.round(y / me.picker.bar.dom.getBoundingClientRect().height), viewItems = me.getViewItems(), item = viewItems[index];
  if (item) {
    me.selectedIndex = index;
    me.selectedNode = item;
    me.fireEvent('slotpick', me, me.getValue(), me.selectedNode);
  }
}, getValue:function(useDom) {
  var store = this.getStore(), record, value;
  if (!store) {
    return;
  }
  if (!this.rendered || !useDom) {
    return this._value;
  }
  if (this._value === false) {
    return null;
  }
  record = store.getAt(this.selectedIndex);
  value = record ? record.get(this.getValueField()) : null;
  return value;
}, setValue:function(value) {
  return this.doSetValue(value);
}, setValueAnimated:function(value) {
  return this.doSetValue(value, true);
}, doSetValue:function(value, animated) {
  if (!this.rendered) {
    this._value = value;
    return;
  }
  var store = this.getStore(), viewItems = this.getViewItems(), valueField = this.getValueField(), index, item;
  index = store.findExact(valueField, value);
  if (index == -1) {
    index = 0;
  }
  item = Ext.get(viewItems[index]);
  this.selectedIndex = index;
  if (item) {
    this.scrollToItem(item, animated ? {duration:100} : false);
    this.select(this.selectedIndex);
  }
  this._value = value;
}});
Ext.define('Ext.picker.Picker', {extend:Ext.Sheet, alias:'widget.picker', alternateClassName:'Ext.Picker', isPicker:true, config:{baseCls:Ext.baseCSSPrefix + 'picker', doneButton:true, cancelButton:true, useTitles:false, slots:null, value:null, height:220, layout:{type:'hbox', align:'stretch'}, centered:false, left:0, right:0, bottom:0, defaultType:'pickerslot', toolbarPosition:'top', toolbar:{xtype:'titlebar'}}, initialize:function() {
  var me = this, clsPrefix = Ext.baseCSSPrefix, innerElement = this.innerElement;
  this.mask = innerElement.createChild({cls:clsPrefix + 'picker-mask'});
  this.bar = this.mask.createChild({cls:clsPrefix + 'picker-bar'});
  me.on({scope:this, delegate:'pickerslot', slotpick:'onSlotPick'});
}, applyToolbar:function(config) {
  if (config === true) {
    config = {};
  }
  Ext.applyIf(config, {docked:this.getToolbarPosition()});
  return Ext.factory(config, 'Ext.TitleBar', this.getToolbar());
}, updateToolbar:function(newToolbar, oldToolbar) {
  if (newToolbar) {
    this.add(newToolbar);
  }
  if (oldToolbar) {
    this.remove(oldToolbar);
  }
}, applyDoneButton:function(config) {
  if (config) {
    if (Ext.isBoolean(config)) {
      config = {};
    }
    if (typeof config == 'string') {
      config = {text:config};
    }
    Ext.applyIf(config, {ui:'action', align:'right', text:'Done'});
  }
  return Ext.factory(config, 'Ext.Button', this.getDoneButton());
}, updateDoneButton:function(newDoneButton, oldDoneButton) {
  var toolbar = this.getToolbar();
  if (newDoneButton) {
    toolbar.add(newDoneButton);
    newDoneButton.on('tap', this.onDoneButtonTap, this);
  } else {
    if (oldDoneButton) {
      toolbar.remove(oldDoneButton);
    }
  }
}, applyCancelButton:function(config) {
  if (config) {
    if (Ext.isBoolean(config)) {
      config = {};
    }
    if (typeof config == 'string') {
      config = {text:config};
    }
    Ext.applyIf(config, {align:'left', text:'Cancel'});
  }
  return Ext.factory(config, 'Ext.Button', this.getCancelButton());
}, updateCancelButton:function(newCancelButton, oldCancelButton) {
  var toolbar = this.getToolbar();
  if (newCancelButton) {
    toolbar.add(newCancelButton);
    newCancelButton.on('tap', this.onCancelButtonTap, this);
  } else {
    if (oldCancelButton) {
      toolbar.remove(oldCancelButton);
    }
  }
}, updateUseTitles:function(useTitles) {
  var innerItems = this.getInnerItems(), ln = innerItems.length, cls = Ext.baseCSSPrefix + 'use-titles', i, innerItem;
  if (useTitles) {
    this.addCls(cls);
  } else {
    this.removeCls(cls);
  }
  for (i = 0; i < ln; i++) {
    innerItem = innerItems[i];
    if (innerItem.isSlot) {
      innerItem.setShowTitle(useTitles);
    }
  }
}, applySlots:function(slots) {
  if (slots) {
    var ln = slots.length, i;
    for (i = 0; i < ln; i++) {
      slots[i].picker = this;
    }
  }
  return slots;
}, updateSlots:function(newSlots) {
  var bcss = Ext.baseCSSPrefix, innerItems;
  this.removeAll();
  if (newSlots) {
    this.add(newSlots);
  }
  innerItems = this.getInnerItems();
  if (innerItems.length > 0) {
    innerItems[0].addCls(bcss + 'first');
    innerItems[innerItems.length - 1].addCls(bcss + 'last');
  }
  this.updateUseTitles(this.getUseTitles());
}, onDoneButtonTap:function() {
  var oldValue = this._value, newValue = this.getValue(true);
  if (newValue != oldValue) {
    this.fireEvent('change', this, newValue);
  }
  this.hide();
  Ext.util.InputBlocker.unblockInputs();
}, onCancelButtonTap:function() {
  this.fireEvent('cancel', this);
  this.hide();
  Ext.util.InputBlocker.unblockInputs();
}, onSlotPick:function(slot) {
  this.fireEvent('pick', this, this.getValue(true), slot);
}, show:function() {
  if (this.getParent() === undefined) {
    Ext.Viewport.add(this);
  }
  this.callParent(arguments);
  if (!this.isHidden()) {
    this.setValue(this._value);
  }
  Ext.util.InputBlocker.blockInputs();
}, setValue:function(values, animated) {
  var me = this, slots = me.getInnerItems(), ln = slots.length, key, slot, loopSlot, i, value;
  if (!values) {
    values = {};
    for (i = 0; i < ln; i++) {
      values[slots[i].config.name] = null;
    }
  }
  for (key in values) {
    slot = null;
    value = values[key];
    for (i = 0; i < slots.length; i++) {
      loopSlot = slots[i];
      if (loopSlot.config.name == key) {
        slot = loopSlot;
        break;
      }
    }
    if (slot) {
      if (animated) {
        slot.setValueAnimated(value);
      } else {
        slot.setValue(value);
      }
    }
  }
  me._values = me._value = values;
  return me;
}, setValueAnimated:function(values) {
  this.setValue(values, true);
}, getValue:function(useDom) {
  var values = {}, items = this.getItems().items, ln = items.length, item, i;
  if (useDom) {
    for (i = 0; i < ln; i++) {
      item = items[i];
      if (item && item.isSlot) {
        values[item.getName()] = item.getValue(useDom);
      }
    }
    this._values = values;
  }
  return this._values;
}, getValues:function() {
  return this.getValue();
}, destroy:function() {
  var me = this;
  me.callParent();
  me.mask = me.bar = Ext.destroy(me.mask, me.bar);
}});
Ext.define('Ext.field.Email', {extend:Ext.field.Text, alternateClassName:'Ext.form.Email', xtype:'emailfield', config:{component:{type:'email'}, autoCapitalize:false}});
Ext.define('Ext.field.Password', {extend:Ext.field.Text, xtype:'passwordfield', alternateClassName:'Ext.form.Password', config:{autoCapitalize:false, revealable:false, revealed:false, component:{type:'password'}}, isPassword:true, initialize:function() {
  this.callParent(arguments);
  this.addCls(Ext.baseCSSPrefix + 'field-password');
}, updateRevealable:function(newValue, oldValue) {
  if (this.$revealIcon) {
    this.getComponent().element.removeChild(this.$revealIcon);
    this.$revealIcon = null;
  }
  if (newValue === true) {
    this.$revealIcon = new Ext.Element(Ext.Element.create({cls:'x-reveal-icon'}, true));
    this.$revealIcon.on({tap:'onRevealIconTap', touchstart:'onRevealIconPress', touchend:'onRevealIconRelease', scope:this});
    this.getComponent().element.appendChild(this.$revealIcon);
  }
}, updateRevealed:function(newValue, oldValue) {
  var component = this.getComponent();
  if (newValue) {
    this.element.addCls(Ext.baseCSSPrefix + 'revealed');
    component.setType('text');
  } else {
    this.element.removeCls(Ext.baseCSSPrefix + 'revealed');
    component.setType('password');
  }
}, updateValue:function(value, oldValue) {
  this.toggleRevealIcon(this.isValidTextValue(value));
  this.callParent([value, oldValue]);
}, doKeyUp:function(me, e) {
  var value = me.getValue(), valid = me.isValidTextValue(me.getValue());
  me.toggleClearIcon(valid);
  if (e.browserEvent.keyCode === 13) {
    me.fireAction('action', [me, e], 'doAction');
  }
  me.toggleRevealIcon(valid);
}, showRevealIcon:function() {
  var me = this, value = me.getValue(), valueValid = value !== undefined && value !== null && value !== '';
  if (me.getRevealable() && !me.getDisabled() && valueValid) {
    me.element.addCls(Ext.baseCSSPrefix + 'field-revealable');
  }
  return me;
}, hideRevealIcon:function() {
  if (this.getRevealable()) {
    this.element.removeCls(Ext.baseCSSPrefix + 'field-revealable');
  }
}, onRevealIconTap:function(e) {
  this.fireAction('revealicontap', [this, e], 'doRevealIconTap');
}, doRevealIconTap:function(me, e) {
  me.setRevealed(!this.getRevealed());
}, onRevealIconPress:function() {
  this.$revealIcon.addCls(Ext.baseCSSPrefix + 'pressing');
}, onRevealIconRelease:function() {
  this.$revealIcon.removeCls(Ext.baseCSSPrefix + 'pressing');
}, privates:{isValidTextValue:function(value) {
  return value !== undefined && value !== null && value !== '';
}, toggleRevealIcon:function(state) {
  if (state) {
    this.showRevealIcon();
  } else {
    this.hideRevealIcon();
  }
}}});
Ext.define('Ext.field.Select', {extend:Ext.field.Picker, xtype:'selectfield', alternateClassName:'Ext.form.Select', config:{ui:'select', valueField:'value', displayField:'text', store:null, options:null, hiddenName:null, autoSelect:true, name:'picker', selection:null}, twoWayBindable:{selection:1}, publishes:{selection:1}, applyValue:function(value) {
  var me = this, record = value, index, store;
  me.getOptions();
  store = me.getStore();
  if ((value || value === 0) && !value.isModel && store) {
    index = store.find(me.getValueField(), value, null, null, null, true);
    if (index === -1) {
      index = store.find(me.getDisplayField(), value, null, null, null, true);
    }
    record = store.getAt(index);
  }
  return record;
}, updateValue:function(value, oldValue) {
  var me = this, component = me.getComponent(), displayValue = '';
  if (value === null || value && value.isModel) {
    me.settingSelection = true;
    me.setSelection(value);
    me.settingSelection = false;
    if (value) {
      displayValue = value.get(me.getDisplayField());
    }
  }
  if (component) {
    component.setValue(displayValue);
  }
  if (me.initialized) {
    me.fireEvent('change', me, value, oldValue);
  }
}, getValue:function() {
  var selection = this.getSelection();
  return selection ? selection.get(this.getValueField()) : null;
}, applySelection:function(selection) {
  return selection || null;
}, updateSelection:function(selection) {
  if (!this.settingSelection) {
    this.setValue(selection ? selection.get(this.getValueField()) : null);
  }
}, getPhonePicker:function() {
  var me = this, phonePicker = me.phonePicker, config;
  if (!phonePicker) {
    config = me.getDefaultPhonePickerConfig();
    me.phonePicker = phonePicker = Ext.create('Ext.picker.Picker', Ext.apply({slots:[{align:me.getPickerSlotAlign(), name:me.getName(), valueField:me.getValueField(), displayField:me.getDisplayField(), value:me.getValue(), store:me.getStore()}], listeners:{change:me.onPickerChange, scope:me}}, config));
  }
  return phonePicker;
}, getTabletPicker:function() {
  var me = this, tabletPicker = me.tabletPicker, config;
  if (!tabletPicker) {
    config = me.getDefaultTabletPickerConfig();
    me.tabletPicker = tabletPicker = Ext.create('Ext.Panel', Ext.apply({left:0, top:0, modal:true, cls:Ext.baseCSSPrefix + 'select-overlay', layout:'fit', hideOnMaskTap:true, width:Ext.os.is.Phone ? '14em' : '18em', height:Ext.os.is.BlackBerry && Ext.os.version.getMajor() === 10 ? '12em' : Ext.os.is.Phone ? '12.5em' : '22em', items:{xtype:'list', store:me.getStore(), itemTpl:'\x3cspan class\x3d"x-list-label"\x3e{' + me.getDisplayField() + ':htmlEncode}\x3c/span\x3e', listeners:{select:me.onListSelect, 
    itemtap:me.onListTap, scope:me}}}, config));
  }
  return tabletPicker;
}, showPicker:function() {
  var me = this, store = me.getStore(), value = me.getValue(), picker, name, pickerValue, list, index, record;
  if (!store || store.getCount() === 0) {
    return;
  }
  if (me.getReadOnly()) {
    return;
  }
  me.isFocused = true;
  if (me.getUsePicker()) {
    picker = me.getPhonePicker();
    name = me.getName();
    pickerValue = {};
    pickerValue[name] = value;
    picker.setValue(pickerValue);
    if (!picker.getParent()) {
      Ext.Viewport.add(picker);
    }
    picker.show();
  } else {
    picker = me.getTabletPicker();
    list = picker.down('list');
    if (!picker.getParent()) {
      Ext.Viewport.add(picker);
    }
    picker.showBy(me.getComponent(), null);
    if (value || me.getAutoSelect()) {
      store = list.getStore();
      index = store.find(me.getValueField(), value, null, null, null, true);
      record = store.getAt(index);
      if (record) {
        list.select(record, null, true);
      }
    }
  }
}, onListSelect:function(item, record) {
  var me = this;
  if (record) {
    me.setValue(record);
  }
}, onListTap:function() {
  this.tabletPicker.hide({type:'fade', out:true, scope:this});
}, onPickerChange:function(picker, value) {
  var me = this, newValue = value[me.getName()], store = me.getStore(), index = store.find(me.getValueField(), newValue, null, null, null, true), record = store.getAt(index);
  me.setValue(record);
}, updateOptions:function(newOptions) {
  var store = this.getStore();
  if (!store) {
    this.setStore(true);
    store = this._store;
  }
  if (!newOptions) {
    store.clearData();
  } else {
    store.setData(newOptions);
    this.onStoreDataChanged(store);
  }
  return this;
}, applyStore:function(store) {
  if (store === true) {
    store = Ext.create('Ext.data.Store', {fields:[this.getValueField(), this.getDisplayField()], autoDestroy:true});
  }
  if (store) {
    store = Ext.data.StoreManager.lookup(store);
  }
  return store;
}, updateStore:function(store, oldStore) {
  var me = this, tabletPicker = me.tabletPicker, phonePicker = me.phonePicker;
  if (oldStore && oldStore.getAutoDestroy()) {
    oldStore.destroy();
  }
  if (store) {
    store.on({scope:this, add:'onStoreDataChanged', remove:'onStoreDataChanged', update:'onStoreDataChanged', refresh:'onStoreDataChanged'});
    me.onStoreDataChanged(store);
  }
  if (me.getUsePicker() && phonePicker) {
    phonePicker.down('pickerslot').setStore(store);
  } else {
    if (tabletPicker) {
      tabletPicker.down('dataview').setStore(store);
    }
  }
}, onStoreDataChanged:function(store) {
  var initialConfig = this.getInitialConfig(), value = this.getValue();
  if (value || value === 0) {
    this.setValue(value);
  }
  if (this.getValue() === null) {
    if (initialConfig.hasOwnProperty('value')) {
      this.setValue(initialConfig.value);
    }
    if (this.getValue() === null && this.getAutoSelect()) {
      if (store.getCount() > 0) {
        this.setValue(store.getAt(0));
      }
    }
  }
}, reset:function() {
  var me = this, record, store, usePicker, picker;
  if (me.getAutoSelect()) {
    store = me.getStore();
    record = me.originalValue ? me.originalValue : store.getAt(0);
  } else {
    usePicker = me.getUsePicker();
    picker = usePicker ? me.phonePicker : me.tabletPicker;
    if (picker) {
      picker = picker.child(usePicker ? 'pickerslot' : 'dataview');
      picker.deselectAll();
    }
    record = null;
  }
  me.setValue(record);
  return me;
}, destroy:function() {
  var store = this.getStore();
  if (store && store.getAutoDestroy()) {
    store.destroy();
  }
  this.callParent();
}});
Ext.define('Ext.slider.Thumb', {extend:Ext.Component, xtype:'thumb', config:{baseCls:Ext.baseCSSPrefix + 'thumb', pressedCls:Ext.baseCSSPrefix + 'thumb-pressing', draggable:{direction:'horizontal'}}, platformConfig:{ie10:{draggable:{translatable:{translationMethod:'csstransform'}}}}, elementWidth:0, initialize:function() {
  var me = this;
  me.callParent();
  me.getDraggable().onBefore({beforedragstart:'onBeforeDragStart', dragstart:'onDragStart', drag:'onDrag', dragend:'onDragEnd', scope:this});
  me.getDraggable().on({touchstart:'onPress', touchend:'onRelease', scope:me});
  me.element.on('resize', 'onElementResize', me);
}, updatePressedCls:function(pressedCls, oldPressedCls) {
  var element = this.element;
  if (element.hasCls(oldPressedCls)) {
    element.replaceCls(oldPressedCls, pressedCls);
  }
}, onPress:function() {
  var me = this, element = me.element, pressedCls = me.getPressedCls();
  if (!me.getDisabled()) {
    element.addCls(pressedCls);
  }
}, onRelease:function(e) {
  this.fireAction('release', [this, e], 'doRelease');
}, doRelease:function(me, e) {
  if (!me.getDisabled()) {
    me.element.removeCls(me.getPressedCls());
  }
}, onBeforeDragStart:function(draggable, e, x, y) {
  if (this.isDisabled()) {
    return false;
  }
  return this.fireEvent('beforedragstart', this, e, x, y);
}, onDragStart:function(draggable, e, x, y) {
  this.fireEvent('dragstart', this, e, x, y);
}, onDrag:function(draggable, e, x, y) {
  if (this.isDisabled()) {
    return false;
  }
  this.fireEvent('drag', this, e, x, y);
}, onDragEnd:function(draggable, e, x, y) {
  if (this.isDisabled()) {
    return false;
  }
  this.fireEvent('dragend', this, e, x, y);
}, onElementResize:function(element, info) {
  this.elementWidth = info.width;
}, getElementWidth:function() {
  return this.elementWidth;
}});
Ext.define('Ext.slider.Slider', {extend:Ext.Container, xtype:'slider', config:{baseCls:'x-slider', thumbConfig:{draggable:{translatable:{easingX:{duration:300, type:'ease-out'}}}}, increment:1, value:0, minValue:0, maxValue:100, allowThumbsOverlapping:false, animation:true, readOnly:false}, elementWidth:0, offsetValueRatio:0, activeThumb:null, constructor:function(config) {
  config = config || {};
  if (config.hasOwnProperty('values')) {
    config.value = config.values;
  }
  this.callParent([config]);
}, initialize:function() {
  var element = this.element, thumb;
  this.callParent();
  element.on({scope:this, tap:'onTap', resize:'onResize'});
  this.on({scope:this, delegate:'\x3e thumb', tap:'onTap', beforedragstart:'onThumbBeforeDragStart', dragstart:'onThumbDragStart', drag:'onThumbDrag', dragend:'onThumbDragEnd'});
  thumb = this.getThumb(0);
  if (thumb) {
    thumb.on('resize', 'onThumbResize', this);
  }
}, factoryThumb:function() {
  return Ext.factory(this.getThumbConfig(), Ext.slider.Thumb);
}, getThumbs:function() {
  return this.innerItems;
}, getThumb:function(index) {
  if (typeof index != 'number') {
    index = 0;
  }
  return this.innerItems[index];
}, refreshOffsetValueRatio:function() {
  var me = this, valueRange = me.getMaxValue() - me.getMinValue(), trackWidth = me.elementWidth - me.thumbWidth;
  me.offsetValueRatio = valueRange === 0 ? 0 : trackWidth / valueRange;
}, onThumbResize:function() {
  var thumb = this.getThumb(0);
  if (thumb) {
    this.thumbWidth = thumb.getElementWidth();
  }
  this.refresh();
}, onResize:function(element, info) {
  this.elementWidth = info.width;
  this.refresh();
}, refresh:function() {
  this.refreshing = true;
  this.refreshValue();
  this.refreshing = false;
}, setActiveThumb:function(thumb) {
  var oldActiveThumb = this.activeThumb;
  if (oldActiveThumb && oldActiveThumb !== thumb) {
    oldActiveThumb.setZIndex(null);
  }
  this.activeThumb = thumb;
  thumb.setZIndex(2);
  return this;
}, onThumbBeforeDragStart:function(thumb, e) {
  if (this.offsetValueRatio === 0 || e.absDeltaX <= e.absDeltaY || this.getReadOnly()) {
    return false;
  }
}, onThumbDragStart:function(thumb, e) {
  var me = this;
  me.refreshAllThumbConstraints();
  e.stopPropagation();
  if (me.getAllowThumbsOverlapping()) {
    me.setActiveThumb(thumb);
  }
  me.dragStartValue = me.getValue()[me.getThumbIndex(thumb)];
  me.fireEvent('dragstart', me, thumb, me.dragStartValue, e);
}, onThumbDrag:function(thumb, e, offsetX) {
  var me = this, index = me.getThumbIndex(thumb), offsetValueRatio = me.offsetValueRatio, constrainedValue = me.constrainValue(me.getMinValue() + offsetX / offsetValueRatio);
  e.stopPropagation();
  me.setIndexValue(index, constrainedValue);
  me.fireEvent('drag', me, thumb, me.getValue(), e);
  return false;
}, setIndexValue:function(index, value, animation) {
  var me = this, thumb = me.getThumb(index), values = me.getValue(), minValue = me.getMinValue(), offsetValueRatio = me.offsetValueRatio, increment = me.getIncrement(), draggable = thumb.getDraggable();
  draggable.setOffset((value - minValue) * offsetValueRatio, null, animation);
  values[index] = minValue + Math.round(draggable.offset.x / offsetValueRatio / increment) * increment;
}, onThumbDragEnd:function(thumb, e) {
  var me = this, index = me.getThumbIndex(thumb), newValue = me.getValue()[index], oldValue = me.dragStartValue;
  me.snapThumbPosition(thumb, newValue);
  me.fireEvent('dragend', me, thumb, me.getValue(), e);
  if (oldValue !== newValue) {
    me.fireEvent('change', me, thumb, newValue, oldValue);
  }
}, getThumbIndex:function(thumb) {
  return this.getThumbs().indexOf(thumb);
}, refreshThumbConstraints:function(thumb) {
  var allowThumbsOverlapping = this.getAllowThumbsOverlapping(), offsetX = thumb.getDraggable().getOffset().x, thumbs = this.getThumbs(), index = this.getThumbIndex(thumb), previousThumb = thumbs[index - 1], nextThumb = thumbs[index + 1], thumbWidth = this.thumbWidth;
  if (previousThumb) {
    previousThumb.getDraggable().addExtraConstraint({max:{x:offsetX - (allowThumbsOverlapping ? 0 : thumbWidth)}});
  }
  if (nextThumb) {
    nextThumb.getDraggable().addExtraConstraint({min:{x:offsetX + (allowThumbsOverlapping ? 0 : thumbWidth)}});
  }
}, onTap:function(e) {
  var me = this, element = me.element, minDistance = Infinity, i, absDistance, testValue, closestIndex, oldValue, thumb, ln, values, value, offset, elementX, targetElement, touchPointX;
  if (me.offsetValueRatio === 0 || me.isDisabled() || me.getReadOnly()) {
    return;
  }
  targetElement = Ext.get(e.target);
  if (!targetElement || Ext.browser.engineName == 'WebKit' && targetElement.hasCls('x-thumb')) {
    return;
  }
  touchPointX = e.touch.point.x;
  elementX = element.getX();
  offset = touchPointX - elementX - me.thumbWidth / 2;
  value = me.constrainValue(me.getMinValue() + offset / me.offsetValueRatio);
  values = me.getValue();
  ln = values.length;
  if (ln === 1) {
    closestIndex = 0;
  } else {
    for (i = 0; i < ln; i++) {
      testValue = values[i];
      absDistance = Math.abs(testValue - value);
      if (absDistance < minDistance) {
        minDistance = absDistance;
        closestIndex = i;
      }
    }
  }
  oldValue = values[closestIndex];
  thumb = me.getThumb(closestIndex);
  me.setIndexValue(closestIndex, value, me.getAnimation());
  me.refreshThumbConstraints(thumb);
  if (oldValue !== value) {
    me.fireEvent('change', me, thumb, value, oldValue);
  }
}, updateThumbs:function(newThumbs) {
  this.add(newThumbs);
}, applyValue:function(value, oldValue) {
  var values = Ext.Array.from(value || 0), filteredValues = [], previousFilteredValue = this.getMinValue(), filteredValue, i, ln;
  for (i = 0, ln = values.length; i < ln; i++) {
    filteredValue = this.constrainValue(values[i]);
    if (filteredValue < previousFilteredValue) {
      Ext.Logger.warn("Invalid values of '" + Ext.encode(values) + "', values at smaller indexes must " + 'be smaller than or equal to values at greater indexes');
      filteredValue = previousFilteredValue;
    }
    filteredValues.push(filteredValue);
    previousFilteredValue = filteredValue;
  }
  if (!this.refreshing && oldValue) {
    if (Ext.Array.equals(value, oldValue)) {
      filteredValues = undefined;
    }
  }
  return filteredValues;
}, updateValue:function(newValue, oldValue) {
  var me = this, thumbs = me.getThumbs(), len = newValue.length, i;
  me.setThumbsCount(len);
  for (i = 0; i < len; i++) {
    me.snapThumbPosition(thumbs[i], newValue[i]);
  }
}, refreshValue:function() {
  this.refreshOffsetValueRatio();
  this.setValue(this.getValue());
}, constrainValue:function(value) {
  var me = this, minValue = me.getMinValue(), maxValue = me.getMaxValue(), increment = me.getIncrement(), remainder;
  value = parseFloat(value);
  if (isNaN(value)) {
    value = minValue;
  }
  remainder = (value - minValue) % increment;
  value -= remainder;
  if (Math.abs(remainder) >= increment / 2) {
    value += remainder > 0 ? increment : -increment;
  }
  value = Math.max(minValue, value);
  value = Math.min(maxValue, value);
  return value;
}, setThumbsCount:function(count) {
  var thumbs = this.getThumbs(), thumbsCount = thumbs.length, i, ln, thumb;
  if (thumbsCount > count) {
    for (i = 0, ln = thumbsCount - count; i < ln; i++) {
      thumb = thumbs[thumbs.length - 1];
      thumb.destroy();
    }
  } else {
    if (thumbsCount < count) {
      for (i = 0, ln = count - thumbsCount; i < ln; i++) {
        this.add(this.factoryThumb());
      }
    }
  }
  return this;
}, setValues:function(value) {
  this.setValue(value);
}, getValues:function() {
  return this.getValue();
}, applyIncrement:function(increment) {
  if (increment === 0) {
    increment = 1;
  }
  return Math.abs(increment);
}, updateAllowThumbsOverlapping:function(newValue, oldValue) {
  if (typeof oldValue != 'undefined') {
    this.refreshValue();
  }
}, updateMinValue:function(newValue, oldValue) {
  if (typeof oldValue != 'undefined') {
    this.refreshValue();
  }
}, updateMaxValue:function(newValue, oldValue) {
  if (typeof oldValue != 'undefined') {
    this.refreshValue();
  }
}, updateIncrement:function(newValue, oldValue) {
  if (typeof oldValue != 'undefined') {
    this.refreshValue();
  }
}, updateDisabled:function(disabled) {
  this.callParent(arguments);
  var items = this.getItems().items, ln = items.length, i;
  for (i = 0; i < ln; i++) {
    items[i].setDisabled(disabled);
  }
}, privates:{refreshAllThumbConstraints:function() {
  var thumbs = this.getThumbs(), len = thumbs.length, i;
  for (i = 0; i < len; i++) {
    this.refreshThumbConstraints(thumbs[i]);
  }
}, snapThumbPosition:function(thumb, value) {
  var ratio = this.offsetValueRatio, offset;
  if (isFinite(ratio)) {
    offset = Ext.Number.correctFloat((value - this.getMinValue()) * ratio);
    thumb.getDraggable().setExtraConstraint(null).setOffset(offset);
  }
}}});
Ext.define('Ext.field.Slider', {extend:Ext.field.Field, xtype:'sliderfield', alternateClassName:'Ext.form.Slider', config:{cls:Ext.baseCSSPrefix + 'slider-field', liveUpdate:false, tabIndex:-1, readOnly:false, value:0}, proxyConfig:{increment:1, minValue:0, maxValue:100}, defaultBindProperty:'values', twoWayBindable:{values:1, value:1}, constructor:function(config) {
  config = config || {};
  if (config.hasOwnProperty('values')) {
    config.value = config.values;
  }
  this.callParent([config]);
  this.updateMultipleState();
}, initialize:function() {
  this.callParent();
  this.getComponent().on({scope:this, change:'onSliderChange', dragstart:'onSliderDragStart', drag:'onSliderDrag', dragend:'onSliderDragEnd'});
}, applyComponent:function(config) {
  return Ext.factory(config, Ext.slider.Slider);
}, updateComponent:function(component, oldComponent) {
  this.callParent([component, oldComponent]);
  component.setMinValue(this.getMinValue());
  component.setMaxValue(this.getMaxValue());
}, applyValue:function(value) {
  var ret = value;
  if (this.dragging && this.isSyncing('value')) {
    ret = undefined;
  }
  return ret;
}, updateValue:function(value, oldValue) {
  var me = this;
  if (!me.dragging) {
    me.setComponentValue(value);
  }
  if (me.initialized) {
    me.fireEvent('change', me, value, oldValue);
  }
}, setComponentValue:function(value) {
  this.getComponent().setValue(value);
}, onSliderChange:function(slider, thumb, newValue, oldValue) {
  this.setValue(slider.getValue());
  this.fireEvent('dragchange', this, slider, thumb, newValue, oldValue);
}, onSliderDragStart:function(slider, thumb, startValue, e) {
  this.dragging = true;
  this.fireEvent('dragstart', this, slider, thumb, startValue, e);
}, onSliderDrag:function(slider, thumb, value, e) {
  var me = this;
  if (me.getLiveUpdate()) {
    me.setValue(slider.getValue());
  }
  me.fireEvent('drag', me, slider, thumb, value, e);
}, onSliderDragEnd:function(slider, thumb, startValue, e) {
  this.dragging = false;
  this.fireEvent('dragend', this, slider, thumb, startValue, e);
}, setValues:function(value) {
  this.setValue(value);
  this.updateMultipleState();
}, getValues:function() {
  return this.getValue();
}, reset:function() {
  var config = this.config, initialValue = this.config.hasOwnProperty('values') ? config.values : config.value;
  this.setValue(initialValue);
}, updateDisabled:function(disabled) {
  this.callParent(arguments);
  this.getComponent().setDisabled(disabled);
}, updateReadOnly:function(newValue) {
  this.getComponent().setReadOnly(newValue);
}, isDirty:function() {
  if (this.getDisabled()) {
    return false;
  }
  return this.getValue() !== this.originalValue;
}, updateMultipleState:function() {
  var value = this.getValue();
  if (value && value.length > 1) {
    this.addCls(Ext.baseCSSPrefix + 'slider-multiple');
  }
}});
Ext.define('Ext.form.Panel', {alternateClassName:'Ext.form.FormPanel', extend:Ext.Panel, xtype:'formpanel', config:{baseCls:Ext.baseCSSPrefix + 'form', standardSubmit:false, url:null, enctype:null, baseParams:null, submitOnAction:false, record:null, method:'post', scrollable:true, trackResetOnLoad:false, api:null, paramOrder:null, paramsAsHash:null, timeout:30, multipartDetection:true, enableSubmissionForm:true}, getElementConfig:function() {
  var config = this.callParent();
  config.tag = 'form';
  config.children.push({tag:'input', type:'submit', style:'visibility: hidden; width: 0; height: 0; position: absolute; right: 0; bottom: 0;'});
  return config;
}, initialize:function() {
  var me = this;
  me.callParent();
  me.element.on({submit:'onSubmit', scope:me});
}, applyEnctype:function(newValue) {
  var form = this.element.dom || null;
  if (form) {
    if (newValue) {
      form.setAttribute('enctype', newValue);
    } else {
      form.setAttribute('enctype');
    }
  }
}, updateRecord:function(newRecord) {
  var fields, values, name;
  if (newRecord) {
    values = this.getValues();
    for (name in values) {
      if (values.hasOwnProperty(name) && newRecord.getField(name)) {
        newRecord.set(name, values[name]);
      }
    }
  }
  return this;
}, setRecord:function(record) {
  var me = this;
  if (record && record.data) {
    me.setValues(record.data);
  }
  me._record = record;
  return this;
}, onSubmit:function(e) {
  var me = this;
  if (e && !me.getStandardSubmit()) {
    e.stopEvent();
  } else {
    this.submit(null, e);
  }
}, updateSubmitOnAction:function(newSubmitOnAction) {
  if (newSubmitOnAction) {
    this.on({action:'onFieldAction', scope:this});
  } else {
    this.un({action:'onFieldAction', scope:this});
  }
}, onFieldAction:function(field) {
  if (this.getSubmitOnAction()) {
    field.blur();
    this.submit();
  }
}, submit:function(options, e) {
  options = options || {};
  var me = this, formValues = me.getValues(me.getStandardSubmit() || !options.submitDisabled), form = me.element.dom || {};
  if (this.getEnableSubmissionForm()) {
    form = this.createSubmissionForm(form, formValues);
  }
  options = Ext.apply({url:me.getUrl() || form.action, submit:false, form:form, method:me.getMethod() || form.method || 'post', autoAbort:false, params:null, waitMsg:null, headers:null, success:null, failure:null}, options || {});
  return me.fireAction('beforesubmit', [me, formValues, options, e], 'doBeforeSubmit', null, null, 'after');
}, createSubmissionForm:function(form, values) {
  var fields = this.getFields(), name, input, field, fileinputElement, inputComponent;
  if (form.nodeType === 1) {
    form = form.cloneNode(false);
    for (name in values) {
      input = document.createElement('input');
      input.setAttribute('type', 'text');
      input.setAttribute('name', name);
      input.setAttribute('value', values[name]);
      form.appendChild(input);
    }
  }
  for (name in fields) {
    if (fields.hasOwnProperty(name)) {
      field = fields[name];
      if (field.isFile) {
        if (!form.$fileswap) {
          form.$fileswap = [];
        }
        inputComponent = field.getComponent().input;
        fileinputElement = inputComponent.dom;
        input = fileinputElement.cloneNode(true);
        fileinputElement.parentNode.insertBefore(input, fileinputElement.nextSibling);
        form.appendChild(fileinputElement);
        form.$fileswap.push({original:fileinputElement, placeholder:input});
      } else {
        if (field.isPassword) {
          if (field.getComponent().getType !== 'password') {
            field.setRevealed(false);
          }
        }
      }
    }
  }
  return form;
}, doBeforeSubmit:function(me, formValues, options) {
  var form = options.form || {}, multipartDetected = false;
  if (this.getMultipartDetection() === true) {
    this.getFieldsAsArray().forEach(function(field) {
      if (field.isFile === true) {
        multipartDetected = true;
        return false;
      }
    });
    if (multipartDetected) {
      form.setAttribute('enctype', 'multipart/form-data');
    }
  }
  if (options.enctype) {
    form.setAttribute('enctype', options.enctype);
  }
  if (me.getStandardSubmit()) {
    if (options.url && Ext.isEmpty(form.action)) {
      form.action = options.url;
    }
    var fields = this.query('spinnerfield'), ln = fields.length, i, field;
    for (i = 0; i < ln; i++) {
      field = fields[i];
      if (!field.getDisabled()) {
        field.getComponent().setDisabled(false);
      }
    }
    form.method = (options.method || form.method).toLowerCase();
    form.submit();
  } else {
    var api = me.getApi(), url = options.url || me.getUrl(), scope = options.scope || me, waitMsg = options.waitMsg, failureFn = function(response, responseText) {
      if (Ext.isFunction(options.failure)) {
        options.failure.call(scope, me, response, responseText);
      }
      me.fireEvent('exception', me, response);
    }, successFn = function(response, responseText) {
      if (Ext.isFunction(options.success)) {
        options.success.call(options.scope || me, me, response, responseText);
      }
      me.fireEvent('submit', me, response);
    }, submit;
    if (options.waitMsg) {
      if (typeof waitMsg === 'string') {
        waitMsg = {xtype:'loadmask', message:waitMsg};
      }
      me.setMasked(waitMsg);
    }
    if (api) {
      submit = api.submit;
      if (typeof submit === 'string') {
        submit = Ext.direct.Manager.parseMethod(submit);
        if (submit) {
          api.submit = submit;
        }
      }
      if (submit) {
        return submit(this.element, function(data, response, success) {
          me.setMasked(false);
          if (success) {
            if (data.success) {
              successFn(response, data);
            } else {
              failureFn(response, data);
            }
          } else {
            failureFn(response, data);
          }
        }, this);
      }
    } else {
      var request = Ext.merge({}, {url:url, timeout:this.getTimeout() * 1000, form:form, scope:me}, options);
      delete request.success;
      delete request.failure;
      request.params = Ext.merge(me.getBaseParams() || {}, options.params);
      request.header = Ext.apply({'Content-Type':'application/x-www-form-urlencoded; charset\x3dUTF-8'}, options.headers || {});
      request.callback = function(callbackOptions, success, response) {
        var me = this, responseText = response.responseText, responseXML = response.responseXML, statusResult = Ext.data.request.Ajax.parseStatus(response.status, response);
        if (form.$fileswap) {
          var original, placeholder;
          Ext.each(form.$fileswap, function(item) {
            original = item.original;
            placeholder = item.placeholder;
            placeholder.parentNode.insertBefore(original, placeholder.nextSibling);
            placeholder.parentNode.removeChild(placeholder);
          });
          form.$fileswap = null;
          delete form.$fileswap;
        }
        me.setMasked(false);
        if (response.success === false) {
          success = false;
        }
        if (success) {
          if (statusResult && responseText && responseText.length === 0) {
            success = true;
          } else {
            if (!Ext.isEmpty(response.responseBytes)) {
              success = statusResult.success;
            } else {
              if (Ext.isString(responseText) && response.request.options.responseType === 'text') {
                response.success = true;
              } else {
                if (Ext.isString(responseText)) {
                  try {
                    response = Ext.decode(responseText);
                  } catch (e$26) {
                    response.success = false;
                    response.error = e$26;
                    response.message = e$26.message;
                  }
                } else {
                  if (Ext.isSimpleObject(responseText)) {
                    response = responseText;
                    Ext.applyIf(response, {success:true});
                  }
                }
              }
              if (!Ext.isEmpty(responseXML)) {
                response.success = true;
              }
              success = !!response.success;
            }
          }
          if (success) {
            successFn(response, responseText);
          } else {
            failureFn(response, responseText);
          }
        } else {
          failureFn(response, responseText);
        }
      };
      if (Ext.feature.has.XHR2 && request.xhr2) {
        delete request.form;
        var formData = new FormData(form);
        if (request.params) {
          Ext.iterate(request.params, function(name, value) {
            if (Ext.isArray(value)) {
              Ext.each(value, function(v) {
                formData.append(name, v);
              });
            } else {
              formData.append(name, value);
            }
          });
          delete request.params;
        }
        request.data = formData;
      }
      return Ext.Ajax.request(request);
    }
  }
}, load:function(options) {
  options = options || {};
  var me = this, api = me.getApi(), url = me.getUrl() || options.url, waitMsg = options.waitMsg, successFn = function(response, data) {
    me.setValues(data.data);
    if (Ext.isFunction(options.success)) {
      options.success.call(options.scope || me, me, response, data);
    }
    me.fireEvent('load', me, response);
  }, failureFn = function(response, data) {
    if (Ext.isFunction(options.failure)) {
      options.failure.call(scope, me, response, data);
    }
    me.fireEvent('exception', me, response);
  }, load, method, args;
  if (options.waitMsg) {
    if (typeof waitMsg === 'string') {
      waitMsg = {xtype:'loadmask', message:waitMsg};
    }
    me.setMasked(waitMsg);
  }
  if (api) {
    load = api.load;
    if (typeof load === 'string') {
      load = Ext.direct.Manager.parseMethod(load);
      if (load) {
        api.load = load;
      }
    }
    if (load) {
      method = load.directCfg.method;
      args = method.getArgs(me.getParams(options.params), me.getParamOrder(), me.getParamsAsHash());
      args.push(function(data, response, success) {
        me.setMasked(false);
        if (success) {
          successFn(response, data);
        } else {
          failureFn(response, data);
        }
      }, me);
      return load.apply(window, args);
    }
  } else {
    if (url) {
      return Ext.Ajax.request({url:url, timeout:(options.timeout || this.getTimeout()) * 1000, method:options.method || 'GET', autoAbort:options.autoAbort, headers:Ext.apply({'Content-Type':'application/x-www-form-urlencoded; charset\x3dUTF-8'}, options.headers || {}), callback:function(callbackOptions, success, response) {
        var responseText = response.responseText, statusResult = Ext.data.request.Ajax.parseStatus(response.status, response);
        me.setMasked(false);
        if (success) {
          if (statusResult && responseText.length === 0) {
            success = true;
          } else {
            response = Ext.decode(responseText);
            success = !!response.success;
          }
          if (success) {
            successFn(response, responseText);
          } else {
            failureFn(response, responseText);
          }
        } else {
          failureFn(response, responseText);
        }
      }});
    }
  }
}, getParams:function(params) {
  return Ext.apply({}, params, this.getBaseParams());
}, setValues:function(values) {
  var fields = this.getFields(), me = this, name, field, value, ln, i, f;
  values = values || {};
  for (name in values) {
    if (values.hasOwnProperty(name)) {
      field = fields[name];
      value = values[name];
      if (field) {
        if (Ext.isArray(field)) {
          ln = field.length;
          for (i = 0; i < ln; i++) {
            f = field[i];
            if (f.isRadio) {
              f.setGroupValue(value);
              break;
            } else {
              if (f.isCheckbox) {
                if (Ext.isArray(value)) {
                  f.setChecked(value.indexOf(f._value) != -1);
                } else {
                  f.setChecked(value == f._value);
                }
              } else {
                if (Ext.isArray(value)) {
                  f.setValue(value[i]);
                }
              }
            }
          }
        } else {
          if (field.isRadio || field.isCheckbox) {
            field.setChecked(value);
          } else {
            field.setValue(value);
          }
        }
        if (me.getTrackResetOnLoad()) {
          field.resetOriginalValue();
        }
      }
    }
  }
  return this;
}, getValues:function(enabled, all) {
  var fields = this.getFields(), values = {}, isArray = Ext.isArray, field, value, addValue, bucket, name, ln, i;
  addValue = function(field, name) {
    if (!all && (!name || name === 'null') || field.isFile) {
      return;
    }
    if (field.isCheckbox) {
      value = field.getSubmitValue();
    } else {
      value = field.getValue();
    }
    if (!(enabled && field.getDisabled())) {
      if (field.isRadio) {
        if (field.isChecked()) {
          values[name] = value;
        }
      } else {
        bucket = values[name];
        if (!Ext.isEmpty(bucket)) {
          if (!isArray(bucket)) {
            bucket = values[name] = [bucket];
          }
          if (isArray(value)) {
            bucket = values[name] = bucket.concat(value);
          } else {
            bucket.push(value);
          }
        } else {
          values[name] = value;
        }
      }
    }
  };
  for (name in fields) {
    if (fields.hasOwnProperty(name)) {
      field = fields[name];
      if (isArray(field)) {
        ln = field.length;
        for (i = 0; i < ln; i++) {
          addValue(field[i], name);
        }
      } else {
        addValue(field, name);
      }
    }
  }
  return values;
}, reset:function() {
  this.getFieldsAsArray().forEach(function(field) {
    field.reset();
  });
  return this;
}, updateDisabled:function(newDisabled) {
  this.getFieldsAsArray().forEach(function(field) {
    field.setDisabled(newDisabled);
  });
  return this;
}, getFieldsAsArray:function() {
  var fields = [], getFieldsFrom = function(item) {
    if (item.isField) {
      fields.push(item);
    }
    if (item.isContainer) {
      item.getItems().each(getFieldsFrom);
    }
  };
  this.getItems().each(getFieldsFrom);
  return fields;
}, getFields:function(byName) {
  var fields = {}, itemName;
  var getFieldsFrom = function(item) {
    if (item.isField) {
      itemName = item.getName();
      if (byName && itemName == byName || typeof byName == 'undefined') {
        if (fields.hasOwnProperty(itemName)) {
          if (!Ext.isArray(fields[itemName])) {
            fields[itemName] = [fields[itemName]];
          }
          fields[itemName].push(item);
        } else {
          fields[itemName] = item;
        }
      }
    }
    if (item.isContainer) {
      item.items.each(getFieldsFrom);
    }
  };
  this.getItems().each(getFieldsFrom);
  return byName ? fields[byName] || [] : fields;
}, getFieldsArray:function() {
  var fields = [];
  var getFieldsFrom = function(item) {
    if (item.isField) {
      fields.push(item);
    }
    if (item.isContainer) {
      item.items.each(getFieldsFrom);
    }
  };
  this.items.each(getFieldsFrom);
  return fields;
}, getFieldsFromItem:Ext.emptyFn, showMask:function(cfg, target) {
  Ext.Logger.warn('showMask is now deprecated. Please use Ext.form.Panel#setMasked instead');
  cfg = Ext.isObject(cfg) ? cfg.message : cfg;
  if (cfg) {
    this.setMasked({xtype:'loadmask', message:cfg});
  } else {
    this.setMasked(true);
  }
  return this;
}, hideMask:function() {
  this.setMasked(false);
  return this;
}, getFocusedField:function() {
  var fields = this.getFieldsArray(), ln = fields.length, field, i;
  for (i = 0; i < ln; i++) {
    field = fields[i];
    if (field.isFocused) {
      return field;
    }
  }
  return null;
}, getNextField:function() {
  var fields = this.getFieldsArray(), focusedField = this.getFocusedField(), index;
  if (focusedField) {
    index = fields.indexOf(focusedField);
    if (index !== fields.length - 1) {
      index++;
      return fields[index];
    }
  }
  return false;
}, focusNextField:function() {
  var field = this.getNextField();
  if (field) {
    field.focus();
    return field;
  }
  return false;
}, getPreviousField:function() {
  var fields = this.getFieldsArray(), focusedField = this.getFocusedField(), index;
  if (focusedField) {
    index = fields.indexOf(focusedField);
    if (index !== 0) {
      index--;
      return fields[index];
    }
  }
  return false;
}, focusPreviousField:function() {
  var field = this.getPreviousField();
  if (field) {
    field.focus();
    return field;
  }
  return false;
}});
Ext.define('Ext.navigation.Bar', {extend:Ext.TitleBar, isToolbar:true, config:{baseCls:Ext.baseCSSPrefix + 'toolbar', cls:Ext.baseCSSPrefix + 'navigation-bar', ui:'dark', title:null, defaultType:'button', layout:{type:'hbox'}, defaultBackButtonText:'Back', animation:{duration:300}, useTitleForBackButtonText:null, view:null, android2Transforms:false, backButton:{align:'left', ui:'back', hidden:true}}, constructor:function(config) {
  config = config || {};
  if (!config.items) {
    config.items = [];
  }
  this.backButtonStack = [];
  this.activeAnimations = [];
  this.callParent([config]);
}, applyBackButton:function(config) {
  return Ext.factory(config, Ext.Button, this.getBackButton());
}, updateBackButton:function(newBackButton, oldBackButton) {
  if (oldBackButton) {
    this.remove(oldBackButton);
  }
  if (newBackButton) {
    this.add(newBackButton);
    newBackButton.on({scope:this, tap:this.onBackButtonTap});
  }
}, onBackButtonTap:function() {
  this.fireEvent('back', this);
}, updateView:function(newView) {
  var me = this, backButton, innerItems, i, backButtonText, item, title, titleText;
  me.getItems();
  backButton = me.getBackButton();
  if (newView) {
    innerItems = newView.getInnerItems();
    for (i = 0; i < innerItems.length; i++) {
      item = innerItems[i];
      title = item.getTitle ? item.getTitle() : item.config.title;
      me.backButtonStack.push(title || '\x26nbsp;');
    }
    titleText = me.getTitleText();
    if (titleText === undefined) {
      titleText = '';
    }
    me.setTitle(titleText);
    backButtonText = me.getBackButtonText();
    if (backButtonText) {
      backButton.setText(backButtonText);
      backButton.show();
    }
  }
}, onViewAdd:function(view, item) {
  var me = this, backButtonStack = me.backButtonStack, hasPrevious, title;
  me.endAnimation();
  title = item.getTitle ? item.getTitle() : item.config.title;
  backButtonStack.push(title || '\x26nbsp;');
  hasPrevious = backButtonStack.length > 1;
  me.doChangeView(view, hasPrevious, false);
}, onViewRemove:function(view) {
  var me = this, backButtonStack = me.backButtonStack, hasPrevious;
  me.endAnimation();
  backButtonStack.pop();
  hasPrevious = backButtonStack.length > 1;
  me.doChangeView(view, hasPrevious, true);
}, doChangeView:function(view, hasPrevious, reverse) {
  var me = this, leftBox = me.leftBox, leftBoxElement = leftBox.element, titleComponent = me.titleComponent, titleElement = titleComponent.element, backButton = me.getBackButton(), titleText = me.getTitleText(), backButtonText = me.getBackButtonText(), animation = me.getAnimation() && view.getLayout().getAnimation(), animated = animation && animation.isAnimation && view.isPainted(), properties, leftGhost, titleGhost, leftProps, titleProps;
  if (animated) {
    leftGhost = me.createProxy(leftBox.element);
    leftBoxElement.setStyle('opacity', '0');
    backButton.setText(backButtonText);
    backButton[hasPrevious ? 'show' : 'hide']();
    titleGhost = me.createProxy(titleComponent.element.getParent());
    titleElement.setStyle('opacity', '0');
    me.setTitle(titleText);
    properties = me.measureView(leftGhost, titleGhost, reverse);
    leftProps = properties.left;
    titleProps = properties.title;
    me.isAnimating = true;
    me.animate(leftBoxElement, leftProps.element);
    me.animate(titleElement, titleProps.element, function() {
      titleElement.setLeft(properties.titleLeft);
      me.isAnimating = false;
      me.refreshTitlePosition();
    });
    me.animate(leftGhost.ghost, leftProps.ghost);
    me.animate(titleGhost.ghost, titleProps.ghost, function() {
      leftGhost.ghost.destroy();
      titleGhost.ghost.destroy();
    });
  } else {
    if (hasPrevious) {
      backButton.setText(backButtonText);
      backButton.show();
    } else {
      backButton.hide();
    }
    me.setTitle(titleText);
  }
}, measureView:function(oldLeft, oldTitle, reverse) {
  var me = this, barElement = me.element, newLeftElement = me.leftBox.element, titleElement = me.titleComponent.element, minOffset = Math.min(barElement.getWidth() / 3, 200), newLeftWidth = newLeftElement.getWidth(), barX = barElement.getX(), barWidth = barElement.getWidth(), titleX = titleElement.getX(), titleLeft = titleElement.getLeft(true), titleWidth = titleElement.getWidth(), oldLeftX = oldLeft.x, oldLeftWidth = oldLeft.width, oldLeftLeft = oldLeft.left, newOffset, oldOffset, leftAnims, titleAnims, 
  omega, theta;
  theta = barX - oldLeftX - oldLeftWidth;
  if (reverse) {
    newOffset = theta;
    oldOffset = Math.min(titleX - oldLeftWidth, minOffset);
  } else {
    oldOffset = theta;
    newOffset = Math.min(titleX - barX, minOffset);
  }
  leftAnims = {element:{from:{transform:{translateX:newOffset}, opacity:0}, to:{transform:{translateX:0}, opacity:1}}, ghost:{to:{transform:{translateX:oldOffset}, opacity:0}}};
  theta = barX - titleX + newLeftWidth;
  if (oldLeftLeft + titleWidth > titleX) {
    omega = barX - titleX - titleWidth;
  }
  if (reverse) {
    titleElement.setLeft(0);
    oldOffset = barX + barWidth - titleX - titleWidth;
    if (omega !== undefined) {
      newOffset = omega;
    } else {
      newOffset = theta;
    }
  } else {
    newOffset = barX + barWidth - titleX - titleWidth;
    if (omega !== undefined) {
      oldOffset = omega;
    } else {
      oldOffset = theta;
    }
    newOffset = Math.max(titleLeft, newOffset);
  }
  titleAnims = {element:{from:{transform:{translateX:newOffset}, opacity:0}, to:{transform:{translateX:titleLeft}, opacity:1}}, ghost:{to:{transform:{translateX:oldOffset}, opacity:0}}};
  return {left:leftAnims, title:titleAnims, titleLeft:titleLeft};
}, animate:function(element, config, callback) {
  var me = this, animation;
  element.setLeft(0);
  config = Ext.apply(config, {element:element, easing:'ease-in-out', duration:me.getAnimation().duration || 250, preserveEndState:true});
  animation = new Ext.fx.Animation(config);
  animation.on('animationend', function() {
    if (callback) {
      callback.call(me);
    }
  }, me);
  Ext.Animator.run(animation);
  me.activeAnimations.push(animation);
}, endAnimation:function() {
  var activeAnimations = this.activeAnimations, animation, i, ln;
  if (activeAnimations) {
    ln = activeAnimations.length;
    for (i = 0; i < ln; i++) {
      animation = activeAnimations[i];
      if (animation.isAnimating) {
        animation.stopAnimation();
      } else {
        animation.destroy();
      }
    }
    this.activeAnimations = [];
  }
}, refreshTitlePosition:function() {
  if (!this.isAnimating) {
    this.callParent();
  }
}, getBackButtonText:function() {
  var text = this.backButtonStack[this.backButtonStack.length - 2], useTitleForBackButtonText = this.getUseTitleForBackButtonText();
  if (!useTitleForBackButtonText) {
    if (text) {
      text = this.getDefaultBackButtonText();
    }
  }
  return text;
}, getTitleText:function() {
  return this.backButtonStack[this.backButtonStack.length - 1];
}, beforePop:function(count) {
  count--;
  for (var i = 0; i < count; i++) {
    this.backButtonStack.pop();
  }
}, updateHidden:function(hidden) {
  if (!hidden) {
    this.element.setStyle({position:'relative', top:'auto', left:'auto', width:'auto'});
  } else {
    this.element.setStyle({position:'absolute', top:'-1000px', left:'-1000px', width:this.element.getWidth() + 'px'});
  }
}, createProxy:function(element) {
  var ghost, x, y, left, width;
  ghost = element.dom.cloneNode(true);
  ghost.id = element.id + '-proxy';
  element.getParent().dom.appendChild(ghost);
  ghost = Ext.get(ghost);
  x = element.getX();
  y = element.getY();
  left = element.getLeft(true);
  width = element.getWidth();
  ghost.setStyle('position', 'absolute');
  ghost.setX(x);
  ghost.setY(y);
  ghost.setHeight(element.getHeight());
  ghost.setWidth(width);
  return {x:x, y:y, left:left, width:width, ghost:ghost};
}});
Ext.define('Ext.navigation.View', {extend:Ext.Container, alternateClassName:'Ext.NavigationView', xtype:'navigationview', config:{baseCls:Ext.baseCSSPrefix + 'navigationview', navigationBar:{docked:'top'}, defaultBackButtonText:'Back', useTitleForBackButtonText:false, layout:{type:'card', animation:{duration:300, easing:'ease-out', type:'slide', direction:'left'}}}, initialize:function() {
  var me = this, navBar = me.getNavigationBar();
  if (navBar) {
    navBar.on({back:me.onBackButtonTap, scope:me});
    me.relayEvents(navBar, 'rightbuttontap');
    me.relayEvents(me, {add:'push', remove:'pop'});
  }
  var layout = me.getLayout();
  if (layout && !layout.isCard) {
    Ext.Logger.error('The base layout for a NavigationView must always be a Card Layout');
  }
}, applyLayout:function(config) {
  config = config || {};
  return config;
}, onBackButtonTap:function() {
  this.pop();
  this.fireEvent('back', this);
}, push:function(view) {
  return this.add(view);
}, pop:function(count) {
  if (this.beforePop(count)) {
    return this.doPop();
  }
}, beforePop:function(count) {
  var me = this, innerItems = me.getInnerItems(), last, i, ln, toRemove;
  if (Ext.isString(count) || Ext.isObject(count)) {
    last = innerItems.length - 1;
    for (i = last; i >= 0; i--) {
      if (Ext.isString(count) && Ext.ComponentQuery.is(innerItems[i], count) || Ext.isObject(count) && count == innerItems[i]) {
        count = last - i;
        break;
      }
    }
    if (!Ext.isNumber(count)) {
      return false;
    }
  }
  ln = innerItems.length;
  if (!Ext.isNumber(count) || count < 1) {
    count = 1;
  }
  count = Math.min(count, ln - 1);
  if (count) {
    me.getNavigationBar().beforePop(count);
    toRemove = innerItems.splice(-count, count - 1);
    for (i = 0; i < toRemove.length; i++) {
      this.remove(toRemove[i]);
    }
    return true;
  }
  return false;
}, doPop:function() {
  var me = this, innerItems = this.getInnerItems();
  me.remove(innerItems[innerItems.length - 1]);
  if (innerItems.length < 3 && this.$backButton) {
    this.$backButton.hide();
  }
  if (this.$titleContainer) {
    if (!this.$titleContainer.setTitle) {
      Ext.Logger.error(['You have selected to display a title in a component that does not ', 'support titles in NavigationView. Please remove the `title` configuration from your ', 'NavigationView item, or change it to a component that has a `setTitle` method.'].join(''));
    }
    var item = innerItems[innerItems.length - 2];
    this.$titleContainer.setTitle(item.getTitle ? item.getTitle() : item.config.title);
  }
  return this.getActiveItem();
}, getPreviousItem:function() {
  var innerItems = this.getInnerItems();
  return innerItems[innerItems.length - 2];
}, updateUseTitleForBackButtonText:function(useTitleForBackButtonText) {
  var navigationBar = this.getNavigationBar();
  if (navigationBar) {
    navigationBar.setUseTitleForBackButtonText(useTitleForBackButtonText);
  }
}, updateDefaultBackButtonText:function(defaultBackButtonText) {
  var navigationBar = this.getNavigationBar();
  if (navigationBar) {
    navigationBar.setDefaultBackButtonText(defaultBackButtonText);
  }
}, onBackButtonContainerAdd:function(toolbar, item) {
  item.on({scope:this, show:this.refreshBackButtonContainer, hide:this.refreshBackButtonContainer});
  this.refreshBackButtonContainer();
}, onBackButtonContainerRemove:function(toolbar, item) {
  item.un({scope:this, show:this.refreshBackButtonContainer, hide:this.refreshBackButtonContainer});
  this.refreshBackButtonContainer();
}, refreshBackButtonContainer:function() {
  if (!this.$backButtonContainer) {
    return;
  }
  var i = 0, backButtonContainer = this.$backButtonContainer, items = backButtonContainer.items, item;
  for (; i < items.length; i++) {
    item = items.get(i);
    if (!item.isHidden()) {
      this.$backButtonContainer.show();
      return;
    }
  }
  this.$backButtonContainer.hide();
}, applyNavigationBar:function(config) {
  var me = this;
  if (!config) {
    config = {hidden:true, docked:'top'};
  }
  me.getItems();
  if (config.title) {
    delete config.title;
    Ext.Logger.warn("Ext.navigation.View: The 'navigationBar' configuration does not accept a 'title' property. You " + "set the title of the navigationBar by giving this navigation view's children a 'title' property.");
  }
  config.view = me;
  config.useTitleForBackButtonText = me.getUseTitleForBackButtonText();
  if (config.splitNavigation) {
    me.$titleContainer = me.add({docked:'top', xtype:'titlebar', ui:'light', title:me.$currentTitle || ''});
    var containerConfig = config.splitNavigation === true ? {} : config.splitNavigation;
    me.$backButtonContainer = me.add({xtype:'toolbar', docked:'bottom', hidden:true});
    me.$backButtonContainer.on({scope:me, add:me.onBackButtonContainerAdd, remove:me.onBackButtonContainerRemove});
    me.$backButton = me.$backButtonContainer.add({xtype:'button', text:'Back', hidden:true, ui:'back'});
    if (config.items) {
      me.$backButtonContainer.add(config.items);
    }
    if (containerConfig.items) {
      me.$titleContainer.add(containerConfig.items);
    }
    me.$backButton.on({scope:me, tap:me.onBackButtonTap});
    config = {hidden:true, docked:'top'};
  }
  return Ext.factory(config, Ext.navigation.Bar, this.getNavigationBar());
}, updateNavigationBar:function(newNavigationBar, oldNavigationBar) {
  if (oldNavigationBar) {
    this.remove(oldNavigationBar, true);
  }
  if (newNavigationBar) {
    this.add(newNavigationBar);
  }
}, applyActiveItem:function(activeItem, currentActiveItem) {
  var me = this, innerItems = me.getInnerItems();
  me.getItems();
  if (!me.initialized) {
    activeItem = innerItems.length - 1;
  }
  return this.callParent([activeItem, currentActiveItem]);
}, doResetActiveItem:function(innerIndex) {
  var me = this, innerItems = me.getInnerItems(), animation = me.getLayout().getAnimation();
  if (innerIndex > 0) {
    if (animation && animation.isAnimation) {
      animation.setReverse(true);
    }
    me.setActiveItem(innerIndex - 1);
    me.getNavigationBar().onViewRemove(me, innerItems[innerIndex], innerIndex);
  }
}, doRemove:function() {
  var animation = this.getLayout().getAnimation();
  if (animation && animation.isAnimation) {
    animation.setReverse(false);
  }
  this.callParent(arguments);
}, onItemAdd:function(item, index) {
  var me = this, initialized = me.initialized, navigationBar;
  if (item && item.getDocked() && item.config.title === true) {
    me.$titleContainer = item;
  }
  me.doItemLayoutAdd(item, index);
  if (initialized && item.isInnerItem()) {
    me.setActiveItem(item);
    navigationBar = this.getNavigationBar();
    if (navigationBar) {
      this.getNavigationBar().onViewAdd(me, item, index);
    }
    if (me.$backButtonContainer) {
      me.$backButton.show();
    }
  }
  if (item && item.isInnerItem()) {
    me.updateTitleContainerTitle(item.getTitle ? item.getTitle() : item.config.title);
  }
  if (initialized) {
    me.fireEvent('add', me, item, index);
  }
}, updateTitleContainerTitle:function(title) {
  if (this.$titleContainer) {
    if (!this.$titleContainer.setTitle) {
      Ext.Logger.error(['You have selected to display a title in a component that does not ', 'support titles in NavigationView. Please remove the `title` configuration from your ', 'NavigationView item, or change it to a component that has a `setTitle` method.'].join(''));
    }
    this.$titleContainer.setTitle(title);
  } else {
    this.$currentTitle = title;
  }
}, reset:function() {
  return this.pop(this.getInnerItems().length);
}});
Ext.define('Ext.panel.Header', {extend:Ext.Container, xtype:'panelheader', isPanelHeader:true, baseCls:Ext.baseCSSPrefix + 'panel-header', config:{glyph:null, icon:null, iconAlign:null, iconCls:null, title:null, titleAlign:null, layout:{type:'hbox', align:'center'}}, add:function(item) {
  var me = this, isArray = Ext.isArray(item), array = isArray ? item.slice(0) : [item], items = me.getItems(), length = items.length, n = array.length, c, i, n, pos;
  for (i = 0; i < n; ++i) {
    array[i] = me.factoryItem(array[i]);
  }
  Ext.Array.sort(array, me.sortByWeight);
  if (length) {
    items = items.items;
    pos = 0;
    for (i = 0; i < n; ++i) {
      c = array[i];
      for (; pos < length; ++pos) {
        if (me.sortByWeight(c, items[pos]) < 0) {
          break;
        }
      }
      me.insert(pos, c);
      ++pos;
      ++length;
    }
  } else {
    me.callParent([array]);
  }
  return isArray ? array : item;
}, applyTitle:function(newTitle, oldTitle) {
  var title = oldTitle;
  if (title) {
    if (!newTitle || typeof newTitle === 'string') {
      title.setText(newTitle || '');
    } else {
      if (newTitle) {
        title.setConfig(newTitle);
      }
    }
  } else {
    title = Ext.create(this.createTitle(newTitle));
  }
  return title;
}, createTitle:function(config) {
  var ret = {xtype:'paneltitle', flex:1};
  if (config) {
    if (typeof config === 'string') {
      config = {text:config};
    }
    Ext.merge(ret, config);
  }
  return ret;
}, createTools:function(tools, toolOwner) {
  var n = tools && tools.length, ret = n && [], c, i;
  toolOwner = toolOwner || null;
  for (i = 0; i < n; ++i) {
    c = tools[i];
    if (typeof c === 'string') {
      c = {xtype:'paneltool', type:c, toolOwner:toolOwner};
    } else {
      if (c.isInstance) {
        if (toolOwner) {
          c.setToolOwner(toolOwner);
        }
      } else {
        c = Ext.apply({xtype:'paneltool', toolOwner:toolOwner}, c);
      }
    }
    ret[i] = c;
  }
  return ret;
}, updateGlyph:function(glyph) {
  this.ensureTitle().setGlyph(glyph);
}, updateIcon:function(icon) {
  this.ensureTitle().setIcon(icon);
}, updateIconAlign:function(align, oldAlign) {
  this.ensureTitle().setIconAlign(align);
}, updateIconCls:function(cls) {
  this.ensureTitle().setIconCls(cls);
}, updateTitle:function(title, oldTitle) {
  if (oldTitle) {
    oldTitle.setConfig(title);
  } else {
    this.add(title);
  }
}, updateTitleAlign:function(align, oldAlign) {
  this.ensureTitle().setTextAlign(align);
}, updateUi:function(ui, oldValue) {
  this.callParent([ui, oldValue]);
  this.ensureTitle().setUi(ui);
}, privates:{clearTools:function() {
  var items = this.getItems().items, c, i;
  for (i = items.length; i-- > 0;) {
    c = items[i];
    if (c.isPanelTool) {
      this.remove(c);
    }
  }
}, ensureTitle:function() {
  var me = this, title = me.getTitle();
  if (!title) {
    me.setTitle('');
    title = me.getTitle();
  }
  return title;
}, sortByWeight:function(item1, item2) {
  return (item1.weight || 0) - (item2.weight || 0);
}}});
Ext.define('Ext.panel.Title', {extend:Ext.Component, xtype:'paneltitle', isPanelTitle:true, _textAlign:'left', _iconAlign:'left', _text:'\x26#160;', cachedConfig:{textAlign:null, text:null, glyph:null, icon:null, iconAlign:null, iconCls:null}, weight:-10, element:{unselectable:'on', reference:'element', cls:Ext.baseCSSPrefix + 'panel-title-align-left', children:[{reference:'iconElement', style:'display:none', cls:Ext.baseCSSPrefix + 'panel-title-icon ' + Ext.baseCSSPrefix + 'panel-title-icon-left'}, 
{reference:'textElement', cls:Ext.baseCSSPrefix + 'panel-title-text'}]}, _textAlignClasses:{left:Ext.baseCSSPrefix + 'panel-title-align-left', center:Ext.baseCSSPrefix + 'panel-title-align-center', right:Ext.baseCSSPrefix + 'panel-title-align-right'}, _iconAlignClasses:{top:Ext.baseCSSPrefix + 'panel-title-icon-top', right:Ext.baseCSSPrefix + 'panel-title-icon-right', bottom:Ext.baseCSSPrefix + 'panel-title-icon-bottom', left:Ext.baseCSSPrefix + 'panel-title-icon-left'}, baseCls:Ext.baseCSSPrefix + 
'panel-title', _titleSuffix:'-title', _glyphCls:Ext.baseCSSPrefix + 'panel-title-glyph', _verticalCls:Ext.baseCSSPrefix + 'panel-title-vertical', applyText:function(text) {
  return text || '\x26#160;';
}, updateGlyph:function(glyph, oldGlyph) {
  glyph = glyph || 0;
  var me = this, glyphCls = me._glyphCls, iconEl = me.iconElement, fontFamily, glyphParts;
  me.glyph = glyph;
  me._syncIconVisibility();
  if (typeof glyph === 'string') {
    glyphParts = glyph.split('@');
    glyph = glyphParts[0];
    fontFamily = glyphParts[1] || Ext._glyphFontFamily;
  }
  if (!glyph) {
    iconEl.dom.innerHTML = '';
    iconEl.removeCls(glyphCls);
  } else {
    iconEl.dom.innerHTML = '\x26#' + glyph + ';';
    iconEl.addCls(glyphCls);
  }
  if (fontFamily) {
    iconEl.setStyle('font-family', fontFamily);
  }
}, updateIcon:function(icon, oldIcon) {
  var me = this, iconEl;
  me._syncIconVisibility();
  iconEl = me.iconElement;
  iconEl.setStyle('background-image', icon ? 'url(' + icon + ')' : '');
}, updateIconAlign:function(align, oldAlign) {
  var me = this, iconEl = me.iconElement, iconAlignClasses = me._iconAlignClasses, el = me.el;
  if (oldAlign) {
    iconEl.removeCls(iconAlignClasses[oldAlign]);
  }
  iconEl.addCls(iconAlignClasses[align]);
  if (align === 'top' || align === 'left') {
    el.insertFirst(iconEl);
  } else {
    el.appendChild(iconEl);
  }
  if (align === 'top' || align === 'bottom') {
    el.addCls(me._verticalCls);
  } else {
    el.removeCls(me._verticalCls);
  }
}, updateIconCls:function(cls, oldCls) {
  var iconEl = this.iconElement;
  this._syncIconVisibility();
  if (oldCls) {
    iconEl.removeCls(oldCls);
  }
  if (cls) {
    iconEl.addCls(cls);
  }
}, updateText:function(text) {
  this.textElement.setHtml(text);
}, updateTextAlign:function(align, oldAlign) {
  var me = this, textAlignClasses = me._textAlignClasses;
  if (oldAlign) {
    me.removeCls(textAlignClasses[oldAlign]);
  }
  me.addCls(textAlignClasses[align]);
}, privates:{_getVerticalAdjustDirection:function() {
  return 'left';
}, _hasIcon:function() {
  return !!(this.getIcon() || this.getIconCls() || this.getGlyph());
}, _syncIconVisibility:function() {
  this.iconElement.setDisplayed(this._hasIcon());
}}});
Ext.define('Ext.panel.Tool', {extend:Ext.Component, xtype:['paneltool', 'tool'], isPanelTool:true, baseCls:Ext.baseCSSPrefix + 'tool', disabledCls:Ext.baseCSSPrefix + 'tool-disabled', toolPressedCls:Ext.baseCSSPrefix + 'tool-pressed', toolOverCls:Ext.baseCSSPrefix + 'tool-over', element:{reference:'element', listeners:{click:'onClick', mousedown:'onMouseDown', mouseover:'onMouseOver', mouseout:'onMouseOut'}, children:[{reference:'toolElement'}]}, handler:null, scope:null, toolOwner:null, config:{iconCls:null, 
type:null}, stopEvent:true, weight:10, updateIconCls:function(iconCls, oldValue) {
  var toolEl = this.toolElement;
  toolEl.replaceCls(oldValue, iconCls);
}, updateType:function(type, oldType) {
  var baseCls = this.getBaseCls(), toolEl = this.toolElement;
  toolEl.replaceCls(oldType && baseCls + '-' + oldType, type && baseCls + '-' + type);
}, privates:{_toolTypes:{close:1, collapse:1, down:1, expand:1, gear:1, help:1, left:1, maximize:1, minimize:1, minus:1, next:1, pin:1, plus:1, prev:1, print:1, refresh:1, restore:1, right:1, save:1, search:1, toggle:1, unpin:1, up:1}, onClick:function(e, target) {
  var me = this, handler = me.handler || me.callback;
  if (me.disabled) {
    return false;
  }
  if (e.type !== 'keydown') {
    me.el.removeCls(me.toolPressedCls + ' ' + me.toolOverCls);
  }
  if (me.stopEvent !== false) {
    e.stopEvent();
  }
  if (handler) {
    Ext.callback(handler, me.scope, [me.toolOwner || me.parent, me, e], 0, me);
  }
  me.fireEvent('click', me, e, me.toolOwner || me.ownerCt);
  return true;
}, onMouseDown:function(e) {
  e.preventDefault();
  if (this.disabled) {
    return false;
  }
  this.el.addCls(this.toolPressedCls);
}, onMouseOver:function() {
  if (this.disabled) {
    return false;
  }
  this.el.addCls(this.toolOverCls);
}, onMouseOut:function() {
  this.el.removeCls(this.toolOverCls);
}}});
Ext.define('Ext.plugin.ListPaging', {extend:Ext.Component, alias:'plugin.listpaging', config:{autoPaging:false, loadMoreText:'Load More...', noMoreRecordsText:'No More Records', loadTpl:['\x3cdiv class\x3d"{cssPrefix}loading-spinner" style\x3d"font-size: 180%; margin: 10px auto;"\x3e', '\x3cspan class\x3d"{cssPrefix}loading-top"\x3e\x3c/span\x3e', '\x3cspan class\x3d"{cssPrefix}loading-right"\x3e\x3c/span\x3e', '\x3cspan class\x3d"{cssPrefix}loading-bottom"\x3e\x3c/span\x3e', '\x3cspan class\x3d"{cssPrefix}loading-left"\x3e\x3c/span\x3e', 
'\x3c/div\x3e', '\x3cdiv class\x3d"{cssPrefix}list-paging-msg"\x3e{message}\x3c/div\x3e'].join(''), loadMoreCmp:{xtype:'component', baseCls:Ext.baseCSSPrefix + 'list-paging', scrollDock:'bottom', hidden:true}, loadMoreCmpAdded:false, loadingCls:Ext.baseCSSPrefix + 'loading', list:null, scroller:null, loading:false}, init:function(list) {
  var scroller = list.getScrollable(), store = list.getStore();
  this.setList(list);
  this.setScroller(scroller);
  this.bindStore(list.getStore());
  this.addLoadMoreCmp();
  list.updateStore = Ext.Function.createInterceptor(list.updateStore, this.bindStore, this);
  if (this.getAutoPaging()) {
    scroller.on({scrollend:this.onScrollEnd, scope:this});
  }
}, bindStore:function(newStore, oldStore) {
  if (oldStore) {
    oldStore.un({beforeload:this.onStoreBeforeLoad, load:this.onStoreLoad, filter:this.onFilter, scope:this});
  }
  if (newStore) {
    newStore.on({beforeload:this.onStoreBeforeLoad, load:this.onStoreLoad, filter:this.onFilter, scope:this});
  }
}, disableDataViewMask:function() {
  var list = this.getList();
  this._listMask = list.getLoadingText();
  list.setLoadingText(null);
}, enableDataViewMask:function() {
  if (this._listMask) {
    var list = this.getList();
    list.setLoadingText(this._listMask);
    delete this._listMask;
  }
}, applyLoadTpl:function(config) {
  return Ext.isObject(config) && config.isTemplate ? config : new Ext.XTemplate(config);
}, applyLoadMoreCmp:function(config) {
  config = Ext.merge(config, {html:this.getLoadTpl().apply({cssPrefix:Ext.baseCSSPrefix, message:this.getLoadMoreText()}), scrollDock:'bottom', listeners:{tap:{fn:this.loadNextPage, scope:this, element:'element'}}});
  return Ext.factory(config, Ext.Component, this.getLoadMoreCmp());
}, onScrollEnd:function(scroller, x, y) {
  var list = this.getList();
  if (!this.getLoading() && y >= scroller.getMaxUserPosition().y) {
    this.currentScrollToTopOnRefresh = list.getScrollToTopOnRefresh();
    list.setScrollToTopOnRefresh(false);
    this.loadNextPage();
  }
}, updateLoading:function(isLoading) {
  var loadMoreCmp = this.getLoadMoreCmp(), loadMoreCls = this.getLoadingCls();
  if (isLoading) {
    loadMoreCmp.addCls(loadMoreCls);
  } else {
    loadMoreCmp.removeCls(loadMoreCls);
  }
}, onStoreBeforeLoad:function(store) {
  if (store.getCount() === 0) {
    this.getLoadMoreCmp().hide();
  }
}, onStoreLoad:function(store) {
  var loadCmp = this.getLoadMoreCmp(), template = this.getLoadTpl(), message = this.storeFullyLoaded() ? this.getNoMoreRecordsText() : this.getLoadMoreText();
  if (store.getCount()) {
    loadCmp.show();
  }
  this.setLoading(false);
  loadCmp.setHtml(template.apply({cssPrefix:Ext.baseCSSPrefix, message:message}));
  if (this.currentScrollToTopOnRefresh !== undefined) {
    this.getList().setScrollToTopOnRefresh(this.currentScrollToTopOnRefresh);
    delete this.currentScrollToTopOnRefresh;
  }
  this.enableDataViewMask();
}, onFilter:function(store) {
  if (store.getCount() === 0) {
    this.getLoadMoreCmp().hide();
  } else {
    this.getLoadMoreCmp().show();
  }
}, addLoadMoreCmp:function() {
  var list = this.getList(), cmp = this.getLoadMoreCmp();
  if (!this.getLoadMoreCmpAdded()) {
    list.add(cmp);
    list.fireEvent('loadmorecmpadded', this, list);
    this.setLoadMoreCmpAdded(true);
  }
  return cmp;
}, storeFullyLoaded:function() {
  var store = this.getList().getStore(), total = store.getTotalCount();
  return total !== null ? store.getTotalCount() <= store.currentPage * store.getPageSize() : false;
}, loadNextPage:function() {
  var me = this;
  if (!me.storeFullyLoaded()) {
    me.disableDataViewMask();
    me.setLoading(true);
    me.getList().getStore().nextPage({addRecords:true});
  }
}});
Ext.define('Ext.plugin.PullRefresh', {extend:Ext.Component, alias:'plugin.pullrefresh', config:{width:'100%', list:null, pullText:'Pull down to refresh...', releaseText:'Release to refresh...', loadingText:'Loading...', loadedText:'Loaded.', lastUpdatedText:'Last Updated:\x26nbsp;', scrollerAutoRefresh:false, autoSnapBack:true, snappingAnimationDuration:300, lastUpdatedDateFormat:'m/d/Y h:iA', overpullSnapBackDuration:300, pullTpl:['\x3cdiv class\x3d"' + Ext.baseCSSPrefix + 'list-pullrefresh-arrow"\x3e\x3c/div\x3e', 
'\x3cdiv class\x3d"' + Ext.baseCSSPrefix + 'loading-spinner"\x3e', '\x3cspan class\x3d"' + Ext.baseCSSPrefix + 'loading-top"\x3e\x3c/span\x3e', '\x3cspan class\x3d"' + Ext.baseCSSPrefix + 'loading-right"\x3e\x3c/span\x3e', '\x3cspan class\x3d"' + Ext.baseCSSPrefix + 'loading-bottom"\x3e\x3c/span\x3e', '\x3cspan class\x3d"' + Ext.baseCSSPrefix + 'loading-left"\x3e\x3c/span\x3e', '\x3c/div\x3e', '\x3cdiv class\x3d"' + Ext.baseCSSPrefix + 'list-pullrefresh-wrap"\x3e', '\x3ch3 class\x3d"' + Ext.baseCSSPrefix + 
'list-pullrefresh-message"\x3e{message}\x3c/h3\x3e', '\x3cdiv class\x3d"' + Ext.baseCSSPrefix + 'list-pullrefresh-updated"\x3e{updated}\x3c/div\x3e', '\x3c/div\x3e'].join(''), translatable:true}, $state:'pull', refreshCls:Ext.baseCSSPrefix + 'list-pullrefresh', getState:function() {
  return this.$state;
}, setState:function(value) {
  this.$state = value;
  this.updateView();
}, $isSnappingBack:false, getIsSnappingBack:function() {
  return this.$isSnappingBack;
}, setIsSnappingBack:function(value) {
  this.$isSnappingBack = value;
}, init:function(list) {
  this.setList(list);
  this.initScrollable();
}, getElementConfig:function() {
  return {reference:'element', classList:['x-unsized'], children:[{reference:'innerElement', className:this.refreshCls}]};
}, initScrollable:function() {
  var me = this, list = me.getList(), scroller = list.getScrollable();
  if (!scroller || !scroller.isTouchScroller) {
    return;
  }
  scroller.setAutoRefresh(me.getScrollerAutoRefresh());
  me.lastUpdated = new Date;
  list.insert(0, me);
  scroller.on({scroll:me.onScrollChange, scope:me});
  me.updateView();
}, applyPullTpl:function(config) {
  if (config instanceof Ext.XTemplate) {
    return config;
  } else {
    return new Ext.XTemplate(config);
  }
}, updateList:function(newList, oldList) {
  var me = this;
  if (newList) {
    newList.on({order:'after', scrollablechange:me.initScrollable, scope:me});
  }
  if (oldList) {
    oldList.un({order:'after', scrollablechange:me.initScrollable, scope:me});
  }
}, getPullHeight:function() {
  return this.innerElement.getHeight();
}, fetchLatest:function() {
  this.getList().getStore().fetch({page:1, start:0, callback:this.onLatestFetched, scope:this});
}, onLatestFetched:function(newRecords) {
  var me = this, store = me.getList().getStore(), oldRecords = store.getData(), length = newRecords.length, toInsert = [], newRecord, oldRecord, i;
  for (i = 0; i < length; i++) {
    newRecord = newRecords[i];
    oldRecord = oldRecords.getByKey(newRecord.getId());
    if (oldRecord) {
      oldRecord.set(newRecord.getData());
    } else {
      toInsert.push(newRecord);
    }
    oldRecord = undefined;
  }
  store.insert(0, toInsert);
  me.setState('loaded');
  me.fireEvent('latestfetched', me, toInsert);
  if (me.getAutoSnapBack()) {
    me.snapBack();
  }
}, snapBack:function(force) {
  var me = this, list, scroller;
  if (this.getState() !== 'loaded' && force !== true) {
    return;
  }
  list = me.getList();
  scroller = list.getScrollable();
  me.setIsSnappingBack(true);
  scroller.doScrollTo(null, 0, {callback:Ext.bind(me.onSnapBackEnd, me), duration:me.getSnappingAnimationDuration()});
}, onSnapBackEnd:function() {
  var list = this.getList(), scroller = list.getScrollable();
  scroller.setMinUserPosition({x:0, y:0});
  this.setState('pull');
  this.setIsSnappingBack(false);
}, onScrollChange:function(scroller, x, y) {
  if (y > 0) {
    return;
  }
  var me = this, pullHeight = me.getPullHeight(), isSnappingBack = me.getIsSnappingBack(), state = me.getState();
  if (state === 'loaded' && !isSnappingBack) {
    me.snapBack();
  }
  if (state !== 'loading' && state !== 'loaded') {
    if (-y >= pullHeight + 10) {
      me.setState('release');
      scroller.getElement().onBefore({dragend:'onScrollerDragEnd', single:true, scope:me});
    } else {
      if (state === 'release' && -y < pullHeight + 10) {
        me.setState('pull');
        scroller.getElement().unBefore({dragend:'onScrollerDragEnd', single:true, scope:me});
      }
    }
  }
  me.getTranslatable().translate(0, -y);
}, onScrollerDragEnd:function() {
  var me = this, pullHeight, list, scroller;
  if (me.getState() === 'loading') {
    return;
  }
  list = me.getList();
  scroller = list.getScrollable();
  pullHeight = me.getPullHeight();
  me.setState('loading');
  scroller.setMinUserPosition({x:0, y:-pullHeight});
  scroller.doScrollTo(0, -pullHeight, {callback:Ext.bind(me.fetchLatest, me), easingY:{duration:me.getOverpullSnapBackDuration()}}, true);
}, updateView:function() {
  var me = this, innerElement = me.innerElement, state = me.getState(), lastUpdatedText = me.getLastUpdatedText() + Ext.util.Format.date(me.lastUpdated, me.getLastUpdatedDateFormat()), templateConfig = {state:state, updated:lastUpdatedText}, stateFn = state.charAt(0).toUpperCase() + state.slice(1).toLowerCase(), fn = 'get' + stateFn + 'Text';
  if (me[fn] && Ext.isFunction(me[fn])) {
    templateConfig.message = me[fn].call(me);
  }
  innerElement.removeCls(['loaded', 'loading', 'release', 'pull'], me.refreshCls);
  innerElement.addCls(state, me.refreshCls);
  me.getPullTpl().overwrite(innerElement, templateConfig);
}});
Ext.define('Ext.tab.Tab', {extend:Ext.Button, xtype:'tab', alternateClassName:'Ext.Tab', isTab:true, config:{baseCls:Ext.baseCSSPrefix + 'tab', pressedCls:Ext.baseCSSPrefix + 'tab-pressed', activeCls:Ext.baseCSSPrefix + 'tab-active', active:false, title:'\x26nbsp;'}, updateIconCls:function(newCls, oldCls) {
  this.callParent([newCls, oldCls]);
  if (oldCls) {
    this.removeCls('x-tab-icon');
  }
  if (newCls) {
    this.addCls('x-tab-icon');
  }
}, updateTitle:function(title) {
  this.setText(title);
}, updateActive:function(active, oldActive) {
  var activeCls = this.getActiveCls();
  if (active && !oldActive) {
    this.element.addCls(activeCls);
    this.fireEvent('activate', this);
  } else {
    if (oldActive) {
      this.element.removeCls(activeCls);
      this.fireEvent('deactivate', this);
    }
  }
}}, function() {
  this.override({activate:function() {
    this.setActive(true);
  }, deactivate:function() {
    this.setActive(false);
  }});
});
Ext.define('Ext.tab.Bar', {extend:Ext.Toolbar, alternateClassName:'Ext.TabBar', xtype:'tabbar', config:{baseCls:Ext.baseCSSPrefix + 'tabbar', defaultType:'tab', defaultTabUI:null, layout:{type:'hbox', align:'middle'}}, eventedConfig:{activeTab:null}, initialize:function() {
  var me = this;
  me.callParent();
  me.on({tap:'onTabTap', delegate:'\x3e tab', scope:me});
}, onTabTap:function(tab) {
  this.setActiveTab(tab);
}, applyActiveTab:function(newActiveTab, oldActiveTab) {
  if (!newActiveTab && newActiveTab !== 0) {
    return;
  }
  var newTabInstance = this.parseActiveTab(newActiveTab);
  if (!newTabInstance) {
    if (oldActiveTab) {
      Ext.Logger.warn('Trying to set a non-existent activeTab');
    }
    return;
  }
  return newTabInstance;
}, updateDocked:function(newDocked) {
  var layout = this.getLayout(), initialConfig = this.getInitialConfig(), pack;
  if (!initialConfig.layout || !initialConfig.layout.pack) {
    pack = newDocked == 'bottom' ? 'center' : 'left';
    if (layout.isLayout) {
      layout.setPack(pack);
    } else {
      layout.pack = layout && layout.pack ? layout.pack : pack;
    }
  }
  this.callParent(arguments);
}, updateActiveTab:function(newTab, oldTab) {
  if (newTab) {
    newTab.setActive(true);
  }
  if (oldTab && oldTab.parent) {
    oldTab.setActive(false);
  }
}, parseActiveTab:function(tab) {
  if (typeof tab == 'number') {
    return this.getItems().items[tab];
  } else {
    if (typeof tab == 'string') {
      tab = Ext.getCmp(tab);
    }
  }
  return tab;
}, onItemAdd:function(item, index) {
  var defaultTabUI = this.getDefaultTabUI();
  if (defaultTabUI && item.isTab && item.getUi() == null) {
    item.setUi(defaultTabUI);
  }
  this.callParent([item, index]);
}});
Ext.define('Ext.tab.Panel', {extend:Ext.Container, xtype:'tabpanel', alternateClassName:'Ext.TabPanel', config:{tabBar:true, tabBarPosition:'top', layout:{type:'card', animation:{type:'slide', direction:'left'}}, cls:Ext.baseCSSPrefix + 'tabpanel'}, initialize:function() {
  this.callParent();
  this.on({beforeactivetabchange:'doTabChange', delegate:'\x3e tabbar', scope:this});
  this.on({disabledchange:'onItemDisabledChange', delegate:'\x3e component', scope:this});
}, applyScrollable:function() {
  return false;
}, updateUi:function(newUi, oldUi) {
  this.callParent(arguments);
  if (this.initialized) {
    this.getTabBar().setUi(newUi);
  }
}, updateActiveItem:function(newActiveItem, oldActiveItem) {
  if (newActiveItem) {
    var items = this.getInnerItems(), oldIndex = items.indexOf(oldActiveItem), newIndex = items.indexOf(newActiveItem), reverse = oldIndex > newIndex, animation = this.getLayout().getAnimation(), tabBar = this.getTabBar(), oldTab = tabBar.parseActiveTab(oldIndex), newTab = tabBar.parseActiveTab(newIndex);
    if (animation && animation.setReverse) {
      animation.setReverse(reverse);
    }
    this.callParent(arguments);
    if (newIndex != -1) {
      this.forcedChange = true;
      tabBar.setActiveTab(newIndex);
      this.forcedChange = false;
      if (oldTab) {
        oldTab.setActive(false);
      }
      if (newTab) {
        newTab.setActive(true);
      }
    }
  }
}, doTabChange:function(tabBar, newTab) {
  var oldActiveItem = this.getActiveItem(), newActiveItem;
  this.setActiveItem(tabBar.indexOf(newTab));
  newActiveItem = this.getActiveItem();
  return this.forcedChange || oldActiveItem !== newActiveItem;
}, applyTabBar:function(config) {
  if (config === true) {
    config = {};
  }
  if (config) {
    Ext.applyIf(config, {ui:this.getUi(), docked:this.getTabBarPosition()});
  }
  return Ext.factory(config, Ext.tab.Bar, this.getTabBar());
}, updateTabBar:function(newTabBar) {
  if (newTabBar) {
    this.add(newTabBar);
    this.setTabBarPosition(newTabBar.getDocked());
  }
}, updateTabBarPosition:function(position) {
  var tabBar = this.getTabBar();
  if (tabBar) {
    tabBar.setDocked(position);
  }
}, onItemAdd:function(card) {
  var me = this;
  if (!card.isInnerItem()) {
    return me.callParent(arguments);
  }
  var tabBar = me.getTabBar(), initialConfig = card.getInitialConfig(), tabConfig = initialConfig.tab || {}, tabTitle = card.getTitle ? card.getTitle() : initialConfig.title, tabIconCls = card.getIconCls ? card.getIconCls() : initialConfig.iconCls, tabHidden = card.getHidden ? card.getHidden() : initialConfig.hidden, tabDisabled = card.getDisabled ? card.getDisabled() : initialConfig.disabled, tabBadgeText = card.getBadgeText ? card.getBadgeText() : initialConfig.badgeText, innerItems = me.getInnerItems(), 
  index = innerItems.indexOf(card), tabs = tabBar.getItems(), activeTab = tabBar.getActiveTab(), currentTabInstance = tabs.length >= innerItems.length && tabs.getAt(index), header = card.isPanel && card.getHeader(), tabInstance;
  if (tabTitle && !tabConfig.title) {
    tabConfig.title = tabTitle;
  }
  if (tabIconCls && !tabConfig.iconCls) {
    tabConfig.iconCls = tabIconCls;
  }
  if (tabHidden && !tabConfig.hidden) {
    tabConfig.hidden = tabHidden;
  }
  if (tabDisabled && !tabConfig.disabled) {
    tabConfig.disabled = tabDisabled;
  }
  if (tabBadgeText && !tabConfig.badgeText) {
    tabConfig.badgeText = tabBadgeText;
  }
  if (!currentTabInstance && !tabConfig.title && !tabConfig.iconCls) {
    if (!tabConfig.title && !tabConfig.iconCls) {
      Ext.Logger.error('Adding a card to a tab container without specifying any tab configuration');
    }
  }
  tabInstance = Ext.factory(tabConfig, Ext.tab.Tab, currentTabInstance);
  if (!currentTabInstance) {
    tabBar.insert(index, tabInstance);
  }
  card.tab = tabInstance;
  if (header) {
    header.setHidden(true);
  }
  me.callParent(arguments);
  if (!activeTab && activeTab !== 0) {
    tabBar.setActiveTab(tabBar.getActiveItem());
  }
}, onItemDisabledChange:function(item, newDisabled) {
  if (item && item.tab) {
    item.tab.setDisabled(newDisabled);
  }
}, onItemRemove:function(item, index) {
  this.getTabBar().remove(item.tab, this.getAutoDestroy());
  this.callParent(arguments);
}});
Ext.define('Ext.tip.ToolTip', {});
Ext.define('Ext.draw.ContainerBase', {extend:Ext.Container, constructor:function(config) {
  this.callParent([config]);
  this.initAnimator();
}, initialize:function() {
  this.callParent();
  this.element.on('resize', 'onBodyResize', this);
}, getElementConfig:function() {
  return {reference:'element', className:'x-container', children:[{reference:'innerElement', className:'x-inner'}]};
}, addElementListener:function() {
  var el = this.element;
  el.on.apply(el, arguments);
}, removeElementListener:function() {
  var el = this.element;
  el.un.apply(el, arguments);
}, preview:function() {
  Ext.Viewport.add({xtype:'panel', layout:'fit', modal:true, width:'90%', height:'90%', hideOnMaskTap:true, centered:true, scrollable:false, items:{xtype:'image', mode:'img', style:{overflow:'hidden'}, src:this.getImage().data}, listeners:{hide:function() {
    Ext.Viewport.remove(this);
  }}}).show();
}});
Ext.define('Ext.draw.SurfaceBase', {extend:Ext.Component, getOwnerBody:function() {
  return this.getRefOwner().bodyElement;
}});
Ext.define('Ext.draw.Color', {statics:{colorToHexRe:/(.*?)rgb\((\d+),\s*(\d+),\s*(\d+)\)/, rgbToHexRe:/\s*rgb\((\d+),\s*(\d+),\s*(\d+)\)/, rgbaToHexRe:/\s*rgba\((\d+),\s*(\d+),\s*(\d+),\s*([\.\d]+)\)/, hexRe:/\s*#([0-9a-fA-F][0-9a-fA-F]?)([0-9a-fA-F][0-9a-fA-F]?)([0-9a-fA-F][0-9a-fA-F]?)\s*/, NONE:'none', RGBA_NONE:'rgba(0, 0, 0, 0)'}, isColor:true, lightnessFactor:0.2, constructor:function(red, green, blue, alpha) {
  this.setRGB(red, green, blue, alpha);
}, setRGB:function(red, green, blue, alpha) {
  var me = this;
  me.r = Math.min(255, Math.max(0, red));
  me.g = Math.min(255, Math.max(0, green));
  me.b = Math.min(255, Math.max(0, blue));
  if (alpha === undefined) {
    me.a = 1;
  } else {
    me.a = Math.min(1, Math.max(0, alpha));
  }
}, getGrayscale:function() {
  return this.r * 0.3 + this.g * 0.59 + this.b * 0.11;
}, getHSL:function() {
  var me = this, r = me.r / 255, g = me.g / 255, b = me.b / 255, max = Math.max(r, g, b), min = Math.min(r, g, b), delta = max - min, h, s = 0, l = 0.5 * (max + min);
  if (min !== max) {
    s = l <= 0.5 ? delta / (max + min) : delta / (2 - max - min);
    if (r === max) {
      h = 60 * (g - b) / delta;
    } else {
      if (g === max) {
        h = 120 + 60 * (b - r) / delta;
      } else {
        h = 240 + 60 * (r - g) / delta;
      }
    }
    if (h < 0) {
      h += 360;
    }
    if (h >= 360) {
      h -= 360;
    }
  }
  return [h, s, l];
}, getHSV:function() {
  var me = this, r = me.r / 255, g = me.g / 255, b = me.b / 255, max = Math.max(r, g, b), min = Math.min(r, g, b), C = max - min, h, s = 0, v = max;
  if (min != max) {
    s = v ? C / v : 0;
    if (r === max) {
      h = 60 * (g - b) / C;
    } else {
      if (g === max) {
        h = 60 * (b - r) / C + 120;
      } else {
        h = 60 * (r - g) / C + 240;
      }
    }
    if (h < 0) {
      h += 360;
    }
    if (h >= 360) {
      h -= 360;
    }
  }
  return [h, s, v];
}, setHSL:function(h, s, l) {
  var me = this, abs = Math.abs, c, x, m;
  h = (h % 360 + 360) % 360;
  s = s > 1 ? 1 : s < 0 ? 0 : s;
  l = l > 1 ? 1 : l < 0 ? 0 : l;
  if (s === 0 || h === null) {
    l *= 255;
    me.setRGB(l, l, l);
  } else {
    h /= 60;
    c = s * (1 - abs(2 * l - 1));
    x = c * (1 - abs(h % 2 - 1));
    m = l - c / 2;
    m *= 255;
    c *= 255;
    x *= 255;
    switch(Math.floor(h)) {
      case 0:
        me.setRGB(c + m, x + m, m);
        break;
      case 1:
        me.setRGB(x + m, c + m, m);
        break;
      case 2:
        me.setRGB(m, c + m, x + m);
        break;
      case 3:
        me.setRGB(m, x + m, c + m);
        break;
      case 4:
        me.setRGB(x + m, m, c + m);
        break;
      case 5:
        me.setRGB(c + m, m, x + m);
        break;
    }
  }
  return me;
}, setHSV:function(h, s, v) {
  var me = this, c, x, m;
  h = (h % 360 + 360) % 360;
  s = s > 1 ? 1 : s < 0 ? 0 : s;
  v = v > 1 ? 1 : v < 0 ? 0 : v;
  if (s === 0 || h === null) {
    v *= 255;
    me.setRGB(v, v, v);
  } else {
    h /= 60;
    c = v * s;
    x = c * (1 - Math.abs(h % 2 - 1));
    m = v - c;
    m *= 255;
    c *= 255;
    x *= 255;
    switch(Math.floor(h)) {
      case 0:
        me.setRGB(c + m, x + m, m);
        break;
      case 1:
        me.setRGB(x + m, c + m, m);
        break;
      case 2:
        me.setRGB(m, c + m, x + m);
        break;
      case 3:
        me.setRGB(m, x + m, c + m);
        break;
      case 4:
        me.setRGB(x + m, m, c + m);
        break;
      case 5:
        me.setRGB(c + m, m, x + m);
        break;
    }
  }
  return me;
}, createLighter:function(factor) {
  if (!factor && factor !== 0) {
    factor = this.lightnessFactor;
  }
  var hsl = this.getHSL();
  hsl[2] = Ext.Number.constrain(hsl[2] + factor, 0, 1);
  return Ext.draw.Color.fromHSL(hsl[0], hsl[1], hsl[2]);
}, createDarker:function(factor) {
  if (!factor && factor !== 0) {
    factor = this.lightnessFactor;
  }
  return this.createLighter(-factor);
}, toString:function() {
  var me = this, round = Math.round;
  if (me.a === 1) {
    var r = round(me.r).toString(16), g = round(me.g).toString(16), b = round(me.b).toString(16);
    r = r.length === 1 ? '0' + r : r;
    g = g.length === 1 ? '0' + g : g;
    b = b.length === 1 ? '0' + b : b;
    return ['#', r, g, b].join('');
  } else {
    return 'rgba(' + [round(me.r), round(me.g), round(me.b), me.a === 0 ? 0 : me.a.toFixed(15)].join(', ') + ')';
  }
}, toHex:function(color) {
  if (Ext.isArray(color)) {
    color = color[0];
  }
  if (!Ext.isString(color)) {
    return '';
  }
  if (color.substr(0, 1) === '#') {
    return color;
  }
  var digits = Ext.draw.Color.colorToHexRe.exec(color);
  if (Ext.isArray(digits)) {
    var red = parseInt(digits[2], 10), green = parseInt(digits[3], 10), blue = parseInt(digits[4], 10), rgb = blue | green << 8 | red << 16;
    return digits[1] + '#' + ('000000' + rgb.toString(16)).slice(-6);
  } else {
    return '';
  }
}, setFromString:function(str) {
  var values, r, g, b, a = 1, parse = parseInt;
  if (str === Ext.draw.Color.NONE) {
    this.r = this.g = this.b = this.a = 0;
    return this;
  }
  if ((str.length === 4 || str.length === 7) && str.substr(0, 1) === '#') {
    values = str.match(Ext.draw.Color.hexRe);
    if (values) {
      r = parse(values[1], 16) >> 0;
      g = parse(values[2], 16) >> 0;
      b = parse(values[3], 16) >> 0;
      if (str.length === 4) {
        r += r * 16;
        g += g * 16;
        b += b * 16;
      }
    }
  } else {
    if (values = str.match(Ext.draw.Color.rgbToHexRe)) {
      r = +values[1];
      g = +values[2];
      b = +values[3];
    } else {
      if (values = str.match(Ext.draw.Color.rgbaToHexRe)) {
        r = +values[1];
        g = +values[2];
        b = +values[3];
        a = +values[4];
      } else {
        if (Ext.draw.Color.ColorList.hasOwnProperty(str.toLowerCase())) {
          return this.setFromString(Ext.draw.Color.ColorList[str.toLowerCase()]);
        }
      }
    }
  }
  if (typeof r === 'undefined') {
    return this;
  }
  this.r = r;
  this.g = g;
  this.b = b;
  this.a = a;
  return this;
}}, function() {
  var flyColor = new this;
  this.addStatics({fly:function(r, g, b, a) {
    switch(arguments.length) {
      case 1:
        flyColor.setFromString(r);
        break;
      case 3:
      case 4:
        flyColor.setRGB(r, g, b, a);
        break;
      default:
        return null;
    }
    return flyColor;
  }, ColorList:{aliceblue:'#f0f8ff', antiquewhite:'#faebd7', aqua:'#00ffff', aquamarine:'#7fffd4', azure:'#f0ffff', beige:'#f5f5dc', bisque:'#ffe4c4', black:'#000000', blanchedalmond:'#ffebcd', blue:'#0000ff', blueviolet:'#8a2be2', brown:'#a52a2a', burlywood:'#deb887', cadetblue:'#5f9ea0', chartreuse:'#7fff00', chocolate:'#d2691e', coral:'#ff7f50', cornflowerblue:'#6495ed', cornsilk:'#fff8dc', crimson:'#dc143c', cyan:'#00ffff', darkblue:'#00008b', darkcyan:'#008b8b', darkgoldenrod:'#b8860b', darkgray:'#a9a9a9', 
  darkgreen:'#006400', darkkhaki:'#bdb76b', darkmagenta:'#8b008b', darkolivegreen:'#556b2f', darkorange:'#ff8c00', darkorchid:'#9932cc', darkred:'#8b0000', darksalmon:'#e9967a', darkseagreen:'#8fbc8f', darkslateblue:'#483d8b', darkslategray:'#2f4f4f', darkturquoise:'#00ced1', darkviolet:'#9400d3', deeppink:'#ff1493', deepskyblue:'#00bfff', dimgray:'#696969', dodgerblue:'#1e90ff', firebrick:'#b22222', floralwhite:'#fffaf0', forestgreen:'#228b22', fuchsia:'#ff00ff', gainsboro:'#dcdcdc', ghostwhite:'#f8f8ff', 
  gold:'#ffd700', goldenrod:'#daa520', gray:'#808080', green:'#008000', greenyellow:'#adff2f', honeydew:'#f0fff0', hotpink:'#ff69b4', indianred:'#cd5c5c', indigo:'#4b0082', ivory:'#fffff0', khaki:'#f0e68c', lavender:'#e6e6fa', lavenderblush:'#fff0f5', lawngreen:'#7cfc00', lemonchiffon:'#fffacd', lightblue:'#add8e6', lightcoral:'#f08080', lightcyan:'#e0ffff', lightgoldenrodyellow:'#fafad2', lightgray:'#d3d3d3', lightgrey:'#d3d3d3', lightgreen:'#90ee90', lightpink:'#ffb6c1', lightsalmon:'#ffa07a', 
  lightseagreen:'#20b2aa', lightskyblue:'#87cefa', lightslategray:'#778899', lightsteelblue:'#b0c4de', lightyellow:'#ffffe0', lime:'#00ff00', limegreen:'#32cd32', linen:'#faf0e6', magenta:'#ff00ff', maroon:'#800000', mediumaquamarine:'#66cdaa', mediumblue:'#0000cd', mediumorchid:'#ba55d3', mediumpurple:'#9370d8', mediumseagreen:'#3cb371', mediumslateblue:'#7b68ee', mediumspringgreen:'#00fa9a', mediumturquoise:'#48d1cc', mediumvioletred:'#c71585', midnightblue:'#191970', mintcream:'#f5fffa', mistyrose:'#ffe4e1', 
  moccasin:'#ffe4b5', navajowhite:'#ffdead', navy:'#000080', oldlace:'#fdf5e6', olive:'#808000', olivedrab:'#6b8e23', orange:'#ffa500', orangered:'#ff4500', orchid:'#da70d6', palegoldenrod:'#eee8aa', palegreen:'#98fb98', paleturquoise:'#afeeee', palevioletred:'#d87093', papayawhip:'#ffefd5', peachpuff:'#ffdab9', peru:'#cd853f', pink:'#ffc0cb', plum:'#dda0dd', powderblue:'#b0e0e6', purple:'#800080', red:'#ff0000', rosybrown:'#bc8f8f', royalblue:'#4169e1', saddlebrown:'#8b4513', salmon:'#fa8072', sandybrown:'#f4a460', 
  seagreen:'#2e8b57', seashell:'#fff5ee', sienna:'#a0522d', silver:'#c0c0c0', skyblue:'#87ceeb', slateblue:'#6a5acd', slategray:'#708090', snow:'#fffafa', springgreen:'#00ff7f', steelblue:'#4682b4', tan:'#d2b48c', teal:'#008080', thistle:'#d8bfd8', tomato:'#ff6347', turquoise:'#40e0d0', violet:'#ee82ee', wheat:'#f5deb3', white:'#ffffff', whitesmoke:'#f5f5f5', yellow:'#ffff00', yellowgreen:'#9acd32'}, fromHSL:function(h, s, l) {
    return (new this(0, 0, 0, 0)).setHSL(h, s, l);
  }, fromHSV:function(h, s, v) {
    return (new this(0, 0, 0, 0)).setHSL(h, s, v);
  }, fromString:function(string) {
    return (new this(0, 0, 0, 0)).setFromString(string);
  }, create:function(arg) {
    if (arg instanceof this) {
      return arg;
    } else {
      if (Ext.isArray(arg)) {
        return new Ext.draw.Color(arg[0], arg[1], arg[2], arg[3]);
      } else {
        if (Ext.isString(arg)) {
          return Ext.draw.Color.fromString(arg);
        } else {
          if (arguments.length > 2) {
            return new Ext.draw.Color(arguments[0], arguments[1], arguments[2], arguments[3]);
          } else {
            return new Ext.draw.Color(0, 0, 0, 0);
          }
        }
      }
    }
  }});
});
Ext.define('Ext.draw.sprite.AnimationParser', function() {
  function compute(from, to, delta) {
    return from + (to - from) * delta;
  }
  return {singleton:true, attributeRe:/^url\(#([a-zA-Z\-]+)\)$/, color:{parseInitial:function(color1, color2) {
    if (Ext.isString(color1)) {
      color1 = Ext.draw.Color.create(color1);
    }
    if (Ext.isString(color2)) {
      color2 = Ext.draw.Color.create(color2);
    }
    if (color1 instanceof Ext.draw.Color && color2 instanceof Ext.draw.Color) {
      return [[color1.r, color1.g, color1.b, color1.a], [color2.r, color2.g, color2.b, color2.a]];
    } else {
      return [color1 || color2, color2 || color1];
    }
  }, compute:function(from, to, delta) {
    if (!Ext.isArray(from) || !Ext.isArray(to)) {
      return to || from;
    } else {
      return [compute(from[0], to[0], delta), compute(from[1], to[1], delta), compute(from[2], to[2], delta), compute(from[3], to[3], delta)];
    }
  }, serve:function(array) {
    var color = Ext.draw.Color.fly(array[0], array[1], array[2], array[3]);
    return color.toString();
  }}, number:{parse:function(n) {
    return n === null ? null : +n;
  }, compute:function(from, to, delta) {
    if (!Ext.isNumber(from) || !Ext.isNumber(to)) {
      return to || from;
    } else {
      return compute(from, to, delta);
    }
  }}, angle:{parseInitial:function(from, to) {
    if (to - from > Math.PI) {
      to -= Math.PI * 2;
    } else {
      if (to - from < -Math.PI) {
        to += Math.PI * 2;
      }
    }
    return [from, to];
  }, compute:function(from, to, delta) {
    if (!Ext.isNumber(from) || !Ext.isNumber(to)) {
      return to || from;
    } else {
      return compute(from, to, delta);
    }
  }}, path:{parseInitial:function(from, to) {
    var fromStripes = from.toStripes(), toStripes = to.toStripes(), i, j, fromLength = fromStripes.length, toLength = toStripes.length, fromStripe, toStripe, length, lastStripe = toStripes[toLength - 1], endPoint = [lastStripe[lastStripe.length - 2], lastStripe[lastStripe.length - 1]];
    for (i = fromLength; i < toLength; i++) {
      fromStripes.push(fromStripes[fromLength - 1].slice(0));
    }
    for (i = toLength; i < fromLength; i++) {
      toStripes.push(endPoint.slice(0));
    }
    length = fromStripes.length;
    toStripes.path = to;
    toStripes.temp = new Ext.draw.Path;
    for (i = 0; i < length; i++) {
      fromStripe = fromStripes[i];
      toStripe = toStripes[i];
      fromLength = fromStripe.length;
      toLength = toStripe.length;
      toStripes.temp.commands.push('M');
      for (j = toLength; j < fromLength; j += 6) {
        toStripe.push(endPoint[0], endPoint[1], endPoint[0], endPoint[1], endPoint[0], endPoint[1]);
      }
      lastStripe = toStripes[toStripes.length - 1];
      endPoint = [lastStripe[lastStripe.length - 2], lastStripe[lastStripe.length - 1]];
      for (j = fromLength; j < toLength; j += 6) {
        fromStripe.push(endPoint[0], endPoint[1], endPoint[0], endPoint[1], endPoint[0], endPoint[1]);
      }
      for (i = 0; i < toStripe.length; i++) {
        toStripe[i] -= fromStripe[i];
      }
      for (i = 2; i < toStripe.length; i += 6) {
        toStripes.temp.commands.push('C');
      }
    }
    return [fromStripes, toStripes];
  }, compute:function(fromStripes, toStripes, delta) {
    if (delta >= 1) {
      return toStripes.path;
    }
    var i = 0, ln = fromStripes.length, j = 0, ln2, from, to, temp = toStripes.temp.params, pos = 0;
    for (; i < ln; i++) {
      from = fromStripes[i];
      to = toStripes[i];
      ln2 = from.length;
      for (j = 0; j < ln2; j++) {
        temp[pos++] = to[j] * delta + from[j];
      }
    }
    return toStripes.temp;
  }}, data:{compute:function(from, to, delta, target) {
    var lf = from.length - 1, lt = to.length - 1, len = Math.max(lf, lt), f, t, i;
    if (!target || target === from) {
      target = [];
    }
    target.length = len + 1;
    for (i = 0; i <= len; i++) {
      f = from[Math.min(i, lf)];
      t = to[Math.min(i, lt)];
      if (Ext.isNumber(f)) {
        if (!Ext.isNumber(t)) {
          t = 0;
        }
        target[i] = (t - f) * delta + f;
      } else {
        target[i] = t;
      }
    }
    return target;
  }}, text:{compute:function(from, to, delta) {
    return from.substr(0, Math.round(from.length * (1 - delta))) + to.substr(Math.round(to.length * (1 - delta)));
  }}, limited:'number', limited01:'number'};
});
(function() {
  if (!Ext.global.Float32Array) {
    var Float32Array = function(array) {
      if (typeof array === 'number') {
        this.length = array;
      } else {
        if ('length' in array) {
          this.length = array.length;
          for (var i = 0, len = array.length; i < len; i++) {
            this[i] = +array[i];
          }
        }
      }
    };
    Float32Array.prototype = [];
    Ext.global.Float32Array = Float32Array;
  }
})();
Ext.define('Ext.draw.Draw', {singleton:true, radian:Math.PI / 180, pi2:Math.PI * 2, reflectFn:function(a) {
  return a;
}, rad:function(degrees) {
  return degrees % 360 * this.radian;
}, degrees:function(radian) {
  return radian / this.radian % 360;
}, isBBoxIntersect:function(bbox1, bbox2, padding) {
  padding = padding || 0;
  return Math.max(bbox1.x, bbox2.x) - padding > Math.min(bbox1.x + bbox1.width, bbox2.x + bbox2.width) || Math.max(bbox1.y, bbox2.y) - padding > Math.min(bbox1.y + bbox1.height, bbox2.y + bbox2.height);
}, isPointInBBox:function(x, y, bbox) {
  return !!bbox && x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;
}, spline:function(points) {
  var i, j, ln = points.length, nd, d, y, ny, r = 0, zs = new Float32Array(points.length), result = new Float32Array(points.length * 3 - 2);
  zs[0] = 0;
  zs[ln - 1] = 0;
  for (i = 1; i < ln - 1; i++) {
    zs[i] = points[i + 1] + points[i - 1] - 2 * points[i] - zs[i - 1];
    r = 1 / (4 - r);
    zs[i] *= r;
  }
  for (i = ln - 2; i > 0; i--) {
    r = 3.732050807568877 + 48.248711305964385 / (-13.928203230275537 + Math.pow(0.07179676972449123, i));
    zs[i] -= zs[i + 1] * r;
  }
  ny = points[0];
  nd = ny - zs[0];
  for (i = 0, j = 0; i < ln - 1; j += 3) {
    y = ny;
    d = nd;
    i++;
    ny = points[i];
    nd = ny - zs[i];
    result[j] = y;
    result[j + 1] = (nd + 2 * d) / 3;
    result[j + 2] = (nd * 2 + d) / 3;
  }
  result[j] = ny;
  return result;
}, getAnchors:function(prevX, prevY, curX, curY, nextX, nextY, value) {
  value = value || 4;
  var PI = Math.PI, halfPI = PI / 2, abs = Math.abs, sin = Math.sin, cos = Math.cos, atan = Math.atan, control1Length, control2Length, control1Angle, control2Angle, control1X, control1Y, control2X, control2Y, alpha;
  control1Length = (curX - prevX) / value;
  control2Length = (nextX - curX) / value;
  if (curY >= prevY && curY >= nextY || curY <= prevY && curY <= nextY) {
    control1Angle = control2Angle = halfPI;
  } else {
    control1Angle = atan((curX - prevX) / abs(curY - prevY));
    if (prevY < curY) {
      control1Angle = PI - control1Angle;
    }
    control2Angle = atan((nextX - curX) / abs(curY - nextY));
    if (nextY < curY) {
      control2Angle = PI - control2Angle;
    }
  }
  alpha = halfPI - (control1Angle + control2Angle) % (PI * 2) / 2;
  if (alpha > halfPI) {
    alpha -= PI;
  }
  control1Angle += alpha;
  control2Angle += alpha;
  control1X = curX - control1Length * sin(control1Angle);
  control1Y = curY + control1Length * cos(control1Angle);
  control2X = curX + control2Length * sin(control2Angle);
  control2Y = curY + control2Length * cos(control2Angle);
  if (curY > prevY && control1Y < prevY || curY < prevY && control1Y > prevY) {
    control1X += abs(prevY - control1Y) * (control1X - curX) / (control1Y - curY);
    control1Y = prevY;
  }
  if (curY > nextY && control2Y < nextY || curY < nextY && control2Y > nextY) {
    control2X -= abs(nextY - control2Y) * (control2X - curX) / (control2Y - curY);
    control2Y = nextY;
  }
  return {x1:control1X, y1:control1Y, x2:control2X, y2:control2Y};
}, smooth:function(dataX, dataY, value) {
  var ln = dataX.length, prevX, prevY, curX, curY, nextX, nextY, x, y, smoothX = [], smoothY = [], i, anchors;
  for (i = 0; i < ln - 1; i++) {
    prevX = dataX[i];
    prevY = dataY[i];
    if (i === 0) {
      x = prevX;
      y = prevY;
      smoothX.push(x);
      smoothY.push(y);
      if (ln === 1) {
        break;
      }
    }
    curX = dataX[i + 1];
    curY = dataY[i + 1];
    nextX = dataX[i + 2];
    nextY = dataY[i + 2];
    if (!Ext.isNumber(nextX + nextY)) {
      smoothX.push(x, curX, curX);
      smoothY.push(y, curY, curY);
      break;
    }
    anchors = this.getAnchors(prevX, prevY, curX, curY, nextX, nextY, value);
    smoothX.push(x, anchors.x1, curX);
    smoothY.push(y, anchors.y1, curY);
    x = anchors.x2;
    y = anchors.y2;
  }
  return {smoothX:smoothX, smoothY:smoothY};
}, beginUpdateIOS:Ext.os.is.iOS ? function() {
  this.iosUpdateEl = Ext.getBody().createChild({'data-sticky':true, style:'position: absolute; top: 0px; bottom: 0px; left: 0px; right: 0px; background: rgba(0,0,0,0.001); z-index: 100000'});
} : Ext.emptyFn, endUpdateIOS:function() {
  this.iosUpdateEl = Ext.destroy(this.iosUpdateEl);
}});
Ext.define('Ext.draw.gradient.Gradient', {isGradient:true, config:{stops:[]}, applyStops:function(newStops) {
  var stops = [], ln = newStops.length, i, stop, color;
  for (i = 0; i < ln; i++) {
    stop = newStops[i];
    color = stop.color;
    if (!(color && color.isColor)) {
      color = Ext.draw.Color.fly(color || Ext.draw.Color.NONE);
    }
    stops.push({offset:Math.min(1, Math.max(0, 'offset' in stop ? stop.offset : stop.position || 0)), color:color.toString()});
  }
  stops.sort(function(a, b) {
    return a.offset - b.offset;
  });
  return stops;
}, onClassExtended:function(subClass, member) {
  if (!member.alias && member.type) {
    member.alias = 'gradient.' + member.type;
  }
}, constructor:function(config) {
  this.initConfig(config);
}, generateGradient:Ext.emptyFn});
Ext.define('Ext.draw.gradient.GradientDefinition', {singleton:true, urlStringRe:/^url\(#([\w\-]+)\)$/, gradients:{}, add:function(gradients) {
  var store = this.gradients, i, n, gradient;
  for (i = 0, n = gradients.length; i < n; i++) {
    gradient = gradients[i];
    if (Ext.isString(gradient.id)) {
      store[gradient.id] = gradient;
    }
  }
}, get:function(str) {
  var store = this.gradients, match = str.match(this.urlStringRe), gradient;
  if (match && match[1] && (gradient = store[match[1]])) {
    return gradient || str;
  }
  return str;
}});
Ext.define('Ext.draw.sprite.AttributeParser', {singleton:true, attributeRe:/^url\(#([a-zA-Z\-]+)\)$/, 'default':Ext.identityFn, string:function(n) {
  return String(n);
}, number:function(n) {
  if (Ext.isNumber(+n)) {
    return n;
  }
}, angle:function(n) {
  if (Ext.isNumber(n)) {
    n %= Math.PI * 2;
    if (n < -Math.PI) {
      n += Math.PI * 2;
    } else {
      if (n >= Math.PI) {
        n -= Math.PI * 2;
      }
    }
    return n;
  }
}, data:function(n) {
  if (Ext.isArray(n)) {
    return n.slice();
  } else {
    if (n instanceof Float32Array) {
      return new Float32Array(n);
    }
  }
}, bool:function(n) {
  return !!n;
}, color:function(n) {
  if (n instanceof Ext.draw.Color) {
    return n.toString();
  } else {
    if (n instanceof Ext.draw.gradient.Gradient) {
      return n;
    } else {
      if (!n) {
        return Ext.draw.Color.NONE;
      } else {
        if (Ext.isString(n)) {
          if (n.substr(0, 3) === 'url') {
            n = Ext.draw.gradient.GradientDefinition.get(n);
            if (Ext.isString(n)) {
              return n;
            }
          } else {
            return Ext.draw.Color.fly(n).toString();
          }
        }
      }
    }
  }
  if (n.type === 'linear') {
    return Ext.create('Ext.draw.gradient.Linear', n);
  } else {
    if (n.type === 'radial') {
      return Ext.create('Ext.draw.gradient.Radial', n);
    } else {
      if (n.type === 'pattern') {
        return Ext.create('Ext.draw.gradient.Pattern', n);
      } else {
        return Ext.draw.Color.NONE;
      }
    }
  }
}, limited:function(low, hi) {
  return function(n) {
    n = +n;
    return Ext.isNumber(n) ? Math.min(Math.max(n, low), hi) : undefined;
  };
}, limited01:function(n) {
  n = +n;
  return Ext.isNumber(n) ? Math.min(Math.max(n, 0), 1) : undefined;
}, enums:function() {
  var enums = {}, args = Array.prototype.slice.call(arguments, 0), i, ln;
  for (i = 0, ln = args.length; i < ln; i++) {
    enums[args[i]] = true;
  }
  return function(n) {
    return n in enums ? n : undefined;
  };
}});
Ext.define('Ext.draw.sprite.AttributeDefinition', {config:{defaults:{$value:{}, lazy:true}, aliases:{}, animationProcessors:{}, processors:{$value:{}, lazy:true}, dirtyTriggers:{}, triggers:{}, updaters:{}}, inheritableStatics:{processorFactoryRe:/^(\w+)\(([\w\-,]*)\)$/}, spriteClass:null, constructor:function(config) {
  var me = this;
  me.initConfig(config);
}, applyDefaults:function(defaults, oldDefaults) {
  oldDefaults = Ext.apply(oldDefaults || {}, this.normalize(defaults));
  return oldDefaults;
}, applyAliases:function(aliases, oldAliases) {
  return Ext.apply(oldAliases || {}, aliases);
}, applyProcessors:function(processors, oldProcessors) {
  this.getAnimationProcessors();
  var result = oldProcessors || {}, defaultProcessor = Ext.draw.sprite.AttributeParser, processorFactoryRe = this.self.processorFactoryRe, animationProcessors = {}, anyAnimationProcessors, name, match, fn;
  for (name in processors) {
    fn = processors[name];
    if (typeof fn === 'string') {
      match = fn.match(processorFactoryRe);
      if (match) {
        fn = defaultProcessor[match[1]].apply(defaultProcessor, match[2].split(','));
      } else {
        if (defaultProcessor[fn]) {
          animationProcessors[name] = fn;
          anyAnimationProcessors = true;
          fn = defaultProcessor[fn];
        }
      }
    }
    if (!Ext.isFunction(fn)) {
      Ext.raise(this.spriteClass.$className + ": processor '" + name + "' has not been found.");
    }
    result[name] = fn;
  }
  if (anyAnimationProcessors) {
    this.setAnimationProcessors(animationProcessors);
  }
  return result;
}, applyAnimationProcessors:function(animationProcessors, oldAnimationProcessors) {
  var parser = Ext.draw.sprite.AnimationParser, name, item;
  if (!oldAnimationProcessors) {
    oldAnimationProcessors = {};
  }
  for (name in animationProcessors) {
    item = animationProcessors[name];
    if (item === 'none') {
      oldAnimationProcessors[name] = null;
    } else {
      if (Ext.isString(item) && !(name in oldAnimationProcessors)) {
        if (item in parser) {
          while (Ext.isString(parser[item])) {
            item = parser[item];
          }
          oldAnimationProcessors[name] = parser[item];
        }
      } else {
        if (Ext.isObject(item)) {
          oldAnimationProcessors[name] = item;
        }
      }
    }
  }
  return oldAnimationProcessors;
}, updateDirtyTriggers:function(dirtyTriggers) {
  this.setTriggers(dirtyTriggers);
}, applyTriggers:function(triggers, oldTriggers) {
  if (!oldTriggers) {
    oldTriggers = {};
  }
  for (var name in triggers) {
    oldTriggers[name] = triggers[name].split(',');
  }
  return oldTriggers;
}, applyUpdaters:function(updaters, oldUpdaters) {
  return Ext.apply(oldUpdaters || {}, updaters);
}, batchedNormalize:function(batchedChanges, keepUnrecognized) {
  if (!batchedChanges) {
    return {};
  }
  var processors = this.getProcessors(), aliases = this.getAliases(), translation = batchedChanges.translation || batchedChanges.translate, normalized = {}, i, ln, name, val, rotation, scaling, matrix, subVal, split;
  if ('rotation' in batchedChanges) {
    rotation = batchedChanges.rotation;
  } else {
    rotation = 'rotate' in batchedChanges ? batchedChanges.rotate : undefined;
  }
  if ('scaling' in batchedChanges) {
    scaling = batchedChanges.scaling;
  } else {
    scaling = 'scale' in batchedChanges ? batchedChanges.scale : undefined;
  }
  if (typeof scaling !== 'undefined') {
    if (Ext.isNumber(scaling)) {
      normalized.scalingX = scaling;
      normalized.scalingY = scaling;
    } else {
      if ('x' in scaling) {
        normalized.scalingX = scaling.x;
      }
      if ('y' in scaling) {
        normalized.scalingY = scaling.y;
      }
      if ('centerX' in scaling) {
        normalized.scalingCenterX = scaling.centerX;
      }
      if ('centerY' in scaling) {
        normalized.scalingCenterY = scaling.centerY;
      }
    }
  }
  if (typeof rotation !== 'undefined') {
    if (Ext.isNumber(rotation)) {
      rotation = Ext.draw.Draw.rad(rotation);
      normalized.rotationRads = rotation;
    } else {
      if ('rads' in rotation) {
        normalized.rotationRads = rotation.rads;
      } else {
        if ('degrees' in rotation) {
          if (Ext.isArray(rotation.degrees)) {
            normalized.rotationRads = Ext.Array.map(rotation.degrees, function(deg) {
              return Ext.draw.Draw.rad(deg);
            });
          } else {
            normalized.rotationRads = Ext.draw.Draw.rad(rotation.degrees);
          }
        }
      }
      if ('centerX' in rotation) {
        normalized.rotationCenterX = rotation.centerX;
      }
      if ('centerY' in rotation) {
        normalized.rotationCenterY = rotation.centerY;
      }
    }
  }
  if (typeof translation !== 'undefined') {
    if ('x' in translation) {
      normalized.translationX = translation.x;
    }
    if ('y' in translation) {
      normalized.translationY = translation.y;
    }
  }
  if ('matrix' in batchedChanges) {
    matrix = Ext.draw.Matrix.create(batchedChanges.matrix);
    split = matrix.split();
    normalized.matrix = matrix;
    normalized.rotationRads = split.rotation;
    normalized.rotationCenterX = 0;
    normalized.rotationCenterY = 0;
    normalized.scalingX = split.scaleX;
    normalized.scalingY = split.scaleY;
    normalized.scalingCenterX = 0;
    normalized.scalingCenterY = 0;
    normalized.translationX = split.translateX;
    normalized.translationY = split.translateY;
  }
  for (name in batchedChanges) {
    val = batchedChanges[name];
    if (typeof val === 'undefined') {
      continue;
    } else {
      if (Ext.isArray(val)) {
        if (name in aliases) {
          name = aliases[name];
        }
        if (name in processors) {
          normalized[name] = [];
          for (i = 0, ln = val.length; i < ln; i++) {
            subVal = processors[name].call(this, val[i]);
            if (typeof subVal !== 'undefined') {
              normalized[name][i] = subVal;
            }
          }
        } else {
          if (keepUnrecognized) {
            normalized[name] = val;
          }
        }
      } else {
        if (name in aliases) {
          name = aliases[name];
        }
        if (name in processors) {
          val = processors[name].call(this, val);
          if (typeof val !== 'undefined') {
            normalized[name] = val;
          }
        } else {
          if (keepUnrecognized) {
            normalized[name] = val;
          }
        }
      }
    }
  }
  return normalized;
}, normalize:function(changes, keepUnrecognized) {
  if (!changes) {
    return {};
  }
  var processors = this.getProcessors(), aliases = this.getAliases(), translation = changes.translation || changes.translate, normalized = {}, name, val, rotation, scaling, matrix, split;
  if ('rotation' in changes) {
    rotation = changes.rotation;
  } else {
    rotation = 'rotate' in changes ? changes.rotate : undefined;
  }
  if ('scaling' in changes) {
    scaling = changes.scaling;
  } else {
    scaling = 'scale' in changes ? changes.scale : undefined;
  }
  if (translation) {
    if ('x' in translation) {
      normalized.translationX = translation.x;
    }
    if ('y' in translation) {
      normalized.translationY = translation.y;
    }
  }
  if (typeof scaling !== 'undefined') {
    if (Ext.isNumber(scaling)) {
      normalized.scalingX = scaling;
      normalized.scalingY = scaling;
    } else {
      if ('x' in scaling) {
        normalized.scalingX = scaling.x;
      }
      if ('y' in scaling) {
        normalized.scalingY = scaling.y;
      }
      if ('centerX' in scaling) {
        normalized.scalingCenterX = scaling.centerX;
      }
      if ('centerY' in scaling) {
        normalized.scalingCenterY = scaling.centerY;
      }
    }
  }
  if (typeof rotation !== 'undefined') {
    if (Ext.isNumber(rotation)) {
      rotation = Ext.draw.Draw.rad(rotation);
      normalized.rotationRads = rotation;
    } else {
      if ('rads' in rotation) {
        normalized.rotationRads = rotation.rads;
      } else {
        if ('degrees' in rotation) {
          normalized.rotationRads = Ext.draw.Draw.rad(rotation.degrees);
        }
      }
      if ('centerX' in rotation) {
        normalized.rotationCenterX = rotation.centerX;
      }
      if ('centerY' in rotation) {
        normalized.rotationCenterY = rotation.centerY;
      }
    }
  }
  if ('matrix' in changes) {
    matrix = Ext.draw.Matrix.create(changes.matrix);
    split = matrix.split();
    normalized.matrix = matrix;
    normalized.rotationRads = split.rotation;
    normalized.rotationCenterX = 0;
    normalized.rotationCenterY = 0;
    normalized.scalingX = split.scaleX;
    normalized.scalingY = split.scaleY;
    normalized.scalingCenterX = 0;
    normalized.scalingCenterY = 0;
    normalized.translationX = split.translateX;
    normalized.translationY = split.translateY;
  }
  for (name in changes) {
    val = changes[name];
    if (typeof val === 'undefined') {
      continue;
    }
    if (name in aliases) {
      name = aliases[name];
    }
    if (name in processors) {
      val = processors[name].call(this, val);
      if (typeof val !== 'undefined') {
        normalized[name] = val;
      }
    } else {
      if (keepUnrecognized) {
        normalized[name] = val;
      }
    }
  }
  return normalized;
}, setBypassingNormalization:function(attr, modifierStack, changes) {
  return modifierStack.pushDown(attr, changes);
}, set:function(attr, modifierStack, changes) {
  changes = this.normalize(changes);
  return this.setBypassingNormalization(attr, modifierStack, changes);
}});
Ext.define('Ext.draw.Matrix', {isMatrix:true, statics:{createAffineMatrixFromTwoPair:function(x0, y0, x1, y1, x0p, y0p, x1p, y1p) {
  var dx = x1 - x0, dy = y1 - y0, dxp = x1p - x0p, dyp = y1p - y0p, r = 1 / (dx * dx + dy * dy), a = dx * dxp + dy * dyp, b = dxp * dy - dx * dyp, c = -a * x0 - b * y0, f = b * x0 - a * y0;
  return new this(a * r, -b * r, b * r, a * r, c * r + x0p, f * r + y0p);
}, createPanZoomFromTwoPair:function(x0, y0, x1, y1, x0p, y0p, x1p, y1p) {
  if (arguments.length === 2) {
    return this.createPanZoomFromTwoPair.apply(this, x0.concat(y0));
  }
  var dx = x1 - x0, dy = y1 - y0, cx = (x0 + x1) * 0.5, cy = (y0 + y1) * 0.5, dxp = x1p - x0p, dyp = y1p - y0p, cxp = (x0p + x1p) * 0.5, cyp = (y0p + y1p) * 0.5, r = dx * dx + dy * dy, rp = dxp * dxp + dyp * dyp, scale = Math.sqrt(rp / r);
  return new this(scale, 0, 0, scale, cxp - scale * cx, cyp - scale * cy);
}, fly:function() {
  var flyMatrix = null, simplefly = function(elements) {
    flyMatrix.elements = elements;
    return flyMatrix;
  };
  return function(elements) {
    if (!flyMatrix) {
      flyMatrix = new Ext.draw.Matrix;
    }
    flyMatrix.elements = elements;
    Ext.draw.Matrix.fly = simplefly;
    return flyMatrix;
  };
}(), create:function(mat) {
  if (mat instanceof this) {
    return mat;
  }
  return new this(mat);
}}, constructor:function(xx, xy, yx, yy, dx, dy) {
  if (xx && xx.length === 6) {
    this.elements = xx.slice();
  } else {
    if (xx !== undefined) {
      this.elements = [xx, xy, yx, yy, dx, dy];
    } else {
      this.elements = [1, 0, 0, 1, 0, 0];
    }
  }
}, prepend:function(xx, xy, yx, yy, dx, dy) {
  var elements = this.elements, xx0 = elements[0], xy0 = elements[1], yx0 = elements[2], yy0 = elements[3], dx0 = elements[4], dy0 = elements[5];
  elements[0] = xx * xx0 + yx * xy0;
  elements[1] = xy * xx0 + yy * xy0;
  elements[2] = xx * yx0 + yx * yy0;
  elements[3] = xy * yx0 + yy * yy0;
  elements[4] = xx * dx0 + yx * dy0 + dx;
  elements[5] = xy * dx0 + yy * dy0 + dy;
  return this;
}, prependMatrix:function(matrix) {
  return this.prepend.apply(this, matrix.elements);
}, append:function(xx, xy, yx, yy, dx, dy) {
  var elements = this.elements, xx0 = elements[0], xy0 = elements[1], yx0 = elements[2], yy0 = elements[3], dx0 = elements[4], dy0 = elements[5];
  elements[0] = xx * xx0 + xy * yx0;
  elements[1] = xx * xy0 + xy * yy0;
  elements[2] = yx * xx0 + yy * yx0;
  elements[3] = yx * xy0 + yy * yy0;
  elements[4] = dx * xx0 + dy * yx0 + dx0;
  elements[5] = dx * xy0 + dy * yy0 + dy0;
  return this;
}, appendMatrix:function(matrix) {
  return this.append.apply(this, matrix.elements);
}, set:function(xx, xy, yx, yy, dx, dy) {
  var elements = this.elements;
  elements[0] = xx;
  elements[1] = xy;
  elements[2] = yx;
  elements[3] = yy;
  elements[4] = dx;
  elements[5] = dy;
  return this;
}, inverse:function(target) {
  var elements = this.elements, a = elements[0], b = elements[1], c = elements[2], d = elements[3], e = elements[4], f = elements[5], rDim = 1 / (a * d - b * c);
  a *= rDim;
  b *= rDim;
  c *= rDim;
  d *= rDim;
  if (target) {
    target.set(d, -b, -c, a, c * f - d * e, b * e - a * f);
    return target;
  } else {
    return new Ext.draw.Matrix(d, -b, -c, a, c * f - d * e, b * e - a * f);
  }
}, translate:function(x, y, prepend) {
  if (prepend) {
    return this.prepend(1, 0, 0, 1, x, y);
  } else {
    return this.append(1, 0, 0, 1, x, y);
  }
}, scale:function(sx, sy, scx, scy, prepend) {
  var me = this;
  if (sy == null) {
    sy = sx;
  }
  if (scx === undefined) {
    scx = 0;
  }
  if (scy === undefined) {
    scy = 0;
  }
  if (prepend) {
    return me.prepend(sx, 0, 0, sy, scx - scx * sx, scy - scy * sy);
  } else {
    return me.append(sx, 0, 0, sy, scx - scx * sx, scy - scy * sy);
  }
}, rotate:function(angle, rcx, rcy, prepend) {
  var me = this, cos = Math.cos(angle), sin = Math.sin(angle);
  rcx = rcx || 0;
  rcy = rcy || 0;
  if (prepend) {
    return me.prepend(cos, sin, -sin, cos, rcx - cos * rcx + rcy * sin, rcy - cos * rcy - rcx * sin);
  } else {
    return me.append(cos, sin, -sin, cos, rcx - cos * rcx + rcy * sin, rcy - cos * rcy - rcx * sin);
  }
}, rotateFromVector:function(x, y, prepend) {
  var me = this, d = Math.sqrt(x * x + y * y), cos = x / d, sin = y / d;
  if (prepend) {
    return me.prepend(cos, sin, -sin, cos, 0, 0);
  } else {
    return me.append(cos, sin, -sin, cos, 0, 0);
  }
}, clone:function() {
  return new Ext.draw.Matrix(this.elements);
}, flipX:function() {
  return this.append(-1, 0, 0, 1, 0, 0);
}, flipY:function() {
  return this.append(1, 0, 0, -1, 0, 0);
}, skewX:function(angle) {
  return this.append(1, 0, Math.tan(angle), 1, 0, 0);
}, skewY:function(angle) {
  return this.append(1, Math.tan(angle), 0, 1, 0, 0);
}, shearX:function(factor) {
  return this.append(1, 0, factor, 1, 0, 0);
}, shearY:function(factor) {
  return this.append(1, factor, 0, 1, 0, 0);
}, reset:function() {
  return this.set(1, 0, 0, 1, 0, 0);
}, precisionCompensate:function(devicePixelRatio, comp) {
  var elements = this.elements, x2x = elements[0], x2y = elements[1], y2x = elements[2], y2y = elements[3], newDx = elements[4], newDy = elements[5], r = x2y * y2x - x2x * y2y;
  comp.b = devicePixelRatio * x2y / x2x;
  comp.c = devicePixelRatio * y2x / y2y;
  comp.d = devicePixelRatio;
  comp.xx = x2x / devicePixelRatio;
  comp.yy = y2y / devicePixelRatio;
  comp.dx = (newDy * x2x * y2x - newDx * x2x * y2y) / r / devicePixelRatio;
  comp.dy = (newDx * x2y * y2y - newDy * x2x * y2y) / r / devicePixelRatio;
}, precisionCompensateRect:function(devicePixelRatio, comp) {
  var elements = this.elements, x2x = elements[0], x2y = elements[1], y2x = elements[2], y2y = elements[3], newDx = elements[4], newDy = elements[5], yxOnXx = y2x / x2x;
  comp.b = devicePixelRatio * x2y / x2x;
  comp.c = devicePixelRatio * yxOnXx;
  comp.d = devicePixelRatio * y2y / x2x;
  comp.xx = x2x / devicePixelRatio;
  comp.yy = x2x / devicePixelRatio;
  comp.dx = (newDy * y2x - newDx * y2y) / (x2y * yxOnXx - y2y) / devicePixelRatio;
  comp.dy = -(newDy * x2x - newDx * x2y) / (x2y * yxOnXx - y2y) / devicePixelRatio;
}, x:function(x, y) {
  var elements = this.elements;
  return x * elements[0] + y * elements[2] + elements[4];
}, y:function(x, y) {
  var elements = this.elements;
  return x * elements[1] + y * elements[3] + elements[5];
}, get:function(i, j) {
  return +this.elements[i + j * 2].toFixed(4);
}, transformPoint:function(point) {
  var elements = this.elements, x, y;
  if (point.isPoint) {
    x = point.x;
    y = point.y;
  } else {
    x = point[0];
    y = point[1];
  }
  return [x * elements[0] + y * elements[2] + elements[4], x * elements[1] + y * elements[3] + elements[5]];
}, transformBBox:function(bbox, radius, target) {
  var elements = this.elements, l = bbox.x, t = bbox.y, w0 = bbox.width * 0.5, h0 = bbox.height * 0.5, xx = elements[0], xy = elements[1], yx = elements[2], yy = elements[3], cx = l + w0, cy = t + h0, w, h, scales;
  if (radius) {
    w0 -= radius;
    h0 -= radius;
    scales = [Math.sqrt(elements[0] * elements[0] + elements[2] * elements[2]), Math.sqrt(elements[1] * elements[1] + elements[3] * elements[3])];
    w = Math.abs(w0 * xx) + Math.abs(h0 * yx) + Math.abs(scales[0] * radius);
    h = Math.abs(w0 * xy) + Math.abs(h0 * yy) + Math.abs(scales[1] * radius);
  } else {
    w = Math.abs(w0 * xx) + Math.abs(h0 * yx);
    h = Math.abs(w0 * xy) + Math.abs(h0 * yy);
  }
  if (!target) {
    target = {};
  }
  target.x = cx * xx + cy * yx + elements[4] - w;
  target.y = cx * xy + cy * yy + elements[5] - h;
  target.width = w + w;
  target.height = h + h;
  return target;
}, transformList:function(list) {
  var elements = this.elements, xx = elements[0], yx = elements[2], dx = elements[4], xy = elements[1], yy = elements[3], dy = elements[5], ln = list.length, p, i;
  for (i = 0; i < ln; i++) {
    p = list[i];
    list[i] = [p[0] * xx + p[1] * yx + dx, p[0] * xy + p[1] * yy + dy];
  }
  return list;
}, isIdentity:function() {
  var elements = this.elements;
  return elements[0] === 1 && elements[1] === 0 && elements[2] === 0 && elements[3] === 1 && elements[4] === 0 && elements[5] === 0;
}, isEqual:function(matrix) {
  var elements = matrix && matrix.isMatrix ? matrix.elements : matrix, myElements = this.elements;
  return myElements[0] === elements[0] && myElements[1] === elements[1] && myElements[2] === elements[2] && myElements[3] === elements[3] && myElements[4] === elements[4] && myElements[5] === elements[5];
}, equals:function(matrix) {
  return this.isEqual(matrix);
}, toArray:function() {
  var elements = this.elements;
  return [elements[0], elements[2], elements[4], elements[1], elements[3], elements[5]];
}, toVerticalArray:function() {
  return this.elements.slice();
}, toString:function() {
  var me = this;
  return [me.get(0, 0), me.get(0, 1), me.get(1, 0), me.get(1, 1), me.get(2, 0), me.get(2, 1)].join(',');
}, toContext:function(ctx) {
  ctx.transform.apply(ctx, this.elements);
  return this;
}, toSvg:function() {
  var elements = this.elements;
  return 'matrix(' + elements[0].toFixed(9) + ',' + elements[1].toFixed(9) + ',' + elements[2].toFixed(9) + ',' + elements[3].toFixed(9) + ',' + elements[4].toFixed(9) + ',' + elements[5].toFixed(9) + ')';
}, getScaleX:function() {
  var elements = this.elements;
  return Math.sqrt(elements[0] * elements[0] + elements[2] * elements[2]);
}, getScaleY:function() {
  var elements = this.elements;
  return Math.sqrt(elements[1] * elements[1] + elements[3] * elements[3]);
}, getXX:function() {
  return this.elements[0];
}, getXY:function() {
  return this.elements[1];
}, getYX:function() {
  return this.elements[2];
}, getYY:function() {
  return this.elements[3];
}, getDX:function() {
  return this.elements[4];
}, getDY:function() {
  return this.elements[5];
}, split:function() {
  var el = this.elements, xx = el[0], xy = el[1], yy = el[3], out = {translateX:el[4], translateY:el[5]};
  out.rotate = out.rotation = Math.atan2(xy, xx);
  out.scaleX = xx / Math.cos(out.rotate);
  out.scaleY = yy / xx * out.scaleX;
  return out;
}}, function() {
  function registerName(properties, name, i) {
    properties[name] = {get:function() {
      return this.elements[i];
    }, set:function(val) {
      this.elements[i] = val;
    }};
  }
  if (Object.defineProperties) {
    var properties = {};
    registerName(properties, 'a', 0);
    registerName(properties, 'b', 1);
    registerName(properties, 'c', 2);
    registerName(properties, 'd', 3);
    registerName(properties, 'e', 4);
    registerName(properties, 'f', 5);
    Object.defineProperties(this.prototype, properties);
  }
  this.prototype.multiply = this.prototype.appendMatrix;
});
Ext.define('Ext.draw.modifier.Modifier', {mixins:{observable:Ext.mixin.Observable}, config:{previous:null, next:null, sprite:null}, constructor:function(config) {
  this.mixins.observable.constructor.call(this, config);
}, updateNext:function(next) {
  if (next) {
    next.setPrevious(this);
  }
}, updatePrevious:function(prev) {
  if (prev) {
    prev.setNext(this);
  }
}, prepareAttributes:function(attr) {
  if (this._previous) {
    this._previous.prepareAttributes(attr);
  }
}, popUp:function(attributes, changes) {
  if (this._next) {
    this._next.popUp(attributes, changes);
  } else {
    Ext.apply(attributes, changes);
  }
}, pushDown:function(attr, changes) {
  if (this._previous) {
    return this._previous.pushDown(attr, changes);
  } else {
    for (var name in changes) {
      if (changes[name] === attr[name]) {
        delete changes[name];
      }
    }
    return changes;
  }
}});
Ext.define('Ext.draw.modifier.Target', {extend:Ext.draw.modifier.Modifier, alias:'modifier.target', statics:{uniqueId:0}, prepareAttributes:function(attr) {
  var previous = this.getPrevious();
  if (previous) {
    previous.prepareAttributes(attr);
  }
  attr.attributeId = 'attribute-' + Ext.draw.modifier.Target.uniqueId++;
  if (!attr.hasOwnProperty('canvasAttributes')) {
    attr.bbox = {plain:{dirty:true}, transform:{dirty:true}};
    attr.dirty = true;
    attr.pendingUpdaters = {};
    attr.canvasAttributes = {};
    attr.matrix = new Ext.draw.Matrix;
    attr.inverseMatrix = new Ext.draw.Matrix;
  }
}, applyChanges:function(attr, changes) {
  Ext.apply(attr, changes);
  var sprite = this.getSprite(), pendingUpdaters = attr.pendingUpdaters, triggers = sprite.self.def.getTriggers(), updaters, instances, instance, name, hasChanges, canvasAttributes, i, j, ln;
  for (name in changes) {
    hasChanges = true;
    if (updaters = triggers[name]) {
      sprite.scheduleUpdaters(attr, updaters, [name]);
    }
    if (attr.template && changes.removeFromInstance && changes.removeFromInstance[name]) {
      delete attr[name];
    }
  }
  if (!hasChanges) {
    return;
  }
  if (pendingUpdaters.canvas) {
    canvasAttributes = pendingUpdaters.canvas;
    delete pendingUpdaters.canvas;
    for (i = 0, ln = canvasAttributes.length; i < ln; i++) {
      name = canvasAttributes[i];
      attr.canvasAttributes[name] = attr[name];
    }
  }
  if (attr.hasOwnProperty('children')) {
    instances = attr.children;
    for (i = 0, ln = instances.length; i < ln; i++) {
      instance = instances[i];
      Ext.apply(instance.pendingUpdaters, pendingUpdaters);
      if (canvasAttributes) {
        for (j = 0; j < canvasAttributes.length; j++) {
          name = canvasAttributes[j];
          instance.canvasAttributes[name] = instance[name];
        }
      }
      sprite.callUpdaters(instance);
    }
  }
  sprite.setDirty(true);
  sprite.callUpdaters(attr);
}, popUp:function(attr, changes) {
  this.applyChanges(attr, changes);
}, pushDown:function(attr, changes) {
  var previous = this.getPrevious();
  if (previous) {
    changes = previous.pushDown(attr, changes);
  }
  this.applyChanges(attr, changes);
  return changes;
}});
Ext.define('Ext.draw.TimingFunctions', function() {
  var pow = Math.pow, sin = Math.sin, cos = Math.cos, sqrt = Math.sqrt, pi = Math.PI, poly = ['quad', 'cube', 'quart', 'quint'], easings = {pow:function(p, x) {
    return pow(p, x || 6);
  }, expo:function(p) {
    return pow(2, 8 * (p - 1));
  }, circ:function(p) {
    return 1 - sqrt(1 - p * p);
  }, sine:function(p) {
    return 1 - sin((1 - p) * pi / 2);
  }, back:function(p, n) {
    n = n || 1.616;
    return p * p * ((n + 1) * p - n);
  }, bounce:function(p) {
    for (var a = 0, b = 1; 1; a += b, b /= 2) {
      if (p >= (7 - 4 * a) / 11) {
        return b * b - pow((11 - 6 * a - 11 * p) / 4, 2);
      }
    }
  }, elastic:function(p, x) {
    return pow(2, 10 * --p) * cos(20 * p * pi * (x || 1) / 3);
  }}, easingsMap = {}, name, len, i;
  function createPoly(times) {
    return function(p) {
      return pow(p, times);
    };
  }
  function addEasing(name, easing) {
    easingsMap[name + 'In'] = function(pos) {
      return easing(pos);
    };
    easingsMap[name + 'Out'] = function(pos) {
      return 1 - easing(1 - pos);
    };
    easingsMap[name + 'InOut'] = function(pos) {
      return pos <= 0.5 ? easing(2 * pos) / 2 : (2 - easing(2 * (1 - pos))) / 2;
    };
  }
  for (i = 0, len = poly.length; i < len; ++i) {
    easings[poly[i]] = createPoly(i + 2);
  }
  for (name in easings) {
    addEasing(name, easings[name]);
  }
  easingsMap.linear = Ext.identityFn;
  easingsMap.easeIn = easingsMap.quadIn;
  easingsMap.easeOut = easingsMap.quadOut;
  easingsMap.easeInOut = easingsMap.quadInOut;
  return {singleton:true, easingMap:easingsMap};
}, function(Cls) {
  Ext.apply(Cls, Cls.easingMap);
});
Ext.define('Ext.draw.Animator', {singleton:true, frameCallbacks:{}, frameCallbackId:0, scheduled:0, frameStartTimeOffset:Ext.now(), animations:[], running:false, animationTime:function() {
  return Ext.AnimationQueue.frameStartTime - this.frameStartTimeOffset;
}, add:function(animation) {
  var me = this;
  if (!me.contains(animation)) {
    me.animations.push(animation);
    me.ignite();
    if ('fireEvent' in animation) {
      animation.fireEvent('animationstart', animation);
    }
  }
}, remove:function(animation) {
  var me = this, animations = me.animations, i = 0, l = animations.length;
  for (; i < l; ++i) {
    if (animations[i] === animation) {
      animations.splice(i, 1);
      if ('fireEvent' in animation) {
        animation.fireEvent('animationend', animation);
      }
      return;
    }
  }
}, contains:function(animation) {
  return Ext.Array.indexOf(this.animations, animation) > -1;
}, empty:function() {
  return this.animations.length === 0;
}, step:function(frameTime) {
  var me = this, animations = me.animations, animation, i = 0, ln = animations.length;
  for (; i < ln; i++) {
    animation = animations[i];
    animation.step(frameTime);
    if (!animation.animating) {
      animations.splice(i, 1);
      i--;
      ln--;
      if (animation.fireEvent) {
        animation.fireEvent('animationend', animation);
      }
    }
  }
}, schedule:function(callback, scope) {
  scope = scope || this;
  var id = 'frameCallback' + this.frameCallbackId++;
  if (Ext.isString(callback)) {
    callback = scope[callback];
  }
  Ext.draw.Animator.frameCallbacks[id] = {fn:callback, scope:scope, once:true};
  this.scheduled++;
  Ext.draw.Animator.ignite();
  return id;
}, scheduleIf:function(callback, scope) {
  scope = scope || this;
  var frameCallbacks = Ext.draw.Animator.frameCallbacks, cb, id;
  if (Ext.isString(callback)) {
    callback = scope[callback];
  }
  for (id in frameCallbacks) {
    cb = frameCallbacks[id];
    if (cb.once && cb.fn === callback && cb.scope === scope) {
      return null;
    }
  }
  return this.schedule(callback, scope);
}, cancel:function(id) {
  if (Ext.draw.Animator.frameCallbacks[id] && Ext.draw.Animator.frameCallbacks[id].once) {
    this.scheduled--;
    delete Ext.draw.Animator.frameCallbacks[id];
  }
}, addFrameCallback:function(callback, scope) {
  scope = scope || this;
  if (Ext.isString(callback)) {
    callback = scope[callback];
  }
  var id = 'frameCallback' + this.frameCallbackId++;
  Ext.draw.Animator.frameCallbacks[id] = {fn:callback, scope:scope};
  return id;
}, removeFrameCallback:function(id) {
  delete Ext.draw.Animator.frameCallbacks[id];
}, fireFrameCallbacks:function() {
  var callbacks = this.frameCallbacks, id, fn, cb;
  for (id in callbacks) {
    cb = callbacks[id];
    fn = cb.fn;
    if (Ext.isString(fn)) {
      fn = cb.scope[fn];
    }
    fn.call(cb.scope);
    if (callbacks[id] && cb.once) {
      this.scheduled--;
      delete callbacks[id];
    }
  }
}, handleFrame:function() {
  this.step(this.animationTime());
  this.fireFrameCallbacks();
  if (!this.scheduled && this.empty()) {
    Ext.AnimationQueue.stop(this.handleFrame, this);
    this.running = false;
    Ext.draw.Draw.endUpdateIOS();
  }
}, ignite:function() {
  if (!this.running) {
    this.running = true;
    Ext.AnimationQueue.start(this.handleFrame, this);
    Ext.draw.Draw.beginUpdateIOS();
  }
}});
Ext.define('Ext.draw.modifier.Animation', {extend:Ext.draw.modifier.Modifier, alias:'modifier.animation', config:{easing:Ext.identityFn, duration:0, customEasings:{}, customDurations:{}, customDuration:null}, constructor:function(config) {
  var me = this;
  me.anyAnimation = me.anySpecialAnimations = false;
  me.animating = 0;
  me.animatingPool = [];
  me.callParent([config]);
}, prepareAttributes:function(attr) {
  if (!attr.hasOwnProperty('timers')) {
    attr.animating = false;
    attr.timers = {};
    attr.animationOriginal = Ext.Object.chain(attr);
    attr.animationOriginal.prototype = attr;
  }
  if (this._previous) {
    this._previous.prepareAttributes(attr.animationOriginal);
  }
}, updateSprite:function(sprite) {
  this.setConfig(sprite.config.fx);
}, updateDuration:function(duration) {
  this.anyAnimation = duration > 0;
}, applyEasing:function(easing) {
  if (typeof easing === 'string') {
    easing = Ext.draw.TimingFunctions.easingMap[easing];
  }
  return easing;
}, applyCustomEasings:function(newEasings, oldEasings) {
  oldEasings = oldEasings || {};
  var any, key, attrs, easing, i, ln;
  for (key in newEasings) {
    any = true;
    easing = newEasings[key];
    attrs = key.split(',');
    if (typeof easing === 'string') {
      easing = Ext.draw.TimingFunctions.easingMap[easing];
    }
    for (i = 0, ln = attrs.length; i < ln; i++) {
      oldEasings[attrs[i]] = easing;
    }
  }
  if (any) {
    this.anySpecialAnimations = any;
  }
  return oldEasings;
}, setEasingOn:function(attrs, easing) {
  attrs = Ext.Array.from(attrs).slice();
  var customEasings = {}, ln = attrs.length, i = 0;
  for (; i < ln; i++) {
    customEasings[attrs[i]] = easing;
  }
  this.setCustomEasings(customEasings);
}, clearEasingOn:function(attrs) {
  attrs = Ext.Array.from(attrs, true);
  var i = 0, ln = attrs.length;
  for (; i < ln; i++) {
    delete this._customEasings[attrs[i]];
  }
}, applyCustomDurations:function(newDurations, oldDurations) {
  oldDurations = oldDurations || {};
  var any, key, duration, attrs, i, ln;
  for (key in newDurations) {
    any = true;
    duration = newDurations[key];
    attrs = key.split(',');
    for (i = 0, ln = attrs.length; i < ln; i++) {
      oldDurations[attrs[i]] = duration;
    }
  }
  if (any) {
    this.anySpecialAnimations = any;
  }
  return oldDurations;
}, applyCustomDuration:function(newDuration, oldDuration) {
  if (newDuration) {
    this.getCustomDurations();
    this.setCustomDurations(newDuration);
    Ext.log.warn("'customDuration' config is deprecated. Use 'customDurations' config instead.");
  }
}, setDurationOn:function(attrs, duration) {
  attrs = Ext.Array.from(attrs).slice();
  var customDurations = {}, i = 0, ln = attrs.length;
  for (; i < ln; i++) {
    customDurations[attrs[i]] = duration;
  }
  this.setCustomDurations(customDurations);
}, clearDurationOn:function(attrs) {
  attrs = Ext.Array.from(attrs, true);
  var i = 0, ln = attrs.length;
  for (; i < ln; i++) {
    delete this._customDurations[attrs[i]];
  }
}, setAnimating:function(attr, animating) {
  var me = this, pool = me.animatingPool;
  if (attr.animating !== animating) {
    attr.animating = animating;
    if (animating) {
      pool.push(attr);
      if (me.animating === 0) {
        Ext.draw.Animator.add(me);
      }
      me.animating++;
    } else {
      for (var i = pool.length; i--;) {
        if (pool[i] === attr) {
          pool.splice(i, 1);
        }
      }
      me.animating = pool.length;
    }
  }
}, setAttrs:function(attr, changes) {
  var me = this, timers = attr.timers, parsers = me._sprite.self.def._animationProcessors, defaultEasing = me._easing, defaultDuration = me._duration, customDurations = me._customDurations, customEasings = me._customEasings, anySpecial = me.anySpecialAnimations, any = me.anyAnimation || anySpecial, animationOriginal = attr.animationOriginal, ignite = false, timer, name, newValue, startValue, parser, easing, duration;
  if (!any) {
    for (name in changes) {
      if (attr[name] === changes[name]) {
        delete changes[name];
      } else {
        attr[name] = changes[name];
      }
      delete animationOriginal[name];
      delete timers[name];
    }
    return changes;
  } else {
    for (name in changes) {
      newValue = changes[name];
      startValue = attr[name];
      if (newValue !== startValue && startValue !== undefined && startValue !== null && (parser = parsers[name])) {
        easing = defaultEasing;
        duration = defaultDuration;
        if (anySpecial) {
          if (name in customEasings) {
            easing = customEasings[name];
          }
          if (name in customDurations) {
            duration = customDurations[name];
          }
        }
        if (startValue && startValue.isGradient || newValue && newValue.isGradient) {
          duration = 0;
        }
        if (duration) {
          if (!timers[name]) {
            timers[name] = {};
          }
          timer = timers[name];
          timer.start = 0;
          timer.easing = easing;
          timer.duration = duration;
          timer.compute = parser.compute;
          timer.serve = parser.serve || Ext.identityFn;
          timer.remove = changes.removeFromInstance && changes.removeFromInstance[name];
          if (parser.parseInitial) {
            var initial = parser.parseInitial(startValue, newValue);
            timer.source = initial[0];
            timer.target = initial[1];
          } else {
            if (parser.parse) {
              timer.source = parser.parse(startValue);
              timer.target = parser.parse(newValue);
            } else {
              timer.source = startValue;
              timer.target = newValue;
            }
          }
          animationOriginal[name] = newValue;
          delete changes[name];
          ignite = true;
          continue;
        } else {
          delete animationOriginal[name];
        }
      } else {
        delete animationOriginal[name];
      }
      delete timers[name];
    }
  }
  if (ignite && !attr.animating) {
    me.setAnimating(attr, true);
  }
  return changes;
}, updateAttributes:function(attr) {
  if (!attr.animating) {
    return {};
  }
  var changes = {}, any = false, timers = attr.timers, animationOriginal = attr.animationOriginal, now = Ext.draw.Animator.animationTime(), name, timer, delta;
  if (attr.lastUpdate === now) {
    return null;
  }
  for (name in timers) {
    timer = timers[name];
    if (!timer.start) {
      timer.start = now;
      delta = 0;
    } else {
      delta = (now - timer.start) / timer.duration;
    }
    if (delta >= 1) {
      changes[name] = animationOriginal[name];
      delete animationOriginal[name];
      if (timers[name].remove) {
        changes.removeFromInstance = changes.removeFromInstance || {};
        changes.removeFromInstance[name] = true;
      }
      delete timers[name];
    } else {
      changes[name] = timer.serve(timer.compute(timer.source, timer.target, timer.easing(delta), attr[name]));
      any = true;
    }
  }
  attr.lastUpdate = now;
  this.setAnimating(attr, any);
  return changes;
}, pushDown:function(attr, changes) {
  changes = this.callParent([attr.animationOriginal, changes]);
  return this.setAttrs(attr, changes);
}, popUp:function(attr, changes) {
  attr = attr.prototype;
  changes = this.setAttrs(attr, changes);
  if (this._next) {
    return this._next.popUp(attr, changes);
  } else {
    return Ext.apply(attr, changes);
  }
}, step:function(frameTime) {
  var me = this, pool = me.animatingPool.slice(), ln = pool.length, i = 0, attr, changes;
  for (; i < ln; i++) {
    attr = pool[i];
    changes = me.updateAttributes(attr);
    if (changes && me._next) {
      me._next.popUp(attr, changes);
    }
  }
}, stop:function() {
  this.step();
  var me = this, pool = me.animatingPool, i, ln;
  for (i = 0, ln = pool.length; i < ln; i++) {
    pool[i].animating = false;
  }
  me.animatingPool.length = 0;
  me.animating = 0;
  Ext.draw.Animator.remove(me);
}, destroy:function() {
  this.animatingPool.length = 0;
  this.animating = 0;
  this.callParent();
}});
Ext.define('Ext.draw.modifier.Highlight', {extend:Ext.draw.modifier.Modifier, alias:'modifier.highlight', config:{enabled:false, highlightStyle:null}, preFx:true, applyHighlightStyle:function(style, oldStyle) {
  oldStyle = oldStyle || {};
  if (this.getSprite()) {
    Ext.apply(oldStyle, this.getSprite().self.def.normalize(style));
  } else {
    Ext.apply(oldStyle, style);
  }
  return oldStyle;
}, prepareAttributes:function(attr) {
  if (!attr.hasOwnProperty('highlightOriginal')) {
    attr.highlighted = false;
    attr.highlightOriginal = Ext.Object.chain(attr);
    attr.highlightOriginal.prototype = attr;
    attr.highlightOriginal.removeFromInstance = {};
  }
  if (this._previous) {
    this._previous.prepareAttributes(attr.highlightOriginal);
  }
}, updateSprite:function(sprite, oldSprite) {
  if (sprite) {
    if (this.getHighlightStyle()) {
      this._highlightStyle = sprite.self.def.normalize(this.getHighlightStyle());
    }
    this.setHighlightStyle(sprite.config.highlight);
  }
  sprite.self.def.setConfig({defaults:{highlighted:false}, processors:{highlighted:'bool'}});
  this.setSprite(sprite);
}, filterChanges:function(attr, changes) {
  var me = this, highlightOriginal = attr.highlightOriginal, style = me.getHighlightStyle(), name;
  if (attr.highlighted) {
    for (name in changes) {
      if (style.hasOwnProperty(name)) {
        highlightOriginal[name] = changes[name];
        delete changes[name];
      }
    }
  }
  for (name in changes) {
    if (name !== 'highlighted' && highlightOriginal[name] === changes[name]) {
      delete changes[name];
    }
  }
  return changes;
}, pushDown:function(attr, changes) {
  var highlightStyle = this.getHighlightStyle(), highlightOriginal = attr.highlightOriginal, removeFromInstance = highlightOriginal.removeFromInstance, highlighted, name, tplAttr, timer;
  if (changes.hasOwnProperty('highlighted')) {
    highlighted = changes.highlighted;
    delete changes.highlighted;
    if (this._previous) {
      changes = this._previous.pushDown(highlightOriginal, changes);
    }
    changes = this.filterChanges(attr, changes);
    if (highlighted !== attr.highlighted) {
      if (highlighted) {
        for (name in highlightStyle) {
          if (name in changes) {
            highlightOriginal[name] = changes[name];
          } else {
            tplAttr = attr.template && attr.template.ownAttr;
            if (tplAttr && !attr.prototype.hasOwnProperty(name)) {
              removeFromInstance[name] = true;
              highlightOriginal[name] = tplAttr.animationOriginal[name];
            } else {
              timer = highlightOriginal.timers[name];
              if (timer && timer.remove) {
                removeFromInstance[name] = true;
              }
              highlightOriginal[name] = attr[name];
            }
          }
          if (highlightOriginal[name] !== highlightStyle[name]) {
            changes[name] = highlightStyle[name];
          }
        }
      } else {
        for (name in highlightStyle) {
          if (!(name in changes)) {
            changes[name] = highlightOriginal[name];
          }
          delete highlightOriginal[name];
        }
        changes.removeFromInstance = changes.removeFromInstance || {};
        Ext.apply(changes.removeFromInstance, removeFromInstance);
        highlightOriginal.removeFromInstance = {};
      }
      changes.highlighted = highlighted;
    }
  } else {
    if (this._previous) {
      changes = this._previous.pushDown(highlightOriginal, changes);
    }
    changes = this.filterChanges(attr, changes);
  }
  return changes;
}, popUp:function(attr, changes) {
  changes = this.filterChanges(attr, changes);
  Ext.draw.modifier.Modifier.prototype.popUp.call(this, attr, changes);
}});
Ext.define('Ext.draw.sprite.Sprite', {alias:'sprite.sprite', mixins:{observable:Ext.mixin.Observable}, isSprite:true, statics:{defaultHitTestOptions:{fill:true, stroke:true}, debug:false}, inheritableStatics:{def:{processors:{debug:'default', strokeStyle:'color', fillStyle:'color', strokeOpacity:'limited01', fillOpacity:'limited01', lineWidth:'number', lineCap:'enums(butt,round,square)', lineJoin:'enums(round,bevel,miter)', lineDash:'data', lineDashOffset:'number', miterLimit:'number', shadowColor:'color', 
shadowOffsetX:'number', shadowOffsetY:'number', shadowBlur:'number', globalAlpha:'limited01', globalCompositeOperation:'enums(source-over,destination-over,source-in,destination-in,source-out,destination-out,source-atop,destination-atop,lighter,xor,copy)', hidden:'bool', transformFillStroke:'bool', zIndex:'number', translationX:'number', translationY:'number', rotationRads:'number', rotationCenterX:'number', rotationCenterY:'number', scalingX:'number', scalingY:'number', scalingCenterX:'number', scalingCenterY:'number', 
constrainGradients:'bool'}, aliases:{'stroke':'strokeStyle', 'fill':'fillStyle', 'color':'fillStyle', 'stroke-width':'lineWidth', 'stroke-linecap':'lineCap', 'stroke-linejoin':'lineJoin', 'stroke-miterlimit':'miterLimit', 'text-anchor':'textAlign', 'opacity':'globalAlpha', translateX:'translationX', translateY:'translationY', rotateRads:'rotationRads', rotateCenterX:'rotationCenterX', rotateCenterY:'rotationCenterY', scaleX:'scalingX', scaleY:'scalingY', scaleCenterX:'scalingCenterX', scaleCenterY:'scalingCenterY'}, 
defaults:{hidden:false, zIndex:0, strokeStyle:'none', fillStyle:'none', lineWidth:1, lineDash:[], lineDashOffset:0, lineCap:'butt', lineJoin:'miter', miterLimit:10, shadowColor:'none', shadowOffsetX:0, shadowOffsetY:0, shadowBlur:0, globalAlpha:1, strokeOpacity:1, fillOpacity:1, transformFillStroke:false, translationX:0, translationY:0, rotationRads:0, rotationCenterX:null, rotationCenterY:null, scalingX:1, scalingY:1, scalingCenterX:null, scalingCenterY:null, constrainGradients:false}, triggers:{zIndex:'zIndex', 
globalAlpha:'canvas', globalCompositeOperation:'canvas', transformFillStroke:'canvas', strokeStyle:'canvas', fillStyle:'canvas', strokeOpacity:'canvas', fillOpacity:'canvas', lineWidth:'canvas', lineCap:'canvas', lineJoin:'canvas', lineDash:'canvas', lineDashOffset:'canvas', miterLimit:'canvas', shadowColor:'canvas', shadowOffsetX:'canvas', shadowOffsetY:'canvas', shadowBlur:'canvas', translationX:'transform', translationY:'transform', rotationRads:'transform', rotationCenterX:'transform', rotationCenterY:'transform', 
scalingX:'transform', scalingY:'transform', scalingCenterX:'transform', scalingCenterY:'transform', constrainGradients:'canvas'}, updaters:{bbox:'bboxUpdater', zIndex:function(attr) {
  attr.dirtyZIndex = true;
}, transform:function(attr) {
  attr.dirtyTransform = true;
  attr.bbox.transform.dirty = true;
}}}}, config:{parent:null, surface:null}, onClassExtended:function(subClass, data) {
  var superclassCfg = subClass.superclass.self.def.initialConfig, ownCfg = data.inheritableStatics && data.inheritableStatics.def, cfg;
  if (ownCfg) {
    cfg = Ext.Object.merge({}, superclassCfg, ownCfg);
    subClass.def = new Ext.draw.sprite.AttributeDefinition(cfg);
    delete data.inheritableStatics.def;
  } else {
    subClass.def = new Ext.draw.sprite.AttributeDefinition(superclassCfg);
  }
  subClass.def.spriteClass = subClass;
}, constructor:function(config) {
  if (Ext.getClassName(this) === 'Ext.draw.sprite.Sprite') {
    throw 'Ext.draw.sprite.Sprite is an abstract class';
  }
  var me = this, attributeDefinition = me.self.def, defaults = attributeDefinition.getDefaults(), modifiers;
  config = Ext.isObject(config) ? config : {};
  me.id = config.id || Ext.id(null, 'ext-sprite-');
  me.attr = {};
  me.mixins.observable.constructor.apply(me, arguments);
  modifiers = Ext.Array.from(config.modifiers, true);
  me.prepareModifiers(modifiers);
  me.initializeAttributes();
  me.setAttributes(defaults, true);
  var processors = attributeDefinition.getProcessors();
  for (var name in config) {
    if (name in processors && me['get' + name.charAt(0).toUpperCase() + name.substr(1)]) {
      Ext.raise('The ' + me.$className + ' sprite has both a config and an attribute with the same name: ' + name + '.');
    }
  }
  me.setAttributes(config);
}, getDirty:function() {
  return this.attr.dirty;
}, setDirty:function(dirty) {
  this.attr.dirty = dirty;
  if (dirty) {
    var parent = this.getParent();
    if (parent) {
      parent.setDirty(true);
    }
  }
}, addModifier:function(modifier, reinitializeAttributes) {
  var me = this;
  if (!(modifier instanceof Ext.draw.modifier.Modifier)) {
    modifier = Ext.factory(modifier, null, null, 'modifier');
  }
  modifier.setSprite(me);
  if (modifier.preFx || modifier.config && modifier.config.preFx) {
    if (me.fx.getPrevious()) {
      me.fx.getPrevious().setNext(modifier);
    }
    modifier.setNext(me.fx);
  } else {
    me.topModifier.getPrevious().setNext(modifier);
    modifier.setNext(me.topModifier);
  }
  if (reinitializeAttributes) {
    me.initializeAttributes();
  }
  return modifier;
}, prepareModifiers:function(additionalModifiers) {
  var me = this, i, ln;
  me.topModifier = new Ext.draw.modifier.Target({sprite:me});
  me.fx = new Ext.draw.modifier.Animation({sprite:me});
  me.fx.setNext(me.topModifier);
  for (i = 0, ln = additionalModifiers.length; i < ln; i++) {
    me.addModifier(additionalModifiers[i], false);
  }
}, getAnimation:function() {
  return this.fx;
}, setAnimation:function(config) {
  this.fx.setConfig(config);
}, initializeAttributes:function() {
  this.topModifier.prepareAttributes(this.attr);
}, callUpdaters:function(attr) {
  var me = this, pendingUpdaters = attr.pendingUpdaters, updaters = me.self.def.getUpdaters(), any = false, dirty = false, flags, updater, fn;
  me.callUpdaters = Ext.emptyFn;
  do {
    any = false;
    for (updater in pendingUpdaters) {
      any = true;
      flags = pendingUpdaters[updater];
      delete pendingUpdaters[updater];
      fn = updaters[updater];
      if (typeof fn === 'string') {
        fn = me[fn];
      }
      if (fn) {
        fn.call(me, attr, flags);
      }
    }
    dirty = dirty || any;
  } while (any);
  delete me.callUpdaters;
  if (dirty) {
    me.setDirty(true);
  }
}, scheduleUpdaters:function(attr, updaters, triggers) {
  var updater;
  if (triggers) {
    for (var i = 0, ln = updaters.length; i < ln; i++) {
      updater = updaters[i];
      this.scheduleUpdater(attr, updater, triggers);
    }
  } else {
    for (updater in updaters) {
      triggers = updaters[updater];
      this.scheduleUpdater(attr, updater, triggers);
    }
  }
}, scheduleUpdater:function(attr, updater, triggers) {
  triggers = triggers || [];
  var pendingUpdaters = attr.pendingUpdaters;
  if (updater in pendingUpdaters) {
    if (triggers.length) {
      pendingUpdaters[updater] = Ext.Array.merge(pendingUpdaters[updater], triggers);
    }
  } else {
    pendingUpdaters[updater] = triggers;
  }
}, setAttributes:function(changes, bypassNormalization, avoidCopy) {
  var attr = this.attr, name, value, obj;
  if (bypassNormalization) {
    if (avoidCopy) {
      this.topModifier.pushDown(attr, changes);
    } else {
      obj = {};
      for (name in changes) {
        value = changes[name];
        if (value !== attr[name]) {
          obj[name] = value;
        }
      }
      this.topModifier.pushDown(attr, obj);
    }
  } else {
    this.topModifier.pushDown(attr, this.self.def.normalize(changes));
  }
}, setAttributesBypassingNormalization:function(changes, avoidCopy) {
  return this.setAttributes(changes, true, avoidCopy);
}, bboxUpdater:function(attr) {
  var hasRotation = attr.rotationRads !== 0, hasScaling = attr.scalingX !== 1 || attr.scalingY !== 1, noRotationCenter = attr.rotationCenterX === null || attr.rotationCenterY === null, noScalingCenter = attr.scalingCenterX === null || attr.scalingCenterY === null;
  attr.bbox.plain.dirty = true;
  attr.bbox.transform.dirty = true;
  if (hasRotation && noRotationCenter || hasScaling && noScalingCenter) {
    this.scheduleUpdater(attr, 'transform');
  }
}, getBBox:function(isWithoutTransform) {
  var me = this, attr = me.attr, bbox = attr.bbox, plain = bbox.plain, transform = bbox.transform;
  if (plain.dirty) {
    me.updatePlainBBox(plain);
    plain.dirty = false;
  }
  if (!isWithoutTransform) {
    me.applyTransformations();
    if (transform.dirty) {
      me.updateTransformedBBox(transform, plain);
      transform.dirty = false;
    }
    return transform;
  }
  return plain;
}, updatePlainBBox:Ext.emptyFn, updateTransformedBBox:function(transform, plain) {
  this.attr.matrix.transformBBox(plain, 0, transform);
}, getBBoxCenter:function(isWithoutTransform) {
  var bbox = this.getBBox(isWithoutTransform);
  if (bbox) {
    return [bbox.x + bbox.width * 0.5, bbox.y + bbox.height * 0.5];
  } else {
    return [0, 0];
  }
}, hide:function() {
  this.attr.hidden = true;
  this.setDirty(true);
  return this;
}, show:function() {
  this.attr.hidden = false;
  this.setDirty(true);
  return this;
}, useAttributes:function(ctx, rect) {
  this.applyTransformations();
  var attr = this.attr, canvasAttributes = attr.canvasAttributes, strokeStyle = canvasAttributes.strokeStyle, fillStyle = canvasAttributes.fillStyle, lineDash = canvasAttributes.lineDash, lineDashOffset = canvasAttributes.lineDashOffset, id;
  if (strokeStyle) {
    if (strokeStyle.isGradient) {
      ctx.strokeStyle = 'black';
      ctx.strokeGradient = strokeStyle;
    } else {
      ctx.strokeGradient = false;
    }
  }
  if (fillStyle) {
    if (fillStyle.isGradient) {
      ctx.fillStyle = 'black';
      ctx.fillGradient = fillStyle;
    } else {
      ctx.fillGradient = false;
    }
  }
  if (lineDash) {
    ctx.setLineDash(lineDash);
  }
  if (Ext.isNumber(lineDashOffset + ctx.lineDashOffset)) {
    ctx.lineDashOffset = lineDashOffset;
  }
  for (id in canvasAttributes) {
    if (canvasAttributes[id] !== undefined && canvasAttributes[id] !== ctx[id]) {
      ctx[id] = canvasAttributes[id];
    }
  }
  this.setGradientBBox(ctx, rect);
}, setGradientBBox:function(ctx, rect) {
  var attr = this.attr;
  if (attr.constrainGradients) {
    ctx.setGradientBBox({x:rect[0], y:rect[1], width:rect[2], height:rect[3]});
  } else {
    ctx.setGradientBBox(this.getBBox(attr.transformFillStroke));
  }
}, applyTransformations:function(force) {
  if (!force && !this.attr.dirtyTransform) {
    return;
  }
  var me = this, attr = me.attr, center = me.getBBoxCenter(true), centerX = center[0], centerY = center[1], tx = attr.translationX, ty = attr.translationY, sx = attr.scalingX, sy = attr.scalingY === null ? attr.scalingX : attr.scalingY, scx = attr.scalingCenterX === null ? centerX : attr.scalingCenterX, scy = attr.scalingCenterY === null ? centerY : attr.scalingCenterY, rad = attr.rotationRads, rcx = attr.rotationCenterX === null ? centerX : attr.rotationCenterX, rcy = attr.rotationCenterY === null ? 
  centerY : attr.rotationCenterY, cos = Math.cos(rad), sin = Math.sin(rad), tx_4, ty_4;
  if (sx === 1 && sy === 1) {
    scx = 0;
    scy = 0;
  }
  if (rad === 0) {
    rcx = 0;
    rcy = 0;
  }
  tx_4 = scx * (1 - sx) - rcx;
  ty_4 = scy * (1 - sy) - rcy;
  attr.matrix.elements = [cos * sx, sin * sx, -sin * sy, cos * sy, cos * tx_4 - sin * ty_4 + rcx + tx, sin * tx_4 + cos * ty_4 + rcy + ty];
  attr.matrix.inverse(attr.inverseMatrix);
  attr.dirtyTransform = false;
  attr.bbox.transform.dirty = true;
}, transform:function(matrix, isSplit) {
  var attr = this.attr, spriteMatrix = attr.matrix, elements;
  if (matrix && matrix.isMatrix) {
    elements = matrix.elements;
  } else {
    elements = matrix;
  }
  if (!(Ext.isArray(elements) && elements.length === 6)) {
    Ext.raise('An instance of Ext.draw.Matrix or an array of 6 numbers is expected.');
  }
  spriteMatrix.prepend.apply(spriteMatrix, elements.slice());
  spriteMatrix.inverse(attr.inverseMatrix);
  if (isSplit) {
    this.updateTransformAttributes();
  }
  attr.dirtyTransform = false;
  attr.bbox.transform.dirty = true;
  this.setDirty(true);
  return this;
}, updateTransformAttributes:function() {
  var attr = this.attr, split = attr.matrix.split();
  attr.rotationRads = split.rotate;
  attr.rotationCenterX = 0;
  attr.rotationCenterY = 0;
  attr.scalingX = split.scaleX;
  attr.scalingY = split.scaleY;
  attr.scalingCenterX = 0;
  attr.scalingCenterY = 0;
  attr.translationX = split.translateX;
  attr.translationY = split.translateY;
}, resetTransform:function(isSplit) {
  var attr = this.attr;
  attr.matrix.reset();
  attr.inverseMatrix.reset();
  if (!isSplit) {
    this.updateTransformAttributes();
  }
  attr.dirtyTransform = false;
  attr.bbox.transform.dirty = true;
  this.setDirty(true);
  return this;
}, setTransform:function(matrix, isSplit) {
  this.resetTransform(true);
  this.transform.call(this, matrix, isSplit);
  return this;
}, preRender:Ext.emptyFn, render:Ext.emptyFn, renderBBox:function(surface, ctx) {
  var bbox = this.getBBox();
  ctx.beginPath();
  ctx.moveTo(bbox.x, bbox.y);
  ctx.lineTo(bbox.x + bbox.width, bbox.y);
  ctx.lineTo(bbox.x + bbox.width, bbox.y + bbox.height);
  ctx.lineTo(bbox.x, bbox.y + bbox.height);
  ctx.closePath();
  ctx.strokeStyle = 'red';
  ctx.strokeOpacity = 1;
  ctx.lineWidth = 0.5;
  ctx.stroke();
}, hitTest:function(point, options) {
  if (this.isVisible()) {
    var x = point[0], y = point[1], bbox = this.getBBox(), isBBoxHit = bbox && x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;
    if (isBBoxHit) {
      return {sprite:this};
    }
  }
  return null;
}, isVisible:function() {
  var attr = this.attr, parent = this.getParent(), hasParent = parent && (parent.isSurface || parent.isVisible()), isSeen = hasParent && !attr.hidden && attr.globalAlpha, none1 = Ext.draw.Color.NONE, none2 = Ext.draw.Color.RGBA_NONE, hasFill = attr.fillOpacity && attr.fillStyle !== none1 && attr.fillStyle !== none2, hasStroke = attr.strokeOpacity && attr.strokeStyle !== none1 && attr.strokeStyle !== none2, result = isSeen && (hasFill || hasStroke);
  return !!result;
}, repaint:function() {
  var surface = this.getSurface();
  if (surface) {
    surface.renderFrame();
  }
}, remove:function() {
  var surface = this.getSurface();
  if (surface && surface.isSurface) {
    return surface.remove(this);
  }
  return null;
}, destroy:function() {
  var me = this, modifier = me.topModifier, currentModifier;
  while (modifier) {
    currentModifier = modifier;
    modifier = modifier.getPrevious();
    currentModifier.destroy();
  }
  delete me.attr;
  me.remove();
  if (me.fireEvent('beforedestroy', me) !== false) {
    me.fireEvent('destroy', me);
  }
  me.callParent();
}}, function() {
  this.def = new Ext.draw.sprite.AttributeDefinition(this.def);
  this.def.spriteClass = this;
});
Ext.define('Ext.draw.Path', {statics:{pathRe:/,?([achlmqrstvxz]),?/gi, pathRe2:/-/gi, pathSplitRe:/\s|,/g}, svgString:'', constructor:function(pathString) {
  var me = this;
  me.commands = [];
  me.params = [];
  me.cursor = null;
  me.startX = 0;
  me.startY = 0;
  if (pathString) {
    me.fromSvgString(pathString);
  }
}, clear:function() {
  var me = this;
  me.params.length = 0;
  me.commands.length = 0;
  me.cursor = null;
  me.startX = 0;
  me.startY = 0;
  me.dirt();
}, dirt:function() {
  this.svgString = '';
}, moveTo:function(x, y) {
  var me = this;
  if (!me.cursor) {
    me.cursor = [x, y];
  }
  me.params.push(x, y);
  me.commands.push('M');
  me.startX = x;
  me.startY = y;
  me.cursor[0] = x;
  me.cursor[1] = y;
  me.dirt();
}, lineTo:function(x, y) {
  var me = this;
  if (!me.cursor) {
    me.cursor = [x, y];
    me.params.push(x, y);
    me.commands.push('M');
  } else {
    me.params.push(x, y);
    me.commands.push('L');
  }
  me.cursor[0] = x;
  me.cursor[1] = y;
  me.dirt();
}, bezierCurveTo:function(cx1, cy1, cx2, cy2, x, y) {
  var me = this;
  if (!me.cursor) {
    me.moveTo(cx1, cy1);
  }
  me.params.push(cx1, cy1, cx2, cy2, x, y);
  me.commands.push('C');
  me.cursor[0] = x;
  me.cursor[1] = y;
  me.dirt();
}, quadraticCurveTo:function(cx, cy, x, y) {
  var me = this;
  if (!me.cursor) {
    me.moveTo(cx, cy);
  }
  me.bezierCurveTo((2 * cx + me.cursor[0]) / 3, (2 * cy + me.cursor[1]) / 3, (2 * cx + x) / 3, (2 * cy + y) / 3, x, y);
}, closePath:function() {
  var me = this;
  if (me.cursor) {
    me.cursor = null;
    me.commands.push('Z');
    me.dirt();
  }
}, arcTo:function(x1, y1, x2, y2, rx, ry, rotation) {
  var me = this;
  if (ry === undefined) {
    ry = rx;
  }
  if (rotation === undefined) {
    rotation = 0;
  }
  if (!me.cursor) {
    me.moveTo(x1, y1);
    return;
  }
  if (rx === 0 || ry === 0) {
    me.lineTo(x1, y1);
    return;
  }
  x2 -= x1;
  y2 -= y1;
  var x0 = me.cursor[0] - x1, y0 = me.cursor[1] - y1, area = x2 * y0 - y2 * x0, cos, sin, xx, yx, xy, yy, l0 = Math.sqrt(x0 * x0 + y0 * y0), l2 = Math.sqrt(x2 * x2 + y2 * y2), dist, cx, cy;
  if (area === 0) {
    me.lineTo(x1, y1);
    return;
  }
  if (ry !== rx) {
    cos = Math.cos(rotation);
    sin = Math.sin(rotation);
    xx = cos / rx;
    yx = sin / ry;
    xy = -sin / rx;
    yy = cos / ry;
    var temp = xx * x0 + yx * y0;
    y0 = xy * x0 + yy * y0;
    x0 = temp;
    temp = xx * x2 + yx * y2;
    y2 = xy * x2 + yy * y2;
    x2 = temp;
  } else {
    x0 /= rx;
    y0 /= ry;
    x2 /= rx;
    y2 /= ry;
  }
  cx = x0 * l2 + x2 * l0;
  cy = y0 * l2 + y2 * l0;
  dist = 1 / (Math.sin(Math.asin(Math.abs(area) / (l0 * l2)) * 0.5) * Math.sqrt(cx * cx + cy * cy));
  cx *= dist;
  cy *= dist;
  var k0 = (cx * x0 + cy * y0) / (x0 * x0 + y0 * y0), k2 = (cx * x2 + cy * y2) / (x2 * x2 + y2 * y2);
  var cosStart = x0 * k0 - cx, sinStart = y0 * k0 - cy, cosEnd = x2 * k2 - cx, sinEnd = y2 * k2 - cy, startAngle = Math.atan2(sinStart, cosStart), endAngle = Math.atan2(sinEnd, cosEnd);
  if (area > 0) {
    if (endAngle < startAngle) {
      endAngle += Math.PI * 2;
    }
  } else {
    if (startAngle < endAngle) {
      startAngle += Math.PI * 2;
    }
  }
  if (ry !== rx) {
    cx = cos * cx * rx - sin * cy * ry + x1;
    cy = sin * cy * ry + cos * cy * ry + y1;
    me.lineTo(cos * rx * cosStart - sin * ry * sinStart + cx, sin * rx * cosStart + cos * ry * sinStart + cy);
    me.ellipse(cx, cy, rx, ry, rotation, startAngle, endAngle, area < 0);
  } else {
    cx = cx * rx + x1;
    cy = cy * ry + y1;
    me.lineTo(rx * cosStart + cx, ry * sinStart + cy);
    me.ellipse(cx, cy, rx, ry, rotation, startAngle, endAngle, area < 0);
  }
}, ellipse:function(cx, cy, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
  var me = this, params = me.params, start = params.length, count, i, j;
  if (endAngle - startAngle >= Math.PI * 2) {
    me.ellipse(cx, cy, radiusX, radiusY, rotation, startAngle, startAngle + Math.PI, anticlockwise);
    me.ellipse(cx, cy, radiusX, radiusY, rotation, startAngle + Math.PI, endAngle, anticlockwise);
    return;
  }
  if (!anticlockwise) {
    if (endAngle < startAngle) {
      endAngle += Math.PI * 2;
    }
    count = me.approximateArc(params, cx, cy, radiusX, radiusY, rotation, startAngle, endAngle);
  } else {
    if (startAngle < endAngle) {
      startAngle += Math.PI * 2;
    }
    count = me.approximateArc(params, cx, cy, radiusX, radiusY, rotation, endAngle, startAngle);
    for (i = start, j = params.length - 2; i < j; i += 2, j -= 2) {
      var temp = params[i];
      params[i] = params[j];
      params[j] = temp;
      temp = params[i + 1];
      params[i + 1] = params[j + 1];
      params[j + 1] = temp;
    }
  }
  if (!me.cursor) {
    me.cursor = [params[params.length - 2], params[params.length - 1]];
    me.commands.push('M');
  } else {
    me.cursor[0] = params[params.length - 2];
    me.cursor[1] = params[params.length - 1];
    me.commands.push('L');
  }
  for (i = 2; i < count; i += 6) {
    me.commands.push('C');
  }
  me.dirt();
}, arc:function(x, y, radius, startAngle, endAngle, anticlockwise) {
  this.ellipse(x, y, radius, radius, 0, startAngle, endAngle, anticlockwise);
}, rect:function(x, y, width, height) {
  if (width == 0 || height == 0) {
    return;
  }
  var me = this;
  me.moveTo(x, y);
  me.lineTo(x + width, y);
  me.lineTo(x + width, y + height);
  me.lineTo(x, y + height);
  me.closePath();
}, approximateArc:function(result, cx, cy, rx, ry, phi, theta1, theta2) {
  var cosPhi = Math.cos(phi), sinPhi = Math.sin(phi), cosTheta1 = Math.cos(theta1), sinTheta1 = Math.sin(theta1), xx = cosPhi * cosTheta1 * rx - sinPhi * sinTheta1 * ry, yx = -cosPhi * sinTheta1 * rx - sinPhi * cosTheta1 * ry, xy = sinPhi * cosTheta1 * rx + cosPhi * sinTheta1 * ry, yy = -sinPhi * sinTheta1 * rx + cosPhi * cosTheta1 * ry, rightAngle = Math.PI / 2, count = 2, exx = xx, eyx = yx, exy = xy, eyy = yy, rho = 0.547443256150549, temp, y1, x3, y3, x2, y2;
  theta2 -= theta1;
  if (theta2 < 0) {
    theta2 += Math.PI * 2;
  }
  result.push(xx + cx, xy + cy);
  while (theta2 >= rightAngle) {
    result.push(exx + eyx * rho + cx, exy + eyy * rho + cy, exx * rho + eyx + cx, exy * rho + eyy + cy, eyx + cx, eyy + cy);
    count += 6;
    theta2 -= rightAngle;
    temp = exx;
    exx = eyx;
    eyx = -temp;
    temp = exy;
    exy = eyy;
    eyy = -temp;
  }
  if (theta2) {
    y1 = (0.3294738052815987 + 0.012120855841304373 * theta2) * theta2;
    x3 = Math.cos(theta2);
    y3 = Math.sin(theta2);
    x2 = x3 + y1 * y3;
    y2 = y3 - y1 * x3;
    result.push(exx + eyx * y1 + cx, exy + eyy * y1 + cy, exx * x2 + eyx * y2 + cx, exy * x2 + eyy * y2 + cy, exx * x3 + eyx * y3 + cx, exy * x3 + eyy * y3 + cy);
    count += 6;
  }
  return count;
}, arcSvg:function(rx, ry, rotation, fA, fS, x2, y2) {
  if (rx < 0) {
    rx = -rx;
  }
  if (ry < 0) {
    ry = -ry;
  }
  var me = this, x1 = me.cursor[0], y1 = me.cursor[1], hdx = (x1 - x2) / 2, hdy = (y1 - y2) / 2, cosPhi = Math.cos(rotation), sinPhi = Math.sin(rotation), xp = hdx * cosPhi + hdy * sinPhi, yp = -hdx * sinPhi + hdy * cosPhi, ratX = xp / rx, ratY = yp / ry, lambda = ratX * ratX + ratY * ratY, cx = (x1 + x2) * 0.5, cy = (y1 + y2) * 0.5, cpx = 0, cpy = 0;
  if (lambda >= 1) {
    lambda = Math.sqrt(lambda);
    rx *= lambda;
    ry *= lambda;
  } else {
    lambda = Math.sqrt(1 / lambda - 1);
    if (fA === fS) {
      lambda = -lambda;
    }
    cpx = lambda * rx * ratY;
    cpy = -lambda * ry * ratX;
    cx += cosPhi * cpx - sinPhi * cpy;
    cy += sinPhi * cpx + cosPhi * cpy;
  }
  var theta1 = Math.atan2((yp - cpy) / ry, (xp - cpx) / rx), deltaTheta = Math.atan2((-yp - cpy) / ry, (-xp - cpx) / rx) - theta1;
  if (fS) {
    if (deltaTheta <= 0) {
      deltaTheta += Math.PI * 2;
    }
  } else {
    if (deltaTheta >= 0) {
      deltaTheta -= Math.PI * 2;
    }
  }
  me.ellipse(cx, cy, rx, ry, rotation, theta1, theta1 + deltaTheta, 1 - fS);
}, fromSvgString:function(pathString) {
  if (!pathString) {
    return;
  }
  var me = this, parts, paramCounts = {a:7, c:6, h:1, l:2, m:2, q:4, s:4, t:2, v:1, z:0, A:7, C:6, H:1, L:2, M:2, Q:4, S:4, T:2, V:1, Z:0}, lastCommand = '', lastControlX, lastControlY, lastX = 0, lastY = 0, part = false, i, partLength, relative;
  if (Ext.isString(pathString)) {
    parts = pathString.replace(Ext.draw.Path.pathRe, ' $1 ').replace(Ext.draw.Path.pathRe2, ' -').split(Ext.draw.Path.pathSplitRe);
  } else {
    if (Ext.isArray(pathString)) {
      parts = pathString.join(',').split(Ext.draw.Path.pathSplitRe);
    }
  }
  for (i = 0, partLength = 0; i < parts.length; i++) {
    if (parts[i] !== '') {
      parts[partLength++] = parts[i];
    }
  }
  parts.length = partLength;
  me.clear();
  for (i = 0; i < parts.length;) {
    lastCommand = part;
    part = parts[i];
    relative = part.toUpperCase() !== part;
    i++;
    switch(part) {
      case 'M':
        me.moveTo(lastX = +parts[i], lastY = +parts[i + 1]);
        i += 2;
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.lineTo(lastX = +parts[i], lastY = +parts[i + 1]);
          i += 2;
        }
        break;
      case 'L':
        me.lineTo(lastX = +parts[i], lastY = +parts[i + 1]);
        i += 2;
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.lineTo(lastX = +parts[i], lastY = +parts[i + 1]);
          i += 2;
        }
        break;
      case 'A':
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.arcSvg(+parts[i], +parts[i + 1], +parts[i + 2] * Math.PI / 180, +parts[i + 3], +parts[i + 4], lastX = +parts[i + 5], lastY = +parts[i + 6]);
          i += 7;
        }
        break;
      case 'C':
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.bezierCurveTo(+parts[i], +parts[i + 1], lastControlX = +parts[i + 2], lastControlY = +parts[i + 3], lastX = +parts[i + 4], lastY = +parts[i + 5]);
          i += 6;
        }
        break;
      case 'Z':
        me.closePath();
        break;
      case 'm':
        me.moveTo(lastX += +parts[i], lastY += +parts[i + 1]);
        i += 2;
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.lineTo(lastX += +parts[i], lastY += +parts[i + 1]);
          i += 2;
        }
        break;
      case 'l':
        me.lineTo(lastX += +parts[i], lastY += +parts[i + 1]);
        i += 2;
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.lineTo(lastX += +parts[i], lastY += +parts[i + 1]);
          i += 2;
        }
        break;
      case 'a':
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.arcSvg(+parts[i], +parts[i + 1], +parts[i + 2] * Math.PI / 180, +parts[i + 3], +parts[i + 4], lastX += +parts[i + 5], lastY += +parts[i + 6]);
          i += 7;
        }
        break;
      case 'c':
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.bezierCurveTo(lastX + +parts[i], lastY + +parts[i + 1], lastControlX = lastX + +parts[i + 2], lastControlY = lastY + +parts[i + 3], lastX += +parts[i + 4], lastY += +parts[i + 5]);
          i += 6;
        }
        break;
      case 'z':
        me.closePath();
        break;
      case 's':
        if (!(lastCommand === 'c' || lastCommand === 'C' || lastCommand === 's' || lastCommand === 'S')) {
          lastControlX = lastX;
          lastControlY = lastY;
        }
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.bezierCurveTo(lastX + lastX - lastControlX, lastY + lastY - lastControlY, lastControlX = lastX + +parts[i], lastControlY = lastY + +parts[i + 1], lastX += +parts[i + 2], lastY += +parts[i + 3]);
          i += 4;
        }
        break;
      case 'S':
        if (!(lastCommand === 'c' || lastCommand === 'C' || lastCommand === 's' || lastCommand === 'S')) {
          lastControlX = lastX;
          lastControlY = lastY;
        }
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.bezierCurveTo(lastX + lastX - lastControlX, lastY + lastY - lastControlY, lastControlX = +parts[i], lastControlY = +parts[i + 1], lastX = +parts[i + 2], lastY = +parts[i + 3]);
          i += 4;
        }
        break;
      case 'q':
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.quadraticCurveTo(lastControlX = lastX + +parts[i], lastControlY = lastY + +parts[i + 1], lastX += +parts[i + 2], lastY += +parts[i + 3]);
          i += 4;
        }
        break;
      case 'Q':
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.quadraticCurveTo(lastControlX = +parts[i], lastControlY = +parts[i + 1], lastX = +parts[i + 2], lastY = +parts[i + 3]);
          i += 4;
        }
        break;
      case 't':
        if (!(lastCommand === 'q' || lastCommand === 'Q' || lastCommand === 't' || lastCommand === 'T')) {
          lastControlX = lastX;
          lastControlY = lastY;
        }
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.quadraticCurveTo(lastControlX = lastX + lastX - lastControlX, lastControlY = lastY + lastY - lastControlY, lastX += +parts[i + 1], lastY += +parts[i + 2]);
          i += 2;
        }
        break;
      case 'T':
        if (!(lastCommand === 'q' || lastCommand === 'Q' || lastCommand === 't' || lastCommand === 'T')) {
          lastControlX = lastX;
          lastControlY = lastY;
        }
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.quadraticCurveTo(lastControlX = lastX + lastX - lastControlX, lastControlY = lastY + lastY - lastControlY, lastX = +parts[i + 1], lastY = +parts[i + 2]);
          i += 2;
        }
        break;
      case 'h':
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.lineTo(lastX += +parts[i], lastY);
          i++;
        }
        break;
      case 'H':
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.lineTo(lastX = +parts[i], lastY);
          i++;
        }
        break;
      case 'v':
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.lineTo(lastX, lastY += +parts[i]);
          i++;
        }
        break;
      case 'V':
        while (i < partLength && !paramCounts.hasOwnProperty(parts[i])) {
          me.lineTo(lastX, lastY = +parts[i]);
          i++;
        }
        break;
    }
  }
}, clone:function() {
  var me = this, path = new Ext.draw.Path;
  path.params = me.params.slice(0);
  path.commands = me.commands.slice(0);
  path.cursor = me.cursor ? me.cursor.slice(0) : null;
  path.startX = me.startX;
  path.startY = me.startY;
  path.svgString = me.svgString;
  return path;
}, transform:function(matrix) {
  if (matrix.isIdentity()) {
    return;
  }
  var xx = matrix.getXX(), yx = matrix.getYX(), dx = matrix.getDX(), xy = matrix.getXY(), yy = matrix.getYY(), dy = matrix.getDY(), params = this.params, i = 0, ln = params.length, x, y;
  for (; i < ln; i += 2) {
    x = params[i];
    y = params[i + 1];
    params[i] = x * xx + y * yx + dx;
    params[i + 1] = x * xy + y * yy + dy;
  }
  this.dirt();
}, getDimension:function(target) {
  if (!target) {
    target = {};
  }
  if (!this.commands || !this.commands.length) {
    target.x = 0;
    target.y = 0;
    target.width = 0;
    target.height = 0;
    return target;
  }
  target.left = Infinity;
  target.top = Infinity;
  target.right = -Infinity;
  target.bottom = -Infinity;
  var i = 0, j = 0, commands = this.commands, params = this.params, ln = commands.length, x, y;
  for (; i < ln; i++) {
    switch(commands[i]) {
      case 'M':
      case 'L':
        x = params[j];
        y = params[j + 1];
        target.left = Math.min(x, target.left);
        target.top = Math.min(y, target.top);
        target.right = Math.max(x, target.right);
        target.bottom = Math.max(y, target.bottom);
        j += 2;
        break;
      case 'C':
        this.expandDimension(target, x, y, params[j], params[j + 1], params[j + 2], params[j + 3], x = params[j + 4], y = params[j + 5]);
        j += 6;
        break;
    }
  }
  target.x = target.left;
  target.y = target.top;
  target.width = target.right - target.left;
  target.height = target.bottom - target.top;
  return target;
}, getDimensionWithTransform:function(matrix, target) {
  if (!this.commands || !this.commands.length) {
    if (!target) {
      target = {};
    }
    target.x = 0;
    target.y = 0;
    target.width = 0;
    target.height = 0;
    return target;
  }
  target.left = Infinity;
  target.top = Infinity;
  target.right = -Infinity;
  target.bottom = -Infinity;
  var xx = matrix.getXX(), yx = matrix.getYX(), dx = matrix.getDX(), xy = matrix.getXY(), yy = matrix.getYY(), dy = matrix.getDY(), i = 0, j = 0, commands = this.commands, params = this.params, ln = commands.length, x, y;
  for (; i < ln; i++) {
    switch(commands[i]) {
      case 'M':
      case 'L':
        x = params[j] * xx + params[j + 1] * yx + dx;
        y = params[j] * xy + params[j + 1] * yy + dy;
        target.left = Math.min(x, target.left);
        target.top = Math.min(y, target.top);
        target.right = Math.max(x, target.right);
        target.bottom = Math.max(y, target.bottom);
        j += 2;
        break;
      case 'C':
        this.expandDimension(target, x, y, params[j] * xx + params[j + 1] * yx + dx, params[j] * xy + params[j + 1] * yy + dy, params[j + 2] * xx + params[j + 3] * yx + dx, params[j + 2] * xy + params[j + 3] * yy + dy, x = params[j + 4] * xx + params[j + 5] * yx + dx, y = params[j + 4] * xy + params[j + 5] * yy + dy);
        j += 6;
        break;
    }
  }
  if (!target) {
    target = {};
  }
  target.x = target.left;
  target.y = target.top;
  target.width = target.right - target.left;
  target.height = target.bottom - target.top;
  return target;
}, expandDimension:function(target, x1, y1, cx1, cy1, cx2, cy2, x2, y2) {
  var me = this, l = target.left, r = target.right, t = target.top, b = target.bottom, dim = me.dim || (me.dim = []);
  me.curveDimension(x1, cx1, cx2, x2, dim);
  l = Math.min(l, dim[0]);
  r = Math.max(r, dim[1]);
  me.curveDimension(y1, cy1, cy2, y2, dim);
  t = Math.min(t, dim[0]);
  b = Math.max(b, dim[1]);
  target.left = l;
  target.right = r;
  target.top = t;
  target.bottom = b;
}, curveDimension:function(a, b, c, d, dim) {
  var qa = 3 * (-a + 3 * (b - c) + d), qb = 6 * (a - 2 * b + c), qc = -3 * (a - b), x, y, min = Math.min(a, d), max = Math.max(a, d), delta;
  if (qa === 0) {
    if (qb === 0) {
      dim[0] = min;
      dim[1] = max;
      return;
    } else {
      x = -qc / qb;
      if (0 < x && x < 1) {
        y = this.interpolate(a, b, c, d, x);
        min = Math.min(min, y);
        max = Math.max(max, y);
      }
    }
  } else {
    delta = qb * qb - 4 * qa * qc;
    if (delta >= 0) {
      delta = Math.sqrt(delta);
      x = (delta - qb) / 2 / qa;
      if (0 < x && x < 1) {
        y = this.interpolate(a, b, c, d, x);
        min = Math.min(min, y);
        max = Math.max(max, y);
      }
      if (delta > 0) {
        x -= delta / qa;
        if (0 < x && x < 1) {
          y = this.interpolate(a, b, c, d, x);
          min = Math.min(min, y);
          max = Math.max(max, y);
        }
      }
    }
  }
  dim[0] = min;
  dim[1] = max;
}, interpolate:function(a, b, c, d, t) {
  if (t === 0) {
    return a;
  }
  if (t === 1) {
    return d;
  }
  var rate = (1 - t) / t;
  return t * t * t * (d + rate * (3 * c + rate * (3 * b + rate * a)));
}, fromStripes:function(stripes) {
  var me = this, i = 0, ln = stripes.length, j, ln2, stripe;
  me.clear();
  for (; i < ln; i++) {
    stripe = stripes[i];
    me.params.push.apply(me.params, stripe);
    me.commands.push('M');
    for (j = 2, ln2 = stripe.length; j < ln2; j += 6) {
      me.commands.push('C');
    }
  }
  if (!me.cursor) {
    me.cursor = [];
  }
  me.cursor[0] = me.params[me.params.length - 2];
  me.cursor[1] = me.params[me.params.length - 1];
  me.dirt();
}, toStripes:function(target) {
  var stripes = target || [], curr, x, y, lastX, lastY, startX, startY, i, j, commands = this.commands, params = this.params, ln = commands.length;
  for (i = 0, j = 0; i < ln; i++) {
    switch(commands[i]) {
      case 'M':
        curr = [startX = lastX = params[j++], startY = lastY = params[j++]];
        stripes.push(curr);
        break;
      case 'L':
        x = params[j++];
        y = params[j++];
        curr.push((lastX + lastX + x) / 3, (lastY + lastY + y) / 3, (lastX + x + x) / 3, (lastY + y + y) / 3, lastX = x, lastY = y);
        break;
      case 'C':
        curr.push(params[j++], params[j++], params[j++], params[j++], lastX = params[j++], lastY = params[j++]);
        break;
      case 'Z':
        x = startX;
        y = startY;
        curr.push((lastX + lastX + x) / 3, (lastY + lastY + y) / 3, (lastX + x + x) / 3, (lastY + y + y) / 3, lastX = x, lastY = y);
        break;
    }
  }
  return stripes;
}, updateSvgString:function() {
  var result = [], commands = this.commands, params = this.params, ln = commands.length, i = 0, j = 0;
  for (; i < ln; i++) {
    switch(commands[i]) {
      case 'M':
        result.push('M' + params[j] + ',' + params[j + 1]);
        j += 2;
        break;
      case 'L':
        result.push('L' + params[j] + ',' + params[j + 1]);
        j += 2;
        break;
      case 'C':
        result.push('C' + params[j] + ',' + params[j + 1] + ' ' + params[j + 2] + ',' + params[j + 3] + ' ' + params[j + 4] + ',' + params[j + 5]);
        j += 6;
        break;
      case 'Z':
        result.push('Z');
        break;
    }
  }
  this.svgString = result.join('');
}, toString:function() {
  if (!this.svgString) {
    this.updateSvgString();
  }
  return this.svgString;
}});
Ext.define('Ext.draw.overrides.Path', {override:'Ext.draw.Path', rayOrigin:{x:-10000, y:-10000}, isPointInPath:function(x, y) {
  var me = this, commands = me.commands, solver = Ext.draw.PathUtil, origin = me.rayOrigin, params = me.params, ln = commands.length, firstX = null, firstY = null, lastX = 0, lastY = 0, count = 0, i, j;
  for (i = 0, j = 0; i < ln; i++) {
    switch(commands[i]) {
      case 'M':
        if (firstX !== null) {
          if (solver.linesIntersection(firstX, firstY, lastX, lastY, origin.x, origin.y, x, y)) {
            count += 1;
          }
        }
        firstX = lastX = params[j];
        firstY = lastY = params[j + 1];
        j += 2;
        break;
      case 'L':
        if (solver.linesIntersection(lastX, lastY, params[j], params[j + 1], origin.x, origin.y, x, y)) {
          count += 1;
        }
        lastX = params[j];
        lastY = params[j + 1];
        j += 2;
        break;
      case 'C':
        count += solver.cubicLineIntersections(lastX, params[j], params[j + 2], params[j + 4], lastY, params[j + 1], params[j + 3], params[j + 5], origin.x, origin.y, x, y).length;
        lastX = params[j + 4];
        lastY = params[j + 5];
        j += 6;
        break;
      case 'Z':
        if (firstX !== null) {
          if (solver.linesIntersection(firstX, firstY, lastX, lastY, origin.x, origin.y, x, y)) {
            count += 1;
          }
        }
        break;
    }
  }
  return count % 2 === 1;
}, isPointOnPath:function(x, y) {
  var me = this, commands = me.commands, solver = Ext.draw.PathUtil, params = me.params, ln = commands.length, firstX = null, firstY = null, lastX = 0, lastY = 0, i, j;
  for (i = 0, j = 0; i < ln; i++) {
    switch(commands[i]) {
      case 'M':
        if (firstX !== null) {
          if (solver.pointOnLine(firstX, firstY, lastX, lastY, x, y)) {
            return true;
          }
        }
        firstX = lastX = params[j];
        firstY = lastY = params[j + 1];
        j += 2;
        break;
      case 'L':
        if (solver.pointOnLine(lastX, lastY, params[j], params[j + 1], x, y)) {
          return true;
        }
        lastX = params[j];
        lastY = params[j + 1];
        j += 2;
        break;
      case 'C':
        if (solver.pointOnCubic(lastX, params[j], params[j + 2], params[j + 4], lastY, params[j + 1], params[j + 3], params[j + 5], x, y)) {
          return true;
        }
        lastX = params[j + 4];
        lastY = params[j + 5];
        j += 6;
        break;
      case 'Z':
        if (firstX !== null) {
          if (solver.pointOnLine(firstX, firstY, lastX, lastY, x, y)) {
            return true;
          }
        }
        break;
    }
  }
  return false;
}, getSegmentIntersections:function(x1, y1, x2, y2, x3, y3, x4, y4) {
  var me = this, count = arguments.length, solver = Ext.draw.PathUtil, commands = me.commands, params = me.params, ln = commands.length, firstX = null, firstY = null, lastX = 0, lastY = 0, intersections = [], i, j, points;
  for (i = 0, j = 0; i < ln; i++) {
    switch(commands[i]) {
      case 'M':
        if (firstX !== null) {
          switch(count) {
            case 4:
              points = solver.linesIntersection(firstX, firstY, lastX, lastY, x1, y1, x2, y2);
              if (points) {
                intersections.push(points);
              }
              break;
            case 8:
              points = solver.cubicLineIntersections(x1, x2, x3, x4, y1, y2, y3, y4, firstX, firstY, lastX, lastY);
              intersections.push.apply(intersections, points);
              break;
          }
        }
        firstX = lastX = params[j];
        firstY = lastY = params[j + 1];
        j += 2;
        break;
      case 'L':
        switch(count) {
          case 4:
            points = solver.linesIntersection(lastX, lastY, params[j], params[j + 1], x1, y1, x2, y2);
            if (points) {
              intersections.push(points);
            }
            break;
          case 8:
            points = solver.cubicLineIntersections(x1, x2, x3, x4, y1, y2, y3, y4, lastX, lastY, params[j], params[j + 1]);
            intersections.push.apply(intersections, points);
            break;
        }lastX = params[j];
        lastY = params[j + 1];
        j += 2;
        break;
      case 'C':
        switch(count) {
          case 4:
            points = solver.cubicLineIntersections(lastX, params[j], params[j + 2], params[j + 4], lastY, params[j + 1], params[j + 3], params[j + 5], x1, y1, x2, y2);
            intersections.push.apply(intersections, points);
            break;
          case 8:
            points = solver.cubicsIntersections(lastX, params[j], params[j + 2], params[j + 4], lastY, params[j + 1], params[j + 3], params[j + 5], x1, x2, x3, x4, y1, y2, y3, y4);
            intersections.push.apply(intersections, points);
            break;
        }lastX = params[j + 4];
        lastY = params[j + 5];
        j += 6;
        break;
      case 'Z':
        if (firstX !== null) {
          switch(count) {
            case 4:
              points = solver.linesIntersection(firstX, firstY, lastX, lastY, x1, y1, x2, y2);
              if (points) {
                intersections.push(points);
              }
              break;
            case 8:
              points = solver.cubicLineIntersections(x1, x2, x3, x4, y1, y2, y3, y4, firstX, firstY, lastX, lastY);
              intersections.push.apply(intersections, points);
              break;
          }
        }
        break;
    }
  }
  return intersections;
}, getIntersections:function(path) {
  var me = this, commands = me.commands, params = me.params, ln = commands.length, firstX = null, firstY = null, lastX = 0, lastY = 0, intersections = [], i, j, points;
  for (i = 0, j = 0; i < ln; i++) {
    switch(commands[i]) {
      case 'M':
        if (firstX !== null) {
          points = path.getSegmentIntersections.call(path, firstX, firstY, lastX, lastY);
          intersections.push.apply(intersections, points);
        }
        firstX = lastX = params[j];
        firstY = lastY = params[j + 1];
        j += 2;
        break;
      case 'L':
        points = path.getSegmentIntersections.call(path, lastX, lastY, params[j], params[j + 1]);
        intersections.push.apply(intersections, points);
        lastX = params[j];
        lastY = params[j + 1];
        j += 2;
        break;
      case 'C':
        points = path.getSegmentIntersections.call(path, lastX, lastY, params[j], params[j + 1], params[j + 2], params[j + 3], params[j + 4], params[j + 5]);
        intersections.push.apply(intersections, points);
        lastX = params[j + 4];
        lastY = params[j + 5];
        j += 6;
        break;
      case 'Z':
        if (firstX !== null) {
          points = path.getSegmentIntersections.call(path, firstX, firstY, lastX, lastY);
          intersections.push.apply(intersections, points);
        }
        break;
    }
  }
  return intersections;
}});
Ext.define('Ext.draw.sprite.Path', {extend:Ext.draw.sprite.Sprite, alias:['sprite.path', 'Ext.draw.Sprite'], type:'path', isPath:true, inheritableStatics:{def:{processors:{path:function(n, o) {
  if (!(n instanceof Ext.draw.Path)) {
    n = new Ext.draw.Path(n);
  }
  return n;
}}, aliases:{d:'path'}, triggers:{path:'bbox'}, updaters:{path:function(attr) {
  var path = attr.path;
  if (!path || path.bindAttr !== attr) {
    path = new Ext.draw.Path;
    path.bindAttr = attr;
    attr.path = path;
  }
  path.clear();
  this.updatePath(path, attr);
  this.scheduleUpdater(attr, 'bbox', ['path']);
}}}}, updatePlainBBox:function(plain) {
  if (this.attr.path) {
    this.attr.path.getDimension(plain);
  }
}, updateTransformedBBox:function(transform) {
  if (this.attr.path) {
    this.attr.path.getDimensionWithTransform(this.attr.matrix, transform);
  }
}, render:function(surface, ctx) {
  var mat = this.attr.matrix, attr = this.attr;
  if (!attr.path || attr.path.params.length === 0) {
    return;
  }
  mat.toContext(ctx);
  ctx.appendPath(attr.path);
  ctx.fillStroke(attr);
  var debug = attr.debug || this.statics().debug || Ext.draw.sprite.Sprite.debug;
  if (debug) {
    debug.bbox && this.renderBBox(surface, ctx);
    debug.xray && this.renderXRay(surface, ctx);
  }
}, renderXRay:function(surface, ctx) {
  var attr = this.attr, mat = attr.matrix, imat = attr.inverseMatrix, path = attr.path, commands = path.commands, params = path.params, ln = commands.length, twoPi = Math.PI * 2, size = 2, i, j;
  mat.toContext(ctx);
  ctx.beginPath();
  for (i = 0, j = 0; i < ln; i++) {
    switch(commands[i]) {
      case 'M':
        ctx.moveTo(params[j] - size, params[j + 1] - size);
        ctx.rect(params[j] - size, params[j + 1] - size, size * 2, size * 2);
        j += 2;
        break;
      case 'L':
        ctx.moveTo(params[j] - size, params[j + 1] - size);
        ctx.rect(params[j] - size, params[j + 1] - size, size * 2, size * 2);
        j += 2;
        break;
      case 'C':
        ctx.moveTo(params[j] + size, params[j + 1]);
        ctx.arc(params[j], params[j + 1], size, 0, twoPi, true);
        j += 2;
        ctx.moveTo(params[j] + size, params[j + 1]);
        ctx.arc(params[j], params[j + 1], size, 0, twoPi, true);
        j += 2;
        ctx.moveTo(params[j] + size * 2, params[j + 1]);
        ctx.rect(params[j] - size, params[j + 1] - size, size * 2, size * 2);
        j += 2;
        break;
      default:
    }
  }
  imat.toContext(ctx);
  ctx.strokeStyle = 'black';
  ctx.strokeOpacity = 1;
  ctx.lineWidth = 1;
  ctx.stroke();
  mat.toContext(ctx);
  ctx.beginPath();
  for (i = 0, j = 0; i < ln; i++) {
    switch(commands[i]) {
      case 'M':
        ctx.moveTo(params[j], params[j + 1]);
        j += 2;
        break;
      case 'L':
        ctx.moveTo(params[j], params[j + 1]);
        j += 2;
        break;
      case 'C':
        ctx.lineTo(params[j], params[j + 1]);
        j += 2;
        ctx.moveTo(params[j], params[j + 1]);
        j += 2;
        ctx.lineTo(params[j], params[j + 1]);
        j += 2;
        break;
      default:
    }
  }
  imat.toContext(ctx);
  ctx.lineWidth = 0.5;
  ctx.stroke();
}, updatePath:function(path, attr) {
}});
Ext.define('Ext.draw.overrides.sprite.Path', {override:'Ext.draw.sprite.Path', isPointInPath:function(x, y) {
  var attr = this.attr;
  if (attr.fillStyle === Ext.draw.Color.RGBA_NONE) {
    return this.isPointOnPath(x, y);
  }
  var path = attr.path, matrix = attr.matrix, params, result;
  if (!matrix.isIdentity()) {
    params = path.params.slice(0);
    path.transform(attr.matrix);
  }
  result = path.isPointInPath(x, y);
  if (params) {
    path.params = params;
  }
  return result;
}, isPointOnPath:function(x, y) {
  var attr = this.attr, path = attr.path, matrix = attr.matrix, params, result;
  if (!matrix.isIdentity()) {
    params = path.params.slice(0);
    path.transform(attr.matrix);
  }
  result = path.isPointOnPath(x, y);
  if (params) {
    path.params = params;
  }
  return result;
}, hitTest:function(point, options) {
  var me = this, attr = me.attr, path = attr.path, matrix = attr.matrix, x = point[0], y = point[1], parentResult = me.callParent([point, options]), result = null, params, isFilled;
  if (!parentResult) {
    return result;
  }
  options = options || Ext.draw.sprite.Sprite.defaultHitTestOptions;
  if (!matrix.isIdentity()) {
    params = path.params.slice(0);
    path.transform(attr.matrix);
  }
  if (options.fill && options.stroke) {
    isFilled = attr.fillStyle !== Ext.draw.Color.NONE && attr.fillStyle !== Ext.draw.Color.RGBA_NONE;
    if (isFilled) {
      if (path.isPointInPath(x, y)) {
        result = {sprite:me};
      }
    } else {
      if (path.isPointInPath(x, y) || path.isPointOnPath(x, y)) {
        result = {sprite:me};
      }
    }
  } else {
    if (options.stroke && !options.fill) {
      if (path.isPointOnPath(x, y)) {
        result = {sprite:me};
      }
    } else {
      if (options.fill && !options.stroke) {
        if (path.isPointInPath(x, y)) {
          result = {sprite:me};
        }
      }
    }
  }
  if (params) {
    path.params = params;
  }
  return result;
}, getIntersections:function(path) {
  if (!(path.isSprite && path.isPath)) {
    return [];
  }
  var aAttr = this.attr, bAttr = path.attr, aPath = aAttr.path, bPath = bAttr.path, aMatrix = aAttr.matrix, bMatrix = bAttr.matrix, aParams, bParams, intersections;
  if (!aMatrix.isIdentity()) {
    aParams = aPath.params.slice(0);
    aPath.transform(aAttr.matrix);
  }
  if (!bMatrix.isIdentity()) {
    bParams = bPath.params.slice(0);
    bPath.transform(bAttr.matrix);
  }
  intersections = aPath.getIntersections(bPath);
  if (aParams) {
    aPath.params = aParams;
  }
  if (bParams) {
    bPath.params = bParams;
  }
  return intersections;
}});
Ext.define('Ext.draw.sprite.Circle', {extend:Ext.draw.sprite.Path, alias:'sprite.circle', type:'circle', inheritableStatics:{def:{processors:{cx:'number', cy:'number', r:'number'}, aliases:{radius:'r', x:'cx', y:'cy', centerX:'cx', centerY:'cy'}, defaults:{cx:0, cy:0, r:4}, triggers:{cx:'path', cy:'path', r:'path'}}}, updatePlainBBox:function(plain) {
  var attr = this.attr, cx = attr.cx, cy = attr.cy, r = attr.r;
  plain.x = cx - r;
  plain.y = cy - r;
  plain.width = r + r;
  plain.height = r + r;
}, updateTransformedBBox:function(transform) {
  var attr = this.attr, cx = attr.cx, cy = attr.cy, r = attr.r, matrix = attr.matrix, scaleX = matrix.getScaleX(), scaleY = matrix.getScaleY(), rx, ry;
  rx = scaleX * r;
  ry = scaleY * r;
  transform.x = matrix.x(cx, cy) - rx;
  transform.y = matrix.y(cx, cy) - ry;
  transform.width = rx + rx;
  transform.height = ry + ry;
}, updatePath:function(path, attr) {
  path.arc(attr.cx, attr.cy, attr.r, 0, Math.PI * 2, false);
}});
Ext.define('Ext.draw.sprite.Arc', {extend:Ext.draw.sprite.Circle, alias:'sprite.arc', type:'arc', inheritableStatics:{def:{processors:{startAngle:'number', endAngle:'number', anticlockwise:'bool'}, aliases:{from:'startAngle', to:'endAngle', start:'startAngle', end:'endAngle'}, defaults:{startAngle:0, endAngle:Math.PI * 2, anticlockwise:false}, triggers:{startAngle:'path', endAngle:'path', anticlockwise:'path'}}}, updatePath:function(path, attr) {
  path.arc(attr.cx, attr.cy, attr.r, attr.startAngle, attr.endAngle, attr.anticlockwise);
}});
Ext.define('Ext.draw.sprite.Arrow', {extend:Ext.draw.sprite.Path, alias:'sprite.arrow', inheritableStatics:{def:{processors:{x:'number', y:'number', size:'number'}, defaults:{x:0, y:0, size:4}, triggers:{x:'path', y:'path', size:'path'}}}, updatePath:function(path, attr) {
  var s = attr.size * 1.5, x = attr.x - attr.lineWidth / 2, y = attr.y;
  path.fromSvgString('M'.concat(x - s * 0.7, ',', y - s * 0.4, 'l', [s * 0.6, 0, 0, -s * 0.4, s, s * 0.8, -s, s * 0.8, 0, -s * 0.4, -s * 0.6, 0], 'z'));
}});
Ext.define('Ext.draw.sprite.Composite', {extend:Ext.draw.sprite.Sprite, alias:'sprite.composite', type:'composite', isComposite:true, config:{sprites:[]}, constructor:function() {
  this.sprites = [];
  this.sprites.map = {};
  this.callParent(arguments);
}, add:function(sprite) {
  if (!sprite) {
    return null;
  }
  if (!sprite.isSprite) {
    sprite = Ext.create('sprite.' + sprite.type, sprite);
    sprite.setParent(this);
    sprite.setSurface(this.getSurface());
  }
  var me = this, attr = me.attr, oldTransformations = sprite.applyTransformations;
  sprite.applyTransformations = function() {
    if (sprite.attr.dirtyTransform) {
      attr.dirtyTransform = true;
      attr.bbox.plain.dirty = true;
      attr.bbox.transform.dirty = true;
    }
    oldTransformations.call(sprite);
  };
  me.sprites.push(sprite);
  me.sprites.map[sprite.id] = sprite.getId();
  attr.bbox.plain.dirty = true;
  attr.bbox.transform.dirty = true;
  return sprite;
}, updateSurface:function(surface) {
  for (var i = 0, ln = this.sprites.length; i < ln; i++) {
    this.sprites[i].setSurface(surface);
  }
}, addAll:function(sprites) {
  if (sprites.isSprite || sprites.type) {
    this.add(sprites);
  } else {
    if (Ext.isArray(sprites)) {
      var i = 0;
      while (i < sprites.length) {
        this.add(sprites[i++]);
      }
    }
  }
}, updatePlainBBox:function(plain) {
  var me = this, left = Infinity, right = -Infinity, top = Infinity, bottom = -Infinity, sprite, bbox, i, ln;
  for (i = 0, ln = me.sprites.length; i < ln; i++) {
    sprite = me.sprites[i];
    sprite.applyTransformations();
    bbox = sprite.getBBox();
    if (left > bbox.x) {
      left = bbox.x;
    }
    if (right < bbox.x + bbox.width) {
      right = bbox.x + bbox.width;
    }
    if (top > bbox.y) {
      top = bbox.y;
    }
    if (bottom < bbox.y + bbox.height) {
      bottom = bbox.y + bbox.height;
    }
  }
  plain.x = left;
  plain.y = top;
  plain.width = right - left;
  plain.height = bottom - top;
}, render:function(surface, ctx, rect) {
  var mat = this.attr.matrix, i, ln;
  mat.toContext(ctx);
  for (i = 0, ln = this.sprites.length; i < ln; i++) {
    surface.renderSprite(this.sprites[i], rect);
  }
}, destroy:function() {
  var me = this, sprites = me.sprites, ln = sprites.length, i;
  me.callParent();
  for (i = 0; i < ln; i++) {
    sprites[i].destroy();
  }
  sprites.length = 0;
}});
Ext.define('Ext.draw.sprite.Cross', {extend:Ext.draw.sprite.Path, alias:'sprite.cross', inheritableStatics:{def:{processors:{x:'number', y:'number', size:'number'}, defaults:{x:0, y:0, size:4}, triggers:{x:'path', y:'path', size:'path'}}}, updatePath:function(path, attr) {
  var s = attr.size / 1.7, x = attr.x - attr.lineWidth / 2, y = attr.y;
  path.fromSvgString('M'.concat(x - s, ',', y, 'l', [-s, -s, s, -s, s, s, s, -s, s, s, -s, s, s, s, -s, s, -s, -s, -s, s, -s, -s, 'z']));
}});
Ext.define('Ext.draw.sprite.Diamond', {extend:Ext.draw.sprite.Path, alias:'sprite.diamond', inheritableStatics:{def:{processors:{x:'number', y:'number', size:'number'}, defaults:{x:0, y:0, size:4}, triggers:{x:'path', y:'path', size:'path'}}}, updatePath:function(path, attr) {
  var s = attr.size * 1.25, x = attr.x - attr.lineWidth / 2, y = attr.y;
  path.fromSvgString(['M', x, y - s, 'l', s, s, -s, s, -s, -s, s, -s, 'z']);
}});
Ext.define('Ext.draw.sprite.Ellipse', {extend:Ext.draw.sprite.Path, alias:'sprite.ellipse', type:'ellipse', inheritableStatics:{def:{processors:{cx:'number', cy:'number', rx:'number', ry:'number', axisRotation:'number'}, aliases:{radius:'r', x:'cx', y:'cy', centerX:'cx', centerY:'cy', radiusX:'rx', radiusY:'ry'}, defaults:{cx:0, cy:0, rx:1, ry:1, axisRotation:0}, triggers:{cx:'path', cy:'path', rx:'path', ry:'path', axisRotation:'path'}}}, updatePlainBBox:function(plain) {
  var attr = this.attr, cx = attr.cx, cy = attr.cy, rx = attr.rx, ry = attr.ry;
  plain.x = cx - rx;
  plain.y = cy - ry;
  plain.width = rx + rx;
  plain.height = ry + ry;
}, updateTransformedBBox:function(transform) {
  var attr = this.attr, cx = attr.cx, cy = attr.cy, rx = attr.rx, ry = attr.ry, rxy = ry / rx, matrix = attr.matrix.clone(), xx, xy, yx, yy, dx, dy, w, h;
  matrix.append(1, 0, 0, rxy, 0, cy * (1 - rxy));
  xx = matrix.getXX();
  yx = matrix.getYX();
  dx = matrix.getDX();
  xy = matrix.getXY();
  yy = matrix.getYY();
  dy = matrix.getDY();
  w = Math.sqrt(xx * xx + yx * yx) * rx;
  h = Math.sqrt(xy * xy + yy * yy) * rx;
  transform.x = cx * xx + cy * yx + dx - w;
  transform.y = cx * xy + cy * yy + dy - h;
  transform.width = w + w;
  transform.height = h + h;
}, updatePath:function(path, attr) {
  path.ellipse(attr.cx, attr.cy, attr.rx, attr.ry, attr.axisRotation, 0, Math.PI * 2, false);
}});
Ext.define('Ext.draw.sprite.EllipticalArc', {extend:Ext.draw.sprite.Ellipse, alias:'sprite.ellipticalArc', type:'ellipticalArc', inheritableStatics:{def:{processors:{startAngle:'number', endAngle:'number', anticlockwise:'bool'}, aliases:{from:'startAngle', to:'endAngle', start:'startAngle', end:'endAngle'}, defaults:{startAngle:0, endAngle:Math.PI * 2, anticlockwise:false}, triggers:{startAngle:'path', endAngle:'path', anticlockwise:'path'}}}, updatePath:function(path, attr) {
  path.ellipse(attr.cx, attr.cy, attr.rx, attr.ry, attr.axisRotation, attr.startAngle, attr.endAngle, attr.anticlockwise);
}});
Ext.define('Ext.draw.sprite.Rect', {extend:Ext.draw.sprite.Path, alias:'sprite.rect', type:'rect', inheritableStatics:{def:{processors:{x:'number', y:'number', width:'number', height:'number', radius:'number'}, aliases:{}, triggers:{x:'path', y:'path', width:'path', height:'path', radius:'path'}, defaults:{x:0, y:0, width:8, height:8, radius:0}}}, updatePlainBBox:function(plain) {
  var attr = this.attr;
  plain.x = attr.x;
  plain.y = attr.y;
  plain.width = attr.width;
  plain.height = attr.height;
}, updateTransformedBBox:function(transform, plain) {
  this.attr.matrix.transformBBox(plain, this.attr.radius, transform);
}, updatePath:function(path, attr) {
  var x = attr.x, y = attr.y, width = attr.width, height = attr.height, radius = Math.min(attr.radius, Math.abs(attr.height) * 0.5, Math.abs(attr.width) * 0.5);
  if (radius === 0) {
    path.rect(x, y, width, height);
  } else {
    path.moveTo(x + radius, y);
    path.arcTo(x + width, y, x + width, y + height, radius);
    path.arcTo(x + width, y + height, x, y + height, radius);
    path.arcTo(x, y + height, x, y, radius);
    path.arcTo(x, y, x + radius, y, radius);
  }
}});
Ext.define('Ext.draw.sprite.Image', {extend:Ext.draw.sprite.Rect, alias:'sprite.image', type:'image', statics:{imageLoaders:{}}, inheritableStatics:{def:{processors:{src:'string'}, defaults:{src:'', width:null, height:null}}}, render:function(surface, ctx) {
  var me = this, attr = me.attr, mat = attr.matrix, src = attr.src, x = attr.x, y = attr.y, width = attr.width, height = attr.height, loadingStub = Ext.draw.sprite.Image.imageLoaders[src], imageLoader, image, i;
  if (loadingStub && loadingStub.done) {
    mat.toContext(ctx);
    image = loadingStub.image;
    ctx.drawImage(image, x, y, width || (image.naturalWidth || image.width) / surface.devicePixelRatio, height || (image.naturalHeight || image.height) / surface.devicePixelRatio);
  } else {
    if (!loadingStub) {
      imageLoader = new Image;
      loadingStub = Ext.draw.sprite.Image.imageLoaders[src] = {image:imageLoader, done:false, pendingSprites:[me], pendingSurfaces:[surface]};
      imageLoader.width = width;
      imageLoader.height = height;
      imageLoader.onload = function() {
        if (!loadingStub.done) {
          loadingStub.done = true;
          for (i = 0; i < loadingStub.pendingSprites.length; i++) {
            loadingStub.pendingSprites[i].setDirty(true);
          }
          for (i in loadingStub.pendingSurfaces) {
            loadingStub.pendingSurfaces[i].renderFrame();
          }
        }
      };
      imageLoader.src = src;
    } else {
      Ext.Array.include(loadingStub.pendingSprites, me);
      Ext.Array.include(loadingStub.pendingSurfaces, surface);
    }
  }
  var debug = attr.debug || this.statics().debug || Ext.draw.sprite.Sprite.debug;
  if (debug) {
    debug.bbox && this.renderBBox(surface, ctx);
  }
}});
Ext.define('Ext.draw.sprite.Instancing', {extend:Ext.draw.sprite.Sprite, alias:'sprite.instancing', type:'instancing', isInstancing:true, config:{template:null}, instances:null, applyTemplate:function(template) {
  if (!Ext.isObject(template)) {
    Ext.raise('A template of an instancing sprite must either be ' + 'a sprite instance or a valid config object from which a template ' + 'sprite will be created.');
  } else {
    if (template.isInstancing || template.isComposite) {
      Ext.raise("Can't use an instancing or composite sprite " + 'as a template for an instancing sprite.');
    }
  }
  if (!template.isSprite) {
    if (!template.xclass && !template.type) {
      template.type = 'circle';
    }
    template = Ext.create(template.xclass || 'sprite.' + template.type, template);
  }
  template.setParent(this);
  return template;
}, updateTemplate:function(template, oldTemplate) {
  if (oldTemplate) {
    delete oldTemplate.ownAttr;
  }
  template.setSurface(this.getSurface());
  template.ownAttr = template.attr;
  this.clearAll();
}, updateSurface:function(surface) {
  var template = this.getTemplate();
  if (template) {
    template.setSurface(surface);
  }
}, get:function(index) {
  return this.instances[index];
}, getCount:function() {
  return this.instances.length;
}, clearAll:function() {
  var template = this.getTemplate();
  template.attr.children = this.instances = [];
  this.position = 0;
}, createInstance:function(config, bypassNormalization, avoidCopy) {
  var template = this.getTemplate(), originalAttr = template.attr, attr = Ext.Object.chain(originalAttr);
  template.topModifier.prepareAttributes(attr);
  template.attr = attr;
  template.setAttributes(config, bypassNormalization, avoidCopy);
  attr.template = template;
  this.instances.push(attr);
  template.attr = originalAttr;
  this.position++;
  return attr;
}, getBBox:function() {
  return null;
}, getBBoxFor:function(index, isWithoutTransform) {
  var template = this.getTemplate(), originalAttr = template.attr, bbox;
  template.attr = this.instances[index];
  bbox = template.getBBox(isWithoutTransform);
  template.attr = originalAttr;
  return bbox;
}, isVisible:function() {
  var attr = this.attr, parent = this.getParent(), result;
  result = parent && parent.isSurface && !attr.hidden && attr.globalAlpha;
  return !!result;
}, isInstanceVisible:function(index) {
  var me = this, template = me.getTemplate(), originalAttr = template.attr, instances = me.instances, result = false;
  if (!Ext.isNumber(index) || index < 0 || index >= instances.length || !me.isVisible()) {
    return result;
  }
  template.attr = instances[index];
  result = template.isVisible(point, options);
  template.attr = originalAttr;
  return result;
}, render:function(surface, ctx, clipRect, rect) {
  if (!this.getTemplate()) {
    Ext.raise('An instancing sprite must have a template.');
  }
  var me = this, template = me.getTemplate(), mat = me.attr.matrix, originalAttr = template.attr, instances = me.instances, i, ln = me.position;
  mat.toContext(ctx);
  template.preRender(surface, ctx, clipRect, rect);
  template.useAttributes(ctx, rect);
  for (i = 0; i < ln; i++) {
    if (instances[i].dirtyZIndex) {
      break;
    }
  }
  for (i = 0; i < ln; i++) {
    if (instances[i].hidden) {
      continue;
    }
    ctx.save();
    template.attr = instances[i];
    template.useAttributes(ctx, rect);
    template.render(surface, ctx, clipRect, rect);
    ctx.restore();
  }
  template.attr = originalAttr;
}, setAttributesFor:function(index, changes, bypassNormalization) {
  var template = this.getTemplate(), originalAttr = template.attr, attr = this.instances[index];
  if (!attr) {
    return;
  }
  template.attr = attr;
  if (bypassNormalization) {
    changes = Ext.apply({}, changes);
  } else {
    changes = template.self.def.normalize(changes);
  }
  template.topModifier.pushDown(attr, changes);
  template.attr = originalAttr;
}, destroy:function() {
  var me = this, template = me.getTemplate();
  me.instances = null;
  if (template) {
    template.destroy();
  }
  me.callParent();
}});
Ext.define('Ext.draw.overrides.sprite.Instancing', {override:'Ext.draw.sprite.Instancing', hitTest:function(point, options) {
  var me = this, template = me.getTemplate(), originalAttr = template.attr, instances = me.instances, ln = instances.length, i = 0, result = null;
  if (!me.isVisible()) {
    return result;
  }
  for (; i < ln; i++) {
    template.attr = instances[i];
    result = template.hitTest(point, options);
    if (result) {
      result.isInstance = true;
      result.template = result.sprite;
      result.sprite = this;
      result.instance = instances[i];
      result.index = i;
      return result;
    }
  }
  template.attr = originalAttr;
  return result;
}});
Ext.define('Ext.draw.sprite.Line', {extend:Ext.draw.sprite.Sprite, alias:'sprite.line', type:'line', inheritableStatics:{def:{processors:{fromX:'number', fromY:'number', toX:'number', toY:'number'}, defaults:{fromX:0, fromY:0, toX:1, toY:1, strokeStyle:'black'}, aliases:{x1:'fromX', y1:'fromY', x2:'toX', y2:'toY'}}}, updateLineBBox:function(bbox, isTransform, x1, y1, x2, y2) {
  var attr = this.attr, matrix = attr.matrix, halfLineWidth = attr.lineWidth / 2, fromX, fromY, toX, toY, dx, dy, p;
  if (isTransform) {
    p = matrix.transformPoint([x1, y1]);
    x1 = p[0];
    y1 = p[1];
    p = matrix.transformPoint([x2, y2]);
    x2 = p[0];
    y2 = p[1];
  }
  fromX = Math.min(x1, x2);
  toX = Math.max(x1, x2);
  fromY = Math.min(y1, y2);
  toY = Math.max(y1, y2);
  var angle = Math.atan2(toX - fromX, toY - fromY), sin = Math.sin(angle), cos = Math.cos(angle), dx = halfLineWidth * cos, dy = halfLineWidth * sin;
  fromX -= dx;
  fromY -= dy;
  toX += dx;
  toY += dy;
  bbox.x = fromX;
  bbox.y = fromY;
  bbox.width = toX - fromX;
  bbox.height = toY - fromY;
}, updatePlainBBox:function(plain) {
  var attr = this.attr;
  this.updateLineBBox(plain, false, attr.fromX, attr.fromY, attr.toX, attr.toY);
}, updateTransformedBBox:function(transform, plain) {
  var attr = this.attr;
  this.updateLineBBox(transform, true, attr.fromX, attr.fromY, attr.toX, attr.toY);
}, render:function(surface, ctx) {
  var attr = this.attr, matrix = this.attr.matrix;
  matrix.toContext(ctx);
  ctx.beginPath();
  ctx.moveTo(attr.fromX, attr.fromY);
  ctx.lineTo(attr.toX, attr.toY);
  ctx.stroke();
  var debug = attr.debug || this.statics().debug || Ext.draw.sprite.Sprite.debug;
  if (debug) {
    this.attr.inverseMatrix.toContext(ctx);
    debug.bbox && this.renderBBox(surface, ctx);
  }
}});
Ext.define('Ext.draw.sprite.Plus', {extend:Ext.draw.sprite.Path, alias:'sprite.plus', inheritableStatics:{def:{processors:{x:'number', y:'number', size:'number'}, defaults:{x:0, y:0, size:4}, triggers:{x:'path', y:'path', size:'path'}}}, updatePath:function(path, attr) {
  var s = attr.size / 1.3, x = attr.x - attr.lineWidth / 2, y = attr.y;
  path.fromSvgString('M'.concat(x - s / 2, ',', y - s / 2, 'l', [0, -s, s, 0, 0, s, s, 0, 0, s, -s, 0, 0, s, -s, 0, 0, -s, -s, 0, 0, -s, 'z']));
}});
Ext.define('Ext.draw.sprite.Sector', {extend:Ext.draw.sprite.Path, alias:'sprite.sector', type:'sector', inheritableStatics:{def:{processors:{centerX:'number', centerY:'number', startAngle:'number', endAngle:'number', startRho:'number', endRho:'number', margin:'number'}, aliases:{rho:'endRho'}, triggers:{centerX:'path,bbox', centerY:'path,bbox', startAngle:'path,bbox', endAngle:'path,bbox', startRho:'path,bbox', endRho:'path,bbox', margin:'path,bbox'}, defaults:{centerX:0, centerY:0, startAngle:0, 
endAngle:0, startRho:0, endRho:150, margin:0, path:'M 0,0'}}}, getMidAngle:function() {
  return this.midAngle || 0;
}, updatePath:function(path, attr) {
  var startAngle = Math.min(attr.startAngle, attr.endAngle), endAngle = Math.max(attr.startAngle, attr.endAngle), midAngle = this.midAngle = (startAngle + endAngle) * 0.5, margin = attr.margin, centerX = attr.centerX, centerY = attr.centerY, startRho = Math.min(attr.startRho, attr.endRho), endRho = Math.max(attr.startRho, attr.endRho);
  if (margin) {
    centerX += margin * Math.cos(midAngle);
    centerY += margin * Math.sin(midAngle);
  }
  path.moveTo(centerX + startRho * Math.cos(startAngle), centerY + startRho * Math.sin(startAngle));
  path.lineTo(centerX + endRho * Math.cos(startAngle), centerY + endRho * Math.sin(startAngle));
  path.arc(centerX, centerY, endRho, startAngle, endAngle, false);
  path.lineTo(centerX + startRho * Math.cos(endAngle), centerY + startRho * Math.sin(endAngle));
  path.arc(centerX, centerY, startRho, endAngle, startAngle, true);
}});
Ext.define('Ext.draw.sprite.Square', {extend:Ext.draw.sprite.Rect, alias:'sprite.square', inheritableStatics:{def:{processors:{size:'number'}, defaults:{size:4}, triggers:{size:'size'}, updaters:{size:function(attr) {
  var size = attr.size, halfLineWidth = attr.lineWidth / 2;
  this.setAttributes({x:attr.x - size - halfLineWidth, y:attr.y - size, height:2 * size, width:2 * size});
}}}}});
Ext.define('Ext.draw.TextMeasurer', {singleton:true, measureDiv:null, measureCache:{}, precise:Ext.isIE8, measureDivTpl:{tag:'div', style:{overflow:'hidden', position:'relative', 'float':'left', width:0, height:0}, 'data-sticky':true, children:{tag:'div', style:{display:'block', position:'absolute', x:-100000, y:-100000, padding:0, margin:0, 'z-index':-100000, 'white-space':'nowrap'}}}, actualMeasureText:function(text, font) {
  var me = Ext.draw.TextMeasurer, measureDiv = me.measureDiv, FARAWAY = 100000, size;
  if (!measureDiv) {
    var parent = Ext.Element.create({'data-sticky':true, style:{'overflow':'hidden', 'position':'relative', 'float':'left', 'width':0, 'height':0}});
    me.measureDiv = measureDiv = Ext.Element.create({style:{'position':'absolute', 'x':FARAWAY, 'y':FARAWAY, 'z-index':-FARAWAY, 'white-space':'nowrap', 'display':'block', 'padding':0, 'margin':0}});
    Ext.getBody().appendChild(parent);
    parent.appendChild(measureDiv);
  }
  if (font) {
    measureDiv.setStyle({font:font, lineHeight:'normal'});
  }
  measureDiv.setText('(' + text + ')');
  size = measureDiv.getSize();
  measureDiv.setText('()');
  size.width -= measureDiv.getSize().width;
  return size;
}, measureTextSingleLine:function(text, font) {
  if (this.precise) {
    return this.preciseMeasureTextSingleLine(text, font);
  }
  text = text.toString();
  var cache = this.measureCache, chars = text.split(''), width = 0, height = 0, cachedItem, charactor, i, ln, size;
  if (!cache[font]) {
    cache[font] = {};
  }
  cache = cache[font];
  if (cache[text]) {
    return cache[text];
  }
  for (i = 0, ln = chars.length; i < ln; i++) {
    charactor = chars[i];
    if (!(cachedItem = cache[charactor])) {
      size = this.actualMeasureText(charactor, font);
      cachedItem = cache[charactor] = size;
    }
    width += cachedItem.width;
    height = Math.max(height, cachedItem.height);
  }
  return cache[text] = {width:width, height:height};
}, preciseMeasureTextSingleLine:function(text, font) {
  text = text.toString();
  var measureDiv = this.measureDiv || (this.measureDiv = Ext.getBody().createChild(this.measureDivTpl).down('div'));
  measureDiv.setStyle({font:font || ''});
  return Ext.util.TextMetrics.measure(measureDiv, text);
}, measureText:function(text, font) {
  var lines = text.split('\n'), ln = lines.length, height = 0, width = 0, line, i, sizes;
  if (ln === 1) {
    return this.measureTextSingleLine(text, font);
  }
  sizes = [];
  for (i = 0; i < ln; i++) {
    line = this.measureTextSingleLine(lines[i], font);
    sizes.push(line);
    height += line.height;
    width = Math.max(width, line.width);
  }
  return {width:width, height:height, sizes:sizes};
}});
Ext.define('Ext.draw.sprite.Text', function() {
  var fontSizes = {'xx-small':true, 'x-small':true, 'small':true, 'medium':true, 'large':true, 'x-large':true, 'xx-large':true};
  var fontWeights = {normal:true, bold:true, bolder:true, lighter:true, 100:true, 200:true, 300:true, 400:true, 500:true, 600:true, 700:true, 800:true, 900:true};
  var textAlignments = {start:'start', left:'start', center:'center', middle:'center', end:'end', right:'end'};
  var textBaselines = {top:'top', hanging:'hanging', middle:'middle', center:'middle', alphabetic:'alphabetic', ideographic:'ideographic', bottom:'bottom'};
  return {extend:Ext.draw.sprite.Sprite, alias:'sprite.text', type:'text', lineBreakRe:/\r?\n/g, statics:{debug:false, fontSizes:fontSizes, fontWeights:fontWeights, textAlignments:textAlignments, textBaselines:textBaselines}, inheritableStatics:{def:{animationProcessors:{text:'text'}, processors:{x:'number', y:'number', text:'string', fontSize:function(n) {
    if (Ext.isNumber(+n)) {
      return n + 'px';
    } else {
      if (n.match(Ext.dom.Element.unitRe)) {
        return n;
      } else {
        if (n in fontSizes) {
          return n;
        }
      }
    }
  }, fontStyle:'enums(,italic,oblique)', fontVariant:'enums(,small-caps)', fontWeight:function(n) {
    if (n in fontWeights) {
      return String(n);
    } else {
      return '';
    }
  }, fontFamily:'string', textAlign:function(n) {
    return textAlignments[n] || 'center';
  }, textBaseline:function(n) {
    return textBaselines[n] || 'alphabetic';
  }, font:'string', debug:'default'}, aliases:{'font-size':'fontSize', 'font-family':'fontFamily', 'font-weight':'fontWeight', 'font-variant':'fontVariant', 'text-anchor':'textAlign'}, defaults:{fontStyle:'', fontVariant:'', fontWeight:'', fontSize:'10px', fontFamily:'sans-serif', font:'10px sans-serif', textBaseline:'alphabetic', textAlign:'start', strokeStyle:'rgba(0, 0, 0, 0)', fillStyle:'#000', x:0, y:0, text:''}, triggers:{fontStyle:'fontX,bbox', fontVariant:'fontX,bbox', fontWeight:'fontX,bbox', 
  fontSize:'fontX,bbox', fontFamily:'fontX,bbox', font:'font,bbox,canvas', textBaseline:'bbox', textAlign:'bbox', x:'bbox', y:'bbox', text:'bbox'}, updaters:{fontX:'makeFontShorthand', font:'parseFontShorthand'}}}, constructor:function(config) {
    if (config && config.font) {
      config = Ext.clone(config);
      for (var key in config) {
        if (key !== 'font' && key.indexOf('font') === 0) {
          delete config[key];
        }
      }
    }
    Ext.draw.sprite.Sprite.prototype.constructor.call(this, config);
  }, fontValuesMap:{'italic':'fontStyle', 'oblique':'fontStyle', 'small-caps':'fontVariant', 'bold':'fontWeight', 'bolder':'fontWeight', 'lighter':'fontWeight', 100:'fontWeight', 200:'fontWeight', 300:'fontWeight', 400:'fontWeight', 500:'fontWeight', 600:'fontWeight', 700:'fontWeight', 800:'fontWeight', 900:'fontWeight', 'xx-small':'fontSize', 'x-small':'fontSize', 'small':'fontSize', 'medium':'fontSize', 'large':'fontSize', 'x-large':'fontSize', 'xx-large':'fontSize'}, makeFontShorthand:function(attr) {
    var parts = [];
    if (attr.fontStyle) {
      parts.push(attr.fontStyle);
    }
    if (attr.fontVariant) {
      parts.push(attr.fontVariant);
    }
    if (attr.fontWeight) {
      parts.push(attr.fontWeight);
    }
    if (attr.fontSize) {
      parts.push(attr.fontSize);
    }
    if (attr.fontFamily) {
      parts.push(attr.fontFamily);
    }
    this.setAttributes({font:parts.join(' ')}, true);
  }, parseFontShorthand:function(attr) {
    var value = attr.font, ln = value.length, changes = {}, dispatcher = this.fontValuesMap, start = 0, end, slashIndex, part, fontProperty;
    while (start < ln && end !== -1) {
      end = value.indexOf(' ', start);
      if (end < 0) {
        part = value.substr(start);
      } else {
        if (end > start) {
          part = value.substr(start, end - start);
        } else {
          continue;
        }
      }
      slashIndex = part.indexOf('/');
      if (slashIndex > 0) {
        part = part.substr(0, slashIndex);
      } else {
        if (slashIndex === 0) {
          continue;
        }
      }
      if (part !== 'normal' && part !== 'inherit') {
        fontProperty = dispatcher[part];
        if (fontProperty) {
          changes[fontProperty] = part;
        } else {
          if (part.match(Ext.dom.Element.unitRe)) {
            changes.fontSize = part;
          } else {
            changes.fontFamily = value.substr(start);
            break;
          }
        }
      }
      start = end + 1;
    }
    if (!changes.fontStyle) {
      changes.fontStyle = '';
    }
    if (!changes.fontVariant) {
      changes.fontVariant = '';
    }
    if (!changes.fontWeight) {
      changes.fontWeight = '';
    }
    this.setAttributes(changes, true);
  }, fontProperties:{fontStyle:true, fontVariant:true, fontWeight:true, fontSize:true, fontFamily:true}, setAttributes:function(changes, bypassNormalization, avoidCopy) {
    var key, obj;
    if (changes && changes.font) {
      obj = {};
      for (key in changes) {
        if (!(key in this.fontProperties)) {
          obj[key] = changes[key];
        }
      }
      changes = obj;
    }
    this.callParent([changes, bypassNormalization, avoidCopy]);
  }, getBBox:function(isWithoutTransform) {
    var me = this, plain = me.attr.bbox.plain, surface = me.getSurface();
    if (!surface) {
      Ext.raise('The sprite does not belong to a surface.');
    }
    if (plain.dirty) {
      me.updatePlainBBox(plain);
      plain.dirty = false;
    }
    if (surface.getInherited().rtl && surface.getFlipRtlText()) {
      me.updatePlainBBox(plain, true);
    }
    return me.callParent([isWithoutTransform]);
  }, rtlAlignments:{start:'end', center:'center', end:'start'}, updatePlainBBox:function(plain, useOldSize) {
    var me = this, attr = me.attr, x = attr.x, y = attr.y, dx = [], font = attr.font, text = attr.text, baseline = attr.textBaseline, alignment = attr.textAlign, size = useOldSize && me.oldSize ? me.oldSize : me.oldSize = Ext.draw.TextMeasurer.measureText(text, font), surface = me.getSurface(), isRtl = surface.getInherited().rtl, flipRtlText = isRtl && surface.getFlipRtlText(), rect = surface.getRect(), sizes = size.sizes, blockHeight = size.height, blockWidth = size.width, ln = sizes ? sizes.length : 
    0, lineWidth, i = 0;
    switch(baseline) {
      case 'hanging':
      case 'top':
        break;
      case 'ideographic':
      case 'bottom':
        y -= blockHeight;
        break;
      case 'alphabetic':
        y -= blockHeight * 0.8;
        break;
      case 'middle':
        y -= blockHeight * 0.5;
        break;
    }
    if (flipRtlText) {
      x = rect[2] - rect[0] - x;
      alignment = me.rtlAlignments[alignment];
    }
    switch(alignment) {
      case 'start':
        if (isRtl) {
          for (; i < ln; i++) {
            lineWidth = sizes[i].width;
            dx.push(-(blockWidth - lineWidth));
          }
        }
        break;
      case 'end':
        x -= blockWidth;
        if (isRtl) {
          break;
        }
        for (; i < ln; i++) {
          lineWidth = sizes[i].width;
          dx.push(blockWidth - lineWidth);
        }
        break;
      case 'center':
        x -= blockWidth * 0.5;
        for (; i < ln; i++) {
          lineWidth = sizes[i].width;
          dx.push((isRtl ? -1 : 1) * (blockWidth - lineWidth) * 0.5);
        }
        break;
    }
    attr.textAlignOffsets = dx;
    plain.x = x;
    plain.y = y;
    plain.width = blockWidth;
    plain.height = blockHeight;
  }, setText:function(text) {
    this.setAttributes({text:text}, true);
  }, render:function(surface, ctx, rect) {
    var me = this, attr = me.attr, mat = Ext.draw.Matrix.fly(attr.matrix.elements.slice(0)), bbox = me.getBBox(true), dx = attr.textAlignOffsets, none = Ext.draw.Color.RGBA_NONE, x, y, i, lines, lineHeight;
    if (attr.text.length === 0) {
      return;
    }
    lines = attr.text.split(me.lineBreakRe);
    lineHeight = bbox.height / lines.length;
    x = attr.bbox.plain.x;
    y = attr.bbox.plain.y + lineHeight * 0.78;
    mat.toContext(ctx);
    if (surface.getInherited().rtl) {
      x += attr.bbox.plain.width;
    }
    for (i = 0; i < lines.length; i++) {
      if (ctx.fillStyle !== none) {
        ctx.fillText(lines[i], x + (dx[i] || 0), y + lineHeight * i);
      }
      if (ctx.strokeStyle !== none) {
        ctx.strokeText(lines[i], x + (dx[i] || 0), y + lineHeight * i);
      }
    }
    var debug = attr.debug || this.statics().debug || Ext.draw.sprite.Sprite.debug;
    if (debug) {
      this.attr.inverseMatrix.toContext(ctx);
      debug.bbox && me.renderBBox(surface, ctx);
    }
  }};
});
Ext.define('Ext.draw.sprite.Tick', {extend:Ext.draw.sprite.Line, alias:'sprite.tick', inheritableStatics:{def:{processors:{x:'number', y:'number', size:'number'}, defaults:{x:0, y:0, size:4}, triggers:{x:'tick', y:'tick', size:'tick'}, updaters:{tick:function(attr) {
  var size = attr.size * 1.5, halfLineWidth = attr.lineWidth / 2, x = attr.x, y = attr.y;
  this.setAttributes({fromX:x - halfLineWidth, fromY:y - size, toX:x - halfLineWidth, toY:y + size});
}}}}});
Ext.define('Ext.draw.sprite.Triangle', {extend:Ext.draw.sprite.Path, alias:'sprite.triangle', inheritableStatics:{def:{processors:{x:'number', y:'number', size:'number'}, defaults:{x:0, y:0, size:4}, triggers:{x:'path', y:'path', size:'path'}}}, updatePath:function(path, attr) {
  var s = attr.size * 2.2, x = attr.x, y = attr.y;
  path.fromSvgString('M'.concat(x, ',', y, 'm0-', s * 0.58, 'l', s * 0.5, ',', s * 0.87, '-', s, ',0z'));
}});
Ext.define('Ext.draw.gradient.Linear', {extend:Ext.draw.gradient.Gradient, type:'linear', config:{degrees:0, radians:0}, applyRadians:function(radians, oldRadians) {
  if (Ext.isNumber(radians)) {
    return radians;
  }
  return oldRadians;
}, applyDegrees:function(degrees, oldDegrees) {
  if (Ext.isNumber(degrees)) {
    return degrees;
  }
  return oldDegrees;
}, updateRadians:function(radians) {
  this.setDegrees(Ext.draw.Draw.degrees(radians));
}, updateDegrees:function(degrees) {
  this.setRadians(Ext.draw.Draw.rad(degrees));
}, generateGradient:function(ctx, bbox) {
  var angle = this.getRadians(), cos = Math.cos(angle), sin = Math.sin(angle), w = bbox.width, h = bbox.height, cx = bbox.x + w * 0.5, cy = bbox.y + h * 0.5, stops = this.getStops(), ln = stops.length, gradient, l, i;
  if (Ext.isNumber(cx + cy) && h > 0 && w > 0) {
    l = Math.sqrt(h * h + w * w) * Math.abs(Math.cos(angle - Math.atan(h / w))) / 2;
    gradient = ctx.createLinearGradient(cx + cos * l, cy + sin * l, cx - cos * l, cy - sin * l);
    for (i = 0; i < ln; i++) {
      gradient.addColorStop(stops[i].offset, stops[i].color);
    }
    return gradient;
  }
  return Ext.draw.Color.NONE;
}});
Ext.define('Ext.draw.gradient.Radial', {extend:Ext.draw.gradient.Gradient, type:'radial', config:{start:{x:0, y:0, r:0}, end:{x:0, y:0, r:1}}, applyStart:function(newStart, oldStart) {
  if (!oldStart) {
    return newStart;
  }
  var circle = {x:oldStart.x, y:oldStart.y, r:oldStart.r};
  if ('x' in newStart) {
    circle.x = newStart.x;
  } else {
    if ('centerX' in newStart) {
      circle.x = newStart.centerX;
    }
  }
  if ('y' in newStart) {
    circle.y = newStart.y;
  } else {
    if ('centerY' in newStart) {
      circle.y = newStart.centerY;
    }
  }
  if ('r' in newStart) {
    circle.r = newStart.r;
  } else {
    if ('radius' in newStart) {
      circle.r = newStart.radius;
    }
  }
  return circle;
}, applyEnd:function(newEnd, oldEnd) {
  if (!oldEnd) {
    return newEnd;
  }
  var circle = {x:oldEnd.x, y:oldEnd.y, r:oldEnd.r};
  if ('x' in newEnd) {
    circle.x = newEnd.x;
  } else {
    if ('centerX' in newEnd) {
      circle.x = newEnd.centerX;
    }
  }
  if ('y' in newEnd) {
    circle.y = newEnd.y;
  } else {
    if ('centerY' in newEnd) {
      circle.y = newEnd.centerY;
    }
  }
  if ('r' in newEnd) {
    circle.r = newEnd.r;
  } else {
    if ('radius' in newEnd) {
      circle.r = newEnd.radius;
    }
  }
  return circle;
}, generateGradient:function(ctx, bbox) {
  var start = this.getStart(), end = this.getEnd(), w = bbox.width * 0.5, h = bbox.height * 0.5, x = bbox.x + w, y = bbox.y + h, gradient = ctx.createRadialGradient(x + start.x * w, y + start.y * h, start.r * Math.max(w, h), x + end.x * w, y + end.y * h, end.r * Math.max(w, h)), stops = this.getStops(), ln = stops.length, i;
  for (i = 0; i < ln; i++) {
    gradient.addColorStop(stops[i].offset, stops[i].color);
  }
  return gradient;
}});
Ext.define('Ext.draw.Surface', {extend:Ext.draw.SurfaceBase, xtype:'surface', devicePixelRatio:window.devicePixelRatio || window.screen.deviceXDPI / window.screen.logicalXDPI, deprecated:{'5.1.0':{statics:{methods:{stableSort:function(list) {
  return Ext.Array.sort(list, function(a, b) {
    return a.attr.zIndex - b.attr.zIndex;
  });
}}}}}, config:{cls:Ext.baseCSSPrefix + 'surface', rect:null, background:null, items:[], dirty:false, flipRtlText:false}, isSurface:true, isPendingRenderFrame:false, dirtyPredecessorCount:0, constructor:function(config) {
  var me = this;
  me.predecessors = [];
  me.successors = [];
  me.map = {};
  me.callParent([config]);
  me.matrix = new Ext.draw.Matrix;
  me.inverseMatrix = me.matrix.inverse();
}, roundPixel:function(num) {
  return Math.round(this.devicePixelRatio * num) / this.devicePixelRatio;
}, waitFor:function(surface) {
  var me = this, predecessors = me.predecessors;
  if (!Ext.Array.contains(predecessors, surface)) {
    predecessors.push(surface);
    surface.successors.push(me);
    if (surface.getDirty()) {
      me.dirtyPredecessorCount++;
    }
  }
}, updateDirty:function(dirty) {
  var successors = this.successors, ln = successors.length, i = 0, successor;
  for (; i < ln; i++) {
    successor = successors[i];
    if (dirty) {
      successor.dirtyPredecessorCount++;
      successor.setDirty(true);
    } else {
      successor.dirtyPredecessorCount--;
      if (successor.dirtyPredecessorCount === 0 && successor.isPendingRenderFrame) {
        successor.renderFrame();
      }
    }
  }
}, applyBackground:function(background, oldBackground) {
  this.setDirty(true);
  if (Ext.isString(background)) {
    background = {fillStyle:background};
  }
  return Ext.factory(background, Ext.draw.sprite.Rect, oldBackground);
}, applyRect:function(rect, oldRect) {
  if (oldRect && rect[0] === oldRect[0] && rect[1] === oldRect[1] && rect[2] === oldRect[2] && rect[3] === oldRect[3]) {
    return;
  }
  if (Ext.isArray(rect)) {
    return [rect[0], rect[1], rect[2], rect[3]];
  } else {
    if (Ext.isObject(rect)) {
      return [rect.x || rect.left, rect.y || rect.top, rect.width || rect.right - rect.left, rect.height || rect.bottom - rect.top];
    }
  }
}, updateRect:function(rect) {
  var me = this, l = rect[0], t = rect[1], r = l + rect[2], b = t + rect[3], background = me.getBackground(), element = me.element;
  element.setLocalXY(Math.floor(l), Math.floor(t));
  element.setSize(Math.ceil(r - Math.floor(l)), Math.ceil(b - Math.floor(t)));
  if (background) {
    background.setAttributes({x:0, y:0, width:Math.ceil(r - Math.floor(l)), height:Math.ceil(b - Math.floor(t))});
  }
  me.setDirty(true);
}, resetTransform:function() {
  this.matrix.set(1, 0, 0, 1, 0, 0);
  this.inverseMatrix.set(1, 0, 0, 1, 0, 0);
  this.setDirty(true);
}, get:function(id) {
  return this.map[id] || this.getItems()[id];
}, add:function() {
  var me = this, args = Array.prototype.slice.call(arguments), argIsArray = Ext.isArray(args[0]), map = me.map, results = [], items, item, sprite, i, ln;
  items = Ext.Array.clean(argIsArray ? args[0] : args);
  if (!items.length) {
    return results;
  }
  for (i = 0, ln = items.length; i < ln; i++) {
    item = items[i];
    sprite = null;
    if (item.isSprite && !map[item.getId()]) {
      sprite = item;
    } else {
      if (!map[item.id]) {
        sprite = this.createItem(item);
      }
    }
    if (sprite) {
      map[sprite.getId()] = sprite;
      results.push(sprite);
      sprite.setParent(me);
      sprite.setSurface(me);
      me.onAdd(sprite);
    }
  }
  items = me.getItems();
  if (items) {
    items.push.apply(items, results);
  }
  me.dirtyZIndex = true;
  me.setDirty(true);
  if (!argIsArray && results.length === 1) {
    return results[0];
  } else {
    return results;
  }
}, onAdd:Ext.emptyFn, remove:function(sprite, isDestroy) {
  var me = this, id, isOwnSprite;
  if (sprite) {
    if (sprite.charAt) {
      sprite = me.map[sprite];
    }
    if (!sprite || !sprite.isSprite) {
      return null;
    }
    if (sprite.isDestroyed || sprite.isDestroying) {
      return sprite;
    }
    id = sprite.getId();
    isOwnSprite = me.map[id];
    delete me.map[id];
    if (isDestroy) {
      sprite.destroy();
    }
    if (!isOwnSprite) {
      return sprite;
    }
    sprite.setParent(null);
    sprite.setSurface(null);
    Ext.Array.remove(me.getItems(), sprite);
    me.dirtyZIndex = true;
    me.setDirty(true);
  }
  return sprite || null;
}, removeAll:function(isDestroy) {
  var items = this.getItems(), i = items.length - 1, item;
  if (isDestroy) {
    for (; i >= 0; i--) {
      items[i].destroy();
    }
  } else {
    for (; i >= 0; i--) {
      item = items[i];
      item.setParent(null);
      item.setSurface(null);
    }
  }
  items.length = 0;
  this.map = {};
  this.dirtyZIndex = true;
}, applyItems:function(items) {
  if (this.getItems()) {
    this.removeAll(true);
  }
  return Ext.Array.from(this.add(items));
}, createItem:function(config) {
  return Ext.create(config.xclass || 'sprite.' + config.type, config);
}, getBBox:function(sprites, isWithoutTransform) {
  var sprites = Ext.Array.from(sprites), left = Infinity, right = -Infinity, top = Infinity, bottom = -Infinity, sprite, bbox, i, ln;
  for (i = 0, ln = sprites.length; i < ln; i++) {
    sprite = sprites[i];
    bbox = sprite.getBBox(isWithoutTransform);
    if (left > bbox.x) {
      left = bbox.x;
    }
    if (right < bbox.x + bbox.width) {
      right = bbox.x + bbox.width;
    }
    if (top > bbox.y) {
      top = bbox.y;
    }
    if (bottom < bbox.y + bbox.height) {
      bottom = bbox.y + bbox.height;
    }
  }
  return {x:left, y:top, width:right - left, height:bottom - top};
}, emptyRect:[0, 0, 0, 0], getEventXY:function(e) {
  var me = this, isRtl = me.getInherited().rtl, pageXY = e.getXY(), container = me.getOwnerBody(), xy = container.getXY(), rect = me.getRect() || me.emptyRect, result = [], width;
  if (isRtl) {
    width = container.getWidth();
    result[0] = xy[0] - pageXY[0] - rect[0] + width;
  } else {
    result[0] = pageXY[0] - xy[0] - rect[0];
  }
  result[1] = pageXY[1] - xy[1] - rect[1];
  return result;
}, clear:Ext.emptyFn, orderByZIndex:function() {
  var me = this, items = me.getItems(), dirtyZIndex = false, i, ln;
  if (me.getDirty()) {
    for (i = 0, ln = items.length; i < ln; i++) {
      if (items[i].attr.dirtyZIndex) {
        dirtyZIndex = true;
        break;
      }
    }
    if (dirtyZIndex) {
      Ext.Array.sort(items, function(a, b) {
        return a.attr.zIndex - b.attr.zIndex;
      });
      this.setDirty(true);
    }
    for (i = 0, ln = items.length; i < ln; i++) {
      items[i].attr.dirtyZIndex = false;
    }
  }
}, repaint:function() {
  var me = this;
  me.repaint = Ext.emptyFn;
  Ext.defer(function() {
    delete me.repaint;
    me.element.repaint();
  }, 1);
}, renderFrame:function() {
  var me = this;
  if (!me.element) {
    return;
  }
  if (me.dirtyPredecessorCount > 0) {
    me.isPendingRenderFrame = true;
    return;
  }
  var rect = me.getRect(), background = me.getBackground(), items = me.getItems(), item, i, ln;
  if (!rect) {
    return;
  }
  me.orderByZIndex();
  if (me.getDirty()) {
    me.clear();
    me.clearTransform();
    if (background) {
      me.renderSprite(background);
    }
    for (i = 0, ln = items.length; i < ln; i++) {
      item = items[i];
      if (me.renderSprite(item) === false) {
        return;
      }
      item.attr.textPositionCount = me.textPosition;
    }
    me.setDirty(false);
  }
}, renderSprite:Ext.emptyFn, clearTransform:Ext.emptyFn, destroy:function() {
  var me = this;
  me.removeAll(true);
  me.predecessors = null;
  me.successors = null;
  me.callParent();
}});
Ext.define('Ext.draw.overrides.Surface', {override:'Ext.draw.Surface', hitTest:function(point, options) {
  var me = this, sprites = me.getItems(), i, sprite, result;
  options = options || Ext.draw.sprite.Sprite.defaultHitTestOptions;
  for (i = sprites.length - 1; i >= 0; i--) {
    sprite = sprites[i];
    if (sprite.hitTest) {
      result = sprite.hitTest(point, options);
      if (result) {
        return result;
      }
    }
  }
  return null;
}, hitTestEvent:function(event, options) {
  var xy = this.getEventXY(event);
  return this.hitTest(xy, options);
}});
Ext.define('Ext.draw.engine.SvgContext', {toSave:['strokeOpacity', 'strokeStyle', 'fillOpacity', 'fillStyle', 'globalAlpha', 'lineWidth', 'lineCap', 'lineJoin', 'lineDash', 'lineDashOffset', 'miterLimit', 'shadowOffsetX', 'shadowOffsetY', 'shadowBlur', 'shadowColor', 'globalCompositeOperation', 'position', 'fillGradient', 'strokeGradient'], 'strokeOpacity':1, 'strokeStyle':'none', 'fillOpacity':1, 'fillStyle':'none', 'lineDash':[], 'lineDashOffset':0, 'globalAlpha':1, 'lineWidth':1, 'lineCap':'butt', 
'lineJoin':'miter', 'miterLimit':10, 'shadowOffsetX':0, 'shadowOffsetY':0, 'shadowBlur':0, 'shadowColor':'none', 'globalCompositeOperation':'src', urlStringRe:/^url\(#([\w\-]+)\)$/, constructor:function(SvgSurface) {
  this.surface = SvgSurface;
  this.state = [];
  this.matrix = new Ext.draw.Matrix;
  this.path = null;
  this.clear();
}, clear:function() {
  this.group = this.surface.mainGroup;
  this.position = 0;
  this.path = null;
}, getElement:function(tag) {
  return this.surface.getSvgElement(this.group, tag, this.position++);
}, removeElement:function(element) {
  var element = Ext.fly(element), fill, stroke, fillMatch, strokeMatch, gradients, gradient, key;
  if (!element) {
    return;
  }
  if (element.dom.tagName === 'g') {
    gradients = element.dom.gradients;
    for (key in gradients) {
      gradients[key].destroy();
    }
  } else {
    fill = element.getAttribute('fill');
    stroke = element.getAttribute('stroke');
    fillMatch = fill && fill.match(this.urlStringRe);
    strokeMatch = stroke && stroke.match(this.urlStringRe);
    if (fillMatch && fillMatch[1]) {
      gradient = Ext.fly(fillMatch[1]);
      if (gradient) {
        gradient.destroy();
      }
    }
    if (strokeMatch && strokeMatch[1]) {
      gradient = Ext.fly(strokeMatch[1]);
      if (gradient) {
        gradient.destroy();
      }
    }
  }
  element.destroy();
}, save:function() {
  var toSave = this.toSave, obj = {}, group = this.getElement('g'), key, i;
  for (i = 0; i < toSave.length; i++) {
    key = toSave[i];
    if (key in this) {
      obj[key] = this[key];
    }
  }
  this.position = 0;
  obj.matrix = this.matrix.clone();
  this.state.push(obj);
  this.group = group;
  return group;
}, restore:function() {
  var toSave = this.toSave, obj = this.state.pop(), children = this.group.dom.childNodes, key, i;
  while (children.length > this.position) {
    this.removeElement(children[children.length - 1]);
  }
  for (i = 0; i < toSave.length; i++) {
    key = toSave[i];
    if (key in obj) {
      this[key] = obj[key];
    } else {
      delete this[key];
    }
  }
  this.setTransform.apply(this, obj.matrix.elements);
  this.group = this.group.getParent();
}, transform:function(xx, yx, xy, yy, dx, dy) {
  if (this.path) {
    var inv = Ext.draw.Matrix.fly([xx, yx, xy, yy, dx, dy]).inverse();
    this.path.transform(inv);
  }
  this.matrix.append(xx, yx, xy, yy, dx, dy);
}, setTransform:function(xx, yx, xy, yy, dx, dy) {
  if (this.path) {
    this.path.transform(this.matrix);
  }
  this.matrix.reset();
  this.transform(xx, yx, xy, yy, dx, dy);
}, scale:function(x, y) {
  this.transform(x, 0, 0, y, 0, 0);
}, rotate:function(angle) {
  var xx = Math.cos(angle), yx = Math.sin(angle), xy = -Math.sin(angle), yy = Math.cos(angle);
  this.transform(xx, yx, xy, yy, 0, 0);
}, translate:function(x, y) {
  this.transform(1, 0, 0, 1, x, y);
}, setGradientBBox:function(bbox) {
  this.bbox = bbox;
}, beginPath:function() {
  this.path = new Ext.draw.Path;
}, moveTo:function(x, y) {
  if (!this.path) {
    this.beginPath();
  }
  this.path.moveTo(x, y);
  this.path.element = null;
}, lineTo:function(x, y) {
  if (!this.path) {
    this.beginPath();
  }
  this.path.lineTo(x, y);
  this.path.element = null;
}, rect:function(x, y, width, height) {
  this.moveTo(x, y);
  this.lineTo(x + width, y);
  this.lineTo(x + width, y + height);
  this.lineTo(x, y + height);
  this.closePath();
}, strokeRect:function(x, y, width, height) {
  this.beginPath();
  this.rect(x, y, width, height);
  this.stroke();
}, fillRect:function(x, y, width, height) {
  this.beginPath();
  this.rect(x, y, width, height);
  this.fill();
}, closePath:function() {
  if (!this.path) {
    this.beginPath();
  }
  this.path.closePath();
  this.path.element = null;
}, arcSvg:function(r1, r2, rotation, large, swipe, x2, y2) {
  if (!this.path) {
    this.beginPath();
  }
  this.path.arcSvg(r1, r2, rotation, large, swipe, x2, y2);
  this.path.element = null;
}, arc:function(x, y, radius, startAngle, endAngle, anticlockwise) {
  if (!this.path) {
    this.beginPath();
  }
  this.path.arc(x, y, radius, startAngle, endAngle, anticlockwise);
  this.path.element = null;
}, ellipse:function(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
  if (!this.path) {
    this.beginPath();
  }
  this.path.ellipse(x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise);
  this.path.element = null;
}, arcTo:function(x1, y1, x2, y2, radiusX, radiusY, rotation) {
  if (!this.path) {
    this.beginPath();
  }
  this.path.arcTo(x1, y1, x2, y2, radiusX, radiusY, rotation);
  this.path.element = null;
}, bezierCurveTo:function(x1, y1, x2, y2, x3, y3) {
  if (!this.path) {
    this.beginPath();
  }
  this.path.bezierCurveTo(x1, y1, x2, y2, x3, y3);
  this.path.element = null;
}, strokeText:function(text, x, y) {
  text = String(text);
  if (this.strokeStyle) {
    var element = this.getElement('text'), tspan = this.surface.getSvgElement(element, 'tspan', 0);
    this.surface.setElementAttributes(element, {'x':x, 'y':y, 'transform':this.matrix.toSvg(), 'stroke':this.strokeStyle, 'fill':'none', 'opacity':this.globalAlpha, 'stroke-opacity':this.strokeOpacity, 'style':'font: ' + this.font, 'stroke-dasharray':this.lineDash.join(','), 'stroke-dashoffset':this.lineDashOffset});
    if (this.lineDash.length) {
      this.surface.setElementAttributes(element, {'stroke-dasharray':this.lineDash.join(','), 'stroke-dashoffset':this.lineDashOffset});
    }
    if (tspan.dom.firstChild) {
      tspan.dom.removeChild(tspan.dom.firstChild);
    }
    this.surface.setElementAttributes(tspan, {'alignment-baseline':'alphabetic'});
    tspan.dom.appendChild(document.createTextNode(Ext.String.htmlDecode(text)));
  }
}, fillText:function(text, x, y) {
  text = String(text);
  if (this.fillStyle) {
    var element = this.getElement('text'), tspan = this.surface.getSvgElement(element, 'tspan', 0);
    this.surface.setElementAttributes(element, {'x':x, 'y':y, 'transform':this.matrix.toSvg(), 'fill':this.fillStyle, 'opacity':this.globalAlpha, 'fill-opacity':this.fillOpacity, 'style':'font: ' + this.font});
    if (tspan.dom.firstChild) {
      tspan.dom.removeChild(tspan.dom.firstChild);
    }
    this.surface.setElementAttributes(tspan, {'alignment-baseline':'alphabetic'});
    tspan.dom.appendChild(document.createTextNode(Ext.String.htmlDecode(text)));
  }
}, drawImage:function(image, sx, sy, sw, sh, dx, dy, dw, dh) {
  var me = this, element = me.getElement('image'), x = sx, y = sy, width = typeof sw === 'undefined' ? image.width : sw, height = typeof sh === 'undefined' ? image.height : sh, viewBox = null;
  if (typeof dh !== 'undefined') {
    viewBox = sx + ' ' + sy + ' ' + sw + ' ' + sh;
    x = dx;
    y = dy;
    width = dw;
    height = dh;
  }
  element.dom.setAttributeNS('http:/' + '/www.w3.org/1999/xlink', 'href', image.src);
  me.surface.setElementAttributes(element, {viewBox:viewBox, x:x, y:y, width:width, height:height, opacity:me.globalAlpha, transform:me.matrix.toSvg()});
}, fill:function() {
  if (!this.path) {
    return;
  }
  if (this.fillStyle) {
    var path, fillGradient = this.fillGradient, bbox = this.bbox, element = this.path.element;
    if (!element) {
      path = this.path.toString();
      element = this.path.element = this.getElement('path');
      this.surface.setElementAttributes(element, {'d':path, 'transform':this.matrix.toSvg()});
    }
    this.surface.setElementAttributes(element, {'fill':fillGradient && bbox ? fillGradient.generateGradient(this, bbox) : this.fillStyle, 'fill-opacity':this.fillOpacity * this.globalAlpha});
  }
}, stroke:function() {
  if (!this.path) {
    return;
  }
  if (this.strokeStyle) {
    var path, strokeGradient = this.strokeGradient, bbox = this.bbox, element = this.path.element;
    if (!element || !this.path.svgString) {
      path = this.path.toString();
      if (!path) {
        return;
      }
      element = this.path.element = this.getElement('path');
      this.surface.setElementAttributes(element, {'fill':'none', 'd':path, 'transform':this.matrix.toSvg()});
    }
    this.surface.setElementAttributes(element, {'stroke':strokeGradient && bbox ? strokeGradient.generateGradient(this, bbox) : this.strokeStyle, 'stroke-linecap':this.lineCap, 'stroke-linejoin':this.lineJoin, 'stroke-width':this.lineWidth, 'stroke-opacity':this.strokeOpacity * this.globalAlpha, 'stroke-dasharray':this.lineDash.join(','), 'stroke-dashoffset':this.lineDashOffset});
    if (this.lineDash.length) {
      this.surface.setElementAttributes(element, {'stroke-dasharray':this.lineDash.join(','), 'stroke-dashoffset':this.lineDashOffset});
    }
  }
}, fillStroke:function(attr, transformFillStroke) {
  var ctx = this, fillStyle = ctx.fillStyle, strokeStyle = ctx.strokeStyle, fillOpacity = ctx.fillOpacity, strokeOpacity = ctx.strokeOpacity;
  if (transformFillStroke === undefined) {
    transformFillStroke = attr.transformFillStroke;
  }
  if (!transformFillStroke) {
    attr.inverseMatrix.toContext(ctx);
  }
  if (fillStyle && fillOpacity !== 0) {
    ctx.fill();
  }
  if (strokeStyle && strokeOpacity !== 0) {
    ctx.stroke();
  }
}, appendPath:function(path) {
  this.path = path.clone();
}, setLineDash:function(lineDash) {
  this.lineDash = lineDash;
}, getLineDash:function() {
  return this.lineDash;
}, createLinearGradient:function(x0, y0, x1, y1) {
  var me = this, element = me.surface.getNextDef('linearGradient'), gradients = me.group.dom.gradients || (me.group.dom.gradients = {}), gradient;
  me.surface.setElementAttributes(element, {'x1':x0, 'y1':y0, 'x2':x1, 'y2':y1, 'gradientUnits':'userSpaceOnUse'});
  gradient = new Ext.draw.engine.SvgContext.Gradient(me, me.surface, element);
  gradients[element.dom.id] = gradient;
  return gradient;
}, createRadialGradient:function(x0, y0, r0, x1, y1, r1) {
  var me = this, element = me.surface.getNextDef('radialGradient'), gradients = me.group.dom.gradients || (me.group.dom.gradients = {}), gradient;
  me.surface.setElementAttributes(element, {'fx':x0, 'fy':y0, 'cx':x1, 'cy':y1, 'r':r1, 'gradientUnits':'userSpaceOnUse'});
  gradient = new Ext.draw.engine.SvgContext.Gradient(me, me.surface, element, r0 / r1);
  gradients[element.dom.id] = gradient;
  return gradient;
}});
Ext.define('Ext.draw.engine.SvgContext.Gradient', {statics:{map:{}}, constructor:function(ctx, surface, element, compression) {
  var map = this.statics().map, oldInstance;
  oldInstance = map[element.dom.id];
  if (oldInstance) {
    oldInstance.element = null;
  }
  map[element.dom.id] = this;
  this.ctx = ctx;
  this.surface = surface;
  this.element = element;
  this.position = 0;
  this.compression = compression || 0;
}, addColorStop:function(offset, color) {
  var stop = this.surface.getSvgElement(this.element, 'stop', this.position++), compression = this.compression;
  this.surface.setElementAttributes(stop, {'offset':(((1 - compression) * offset + compression) * 100).toFixed(2) + '%', 'stop-color':color, 'stop-opacity':Ext.draw.Color.fly(color).a.toFixed(15)});
}, toString:function() {
  var children = this.element.dom.childNodes;
  while (children.length > this.position) {
    Ext.fly(children[children.length - 1]).destroy();
  }
  return 'url(#' + this.element.getId() + ')';
}, destroy:function() {
  var map = this.statics().map, element = this.element;
  if (element && element.dom) {
    delete map[element.dom.id];
    element.destroy();
  }
  this.callParent();
}});
Ext.define('Ext.draw.engine.Svg', {extend:Ext.draw.Surface, statics:{BBoxTextCache:{}}, config:{highPrecision:false}, getElementConfig:function() {
  return {reference:'element', style:{position:'absolute'}, children:[{reference:'innerElement', style:{width:'100%', height:'100%', position:'relative'}, children:[{tag:'svg', reference:'svgElement', namespace:'http://www.w3.org/2000/svg', width:'100%', height:'100%', version:1.1}]}]};
}, constructor:function(config) {
  var me = this;
  me.callParent([config]);
  me.mainGroup = me.createSvgNode('g');
  me.defElement = me.createSvgNode('defs');
  me.svgElement.appendChild(me.mainGroup);
  me.svgElement.appendChild(me.defElement);
  me.ctx = new Ext.draw.engine.SvgContext(me);
}, createSvgNode:function(type) {
  var node = document.createElementNS('http://www.w3.org/2000/svg', type);
  return Ext.get(node);
}, getSvgElement:function(group, tag, position) {
  var element;
  if (group.dom.childNodes.length > position) {
    element = group.dom.childNodes[position];
    if (element.tagName === tag) {
      return Ext.get(element);
    } else {
      Ext.destroy(element);
    }
  }
  element = Ext.get(this.createSvgNode(tag));
  if (position === 0) {
    group.insertFirst(element);
  } else {
    element.insertAfter(Ext.fly(group.dom.childNodes[position - 1]));
  }
  element.cache = {};
  return element;
}, setElementAttributes:function(element, attributes) {
  var dom = element.dom, cache = element.cache, name, value;
  for (name in attributes) {
    value = attributes[name];
    if (cache[name] !== value) {
      cache[name] = value;
      dom.setAttribute(name, value);
    }
  }
}, getNextDef:function(tagName) {
  return this.getSvgElement(this.defElement, tagName, this.defPosition++);
}, clearTransform:function() {
  var me = this;
  me.mainGroup.set({transform:me.matrix.toSvg()});
}, clear:function() {
  this.ctx.clear();
  this.defPosition = 0;
}, renderSprite:function(sprite) {
  var me = this, rect = me.getRect(), ctx = me.ctx;
  if (sprite.attr.hidden || sprite.attr.globalAlpha === 0) {
    ctx.save();
    ctx.restore();
    return;
  }
  sprite.element = ctx.save();
  sprite.preRender(this);
  sprite.useAttributes(ctx, rect);
  if (false === sprite.render(this, ctx, [0, 0, rect[2], rect[3]])) {
    return false;
  }
  sprite.setDirty(false);
  ctx.restore();
}, flatten:function(size, surfaces) {
  var svg = '\x3c?xml version\x3d"1.0" standalone\x3d"yes"?\x3e', className = Ext.getClassName(this), surface, rect, i;
  svg += '\x3csvg version\x3d"1.1" baseProfile\x3d"full" xmlns\x3d"http://www.w3.org/2000/svg"' + ' width\x3d"' + size.width + '"' + ' height\x3d"' + size.height + '"\x3e';
  for (i = 0; i < surfaces.length; i++) {
    surface = surfaces[i];
    if (Ext.getClassName(surface) !== className) {
      continue;
    }
    rect = surface.getRect();
    svg += '\x3cg transform\x3d"translate(' + rect[0] + ',' + rect[1] + ')"\x3e';
    svg += this.serializeNode(surface.svgElement.dom);
    svg += '\x3c/g\x3e';
  }
  svg += '\x3c/svg\x3e';
  return {data:'data:image/svg+xml;utf8,' + encodeURIComponent(svg), type:'svg'};
}, serializeNode:function(node) {
  var result = '', i, n, attr, child;
  if (node.nodeType === document.TEXT_NODE) {
    return node.nodeValue;
  }
  result += '\x3c' + node.nodeName;
  if (node.attributes.length) {
    for (i = 0, n = node.attributes.length; i < n; i++) {
      attr = node.attributes[i];
      result += ' ' + attr.name + '\x3d"' + attr.value + '"';
    }
  }
  result += '\x3e';
  if (node.childNodes && node.childNodes.length) {
    for (i = 0, n = node.childNodes.length; i < n; i++) {
      child = node.childNodes[i];
      result += this.serializeNode(child);
    }
  }
  result += '\x3c/' + node.nodeName + '\x3e';
  return result;
}, destroy:function() {
  var me = this;
  me.ctx.destroy();
  me.mainGroup.destroy();
  delete me.mainGroup;
  delete me.ctx;
  me.callParent();
}, remove:function(sprite, destroySprite) {
  if (sprite && sprite.element) {
    if (this.ctx) {
      this.ctx.removeElement(sprite.element);
    } else {
      sprite.element.destroy();
    }
    sprite.element = null;
  }
  this.callParent(arguments);
}});
Ext.draw || (Ext.draw = {});
Ext.draw.engine || (Ext.draw.engine = {});
Ext.draw.engine.excanvas = true;
if (!document.createElement('canvas').getContext) {
  (function() {
    var m = Math;
    var mr = m.round;
    var ms = m.sin;
    var mc = m.cos;
    var abs = m.abs;
    var sqrt = m.sqrt;
    var Z = 10;
    var Z2 = Z / 2;
    var IE_VERSION = +navigator.userAgent.match(/MSIE ([\d.]+)?/)[1];
    function getContext() {
      return this.context_ || (this.context_ = new CanvasRenderingContext2D_(this));
    }
    var slice = Array.prototype.slice;
    function bind(f, obj, var_args) {
      var a = slice.call(arguments, 2);
      return function() {
        return f.apply(obj, a.concat(slice.call(arguments)));
      };
    }
    function encodeHtmlAttribute(s) {
      return String(s).replace(/&/g, '\x26amp;').replace(/"/g, '\x26quot;');
    }
    function addNamespace(doc, prefix, urn) {
      Ext.onReady(function() {
        if (!doc.namespaces[prefix]) {
          doc.namespaces.add(prefix, urn, '#default#VML');
        }
      });
    }
    function addNamespacesAndStylesheet(doc) {
      addNamespace(doc, 'g_vml_', 'urn:schemas-microsoft-com:vml');
      addNamespace(doc, 'g_o_', 'urn:schemas-microsoft-com:office:office');
      if (!doc.styleSheets['ex_canvas_']) {
        var ss = doc.createStyleSheet();
        ss.owningElement.id = 'ex_canvas_';
        ss.cssText = 'canvas{display:inline-block;overflow:hidden;' + 'text-align:left;width:300px;height:150px}';
      }
    }
    addNamespacesAndStylesheet(document);
    var G_vmlCanvasManager_ = {init:function(opt_doc) {
      var doc = opt_doc || document;
      doc.createElement('canvas');
      doc.attachEvent('onreadystatechange', bind(this.init_, this, doc));
    }, init_:function(doc) {
      var els = doc.getElementsByTagName('canvas');
      for (var i = 0; i < els.length; i++) {
        this.initElement(els[i]);
      }
    }, initElement:function(el) {
      if (!el.getContext) {
        el.getContext = getContext;
        addNamespacesAndStylesheet(el.ownerDocument);
        el.innerHTML = '';
        el.attachEvent('onpropertychange', onPropertyChange);
        el.attachEvent('onresize', onResize);
        var attrs = el.attributes;
        if (attrs.width && attrs.width.specified) {
          el.style.width = attrs.width.nodeValue + 'px';
        } else {
          el.width = el.clientWidth;
        }
        if (attrs.height && attrs.height.specified) {
          el.style.height = attrs.height.nodeValue + 'px';
        } else {
          el.height = el.clientHeight;
        }
      }
      return el;
    }};
    function onPropertyChange(e) {
      var el = e.srcElement;
      switch(e.propertyName) {
        case 'width':
          el.getContext().clearRect();
          el.style.width = el.attributes.width.nodeValue + 'px';
          el.firstChild.style.width = el.clientWidth + 'px';
          break;
        case 'height':
          el.getContext().clearRect();
          el.style.height = el.attributes.height.nodeValue + 'px';
          el.firstChild.style.height = el.clientHeight + 'px';
          break;
      }
    }
    function onResize(e) {
      var el = e.srcElement;
      if (el.firstChild) {
        el.firstChild.style.width = el.clientWidth + 'px';
        el.firstChild.style.height = el.clientHeight + 'px';
      }
    }
    G_vmlCanvasManager_.init();
    var decToHex = [];
    for (var i = 0; i < 16; i++) {
      for (var j = 0; j < 16; j++) {
        decToHex[i * 16 + j] = i.toString(16) + j.toString(16);
      }
    }
    function createMatrixIdentity() {
      return [[1, 0, 0], [0, 1, 0], [0, 0, 1]];
    }
    function matrixMultiply(m1, m2) {
      var result = createMatrixIdentity();
      for (var x = 0; x < 3; x++) {
        for (var y = 0; y < 3; y++) {
          var sum = 0;
          for (var z = 0; z < 3; z++) {
            sum += m1[x][z] * m2[z][y];
          }
          result[x][y] = sum;
        }
      }
      return result;
    }
    function copyState(o1, o2) {
      o2.fillStyle = o1.fillStyle;
      o2.lineCap = o1.lineCap;
      o2.lineJoin = o1.lineJoin;
      o2.lineDash = o1.lineDash;
      o2.lineWidth = o1.lineWidth;
      o2.miterLimit = o1.miterLimit;
      o2.shadowBlur = o1.shadowBlur;
      o2.shadowColor = o1.shadowColor;
      o2.shadowOffsetX = o1.shadowOffsetX;
      o2.shadowOffsetY = o1.shadowOffsetY;
      o2.strokeStyle = o1.strokeStyle;
      o2.globalAlpha = o1.globalAlpha;
      o2.font = o1.font;
      o2.textAlign = o1.textAlign;
      o2.textBaseline = o1.textBaseline;
      o2.arcScaleX_ = o1.arcScaleX_;
      o2.arcScaleY_ = o1.arcScaleY_;
      o2.lineScale_ = o1.lineScale_;
    }
    var colorData = {aliceblue:'#F0F8FF', antiquewhite:'#FAEBD7', aquamarine:'#7FFFD4', azure:'#F0FFFF', beige:'#F5F5DC', bisque:'#FFE4C4', black:'#000000', blanchedalmond:'#FFEBCD', blueviolet:'#8A2BE2', brown:'#A52A2A', burlywood:'#DEB887', cadetblue:'#5F9EA0', chartreuse:'#7FFF00', chocolate:'#D2691E', coral:'#FF7F50', cornflowerblue:'#6495ED', cornsilk:'#FFF8DC', crimson:'#DC143C', cyan:'#00FFFF', darkblue:'#00008B', darkcyan:'#008B8B', darkgoldenrod:'#B8860B', darkgray:'#A9A9A9', darkgreen:'#006400', 
    darkgrey:'#A9A9A9', darkkhaki:'#BDB76B', darkmagenta:'#8B008B', darkolivegreen:'#556B2F', darkorange:'#FF8C00', darkorchid:'#9932CC', darkred:'#8B0000', darksalmon:'#E9967A', darkseagreen:'#8FBC8F', darkslateblue:'#483D8B', darkslategray:'#2F4F4F', darkslategrey:'#2F4F4F', darkturquoise:'#00CED1', darkviolet:'#9400D3', deeppink:'#FF1493', deepskyblue:'#00BFFF', dimgray:'#696969', dimgrey:'#696969', dodgerblue:'#1E90FF', firebrick:'#B22222', floralwhite:'#FFFAF0', forestgreen:'#228B22', gainsboro:'#DCDCDC', 
    ghostwhite:'#F8F8FF', gold:'#FFD700', goldenrod:'#DAA520', grey:'#808080', greenyellow:'#ADFF2F', honeydew:'#F0FFF0', hotpink:'#FF69B4', indianred:'#CD5C5C', indigo:'#4B0082', ivory:'#FFFFF0', khaki:'#F0E68C', lavender:'#E6E6FA', lavenderblush:'#FFF0F5', lawngreen:'#7CFC00', lemonchiffon:'#FFFACD', lightblue:'#ADD8E6', lightcoral:'#F08080', lightcyan:'#E0FFFF', lightgoldenrodyellow:'#FAFAD2', lightgreen:'#90EE90', lightgrey:'#D3D3D3', lightpink:'#FFB6C1', lightsalmon:'#FFA07A', lightseagreen:'#20B2AA', 
    lightskyblue:'#87CEFA', lightslategray:'#778899', lightslategrey:'#778899', lightsteelblue:'#B0C4DE', lightyellow:'#FFFFE0', limegreen:'#32CD32', linen:'#FAF0E6', magenta:'#FF00FF', mediumaquamarine:'#66CDAA', mediumblue:'#0000CD', mediumorchid:'#BA55D3', mediumpurple:'#9370DB', mediumseagreen:'#3CB371', mediumslateblue:'#7B68EE', mediumspringgreen:'#00FA9A', mediumturquoise:'#48D1CC', mediumvioletred:'#C71585', midnightblue:'#191970', mintcream:'#F5FFFA', mistyrose:'#FFE4E1', moccasin:'#FFE4B5', 
    navajowhite:'#FFDEAD', oldlace:'#FDF5E6', olivedrab:'#6B8E23', orange:'#FFA500', orangered:'#FF4500', orchid:'#DA70D6', palegoldenrod:'#EEE8AA', palegreen:'#98FB98', paleturquoise:'#AFEEEE', palevioletred:'#DB7093', papayawhip:'#FFEFD5', peachpuff:'#FFDAB9', peru:'#CD853F', pink:'#FFC0CB', plum:'#DDA0DD', powderblue:'#B0E0E6', rosybrown:'#BC8F8F', royalblue:'#4169E1', saddlebrown:'#8B4513', salmon:'#FA8072', sandybrown:'#F4A460', seagreen:'#2E8B57', seashell:'#FFF5EE', sienna:'#A0522D', skyblue:'#87CEEB', 
    slateblue:'#6A5ACD', slategray:'#708090', slategrey:'#708090', snow:'#FFFAFA', springgreen:'#00FF7F', steelblue:'#4682B4', tan:'#D2B48C', thistle:'#D8BFD8', tomato:'#FF6347', turquoise:'#40E0D0', violet:'#EE82EE', wheat:'#F5DEB3', whitesmoke:'#F5F5F5', yellowgreen:'#9ACD32'};
    function getRgbHslContent(styleString) {
      var start = styleString.indexOf('(', 3);
      var end = styleString.indexOf(')', start + 1);
      var parts = styleString.substring(start + 1, end).split(',');
      if (parts.length != 4 || styleString.charAt(3) != 'a') {
        parts[3] = 1;
      }
      return parts;
    }
    function percent(s) {
      return parseFloat(s) / 100;
    }
    function clamp(v, min, max) {
      return Math.min(max, Math.max(min, v));
    }
    function hslToRgb(parts) {
      var r, g, b, h, s, l;
      h = parseFloat(parts[0]) / 360 % 360;
      if (h < 0) {
        h++;
      }
      s = clamp(percent(parts[1]), 0, 1);
      l = clamp(percent(parts[2]), 0, 1);
      if (s == 0) {
        r = g = b = l;
      } else {
        var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        var p = 2 * l - q;
        r = hueToRgb(p, q, h + 1 / 3);
        g = hueToRgb(p, q, h);
        b = hueToRgb(p, q, h - 1 / 3);
      }
      return '#' + decToHex[Math.floor(r * 255)] + decToHex[Math.floor(g * 255)] + decToHex[Math.floor(b * 255)];
    }
    function hueToRgb(m1, m2, h) {
      if (h < 0) {
        h++;
      }
      if (h > 1) {
        h--;
      }
      if (6 * h < 1) {
        return m1 + (m2 - m1) * 6 * h;
      } else {
        if (2 * h < 1) {
          return m2;
        } else {
          if (3 * h < 2) {
            return m1 + (m2 - m1) * (2 / 3 - h) * 6;
          } else {
            return m1;
          }
        }
      }
    }
    var processStyleCache = {};
    function processStyle(styleString) {
      if (styleString in processStyleCache) {
        return processStyleCache[styleString];
      }
      var str, alpha = 1;
      styleString = String(styleString);
      if (styleString.charAt(0) == '#') {
        str = styleString;
      } else {
        if (/^rgb/.test(styleString)) {
          var parts = getRgbHslContent(styleString);
          var str = '#', n;
          for (var i = 0; i < 3; i++) {
            if (parts[i].indexOf('%') != -1) {
              n = Math.floor(percent(parts[i]) * 255);
            } else {
              n = +parts[i];
            }
            str += decToHex[clamp(n, 0, 255)];
          }
          alpha = +parts[3];
        } else {
          if (/^hsl/.test(styleString)) {
            var parts = getRgbHslContent(styleString);
            str = hslToRgb(parts);
            alpha = parts[3];
          } else {
            str = colorData[styleString] || styleString;
          }
        }
      }
      return processStyleCache[styleString] = {color:str, alpha:alpha};
    }
    var DEFAULT_STYLE = {style:'normal', variant:'normal', weight:'normal', size:10, family:'sans-serif'};
    var fontStyleCache = {};
    function processFontStyle(styleString) {
      if (fontStyleCache[styleString]) {
        return fontStyleCache[styleString];
      }
      var el = document.createElement('div');
      var style = el.style;
      try {
        style.font = styleString;
      } catch (ex) {
      }
      return fontStyleCache[styleString] = {style:style.fontStyle || DEFAULT_STYLE.style, variant:style.fontVariant || DEFAULT_STYLE.variant, weight:style.fontWeight || DEFAULT_STYLE.weight, size:style.fontSize || DEFAULT_STYLE.size, family:style.fontFamily || DEFAULT_STYLE.family};
    }
    function getComputedStyle(style, element) {
      var computedStyle = {};
      for (var p in style) {
        computedStyle[p] = style[p];
      }
      var canvasFontSize = parseFloat(element.currentStyle.fontSize), fontSize = parseFloat(style.size);
      if (typeof style.size == 'number') {
        computedStyle.size = style.size;
      } else {
        if (style.size.indexOf('px') != -1) {
          computedStyle.size = fontSize;
        } else {
          if (style.size.indexOf('em') != -1) {
            computedStyle.size = canvasFontSize * fontSize;
          } else {
            if (style.size.indexOf('%') != -1) {
              computedStyle.size = canvasFontSize / 100 * fontSize;
            } else {
              if (style.size.indexOf('pt') != -1) {
                computedStyle.size = fontSize / 0.75;
              } else {
                computedStyle.size = canvasFontSize;
              }
            }
          }
        }
      }
      computedStyle.size *= 0.981;
      return computedStyle;
    }
    function buildStyle(style) {
      return style.style + ' ' + style.variant + ' ' + style.weight + ' ' + style.size + 'px ' + style.family;
    }
    var lineCapMap = {'butt':'flat', 'round':'round'};
    function processLineCap(lineCap) {
      return lineCapMap[lineCap] || 'square';
    }
    function CanvasRenderingContext2D_(canvasElement) {
      this.m_ = createMatrixIdentity();
      this.mStack_ = [];
      this.aStack_ = [];
      this.currentPath_ = [];
      this.strokeStyle = '#000';
      this.fillStyle = '#000';
      this.lineWidth = 1;
      this.lineJoin = 'miter';
      this.lineDash = [];
      this.lineCap = 'butt';
      this.miterLimit = Z * 1;
      this.globalAlpha = 1;
      this.font = '10px sans-serif';
      this.textAlign = 'left';
      this.textBaseline = 'alphabetic';
      this.canvas = canvasElement;
      var cssText = 'width:' + canvasElement.clientWidth + 'px;height:' + canvasElement.clientHeight + 'px;overflow:hidden;position:absolute';
      var el = canvasElement.ownerDocument.createElement('div');
      el.style.cssText = cssText;
      canvasElement.appendChild(el);
      var overlayEl = el.cloneNode(false);
      overlayEl.style.backgroundColor = 'red';
      overlayEl.style.filter = 'alpha(opacity\x3d0)';
      canvasElement.appendChild(overlayEl);
      this.element_ = el;
      this.arcScaleX_ = 1;
      this.arcScaleY_ = 1;
      this.lineScale_ = 1;
    }
    var contextPrototype = CanvasRenderingContext2D_.prototype;
    contextPrototype.clearRect = function() {
      if (this.textMeasureEl_) {
        this.textMeasureEl_.removeNode(true);
        this.textMeasureEl_ = null;
      }
      this.element_.innerHTML = '';
    };
    contextPrototype.beginPath = function() {
      this.currentPath_ = [];
    };
    contextPrototype.moveTo = function(aX, aY) {
      var p = getCoords(this, aX, aY);
      this.currentPath_.push({type:'moveTo', x:p.x, y:p.y});
      this.currentX_ = p.x;
      this.currentY_ = p.y;
    };
    contextPrototype.lineTo = function(aX, aY) {
      var p = getCoords(this, aX, aY);
      this.currentPath_.push({type:'lineTo', x:p.x, y:p.y});
      this.currentX_ = p.x;
      this.currentY_ = p.y;
    };
    contextPrototype.bezierCurveTo = function(aCP1x, aCP1y, aCP2x, aCP2y, aX, aY) {
      var p = getCoords(this, aX, aY);
      var cp1 = getCoords(this, aCP1x, aCP1y);
      var cp2 = getCoords(this, aCP2x, aCP2y);
      bezierCurveTo(this, cp1, cp2, p);
    };
    function bezierCurveTo(self, cp1, cp2, p) {
      self.currentPath_.push({type:'bezierCurveTo', cp1x:cp1.x, cp1y:cp1.y, cp2x:cp2.x, cp2y:cp2.y, x:p.x, y:p.y});
      self.currentX_ = p.x;
      self.currentY_ = p.y;
    }
    contextPrototype.quadraticCurveTo = function(aCPx, aCPy, aX, aY) {
      var cp = getCoords(this, aCPx, aCPy);
      var p = getCoords(this, aX, aY);
      var cp1 = {x:this.currentX_ + 2 / 3 * (cp.x - this.currentX_), y:this.currentY_ + 2 / 3 * (cp.y - this.currentY_)};
      var cp2 = {x:cp1.x + (p.x - this.currentX_) / 3, y:cp1.y + (p.y - this.currentY_) / 3};
      bezierCurveTo(this, cp1, cp2, p);
    };
    contextPrototype.arc = function(aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise) {
      aRadius *= Z;
      var arcType = aClockwise ? 'at' : 'wa';
      var xStart = aX + mc(aStartAngle) * aRadius - Z2;
      var yStart = aY + ms(aStartAngle) * aRadius - Z2;
      var xEnd = aX + mc(aEndAngle) * aRadius - Z2;
      var yEnd = aY + ms(aEndAngle) * aRadius - Z2;
      if (xStart == xEnd && !aClockwise) {
        xStart += 0.125;
      }
      var p = getCoords(this, aX, aY);
      var pStart = getCoords(this, xStart, yStart);
      var pEnd = getCoords(this, xEnd, yEnd);
      this.currentPath_.push({type:arcType, x:p.x, y:p.y, radius:aRadius, xStart:pStart.x, yStart:pStart.y, xEnd:pEnd.x, yEnd:pEnd.y});
    };
    contextPrototype.rect = function(aX, aY, aWidth, aHeight) {
      this.moveTo(aX, aY);
      this.lineTo(aX + aWidth, aY);
      this.lineTo(aX + aWidth, aY + aHeight);
      this.lineTo(aX, aY + aHeight);
      this.closePath();
    };
    contextPrototype.strokeRect = function(aX, aY, aWidth, aHeight) {
      var oldPath = this.currentPath_;
      this.beginPath();
      this.moveTo(aX, aY);
      this.lineTo(aX + aWidth, aY);
      this.lineTo(aX + aWidth, aY + aHeight);
      this.lineTo(aX, aY + aHeight);
      this.closePath();
      this.stroke();
      this.currentPath_ = oldPath;
    };
    contextPrototype.fillRect = function(aX, aY, aWidth, aHeight) {
      var oldPath = this.currentPath_;
      this.beginPath();
      this.moveTo(aX, aY);
      this.lineTo(aX + aWidth, aY);
      this.lineTo(aX + aWidth, aY + aHeight);
      this.lineTo(aX, aY + aHeight);
      this.closePath();
      this.fill();
      this.currentPath_ = oldPath;
    };
    contextPrototype.createLinearGradient = function(aX0, aY0, aX1, aY1) {
      var gradient = new CanvasGradient_('gradient');
      gradient.x0_ = aX0;
      gradient.y0_ = aY0;
      gradient.x1_ = aX1;
      gradient.y1_ = aY1;
      return gradient;
    };
    contextPrototype.createRadialGradient = function(aX0, aY0, aR0, aX1, aY1, aR1) {
      var gradient = new CanvasGradient_('gradientradial');
      gradient.x0_ = aX0;
      gradient.y0_ = aY0;
      gradient.r0_ = aR0;
      gradient.x1_ = aX1;
      gradient.y1_ = aY1;
      gradient.r1_ = aR1;
      return gradient;
    };
    contextPrototype.drawImage = function(image, var_args) {
      var dx, dy, dw, dh, sx, sy, sw, sh;
      var oldRuntimeWidth = image.runtimeStyle.width;
      var oldRuntimeHeight = image.runtimeStyle.height;
      image.runtimeStyle.width = 'auto';
      image.runtimeStyle.height = 'auto';
      var w = image.width;
      var h = image.height;
      image.runtimeStyle.width = oldRuntimeWidth;
      image.runtimeStyle.height = oldRuntimeHeight;
      if (arguments.length == 3) {
        dx = arguments[1];
        dy = arguments[2];
        sx = sy = 0;
        sw = dw = w;
        sh = dh = h;
      } else {
        if (arguments.length == 5) {
          dx = arguments[1];
          dy = arguments[2];
          dw = arguments[3];
          dh = arguments[4];
          sx = sy = 0;
          sw = w;
          sh = h;
        } else {
          if (arguments.length == 9) {
            sx = arguments[1];
            sy = arguments[2];
            sw = arguments[3];
            sh = arguments[4];
            dx = arguments[5];
            dy = arguments[6];
            dw = arguments[7];
            dh = arguments[8];
          } else {
            throw Error('Invalid number of arguments');
          }
        }
      }
      var d = getCoords(this, dx, dy);
      var vmlStr = [];
      var W = 10;
      var H = 10;
      var m = this.m_;
      vmlStr.push(' \x3cg_vml_:group', ' coordsize\x3d"', Z * W, ',', Z * H, '"', ' coordorigin\x3d"0,0"', ' style\x3d"width:', mr(W * m[0][0]), 'px;height:', mr(H * m[1][1]), 'px;position:absolute;', 'top:', mr(d.y / Z), 'px;left:', mr(d.x / Z), 'px; rotation:', mr(Math.atan(m[0][1] / m[1][1]) * 180 / Math.PI), ';');
      vmlStr.push('" \x3e', '\x3cg_vml_:image src\x3d"', image.src, '"', ' style\x3d"width:', Z * dw, 'px;', ' height:', Z * dh, 'px"', ' cropleft\x3d"', sx / w, '"', ' croptop\x3d"', sy / h, '"', ' cropright\x3d"', (w - sx - sw) / w, '"', ' cropbottom\x3d"', (h - sy - sh) / h, '"', ' /\x3e', '\x3c/g_vml_:group\x3e');
      this.element_.insertAdjacentHTML('BeforeEnd', vmlStr.join(''));
    };
    contextPrototype.setLineDash = function(lineDash) {
      if (lineDash.length === 1) {
        lineDash = lineDash.slice();
        lineDash[1] = lineDash[0];
      }
      this.lineDash = lineDash;
    };
    contextPrototype.getLineDash = function() {
      return this.lineDash;
    };
    contextPrototype.stroke = function(aFill) {
      var lineStr = [];
      var W = 10;
      var H = 10;
      lineStr.push('\x3cg_vml_:shape', ' filled\x3d"', !!aFill, '"', ' style\x3d"position:absolute;width:', W, 'px;height:', H, 'px;left:0px;top:0px;"', ' coordorigin\x3d"0,0"', ' coordsize\x3d"', Z * W, ',', Z * H, '"', ' stroked\x3d"', !aFill, '"', ' path\x3d"');
      var min = {x:null, y:null};
      var max = {x:null, y:null};
      for (var i = 0; i < this.currentPath_.length; i++) {
        var p = this.currentPath_[i];
        var c;
        switch(p.type) {
          case 'moveTo':
            c = p;
            lineStr.push(' m ', mr(p.x), ',', mr(p.y));
            break;
          case 'lineTo':
            lineStr.push(' l ', mr(p.x), ',', mr(p.y));
            break;
          case 'close':
            lineStr.push(' x ');
            p = null;
            break;
          case 'bezierCurveTo':
            lineStr.push(' c ', mr(p.cp1x), ',', mr(p.cp1y), ',', mr(p.cp2x), ',', mr(p.cp2y), ',', mr(p.x), ',', mr(p.y));
            break;
          case 'at':
          case 'wa':
            lineStr.push(' ', p.type, ' ', mr(p.x - this.arcScaleX_ * p.radius), ',', mr(p.y - this.arcScaleY_ * p.radius), ' ', mr(p.x + this.arcScaleX_ * p.radius), ',', mr(p.y + this.arcScaleY_ * p.radius), ' ', mr(p.xStart), ',', mr(p.yStart), ' ', mr(p.xEnd), ',', mr(p.yEnd));
            break;
        }
        if (p) {
          if (min.x == null || p.x < min.x) {
            min.x = p.x;
          }
          if (max.x == null || p.x > max.x) {
            max.x = p.x;
          }
          if (min.y == null || p.y < min.y) {
            min.y = p.y;
          }
          if (max.y == null || p.y > max.y) {
            max.y = p.y;
          }
        }
      }
      lineStr.push(' "\x3e');
      if (!aFill) {
        appendStroke(this, lineStr);
      } else {
        appendFill(this, lineStr, min, max);
      }
      lineStr.push('\x3c/g_vml_:shape\x3e');
      this.element_.insertAdjacentHTML('beforeEnd', lineStr.join(''));
    };
    function appendStroke(ctx, lineStr) {
      var a = processStyle(ctx.strokeStyle);
      var color = a.color;
      var opacity = a.alpha * ctx.globalAlpha;
      var lineWidth = ctx.lineScale_ * ctx.lineWidth;
      if (lineWidth < 1) {
        opacity *= lineWidth;
      }
      lineStr.push('\x3cg_vml_:stroke', ' opacity\x3d"', opacity, '"', ' joinstyle\x3d"', ctx.lineJoin, '"', ' dashstyle\x3d"', ctx.lineDash.join(' '), '"', ' miterlimit\x3d"', ctx.miterLimit, '"', ' endcap\x3d"', processLineCap(ctx.lineCap), '"', ' weight\x3d"', lineWidth, 'px"', ' color\x3d"', color, '" /\x3e');
    }
    function appendFill(ctx, lineStr, min, max) {
      var fillStyle = ctx.fillStyle;
      var arcScaleX = ctx.arcScaleX_;
      var arcScaleY = ctx.arcScaleY_;
      var width = max.x - min.x;
      var height = max.y - min.y;
      if (fillStyle instanceof CanvasGradient_) {
        var angle = 0;
        var focus = {x:0, y:0};
        var shift = 0;
        var expansion = 1;
        if (fillStyle.type_ == 'gradient') {
          var x0 = fillStyle.x0_ / arcScaleX;
          var y0 = fillStyle.y0_ / arcScaleY;
          var x1 = fillStyle.x1_ / arcScaleX;
          var y1 = fillStyle.y1_ / arcScaleY;
          var p0 = getCoords(ctx, x0, y0);
          var p1 = getCoords(ctx, x1, y1);
          var dx = p1.x - p0.x;
          var dy = p1.y - p0.y;
          angle = Math.atan2(dx, dy) * 180 / Math.PI;
          if (angle < 0) {
            angle += 360;
          }
          if (angle < 1.0E-6) {
            angle = 0;
          }
        } else {
          var p0 = getCoords(ctx, fillStyle.x0_, fillStyle.y0_);
          focus = {x:(p0.x - min.x) / width, y:(p0.y - min.y) / height};
          width /= arcScaleX * Z;
          height /= arcScaleY * Z;
          var dimension = m.max(width, height);
          shift = 2 * fillStyle.r0_ / dimension;
          expansion = 2 * fillStyle.r1_ / dimension - shift;
        }
        var stops = fillStyle.colors_;
        stops.sort(function(cs1, cs2) {
          return cs1.offset - cs2.offset;
        });
        var length = stops.length;
        var color1 = stops[0].color;
        var color2 = stops[length - 1].color;
        var opacity1 = stops[0].alpha * ctx.globalAlpha;
        var opacity2 = stops[length - 1].alpha * ctx.globalAlpha;
        var colors = [];
        for (var i = 0; i < length; i++) {
          var stop = stops[i];
          colors.push(stop.offset * expansion + shift + ' ' + stop.color);
        }
        lineStr.push('\x3cg_vml_:fill type\x3d"', fillStyle.type_, '"', ' method\x3d"none" focus\x3d"100%"', ' color\x3d"', color1, '"', ' color2\x3d"', color2, '"', ' colors\x3d"', colors.join(','), '"', ' opacity\x3d"', opacity2, '"', ' g_o_:opacity2\x3d"', opacity1, '"', ' angle\x3d"', angle, '"', ' focusposition\x3d"', focus.x, ',', focus.y, '" /\x3e');
      } else {
        if (fillStyle instanceof CanvasPattern_) {
          if (width && height) {
            var deltaLeft = -min.x;
            var deltaTop = -min.y;
            lineStr.push('\x3cg_vml_:fill', ' position\x3d"', deltaLeft / width * arcScaleX * arcScaleX, ',', deltaTop / height * arcScaleY * arcScaleY, '"', ' type\x3d"tile"', ' src\x3d"', fillStyle.src_, '" /\x3e');
          }
        } else {
          var a = processStyle(ctx.fillStyle);
          var color = a.color;
          var opacity = a.alpha * ctx.globalAlpha;
          lineStr.push('\x3cg_vml_:fill color\x3d"', color, '" opacity\x3d"', opacity, '" /\x3e');
        }
      }
    }
    contextPrototype.fill = function() {
      this.$stroke(true);
    };
    contextPrototype.closePath = function() {
      this.currentPath_.push({type:'close'});
    };
    function getCoords(ctx, aX, aY) {
      var m = ctx.m_;
      return {x:Z * (aX * m[0][0] + aY * m[1][0] + m[2][0]) - Z2, y:Z * (aX * m[0][1] + aY * m[1][1] + m[2][1]) - Z2};
    }
    contextPrototype.save = function() {
      var o = {};
      copyState(this, o);
      this.aStack_.push(o);
      this.mStack_.push(this.m_);
      this.m_ = matrixMultiply(createMatrixIdentity(), this.m_);
    };
    contextPrototype.restore = function() {
      if (this.aStack_.length) {
        copyState(this.aStack_.pop(), this);
        this.m_ = this.mStack_.pop();
      }
    };
    function matrixIsFinite(m) {
      return isFinite(m[0][0]) && isFinite(m[0][1]) && isFinite(m[1][0]) && isFinite(m[1][1]) && isFinite(m[2][0]) && isFinite(m[2][1]);
    }
    function setM(ctx, m, updateLineScale) {
      if (!matrixIsFinite(m)) {
        return;
      }
      ctx.m_ = m;
      if (updateLineScale) {
        var det = m[0][0] * m[1][1] - m[0][1] * m[1][0];
        ctx.lineScale_ = sqrt(abs(det));
      }
    }
    contextPrototype.translate = function(aX, aY) {
      var m1 = [[1, 0, 0], [0, 1, 0], [aX, aY, 1]];
      setM(this, matrixMultiply(m1, this.m_), false);
    };
    contextPrototype.rotate = function(aRot) {
      var c = mc(aRot);
      var s = ms(aRot);
      var m1 = [[c, s, 0], [-s, c, 0], [0, 0, 1]];
      setM(this, matrixMultiply(m1, this.m_), false);
    };
    contextPrototype.scale = function(aX, aY) {
      this.arcScaleX_ *= aX;
      this.arcScaleY_ *= aY;
      var m1 = [[aX, 0, 0], [0, aY, 0], [0, 0, 1]];
      setM(this, matrixMultiply(m1, this.m_), true);
    };
    contextPrototype.transform = function(m11, m12, m21, m22, dx, dy) {
      var m1 = [[m11, m12, 0], [m21, m22, 0], [dx, dy, 1]];
      setM(this, matrixMultiply(m1, this.m_), true);
    };
    contextPrototype.setTransform = function(m11, m12, m21, m22, dx, dy) {
      var m = [[m11, m12, 0], [m21, m22, 0], [dx, dy, 1]];
      setM(this, m, true);
    };
    contextPrototype.drawText_ = function(text, x, y, maxWidth, stroke) {
      var m = this.m_, delta = 1000, left = 0, right = delta, offset = {x:0, y:0}, lineStr = [];
      var fontStyle = getComputedStyle(processFontStyle(this.font), this.element_);
      var fontStyleString = buildStyle(fontStyle);
      var elementStyle = this.element_.currentStyle;
      var textAlign = this.textAlign.toLowerCase();
      switch(textAlign) {
        case 'left':
        case 'center':
        case 'right':
          break;
        case 'end':
          textAlign = elementStyle.direction == 'ltr' ? 'right' : 'left';
          break;
        case 'start':
          textAlign = elementStyle.direction == 'rtl' ? 'right' : 'left';
          break;
        default:
          textAlign = 'left';
      }
      switch(this.textBaseline) {
        case 'hanging':
        case 'top':
          offset.y = fontStyle.size / 1.75;
          break;
        case 'middle':
          break;
        default:
        case null:
        case 'alphabetic':
        case 'ideographic':
        case 'bottom':
          offset.y = -fontStyle.size / 3;
          break;
      }
      switch(textAlign) {
        case 'right':
          left = delta;
          right = 0.05;
          break;
        case 'center':
          left = right = delta / 2;
          break;
      }
      var d = getCoords(this, x + offset.x, y + offset.y);
      lineStr.push('\x3cg_vml_:line from\x3d"', -left, ' 0" to\x3d"', right, ' 0.05" ', ' coordsize\x3d"100 100" coordorigin\x3d"0 0"', ' filled\x3d"', !stroke, '" stroked\x3d"', !!stroke, '" style\x3d"position:absolute;width:1px;height:1px;left:0px;top:0px;"\x3e');
      if (stroke) {
        appendStroke(this, lineStr);
      } else {
        appendFill(this, lineStr, {x:-left, y:0}, {x:right, y:fontStyle.size});
      }
      var skewM = m[0][0].toFixed(3) + ',' + m[1][0].toFixed(3) + ',' + m[0][1].toFixed(3) + ',' + m[1][1].toFixed(3) + ',0,0';
      var skewOffset = mr(d.x / Z) + ',' + mr(d.y / Z);
      lineStr.push('\x3cg_vml_:skew on\x3d"t" matrix\x3d"', skewM, '" ', ' offset\x3d"', skewOffset, '" origin\x3d"', left, ' 0" /\x3e', '\x3cg_vml_:path textpathok\x3d"true" /\x3e', '\x3cg_vml_:textpath on\x3d"true" string\x3d"', encodeHtmlAttribute(text), '" style\x3d"v-text-align:', textAlign, ';font:', encodeHtmlAttribute(fontStyleString), '" /\x3e\x3c/g_vml_:line\x3e');
      this.element_.insertAdjacentHTML('beforeEnd', lineStr.join(''));
    };
    contextPrototype.fillText = function(text, x, y, maxWidth) {
      this.drawText_(text, x, y, maxWidth, false);
    };
    contextPrototype.strokeText = function(text, x, y, maxWidth) {
      this.drawText_(text, x, y, maxWidth, true);
    };
    contextPrototype.measureText = function(text) {
      if (!this.textMeasureEl_) {
        var s = '\x3cspan style\x3d"position:absolute;' + 'top:-20000px;left:0;padding:0;margin:0;border:none;' + 'white-space:pre;"\x3e\x3c/span\x3e';
        this.element_.insertAdjacentHTML('beforeEnd', s);
        this.textMeasureEl_ = this.element_.lastChild;
      }
      var doc = this.element_.ownerDocument;
      this.textMeasureEl_.innerHTML = '';
      this.textMeasureEl_.style.font = this.font;
      this.textMeasureEl_.appendChild(doc.createTextNode(text));
      return {width:this.textMeasureEl_.offsetWidth};
    };
    contextPrototype.clip = function() {
    };
    contextPrototype.arcTo = function() {
    };
    contextPrototype.createPattern = function(image, repetition) {
      return new CanvasPattern_(image, repetition);
    };
    function CanvasGradient_(aType) {
      this.type_ = aType;
      this.x0_ = 0;
      this.y0_ = 0;
      this.r0_ = 0;
      this.x1_ = 0;
      this.y1_ = 0;
      this.r1_ = 0;
      this.colors_ = [];
    }
    CanvasGradient_.prototype.addColorStop = function(aOffset, aColor) {
      aColor = processStyle(aColor);
      this.colors_.push({offset:aOffset, color:aColor.color, alpha:aColor.alpha});
    };
    function CanvasPattern_(image, repetition) {
      assertImageIsValid(image);
      switch(repetition) {
        case 'repeat':
        case null:
        case '':
          this.repetition_ = 'repeat';
          break;
        case 'repeat-x':
        case 'repeat-y':
        case 'no-repeat':
          this.repetition_ = repetition;
          break;
        default:
          throwException('SYNTAX_ERR');
      }
      this.src_ = image.src;
      this.width_ = image.width;
      this.height_ = image.height;
    }
    function throwException(s) {
      throw new DOMException_(s);
    }
    function assertImageIsValid(img) {
      if (!img || img.nodeType != 1 || img.tagName != 'IMG') {
        throwException('TYPE_MISMATCH_ERR');
      }
      if (img.readyState != 'complete') {
        throwException('INVALID_STATE_ERR');
      }
    }
    function DOMException_(s) {
      this.code = this[s];
      this.message = s + ': DOM Exception ' + this.code;
    }
    var p = DOMException_.prototype = new Error;
    p.INDEX_SIZE_ERR = 1;
    p.DOMSTRING_SIZE_ERR = 2;
    p.HIERARCHY_REQUEST_ERR = 3;
    p.WRONG_DOCUMENT_ERR = 4;
    p.INVALID_CHARACTER_ERR = 5;
    p.NO_DATA_ALLOWED_ERR = 6;
    p.NO_MODIFICATION_ALLOWED_ERR = 7;
    p.NOT_FOUND_ERR = 8;
    p.NOT_SUPPORTED_ERR = 9;
    p.INUSE_ATTRIBUTE_ERR = 10;
    p.INVALID_STATE_ERR = 11;
    p.SYNTAX_ERR = 12;
    p.INVALID_MODIFICATION_ERR = 13;
    p.NAMESPACE_ERR = 14;
    p.INVALID_ACCESS_ERR = 15;
    p.VALIDATION_ERR = 16;
    p.TYPE_MISMATCH_ERR = 17;
    G_vmlCanvasManager = G_vmlCanvasManager_;
    CanvasRenderingContext2D = CanvasRenderingContext2D_;
    CanvasGradient = CanvasGradient_;
    CanvasPattern = CanvasPattern_;
    DOMException = DOMException_;
  })();
}
Ext.define('Ext.draw.engine.Canvas', {extend:Ext.draw.Surface, config:{highPrecision:false}, statics:{contextOverrides:{setGradientBBox:function(bbox) {
  this.bbox = bbox;
}, fill:function() {
  var fillStyle = this.fillStyle, fillGradient = this.fillGradient, fillOpacity = this.fillOpacity, alpha = this.globalAlpha, bbox = this.bbox;
  if (fillStyle !== Ext.draw.Color.RGBA_NONE && fillOpacity !== 0) {
    if (fillGradient && bbox) {
      this.fillStyle = fillGradient.generateGradient(this, bbox);
    }
    if (fillOpacity !== 1) {
      this.globalAlpha = alpha * fillOpacity;
    }
    this.$fill();
    if (fillOpacity !== 1) {
      this.globalAlpha = alpha;
    }
    if (fillGradient && bbox) {
      this.fillStyle = fillStyle;
    }
  }
}, stroke:function() {
  var strokeStyle = this.strokeStyle, strokeGradient = this.strokeGradient, strokeOpacity = this.strokeOpacity, alpha = this.globalAlpha, bbox = this.bbox;
  if (strokeStyle !== Ext.draw.Color.RGBA_NONE && strokeOpacity !== 0) {
    if (strokeGradient && bbox) {
      this.strokeStyle = strokeGradient.generateGradient(this, bbox);
    }
    if (strokeOpacity !== 1) {
      this.globalAlpha = alpha * strokeOpacity;
    }
    this.$stroke();
    if (strokeOpacity !== 1) {
      this.globalAlpha = alpha;
    }
    if (strokeGradient && bbox) {
      this.strokeStyle = strokeStyle;
    }
  }
}, fillStroke:function(attr, transformFillStroke) {
  var ctx = this, fillStyle = this.fillStyle, fillOpacity = this.fillOpacity, strokeStyle = this.strokeStyle, strokeOpacity = this.strokeOpacity, shadowColor = ctx.shadowColor, shadowBlur = ctx.shadowBlur, none = Ext.draw.Color.RGBA_NONE;
  if (transformFillStroke === undefined) {
    transformFillStroke = attr.transformFillStroke;
  }
  if (!transformFillStroke) {
    attr.inverseMatrix.toContext(ctx);
  }
  if (fillStyle !== none && fillOpacity !== 0) {
    ctx.fill();
    ctx.shadowColor = none;
    ctx.shadowBlur = 0;
  }
  if (strokeStyle !== none && strokeOpacity !== 0) {
    ctx.stroke();
  }
  ctx.shadowColor = shadowColor;
  ctx.shadowBlur = shadowBlur;
}, setLineDash:function(dashList) {
  if (this.$setLineDash) {
    this.$setLineDash(dashList);
  }
}, getLineDash:function() {
  if (this.$getLineDash) {
    return this.$getLineDash();
  }
}, ellipse:function(cx, cy, rx, ry, rotation, start, end, anticlockwise) {
  var cos = Math.cos(rotation), sin = Math.sin(rotation);
  this.transform(cos * rx, sin * rx, -sin * ry, cos * ry, cx, cy);
  this.arc(0, 0, 1, start, end, anticlockwise);
  this.transform(cos / rx, -sin / ry, sin / rx, cos / ry, -(cos * cx + sin * cy) / rx, (sin * cx - cos * cy) / ry);
}, appendPath:function(path) {
  var me = this, i = 0, j = 0, commands = path.commands, params = path.params, ln = commands.length;
  me.beginPath();
  for (; i < ln; i++) {
    switch(commands[i]) {
      case 'M':
        me.moveTo(params[j], params[j + 1]);
        j += 2;
        break;
      case 'L':
        me.lineTo(params[j], params[j + 1]);
        j += 2;
        break;
      case 'C':
        me.bezierCurveTo(params[j], params[j + 1], params[j + 2], params[j + 3], params[j + 4], params[j + 5]);
        j += 6;
        break;
      case 'Z':
        me.closePath();
        break;
    }
  }
}, save:function() {
  var toSave = this.toSave, ln = toSave.length, obj = ln && {}, i = 0, key;
  for (; i < ln; i++) {
    key = toSave[i];
    if (key in this) {
      obj[key] = this[key];
    }
  }
  this.state.push(obj);
  this.$save();
}, restore:function() {
  var obj = this.state.pop(), key;
  if (obj) {
    for (key in obj) {
      this[key] = obj[key];
    }
  }
  this.$restore();
}}}, splitThreshold:3000, toSave:['fillGradient', 'strokeGradient'], element:{reference:'element', style:{position:'absolute'}, children:[{reference:'innerElement', style:{width:'100%', height:'100%', position:'relative'}}]}, createCanvas:function() {
  var canvas = Ext.Element.create({tag:'canvas', cls:Ext.baseCSSPrefix + 'surface-canvas'});
  window['G_vmlCanvasManager'] && G_vmlCanvasManager.initElement(canvas.dom);
  var overrides = Ext.draw.engine.Canvas.contextOverrides, ctx = canvas.dom.getContext('2d'), name;
  if (ctx.ellipse) {
    delete overrides.ellipse;
  }
  ctx.state = [];
  ctx.toSave = this.toSave;
  for (name in overrides) {
    ctx['$' + name] = ctx[name];
  }
  Ext.apply(ctx, overrides);
  if (this.getHighPrecision()) {
    this.enablePrecisionCompensation(ctx);
  } else {
    this.disablePrecisionCompensation(ctx);
  }
  this.innerElement.appendChild(canvas);
  this.canvases.push(canvas);
  this.contexts.push(ctx);
}, updateHighPrecision:function(highPrecision) {
  var contexts = this.contexts, ln = contexts.length, i, context;
  for (i = 0; i < ln; i++) {
    context = contexts[i];
    if (highPrecision) {
      this.enablePrecisionCompensation(context);
    } else {
      this.disablePrecisionCompensation(context);
    }
  }
}, precisionNames:['rect', 'fillRect', 'strokeRect', 'clearRect', 'moveTo', 'lineTo', 'arc', 'arcTo', 'save', 'restore', 'updatePrecisionCompensate', 'setTransform', 'transform', 'scale', 'translate', 'rotate', 'quadraticCurveTo', 'bezierCurveTo', 'createLinearGradient', 'createRadialGradient', 'fillText', 'strokeText', 'drawImage'], disablePrecisionCompensation:function(ctx) {
  var regularOverrides = Ext.draw.engine.Canvas.contextOverrides, precisionOverrides = this.precisionNames, ln = precisionOverrides.length, i, name;
  for (i = 0; i < ln; i++) {
    name = precisionOverrides[i];
    if (!(name in regularOverrides)) {
      delete ctx[name];
    }
  }
  this.setDirty(true);
}, enablePrecisionCompensation:function(ctx) {
  var surface = this, xx = 1, yy = 1, dx = 0, dy = 0, matrix = new Ext.draw.Matrix, transStack = [], comp = {}, regularOverrides = Ext.draw.engine.Canvas.contextOverrides, originalCtx = ctx.constructor.prototype;
  var precisionOverrides = {toSave:surface.toSave, rect:function(x, y, w, h) {
    return originalCtx.rect.call(this, x * xx + dx, y * yy + dy, w * xx, h * yy);
  }, fillRect:function(x, y, w, h) {
    this.updatePrecisionCompensateRect();
    originalCtx.fillRect.call(this, x * xx + dx, y * yy + dy, w * xx, h * yy);
    this.updatePrecisionCompensate();
  }, strokeRect:function(x, y, w, h) {
    this.updatePrecisionCompensateRect();
    originalCtx.strokeRect.call(this, x * xx + dx, y * yy + dy, w * xx, h * yy);
    this.updatePrecisionCompensate();
  }, clearRect:function(x, y, w, h) {
    return originalCtx.clearRect.call(this, x * xx + dx, y * yy + dy, w * xx, h * yy);
  }, moveTo:function(x, y) {
    return originalCtx.moveTo.call(this, x * xx + dx, y * yy + dy);
  }, lineTo:function(x, y) {
    return originalCtx.lineTo.call(this, x * xx + dx, y * yy + dy);
  }, arc:function(x, y, radius, startAngle, endAngle, anticlockwise) {
    this.updatePrecisionCompensateRect();
    originalCtx.arc.call(this, x * xx + dx, y * xx + dy, radius * xx, startAngle, endAngle, anticlockwise);
    this.updatePrecisionCompensate();
  }, arcTo:function(x1, y1, x2, y2, radius) {
    this.updatePrecisionCompensateRect();
    originalCtx.arcTo.call(this, x1 * xx + dx, y1 * yy + dy, x2 * xx + dx, y2 * yy + dy, radius * xx);
    this.updatePrecisionCompensate();
  }, save:function() {
    transStack.push(matrix);
    matrix = matrix.clone();
    regularOverrides.save.call(this);
    originalCtx.save.call(this);
  }, restore:function() {
    matrix = transStack.pop();
    regularOverrides.restore.call(this);
    originalCtx.restore.call(this);
    this.updatePrecisionCompensate();
  }, updatePrecisionCompensate:function() {
    matrix.precisionCompensate(surface.devicePixelRatio, comp);
    xx = comp.xx;
    yy = comp.yy;
    dx = comp.dx;
    dy = comp.dy;
    originalCtx.setTransform.call(this, surface.devicePixelRatio, comp.b, comp.c, comp.d, 0, 0);
  }, updatePrecisionCompensateRect:function() {
    matrix.precisionCompensateRect(surface.devicePixelRatio, comp);
    xx = comp.xx;
    yy = comp.yy;
    dx = comp.dx;
    dy = comp.dy;
    originalCtx.setTransform.call(this, surface.devicePixelRatio, comp.b, comp.c, comp.d, 0, 0);
  }, setTransform:function(x2x, x2y, y2x, y2y, newDx, newDy) {
    matrix.set(x2x, x2y, y2x, y2y, newDx, newDy);
    this.updatePrecisionCompensate();
  }, transform:function(x2x, x2y, y2x, y2y, newDx, newDy) {
    matrix.append(x2x, x2y, y2x, y2y, newDx, newDy);
    this.updatePrecisionCompensate();
  }, scale:function(sx, sy) {
    this.transform(sx, 0, 0, sy, 0, 0);
  }, translate:function(dx, dy) {
    this.transform(1, 0, 0, 1, dx, dy);
  }, rotate:function(radians) {
    var cos = Math.cos(radians), sin = Math.sin(radians);
    this.transform(cos, sin, -sin, cos, 0, 0);
  }, quadraticCurveTo:function(cx, cy, x, y) {
    originalCtx.quadraticCurveTo.call(this, cx * xx + dx, cy * yy + dy, x * xx + dx, y * yy + dy);
  }, bezierCurveTo:function(c1x, c1y, c2x, c2y, x, y) {
    originalCtx.bezierCurveTo.call(this, c1x * xx + dx, c1y * yy + dy, c2x * xx + dx, c2y * yy + dy, x * xx + dx, y * yy + dy);
  }, createLinearGradient:function(x0, y0, x1, y1) {
    this.updatePrecisionCompensateRect();
    var grad = originalCtx.createLinearGradient.call(this, x0 * xx + dx, y0 * yy + dy, x1 * xx + dx, y1 * yy + dy);
    this.updatePrecisionCompensate();
    return grad;
  }, createRadialGradient:function(x0, y0, r0, x1, y1, r1) {
    this.updatePrecisionCompensateRect();
    var grad = originalCtx.createLinearGradient.call(this, x0 * xx + dx, y0 * xx + dy, r0 * xx, x1 * xx + dx, y1 * xx + dy, r1 * xx);
    this.updatePrecisionCompensate();
    return grad;
  }, fillText:function(text, x, y, maxWidth) {
    originalCtx.setTransform.apply(this, matrix.elements);
    if (typeof maxWidth === 'undefined') {
      originalCtx.fillText.call(this, text, x, y);
    } else {
      originalCtx.fillText.call(this, text, x, y, maxWidth);
    }
    this.updatePrecisionCompensate();
  }, strokeText:function(text, x, y, maxWidth) {
    originalCtx.setTransform.apply(this, matrix.elements);
    if (typeof maxWidth === 'undefined') {
      originalCtx.strokeText.call(this, text, x, y);
    } else {
      originalCtx.strokeText.call(this, text, x, y, maxWidth);
    }
    this.updatePrecisionCompensate();
  }, fill:function() {
    var fillGradient = this.fillGradient, bbox = this.bbox;
    this.updatePrecisionCompensateRect();
    if (fillGradient && bbox) {
      this.fillStyle = fillGradient.generateGradient(this, bbox);
    }
    originalCtx.fill.call(this);
    this.updatePrecisionCompensate();
  }, stroke:function() {
    var strokeGradient = this.strokeGradient, bbox = this.bbox;
    this.updatePrecisionCompensateRect();
    if (strokeGradient && bbox) {
      this.strokeStyle = strokeGradient.generateGradient(this, bbox);
    }
    originalCtx.stroke.call(this);
    this.updatePrecisionCompensate();
  }, drawImage:function(img_elem, arg1, arg2, arg3, arg4, dst_x, dst_y, dw, dh) {
    switch(arguments.length) {
      case 3:
        return originalCtx.drawImage.call(this, img_elem, arg1 * xx + dx, arg2 * yy + dy);
      case 5:
        return originalCtx.drawImage.call(this, img_elem, arg1 * xx + dx, arg2 * yy + dy, arg3 * xx, arg4 * yy);
      case 9:
        return originalCtx.drawImage.call(this, img_elem, arg1, arg2, arg3, arg4, dst_x * xx + dx, dst_y * yy * dy, dw * xx, dh * yy);
    }
  }};
  Ext.apply(ctx, precisionOverrides);
  this.setDirty(true);
}, updateRect:function(rect) {
  this.callParent([rect]);
  var me = this, l = Math.floor(rect[0]), t = Math.floor(rect[1]), r = Math.ceil(rect[0] + rect[2]), b = Math.ceil(rect[1] + rect[3]), devicePixelRatio = me.devicePixelRatio, canvases = me.canvases, w = r - l, h = b - t, splitThreshold = Math.round(me.splitThreshold / devicePixelRatio), xSplits = me.xSplits = Math.ceil(w / splitThreshold), ySplits = me.ySplits = Math.ceil(h / splitThreshold), i, j, k, offsetX, offsetY, dom, width, height;
  for (j = 0, offsetY = 0; j < ySplits; j++, offsetY += splitThreshold) {
    for (i = 0, offsetX = 0; i < xSplits; i++, offsetX += splitThreshold) {
      k = j * xSplits + i;
      if (k >= canvases.length) {
        me.createCanvas();
      }
      dom = canvases[k].dom;
      dom.style.left = offsetX + 'px';
      dom.style.top = offsetY + 'px';
      height = Math.min(splitThreshold, h - offsetY);
      if (height * devicePixelRatio !== dom.height) {
        dom.height = height * devicePixelRatio;
        dom.style.height = height + 'px';
      }
      width = Math.min(splitThreshold, w - offsetX);
      if (width * devicePixelRatio !== dom.width) {
        dom.width = width * devicePixelRatio;
        dom.style.width = width + 'px';
      }
      me.applyDefaults(me.contexts[k]);
    }
  }
  for (k += 1; k < canvases.length; k++) {
    canvases[k].destroy();
  }
  me.activeCanvases = xSplits * ySplits;
  canvases.length = me.activeCanvases;
  me.clear();
}, clearTransform:function() {
  var me = this, xSplits = me.xSplits, ySplits = me.ySplits, contexts = me.contexts, splitThreshold = me.splitThreshold, devicePixelRatio = me.devicePixelRatio, i, j, k, ctx;
  for (i = 0; i < xSplits; i++) {
    for (j = 0; j < ySplits; j++) {
      k = j * xSplits + i;
      ctx = contexts[k];
      ctx.translate(-splitThreshold * i, -splitThreshold * j);
      ctx.scale(devicePixelRatio, devicePixelRatio);
      me.matrix.toContext(ctx);
    }
  }
}, renderSprite:function(sprite) {
  var me = this, rect = me.getRect(), surfaceMatrix = me.matrix, parent = sprite.getParent(), matrix = Ext.draw.Matrix.fly([1, 0, 0, 1, 0, 0]), splitThreshold = me.splitThreshold / me.devicePixelRatio, xSplits = me.xSplits, ySplits = me.ySplits, offsetX, offsetY, ctx, bbox, width, height, left = 0, right, top = 0, bottom, w = rect[2], h = rect[3], i, j, k;
  while (parent && parent !== me) {
    matrix.prependMatrix(parent.matrix || parent.attr && parent.attr.matrix);
    parent = parent.getParent();
  }
  matrix.prependMatrix(surfaceMatrix);
  bbox = sprite.getBBox();
  if (bbox) {
    bbox = matrix.transformBBox(bbox);
  }
  sprite.preRender(me);
  if (sprite.attr.hidden || sprite.attr.globalAlpha === 0) {
    sprite.setDirty(false);
    return;
  }
  for (j = 0, offsetY = 0; j < ySplits; j++, offsetY += splitThreshold) {
    for (i = 0, offsetX = 0; i < xSplits; i++, offsetX += splitThreshold) {
      k = j * xSplits + i;
      ctx = me.contexts[k];
      width = Math.min(splitThreshold, w - offsetX);
      height = Math.min(splitThreshold, h - offsetY);
      left = offsetX;
      right = left + width;
      top = offsetY;
      bottom = top + height;
      if (bbox) {
        if (bbox.x > right || bbox.x + bbox.width < left || bbox.y > bottom || bbox.y + bbox.height < top) {
          continue;
        }
      }
      ctx.save();
      sprite.useAttributes(ctx, rect);
      if (false === sprite.render(me, ctx, [left, top, width, height], rect)) {
        return false;
      }
      ctx.restore();
    }
  }
  sprite.setDirty(false);
}, flatten:function(size, surfaces) {
  var targetCanvas = document.createElement('canvas'), className = Ext.getClassName(this), ratio = this.devicePixelRatio, ctx = targetCanvas.getContext('2d'), surface, canvas, rect, i, j, xy;
  targetCanvas.width = Math.ceil(size.width * ratio);
  targetCanvas.height = Math.ceil(size.height * ratio);
  for (i = 0; i < surfaces.length; i++) {
    surface = surfaces[i];
    if (Ext.getClassName(surface) !== className) {
      continue;
    }
    rect = surface.getRect();
    for (j = 0; j < surface.canvases.length; j++) {
      canvas = surface.canvases[j];
      xy = canvas.getOffsetsTo(canvas.getParent());
      ctx.drawImage(canvas.dom, (rect[0] + xy[0]) * ratio, (rect[1] + xy[1]) * ratio);
    }
  }
  return {data:targetCanvas.toDataURL(), type:'png'};
}, applyDefaults:function(ctx) {
  var none = Ext.draw.Color.RGBA_NONE;
  ctx.strokeStyle = none;
  ctx.fillStyle = none;
  ctx.textAlign = 'start';
  ctx.textBaseline = 'alphabetic';
  ctx.miterLimit = 1;
}, clear:function() {
  var me = this, activeCanvases = me.activeCanvases, i, canvas, ctx;
  for (i = 0; i < activeCanvases; i++) {
    canvas = me.canvases[i].dom;
    ctx = me.contexts[i];
    ctx.setTransform(1, 0, 0, 1, 0, 0);
    ctx.clearRect(0, 0, canvas.width, canvas.height);
  }
  me.setDirty(true);
}, destroy:function() {
  var me = this, i, ln = me.canvases.length;
  for (i = 0; i < ln; i++) {
    me.contexts[i] = null;
    me.canvases[i].destroy();
    me.canvases[i] = null;
  }
  delete me.contexts;
  delete me.canvases;
  me.callParent();
}, privates:{initElement:function() {
  var me = this;
  me.callParent();
  me.canvases = [];
  me.contexts = [];
  me.activeCanvases = (me.xSplits = 0) * (me.ySplits = 0);
}}}, function() {
  var me = this, proto = me.prototype, splitThreshold = 1.0E10;
  if (Ext.os.is.Android4 && Ext.browser.is.Chrome) {
    splitThreshold = 3000;
  } else {
    if (Ext.is.iOS) {
      splitThreshold = 2200;
    }
  }
  proto.splitThreshold = splitThreshold;
});
Ext.define('Ext.draw.Container', {extend:Ext.draw.ContainerBase, alternateClassName:'Ext.draw.Component', xtype:'draw', defaultType:'surface', isDrawContainer:true, engine:'Ext.draw.engine.Canvas', config:{cls:Ext.baseCSSPrefix + 'draw-container', resizeHandler:null, sprites:null, gradients:[]}, defaultDownloadServerUrl:'http://svg.sencha.io', supportedFormats:['png', 'pdf', 'jpeg', 'gif'], supportedOptions:{version:Ext.isNumber, data:Ext.isString, format:function(format) {
  return Ext.Array.indexOf(this.supportedFormats, format) >= 0;
}, filename:Ext.isString, width:Ext.isNumber, height:Ext.isNumber, scale:Ext.isNumber, pdf:Ext.isObject, jpeg:Ext.isObject}, initAnimator:function() {
  this.frameCallbackId = Ext.draw.Animator.addFrameCallback('renderFrame', this);
}, applyGradients:function(gradients) {
  var result = [], i, n, gradient, offset;
  if (!Ext.isArray(gradients)) {
    return result;
  }
  for (i = 0, n = gradients.length; i < n; i++) {
    gradient = gradients[i];
    if (!Ext.isObject(gradient)) {
      continue;
    }
    if (typeof gradient.type !== 'string') {
      gradient.type = 'linear';
    }
    if (gradient.angle) {
      gradient.degrees = gradient.angle;
      delete gradient.angle;
    }
    if (Ext.isObject(gradient.stops)) {
      gradient.stops = function(stops) {
        var result = [], stop;
        for (offset in stops) {
          stop = stops[offset];
          stop.offset = offset / 100;
          result.push(stop);
        }
        return result;
      }(gradient.stops);
    }
    result.push(gradient);
  }
  Ext.draw.gradient.GradientDefinition.add(result);
  return result;
}, applySprites:function(sprites) {
  if (!sprites) {
    return;
  }
  sprites = Ext.Array.from(sprites);
  var ln = sprites.length, result = [], i, surface, sprite;
  for (i = 0; i < ln; i++) {
    sprite = sprites[i];
    surface = sprite.surface;
    if (!(surface && surface.isSurface)) {
      if (Ext.isString(surface)) {
        surface = this.getSurface(surface);
      } else {
        surface = this.getSurface('main');
      }
    }
    sprite = surface.add(sprite);
    result.push(sprite);
  }
  return result;
}, onBodyResize:function() {
  var el = this.element, size;
  if (!el) {
    return;
  }
  size = el.getSize();
  if (size.width && size.height) {
    this.setBodySize(size);
  }
}, setBodySize:function(size) {
  var me = this, resizeHandler = me.getResizeHandler() || me.defaultResizeHandler, result;
  me.fireEvent('bodyresize', me, size);
  result = resizeHandler.call(me, size);
  if (result !== false) {
    me.renderFrame();
  }
}, defaultResizeHandler:function(size) {
  this.getItems().each(function(surface) {
    surface.setRect([0, 0, size.width, size.height]);
  });
}, getSurface:function(id) {
  id = this.getId() + '-' + (id || 'main');
  var me = this, surfaces = me.getItems(), surface = surfaces.get(id);
  if (!surface) {
    surface = me.add({xclass:me.engine, id:id});
    me.onBodyResize();
  }
  return surface;
}, renderFrame:function() {
  var me = this, surfaces = me.getItems(), i, ln, item;
  for (i = 0, ln = surfaces.length; i < ln; i++) {
    item = surfaces.items[i];
    if (item.isSurface) {
      item.renderFrame();
    }
  }
}, getImage:function(format) {
  var size = this.innerElement.getSize(), surfaces = Array.prototype.slice.call(this.items.items), image, imageElement, zIndexes = this.surfaceZIndexes, i, j, surface, zIndex;
  for (j = 1; j < surfaces.length; j++) {
    surface = surfaces[j];
    zIndex = zIndexes[surface.type];
    i = j - 1;
    while (i >= 0 && zIndexes[surfaces[i].type] > zIndex) {
      surfaces[i + 1] = surfaces[i];
      i--;
    }
    surfaces[i + 1] = surface;
  }
  image = surfaces[0].flatten(size, surfaces);
  if (format === 'image') {
    imageElement = new Image;
    imageElement.src = image.data;
    image.data = imageElement;
    return image;
  }
  if (format === 'stream') {
    image.data = image.data.replace(/^data:image\/[^;]+/, 'data:application/octet-stream');
    return image;
  }
  return image;
}, download:function(config) {
  var me = this, inputs = [], markup, name, value;
  config = Ext.apply({version:2, data:me.getImage().data}, config);
  for (name in config) {
    if (config.hasOwnProperty(name)) {
      value = config[name];
      if (name in me.supportedOptions) {
        if (me.supportedOptions[name].call(me, value)) {
          inputs.push({tag:'input', type:'hidden', name:name, value:Ext.String.htmlEncode(Ext.isObject(value) ? Ext.JSON.encode(value) : value)});
        } else {
          Ext.log.error('Invalid value for image download option "' + name + '": ' + value);
        }
      } else {
        Ext.log.error('Invalid image download option: "' + name + '"');
      }
    }
  }
  markup = Ext.dom.Helper.markup({tag:'html', children:[{tag:'head'}, {tag:'body', children:[{tag:'form', method:'POST', action:config.url || me.defaultDownloadServerUrl, children:inputs}, {tag:'script', type:'text/javascript', children:'document.getElementsByTagName("form")[0].submit();'}]}]});
  window.open('', 'ImageDownload_' + Date.now()).document.write(markup);
}, destroy:function() {
  var callbackId = this.frameCallbackId;
  if (callbackId) {
    Ext.draw.Animator.removeFrameCallback(callbackId);
  }
  this.callParent();
}}, function() {
  if (location.search.match('svg')) {
    Ext.draw.Container.prototype.engine = 'Ext.draw.engine.Svg';
  } else {
    if (Ext.os.is.BlackBerry && Ext.os.version.getMajor() === 10 || Ext.browser.is.AndroidStock4 && (Ext.os.version.getMinor() === 1 || Ext.os.version.getMinor() === 2 || Ext.os.version.getMinor() === 3)) {
      Ext.draw.Container.prototype.engine = 'Ext.draw.engine.Svg';
    }
  }
});
Ext.define('Ext.chart.theme.Base', {mixins:{factoryable:Ext.mixin.Factoryable}, factoryConfig:{type:'chart.theme'}, isTheme:true, config:{baseColor:null, colors:undefined, gradients:null, chart:{defaults:{background:'white'}}, axis:{defaults:{label:{x:0, y:0, textBaseline:'middle', textAlign:'center', fontSize:'default', fontFamily:'default', fontWeight:'default', fillStyle:'black'}, title:{fillStyle:'black', fontSize:'default*1.23', fontFamily:'default', fontWeight:'default'}, style:{strokeStyle:'black'}, 
grid:{strokeStyle:'rgb(221, 221, 221)'}}, top:{style:{textPadding:5}}, bottom:{style:{textPadding:5}}}, series:{defaults:{label:{fillStyle:'black', strokeStyle:'none', fontFamily:'default', fontWeight:'default', fontSize:'default*1.077', textBaseline:'middle', textAlign:'center'}, labelOverflowPadding:5}}, sprites:{text:{fontSize:'default', fontWeight:'default', fontFamily:'default', fillStyle:'black'}}, seriesThemes:undefined, markerThemes:{type:['circle', 'cross', 'plus', 'square', 'triangle', 
'diamond']}, useGradients:false, background:null}, colorDefaults:['#94ae0a', '#115fa6', '#a61120', '#ff8809', '#ffd13e', '#a61187', '#24ad9a', '#7c7474', '#a66111'], constructor:function(config) {
  this.initConfig(config);
  this.resolveDefaults();
}, defaultRegEx:/^default([+\-/\*]\d+(?:\.\d+)?)?$/, defaultOperators:{'*':function(v1, v2) {
  return v1 * v2;
}, '+':function(v1, v2) {
  return v1 + v2;
}, '-':function(v1, v2) {
  return v1 - v2;
}}, resolveDefaults:function() {
  var me = this;
  Ext.onReady(function() {
    var sprites = Ext.clone(me.getSprites()), axis = Ext.clone(me.getAxis()), series = Ext.clone(me.getSeries()), div, key, config;
    if (!me.superclass.defaults) {
      div = Ext.getBody().createChild({tag:'div', cls:'x-component'});
      me.superclass.defaults = {fontFamily:div.getStyle('fontFamily'), fontWeight:div.getStyle('fontWeight'), fontSize:parseFloat(div.getStyle('fontSize')), fontVariant:div.getStyle('fontVariant'), fontStyle:div.getStyle('fontStyle')};
      div.destroy();
    }
    me.replaceDefaults(sprites.text);
    me.setSprites(sprites);
    for (key in axis) {
      config = axis[key];
      me.replaceDefaults(config.label);
      me.replaceDefaults(config.title);
    }
    me.setAxis(axis);
    for (key in series) {
      config = series[key];
      me.replaceDefaults(config.label);
    }
    me.setSeries(series);
  });
}, replaceDefaults:function(target) {
  var me = this, defaults = me.superclass.defaults, defaultRegEx = me.defaultRegEx, key, value, match, binaryFn;
  if (Ext.isObject(target)) {
    for (key in defaults) {
      match = defaultRegEx.exec(target[key]);
      if (match) {
        value = defaults[key];
        match = match[1];
        if (match) {
          binaryFn = me.defaultOperators[match.charAt(0)];
          value = Math.round(binaryFn(value, parseFloat(match.substr(1))));
        }
        target[key] = value;
      }
    }
  }
}, applyBaseColor:function(baseColor) {
  var midColor, midL;
  if (baseColor) {
    midColor = baseColor.isColor ? baseColor : Ext.draw.Color.fromString(baseColor);
    midL = midColor.getHSL()[2];
    if (midL < 0.15) {
      midColor = midColor.createLighter(0.3);
    } else {
      if (midL < 0.3) {
        midColor = midColor.createLighter(0.15);
      } else {
        if (midL > 0.85) {
          midColor = midColor.createDarker(0.3);
        } else {
          if (midL > 0.7) {
            midColor = midColor.createDarker(0.15);
          }
        }
      }
    }
    this.setColors([midColor.createDarker(0.3).toString(), midColor.createDarker(0.15).toString(), midColor.toString(), midColor.createLighter(0.12).toString(), midColor.createLighter(0.24).toString(), midColor.createLighter(0.31).toString()]);
  }
  return baseColor;
}, applyColors:function(newColors) {
  return newColors || this.colorDefaults;
}, updateUseGradients:function(useGradients) {
  if (useGradients) {
    this.updateGradients({type:'linear', degrees:90});
  }
}, updateBackground:function(background) {
  if (background) {
    var chart = this.getChart();
    chart.defaults.background = background;
    this.setChart(chart);
  }
}, updateGradients:function(gradients) {
  var colors = this.getColors(), items = [], gradient, midColor, color, i, ln;
  if (Ext.isObject(gradients)) {
    for (i = 0, ln = colors && colors.length || 0; i < ln; i++) {
      midColor = Ext.draw.Color.fromString(colors[i]);
      if (midColor) {
        color = midColor.createLighter(0.15).toString();
        gradient = Ext.apply(Ext.Object.chain(gradients), {stops:[{offset:1, color:midColor.toString()}, {offset:0, color:color.toString()}]});
        items.push(gradient);
      }
    }
    this.setColors(items);
  }
}, applySeriesThemes:function(newSeriesThemes) {
  this.getBaseColor();
  this.getUseGradients();
  this.getGradients();
  var colors = this.getColors();
  if (!newSeriesThemes) {
    newSeriesThemes = {fillStyle:Ext.Array.clone(colors), strokeStyle:Ext.Array.map(colors, function(value) {
      var color = Ext.draw.Color.fromString(value.stops ? value.stops[0].color : value);
      return color.createDarker(0.15).toString();
    })};
  }
  return newSeriesThemes;
}});
Ext.define('Ext.chart.theme.Default', {extend:Ext.chart.theme.Base, singleton:true, alias:['chart.theme.default', 'chart.theme.Base']});
Ext.define('Ext.chart.Markers', {extend:Ext.draw.sprite.Instancing, isMarkers:true, defaultCategory:'default', constructor:function() {
  this.callParent(arguments);
  this.categories = {};
  this.revisions = {};
}, destroy:function() {
  this.categories = null;
  this.revisions = null;
  this.callParent();
}, getMarkerFor:function(category, index) {
  if (category in this.categories) {
    var categoryInstances = this.categories[category];
    if (index in categoryInstances) {
      return this.get(categoryInstances[index]);
    }
  }
}, clear:function(category) {
  category = category || this.defaultCategory;
  if (!(category in this.revisions)) {
    this.revisions[category] = 1;
  } else {
    this.revisions[category]++;
  }
}, putMarkerFor:function(category, attr, index, bypassNormalization, keepRevision) {
  category = category || this.defaultCategory;
  var me = this, categoryInstances = me.categories[category] || (me.categories[category] = {}), instance;
  if (index in categoryInstances) {
    me.setAttributesFor(categoryInstances[index], attr, bypassNormalization);
  } else {
    categoryInstances[index] = me.getCount();
    me.createInstance(attr, bypassNormalization);
  }
  instance = me.get(categoryInstances[index]);
  if (instance) {
    instance.category = category;
    if (!keepRevision) {
      instance.revision = me.revisions[category] || (me.revisions[category] = 1);
    }
  }
}, getMarkerBBoxFor:function(category, index, isWithoutTransform) {
  if (category in this.categories) {
    var categoryInstances = this.categories[category];
    if (index in categoryInstances) {
      return this.getBBoxFor(categoryInstances[index], isWithoutTransform);
    }
  }
}, getBBox:function() {
  return null;
}, render:function(surface, ctx, clipRect) {
  var me = this, revisions = me.revisions, mat = me.attr.matrix, template = me.getTemplate(), templateAttr = template.attr, instance, i, ln;
  mat.toContext(ctx);
  template.preRender(surface, ctx, clipRect);
  template.useAttributes(ctx, clipRect);
  for (i = 0, ln = me.instances.length; i < ln; i++) {
    instance = me.get(i);
    if (instance.hidden || instance.revision !== revisions[instance.category]) {
      continue;
    }
    ctx.save();
    template.attr = instance;
    template.useAttributes(ctx, clipRect);
    template.render(surface, ctx, clipRect);
    ctx.restore();
  }
  template.attr = templateAttr;
}});
Ext.define('Ext.chart.label.Callout', {extend:Ext.draw.modifier.Modifier, prepareAttributes:function(attr) {
  if (!attr.hasOwnProperty('calloutOriginal')) {
    attr.calloutOriginal = Ext.Object.chain(attr);
    attr.calloutOriginal.prototype = attr;
  }
  if (this._previous) {
    this._previous.prepareAttributes(attr.calloutOriginal);
  }
}, setAttrs:function(attr, changes) {
  var callout = attr.callout, origin = attr.calloutOriginal, bbox = attr.bbox.plain, width = (bbox.width || 0) + attr.labelOverflowPadding, height = (bbox.height || 0) + attr.labelOverflowPadding, dx, dy;
  if ('callout' in changes) {
    callout = changes.callout;
  }
  if ('callout' in changes || 'calloutPlaceX' in changes || 'calloutPlaceY' in changes || 'x' in changes || 'y' in changes) {
    var rotationRads = 'rotationRads' in changes ? origin.rotationRads = changes.rotationRads : origin.rotationRads, x = 'x' in changes ? origin.x = changes.x : origin.x, y = 'y' in changes ? origin.y = changes.y : origin.y, calloutPlaceX = 'calloutPlaceX' in changes ? changes.calloutPlaceX : attr.calloutPlaceX, calloutPlaceY = 'calloutPlaceY' in changes ? changes.calloutPlaceY : attr.calloutPlaceY, calloutVertical = 'calloutVertical' in changes ? changes.calloutVertical : attr.calloutVertical, temp;
    rotationRads %= Math.PI * 2;
    if (Math.cos(rotationRads) < 0) {
      rotationRads = (rotationRads + Math.PI) % (Math.PI * 2);
    }
    if (rotationRads > Math.PI) {
      rotationRads -= Math.PI * 2;
    }
    if (calloutVertical) {
      rotationRads = rotationRads * (1 - callout) - Math.PI / 2 * callout;
      temp = width;
      width = height;
      height = temp;
    } else {
      rotationRads = rotationRads * (1 - callout);
    }
    changes.rotationRads = rotationRads;
    changes.x = x * (1 - callout) + calloutPlaceX * callout;
    changes.y = y * (1 - callout) + calloutPlaceY * callout;
    dx = calloutPlaceX - x;
    dy = calloutPlaceY - y;
    if (Math.abs(dy * width) > Math.abs(dx * height)) {
      if (dy > 0) {
        changes.calloutEndX = changes.x - height / 2 * (dx / dy) * callout;
        changes.calloutEndY = changes.y - height / 2 * callout;
      } else {
        changes.calloutEndX = changes.x + height / 2 * (dx / dy) * callout;
        changes.calloutEndY = changes.y + height / 2 * callout;
      }
    } else {
      if (dx > 0) {
        changes.calloutEndX = changes.x - width / 2;
        changes.calloutEndY = changes.y - width / 2 * (dy / dx) * callout;
      } else {
        changes.calloutEndX = changes.x + width / 2;
        changes.calloutEndY = changes.y + width / 2 * (dy / dx) * callout;
      }
    }
    if (changes.calloutStartX && changes.calloutStartY) {
      changes.calloutHasLine = dx > 0 && changes.calloutStartX < changes.calloutEndX || dx <= 0 && changes.calloutStartX > changes.calloutEndX || dy > 0 && changes.calloutStartY < changes.calloutEndY || dy <= 0 && changes.calloutStartY > changes.calloutEndY;
    } else {
      changes.calloutHasLine = true;
    }
  }
  return changes;
}, pushDown:function(attr, changes) {
  changes = this.callParent([attr.calloutOriginal, changes]);
  return this.setAttrs(attr, changes);
}, popUp:function(attr, changes) {
  attr = attr.prototype;
  changes = this.setAttrs(attr, changes);
  if (this._next) {
    return this._next.popUp(attr, changes);
  } else {
    return Ext.apply(attr, changes);
  }
}});
Ext.define('Ext.chart.label.Label', {extend:Ext.draw.sprite.Text, inheritableStatics:{def:{processors:{callout:'limited01', calloutHasLine:'bool', calloutPlaceX:'number', calloutPlaceY:'number', calloutStartX:'number', calloutStartY:'number', calloutEndX:'number', calloutEndY:'number', calloutColor:'color', calloutWidth:'number', calloutVertical:'bool', labelOverflowPadding:'number', display:'enums(none,under,over,rotate,insideStart,insideEnd,inside,outside)', orientation:'enums(horizontal,vertical)', 
renderer:'default'}, defaults:{callout:0, calloutHasLine:true, calloutPlaceX:0, calloutPlaceY:0, calloutStartX:0, calloutStartY:0, calloutEndX:0, calloutEndY:0, calloutWidth:1, calloutVertical:false, calloutColor:'black', labelOverflowPadding:5, display:'none', orientation:'', renderer:null}, triggers:{callout:'transform', calloutPlaceX:'transform', calloutPlaceY:'transform', labelOverflowPadding:'transform', calloutRotation:'transform', display:'hidden'}, updaters:{hidden:function(attrs) {
  attrs.hidden = attrs.display === 'none';
}}}}, config:{fx:{customDurations:{callout:200}}, field:null, calloutLine:true}, applyCalloutLine:function(calloutLine) {
  if (calloutLine) {
    return Ext.apply({}, calloutLine);
  }
}, prepareModifiers:function() {
  this.callParent(arguments);
  this.calloutModifier = new Ext.chart.label.Callout({sprite:this});
  this.fx.setNext(this.calloutModifier);
  this.calloutModifier.setNext(this.topModifier);
}, render:function(surface, ctx) {
  var me = this, attr = me.attr, calloutColor = attr.calloutColor;
  ctx.save();
  ctx.globalAlpha *= attr.callout;
  if (ctx.globalAlpha > 0 && attr.calloutHasLine) {
    if (calloutColor && calloutColor.isGradient) {
      calloutColor = calloutColor.getStops()[0].color;
    }
    ctx.strokeStyle = calloutColor;
    ctx.fillStyle = calloutColor;
    ctx.lineWidth = attr.calloutWidth;
    ctx.beginPath();
    ctx.moveTo(me.attr.calloutStartX, me.attr.calloutStartY);
    ctx.lineTo(me.attr.calloutEndX, me.attr.calloutEndY);
    ctx.stroke();
    ctx.beginPath();
    ctx.arc(me.attr.calloutStartX, me.attr.calloutStartY, 1 * attr.calloutWidth, 0, 2 * Math.PI, true);
    ctx.fill();
    ctx.beginPath();
    ctx.arc(me.attr.calloutEndX, me.attr.calloutEndY, 1 * attr.calloutWidth, 0, 2 * Math.PI, true);
    ctx.fill();
  }
  ctx.restore();
  Ext.draw.sprite.Text.prototype.render.apply(me, arguments);
}});
Ext.define('Ext.chart.series.Series', {mixins:[Ext.mixin.Observable, Ext.mixin.Bindable], isSeries:true, defaultBindProperty:'store', type:null, seriesType:'sprite', identifiablePrefix:'ext-line-', observableType:'series', darkerStrokeRatio:0.15, config:{chart:null, title:null, renderer:null, showInLegend:true, triggerAfterDraw:false, style:{}, subStyle:{}, themeStyle:{}, colors:null, useDarkerStrokeColor:true, store:null, label:{}, labelOverflowPadding:null, showMarkers:true, marker:null, markerSubStyle:null, 
itemInstancing:null, background:null, highlightItem:null, surface:null, overlaySurface:null, hidden:false, highlight:false, highlightCfg:{merge:function(value) {
  return value;
}, $value:{fillStyle:'yellow', strokeStyle:'red'}}, animation:null, tooltip:null}, directions:[], sprites:null, themeColorCount:function() {
  return 1;
}, isStoreDependantColorCount:false, themeMarkerCount:function() {
  return 0;
}, getFields:function(fieldCategory) {
  var me = this, fields = [], fieldsItem, i, ln;
  for (i = 0, ln = fieldCategory.length; i < ln; i++) {
    fieldsItem = me['get' + fieldCategory[i] + 'Field']();
    if (Ext.isArray(fieldsItem)) {
      fields.push.apply(fields, fieldsItem);
    } else {
      fields.push(fieldsItem);
    }
  }
  return fields;
}, applyAnimation:function(newAnimation, oldAnimation) {
  if (!newAnimation) {
    newAnimation = {duration:0};
  } else {
    if (newAnimation === true) {
      newAnimation = {easing:'easeInOut', duration:500};
    }
  }
  return oldAnimation ? Ext.apply({}, newAnimation, oldAnimation) : newAnimation;
}, getAnimation:function() {
  var chart = this.getChart();
  if (chart && chart.animationSuspendCount) {
    return {duration:0};
  } else {
    return this.callParent();
  }
}, updateTitle:function(newTitle) {
  var me = this, chart = me.getChart();
  if (!chart || chart.isInitializing) {
    return;
  }
  newTitle = Ext.Array.from(newTitle);
  var series = chart.getSeries(), seriesIndex = Ext.Array.indexOf(series, me), legendStore = chart.getLegendStore(), yField = me.getYField(), i, item, title, ln;
  if (legendStore.getCount() && seriesIndex !== -1) {
    ln = yField ? Math.min(newTitle.length, yField.length) : newTitle.length;
    for (i = 0; i < ln; i++) {
      title = newTitle[i];
      item = legendStore.getAt(seriesIndex + i);
      if (title && item) {
        item.set('name', title);
      }
    }
  }
}, applyHighlight:function(highlight, oldHighlight) {
  if (Ext.isObject(highlight)) {
    highlight = Ext.merge({}, this.config.highlightCfg, highlight);
  } else {
    if (highlight === true) {
      highlight = this.config.highlightCfg;
    }
  }
  return Ext.apply(oldHighlight || {}, highlight);
}, updateHighlight:function(highlight) {
  this.getStyle();
  if (!Ext.Object.isEmpty(highlight)) {
    this.addItemHighlight();
  }
}, updateHighlightCfg:function(highlightCfg) {
  if (!Ext.Object.equals(highlightCfg, this.defaultConfig.highlightCfg)) {
    this.addItemHighlight();
  }
}, applyItemInstancing:function(instancing, oldInstancing) {
  return Ext.merge(oldInstancing || {}, instancing);
}, setAttributesForItem:function(item, change) {
  var sprite = item && item.sprite, i;
  if (sprite) {
    if (sprite.itemsMarker && item.category === 'items') {
      sprite.putMarker(item.category, change, item.index, false, true);
    }
    if (sprite.isMarkerHolder && item.category === 'markers') {
      sprite.putMarker(item.category, change, item.index, false, true);
    } else {
      if (sprite.isInstancing) {
        sprite.setAttributesFor(item.index, change);
      } else {
        if (Ext.isArray(sprite)) {
          for (i = 0; i < sprite.length; i++) {
            sprite[i].setAttributes(change);
          }
        } else {
          sprite.setAttributes(change);
        }
      }
    }
  }
}, getBBoxForItem:function(item) {
  if (item && item.sprite) {
    if (item.sprite.itemsMarker && item.category === 'items') {
      return item.sprite.getMarkerBBox(item.category, item.index);
    } else {
      if (item.sprite instanceof Ext.draw.sprite.Instancing) {
        return item.sprite.getBBoxFor(item.index);
      } else {
        return item.sprite.getBBox();
      }
    }
  }
  return null;
}, applyHighlightItem:function(newHighlightItem, oldHighlightItem) {
  if (newHighlightItem === oldHighlightItem) {
    return;
  }
  if (Ext.isObject(newHighlightItem) && Ext.isObject(oldHighlightItem)) {
    var isSameSprite = newHighlightItem.sprite === oldHighlightItem.sprite, isSameIndex = newHighlightItem.index === oldHighlightItem.index;
    if (isSameSprite && isSameIndex) {
      return;
    }
  }
  return newHighlightItem;
}, updateHighlightItem:function(newHighlightItem, oldHighlightItem) {
  this.setAttributesForItem(oldHighlightItem, {highlighted:false});
  this.setAttributesForItem(newHighlightItem, {highlighted:true});
}, constructor:function(config) {
  var me = this, id;
  config = config || {};
  if (config.tips) {
    config = Ext.apply({tooltip:config.tips}, config);
  }
  if (config.highlightCfg) {
    config = Ext.apply({highlight:config.highlightCfg}, config);
  }
  if ('id' in config) {
    id = config.id;
  } else {
    if ('id' in me.config) {
      id = me.config.id;
    } else {
      id = me.getId();
    }
  }
  me.setId(id);
  me.sprites = [];
  me.dataRange = [];
  me.mixins.observable.constructor.call(me, config);
  me.initBindable();
}, lookupViewModel:function(skipThis) {
  var chart = this.getChart();
  return chart ? chart.lookupViewModel(skipThis) : null;
}, applyTooltip:function(tooltip, oldTooltip) {
  var config = Ext.apply({xtype:'tooltip', renderer:Ext.emptyFn, constrainPosition:true, shrinkWrapDock:true, autoHide:true, offsetX:10, offsetY:10}, tooltip);
  return Ext.create(config);
}, updateTooltip:function() {
  this.addItemHighlight();
}, addItemHighlight:function() {
  var chart = this.getChart();
  if (!chart) {
    return;
  }
  var interactions = chart.getInteractions(), i, interaction, hasRequiredInteraction;
  for (i = 0; i < interactions.length; i++) {
    interaction = interactions[i];
    if (interaction.isItemHighlight || interaction.isItemEdit) {
      hasRequiredInteraction = true;
      break;
    }
  }
  if (!hasRequiredInteraction) {
    interactions.push('itemhighlight');
    chart.setInteractions(interactions);
  }
}, showTooltip:function(item, xy) {
  var me = this, tooltip = me.getTooltip(), sprite, surface, surfaceEl, pos, point, bbox, x, y, config, isRtl;
  if (!tooltip) {
    return;
  }
  clearTimeout(me.tooltipTimeout);
  config = tooltip.config;
  if (tooltip.trackMouse) {
    xy[0] += config.offsetX;
    xy[1] += config.offsetY;
  } else {
    sprite = item.sprite;
    surface = sprite.getSurface();
    surfaceEl = Ext.get(surface.getId());
    if (surfaceEl) {
      bbox = item.series.getBBoxForItem(item);
      x = bbox.x + bbox.width / 2;
      y = bbox.y + bbox.height / 2;
      point = surface.matrix.transformPoint([x, y]);
      pos = surfaceEl.getXY();
      isRtl = surface.getInherited().rtl;
      x = isRtl ? pos[0] + surfaceEl.getWidth() - point[0] : pos[0] + point[0];
      y = pos[1] + point[1];
      xy = [x, y];
    }
  }
  Ext.callback(tooltip.renderer, tooltip.scope, [tooltip, item.record, item], 0, me);
  tooltip.show(xy);
}, hideTooltip:function(item) {
  var me = this, tooltip = me.getTooltip();
  if (!tooltip) {
    return;
  }
  clearTimeout(me.tooltipTimeout);
  me.tooltipTimeout = Ext.defer(function() {
    tooltip.hide();
  }, 1);
}, applyStore:function(store) {
  return store && Ext.StoreManager.lookup(store);
}, getStore:function() {
  return this._store || this.getChart() && this.getChart().getStore();
}, updateStore:function(newStore, oldStore) {
  var me = this, chart = me.getChart(), chartStore = chart && chart.getStore(), sprites, sprite, len, i;
  oldStore = oldStore || chartStore;
  if (oldStore && oldStore !== newStore) {
    oldStore.un({datachanged:'onDataChanged', update:'onDataChanged', scope:me});
  }
  if (newStore) {
    newStore.on({datachanged:'onDataChanged', update:'onDataChanged', scope:me});
    sprites = me.getSprites();
    for (i = 0, len = sprites.length; i < len; i++) {
      sprite = sprites[i];
      if (sprite.setStore) {
        sprite.setStore(newStore);
      }
    }
    me.onDataChanged();
  }
  me.fireEvent('storechange', me, newStore, oldStore);
}, onStoreChange:function(chart, newStore, oldStore) {
  if (!this._store) {
    this.updateStore(newStore, oldStore);
  }
}, coordinate:function(direction, directionOffset, directionCount) {
  var me = this, store = me.getStore(), hidden = me.getHidden(), items = store.getData().items, axis = me['get' + direction + 'Axis'](), range = {min:Infinity, max:-Infinity}, fieldCategory = me['fieldCategory' + direction] || [direction], fields = me.getFields(fieldCategory), i, field, data, style = {}, sprites = me.getSprites();
  if (sprites.length > 0) {
    if (!Ext.isBoolean(hidden) || !hidden) {
      for (i = 0; i < fieldCategory.length; i++) {
        field = fields[i];
        data = me.coordinateData(items, field, axis);
        me.getRangeOfData(data, range);
        style['data' + fieldCategory[i]] = data;
      }
    }
    me.dataRange[directionOffset] = range.min;
    me.dataRange[directionOffset + directionCount] = range.max;
    style['dataMin' + direction] = range.min;
    style['dataMax' + direction] = range.max;
    if (axis) {
      axis.range = null;
      style['range' + direction] = axis.getRange();
    }
    for (i = 0; i < sprites.length; i++) {
      sprites[i].setAttributes(style);
    }
  }
}, coordinateData:function(items, field, axis) {
  var data = [], length = items.length, layout = axis && axis.getLayout(), i, x;
  for (i = 0; i < length; i++) {
    x = items[i].data[field];
    if (!Ext.isEmpty(x, true)) {
      if (layout) {
        data[i] = layout.getCoordFor(x, field, i, items);
      } else {
        data[i] = +x;
      }
    } else {
      data[i] = x;
    }
  }
  return data;
}, getRangeOfData:function(data, range) {
  var length = data.length, min = range.min, max = range.max, i, value;
  for (i = 0; i < length; i++) {
    value = data[i];
    if (value < min) {
      min = value;
    }
    if (value > max) {
      max = value;
    }
  }
  range.min = min;
  range.max = max;
}, updateLabelData:function() {
  var me = this, store = me.getStore(), items = store.getData().items, sprites = me.getSprites(), labelTpl = me.getLabel().getTemplate(), labelFields = Ext.Array.from(labelTpl.getField()), i, j, ln, labels, sprite, field;
  if (!sprites.length || !labelFields.length) {
    return;
  }
  for (i = 0; i < sprites.length; i++) {
    labels = [];
    sprite = sprites[i];
    field = sprite.getField();
    if (Ext.Array.indexOf(labelFields, field) < 0) {
      field = labelFields[i];
    }
    for (j = 0, ln = items.length; j < ln; j++) {
      labels.push(items[j].get(field));
    }
    sprite.setAttributes({labels:labels});
  }
}, processData:function() {
  if (!this.getStore()) {
    return;
  }
  var me = this, directions = this.directions, i, ln = directions.length, direction, axis;
  for (i = 0; i < ln; i++) {
    direction = directions[i];
    axis = me['get' + direction + 'Axis']();
    if (axis) {
      axis.processData(me);
      continue;
    }
    if (me['coordinate' + direction]) {
      me['coordinate' + direction]();
    }
  }
  me.updateLabelData();
}, applyBackground:function(background) {
  if (this.getChart()) {
    this.getSurface().setBackground(background);
    return this.getSurface().getBackground();
  } else {
    return background;
  }
}, updateChart:function(newChart, oldChart) {
  var me = this, store = me._store;
  if (oldChart) {
    oldChart.un('axeschange', 'onAxesChange', me);
    me.clearSprites();
    me.setSurface(null);
    me.setOverlaySurface(null);
    oldChart.unregister(me);
    me.onChartDetached(oldChart);
    if (!store) {
      me.updateStore(null);
    }
  }
  if (newChart) {
    me.setSurface(newChart.getSurface('series'));
    me.setOverlaySurface(newChart.getSurface('overlay'));
    newChart.on('axeschange', 'onAxesChange', me);
    if (newChart.getAxes()) {
      me.onAxesChange(newChart);
    }
    me.onChartAttached(newChart);
    newChart.register(me);
    if (!store) {
      me.updateStore(newChart.getStore());
    }
  }
}, onAxesChange:function(chart) {
  var me = this, axes = chart.getAxes(), axis, directionToAxesMap = {}, directionToFieldsMap = {}, needHighPrecision = false, directions = this.directions, direction, i, ln;
  for (i = 0, ln = directions.length; i < ln; i++) {
    direction = directions[i];
    directionToFieldsMap[direction] = me.getFields(me['fieldCategory' + direction]);
  }
  for (i = 0, ln = axes.length; i < ln; i++) {
    axis = axes[i];
    if (!directionToAxesMap[axis.getDirection()]) {
      directionToAxesMap[axis.getDirection()] = [axis];
    } else {
      directionToAxesMap[axis.getDirection()].push(axis);
    }
  }
  for (i = 0, ln = directions.length; i < ln; i++) {
    direction = directions[i];
    if (me['get' + direction + 'Axis']()) {
      continue;
    }
    if (directionToAxesMap[direction]) {
      axis = me.findMatchingAxis(directionToAxesMap[direction], directionToFieldsMap[direction]);
      if (axis) {
        me['set' + direction + 'Axis'](axis);
        if (axis.getNeedHighPrecision()) {
          needHighPrecision = true;
        }
      }
    }
  }
  this.getSurface().setHighPrecision(needHighPrecision);
}, findMatchingAxis:function(directionAxes, directionFields) {
  var axis, axisFields, i, j;
  for (i = 0; i < directionAxes.length; i++) {
    axis = directionAxes[i];
    axisFields = axis.getFields();
    if (!axisFields.length) {
      return axis;
    } else {
      if (directionFields) {
        for (j = 0; j < directionFields.length; j++) {
          if (Ext.Array.indexOf(axisFields, directionFields[j]) >= 0) {
            return axis;
          }
        }
      }
    }
  }
}, onChartDetached:function(oldChart) {
  var me = this;
  me.fireEvent('chartdetached', oldChart, me);
  oldChart.un('storechange', 'onStoreChange', me);
}, onChartAttached:function(chart) {
  var me = this;
  me.setBackground(me.getBackground());
  me.fireEvent('chartattached', chart, me);
  chart.on('storechange', 'onStoreChange', me);
  me.processData();
}, updateOverlaySurface:function(overlaySurface) {
  var me = this;
  if (overlaySurface) {
    if (me.getLabel()) {
      me.getOverlaySurface().add(me.getLabel());
    }
  }
}, applyLabel:function(newLabel, oldLabel) {
  if (!oldLabel) {
    oldLabel = new Ext.chart.Markers({zIndex:10});
    oldLabel.setTemplate(new Ext.chart.label.Label(newLabel));
  } else {
    oldLabel.getTemplate().setAttributes(newLabel);
  }
  return oldLabel;
}, createItemInstancingSprite:function(sprite, itemInstancing) {
  var me = this, markers = new Ext.chart.Markers, config, template;
  markers.setAttributes({zIndex:Number.MAX_VALUE});
  config = Ext.apply({}, itemInstancing);
  if (me.getHighlight()) {
    config.highlight = me.getHighlight();
    config.modifiers = ['highlight'];
  }
  markers.setTemplate(config);
  template = markers.getTemplate();
  template.setAttributes(me.getStyle());
  template.fx.on('animationstart', 'onSpriteAnimationStart', this);
  template.fx.on('animationend', 'onSpriteAnimationEnd', this);
  sprite.bindMarker('items', markers);
  me.getSurface().add(markers);
  return markers;
}, getDefaultSpriteConfig:function() {
  return {type:this.seriesType, renderer:this.getRenderer()};
}, updateRenderer:function(renderer) {
  var me = this, chart = me.getChart(), sprites;
  if (chart && chart.isInitializing) {
    return;
  }
  sprites = me.getSprites();
  if (sprites.length) {
    sprites[0].setAttributes({renderer:renderer || null});
    if (chart && !chart.isInitializing) {
      chart.redraw();
    }
  }
}, updateShowMarkers:function(showMarkers) {
  var sprites = this.getSprites(), sprite = sprites && sprites[0], markers = sprite && sprite.getMarker('markers');
  if (markers) {
    markers.getTemplate().setAttributes({hidden:!showMarkers});
  }
}, createSprite:function() {
  var me = this, surface = me.getSurface(), itemInstancing = me.getItemInstancing(), sprite = surface.add(me.getDefaultSpriteConfig()), marker = me.getMarker(), markers, markersTpl;
  sprite.setAttributes(me.getStyle());
  sprite.setSeries(me);
  if (itemInstancing) {
    sprite.itemsMarker = me.createItemInstancingSprite(sprite, itemInstancing);
  }
  if (sprite.bindMarker) {
    if (marker) {
      markers = new Ext.chart.Markers;
      markersTpl = Ext.Object.merge({}, marker);
      if (me.getHighlight()) {
        markersTpl.highlight = me.getHighlight();
        markersTpl.modifiers = ['highlight'];
      }
      markers.setTemplate(markersTpl);
      markers.getTemplate().fx.setCustomDurations({translationX:0, translationY:0});
      sprite.dataMarker = markers;
      sprite.bindMarker('markers', markers);
      me.getOverlaySurface().add(markers);
    }
    if (me.getLabel().getTemplate().getField()) {
      sprite.bindMarker('labels', me.getLabel());
    }
  }
  if (sprite.setStore) {
    sprite.setStore(me.getStore());
  }
  sprite.fx.on('animationstart', 'onSpriteAnimationStart', me);
  sprite.fx.on('animationend', 'onSpriteAnimationEnd', me);
  me.sprites.push(sprite);
  return sprite;
}, getSprites:Ext.emptyFn, onDataChanged:function() {
  var me = this, chart = me.getChart(), chartStore = chart && chart.getStore(), seriesStore = me.getStore();
  if (seriesStore !== chartStore) {
    me.processData();
  }
}, isXType:function(xtype) {
  return xtype === 'series';
}, getItemId:function() {
  return this.getId();
}, applyThemeStyle:function(theme, oldTheme) {
  var me = this, fill, stroke;
  fill = theme && theme.subStyle && theme.subStyle.fillStyle;
  stroke = fill && theme.subStyle.strokeStyle;
  if (fill && !stroke) {
    theme.subStyle.strokeStyle = me.getStrokeColorsFromFillColors(fill);
  }
  fill = theme && theme.markerSubStyle && theme.markerSubStyle.fillStyle;
  stroke = fill && theme.markerSubStyle.strokeStyle;
  if (fill && !stroke) {
    theme.markerSubStyle.strokeStyle = me.getStrokeColorsFromFillColors(fill);
  }
  return Ext.apply(oldTheme || {}, theme);
}, applyStyle:function(style, oldStyle) {
  var cls = Ext.ClassManager.get(Ext.ClassManager.getNameByAlias('sprite.' + this.seriesType));
  if (cls && cls.def) {
    style = cls.def.normalize(style);
  }
  return Ext.apply({}, style, oldStyle);
}, applySubStyle:function(subStyle, oldSubStyle) {
  var cls = Ext.ClassManager.get(Ext.ClassManager.getNameByAlias('sprite.' + this.seriesType));
  if (cls && cls.def) {
    subStyle = cls.def.batchedNormalize(subStyle, true);
  }
  return Ext.merge({}, oldSubStyle, subStyle);
}, applyMarker:function(marker, oldMarker) {
  var type = marker && marker.type || oldMarker && oldMarker.type || 'circle', cls = Ext.ClassManager.get(Ext.ClassManager.getNameByAlias('sprite.' + type));
  if (cls && cls.def) {
    marker = cls.def.normalize(Ext.isObject(marker) ? marker : {}, true);
    marker.type = type;
  }
  return Ext.merge(oldMarker || {}, marker);
}, applyMarkerSubStyle:function(marker, oldMarker) {
  var type = marker && marker.type || oldMarker && oldMarker.type || 'circle', cls = Ext.ClassManager.get(Ext.ClassManager.getNameByAlias('sprite.' + type));
  if (cls && cls.def) {
    marker = cls.def.batchedNormalize(marker, true);
  }
  return Ext.merge(oldMarker || {}, marker);
}, updateHidden:function(hidden) {
  var me = this;
  me.getColors();
  me.getSubStyle();
  me.setSubStyle({hidden:hidden});
  me.processData();
  me.doUpdateStyles();
  if (!Ext.isArray(hidden)) {
    me.updateLegendStore(hidden);
  }
}, updateLegendStore:function(hidden, index) {
  var me = this, chart = me.getChart(), legendStore = chart.getLegendStore(), id = me.getId(), record;
  if (legendStore) {
    if (arguments.length > 1) {
      record = legendStore.findBy(function(rec) {
        return rec.get('series') === id && rec.get('index') === index;
      });
      if (record !== -1) {
        record = legendStore.getAt(record);
      }
    } else {
      record = legendStore.findRecord('series', id);
    }
    if (record && record.get('disabled') !== hidden) {
      record.set('disabled', hidden);
    }
  }
}, setHiddenByIndex:function(index, value) {
  var me = this;
  if (Ext.isArray(me.getHidden())) {
    me.getHidden()[index] = value;
    me.updateHidden(me.getHidden());
    me.updateLegendStore(value, index);
  } else {
    me.setHidden(value);
  }
}, getStrokeColorsFromFillColors:function(colors) {
  var me = this, darker = me.getUseDarkerStrokeColor(), darkerRatio = Ext.isNumber(darker) ? darker : me.darkerStrokeRatio, strokeColors;
  if (darker) {
    strokeColors = Ext.Array.map(colors, function(color) {
      color = Ext.isString(color) ? color : color.stops[0].color;
      color = Ext.draw.Color.fromString(color);
      return color.createDarker(darkerRatio).toString();
    });
  } else {
    strokeColors = Ext.Array.clone(colors);
  }
  return strokeColors;
}, updateThemeColors:function(colors) {
  var me = this, theme = me.getThemeStyle(), fillColors = Ext.Array.clone(colors), strokeColors = me.getStrokeColorsFromFillColors(colors), newSubStyle = {fillStyle:fillColors, strokeStyle:strokeColors};
  theme.subStyle = Ext.apply(theme.subStyle || {}, newSubStyle);
  theme.markerSubStyle = Ext.apply(theme.markerSubStyle || {}, newSubStyle);
  me.doUpdateStyles();
}, themeOnlyIfConfigured:{}, updateTheme:function(theme) {
  var me = this, seriesTheme = theme.getSeries(), initialConfig = me.getInitialConfig(), defaultConfig = me.defaultConfig, configs = me.getConfigurator().configs, genericSeriesTheme = seriesTheme.defaults, specificSeriesTheme = seriesTheme[me.type], themeOnlyIfConfigured = me.themeOnlyIfConfigured, key, value, isObjValue, isUnusedConfig, initialValue, cfg;
  seriesTheme = Ext.merge({}, genericSeriesTheme, specificSeriesTheme);
  for (key in seriesTheme) {
    value = seriesTheme[key];
    cfg = configs[key];
    if (value !== null && value !== undefined && cfg) {
      initialValue = initialConfig[key];
      isObjValue = Ext.isObject(value);
      isUnusedConfig = initialValue === defaultConfig[key];
      if (isObjValue) {
        if (isUnusedConfig && themeOnlyIfConfigured[key]) {
          continue;
        }
        value = Ext.merge({}, value, initialValue);
      }
      if (isUnusedConfig || isObjValue) {
        me[cfg.names.set](value);
      }
    }
  }
}, updateChartColors:function(colors) {
  var me = this;
  if (!me.getColors()) {
    me.updateThemeColors(colors);
  }
}, updateColors:function(colors) {
  this.updateThemeColors(colors);
}, updateStyle:function() {
  this.doUpdateStyles();
}, updateSubStyle:function() {
  this.doUpdateStyles();
}, updateThemeStyle:function() {
  this.doUpdateStyles();
}, doUpdateStyles:function() {
  var me = this, sprites = me.sprites, itemInstancing = me.getItemInstancing(), i = 0, ln = sprites && sprites.length, showMarkers = me.getConfig('showMarkers', true), markerCfg = me.getMarker(), style;
  for (; i < ln; i++) {
    style = me.getStyleByIndex(i);
    if (itemInstancing) {
      sprites[i].itemsMarker.getTemplate().setAttributes(style);
    }
    sprites[i].setAttributes(style);
    if (markerCfg && sprites[i].dataMarker) {
      sprites[i].dataMarker.getTemplate().setAttributes(me.getMarkerStyleByIndex(i));
    }
  }
}, getStyleWithTheme:function() {
  var me = this, theme = me.getThemeStyle(), seriesThemeStyle = theme && theme.style || {}, style = Ext.applyIf(Ext.apply({}, me.getStyle()), seriesThemeStyle);
  return style;
}, getSubStyleWithTheme:function() {
  var me = this, theme = me.getThemeStyle(), seriesThemeSubStyle = theme && theme.subStyle || {}, subStyle = Ext.applyIf(Ext.apply({}, me.getSubStyle()), seriesThemeSubStyle);
  return subStyle;
}, getStyleByIndex:function(i) {
  var me = this, theme = me.getThemeStyle(), style, themeStyle, subStyle, themeSubStyle, result = {};
  style = me.getStyle();
  themeStyle = theme && theme.style || {};
  subStyle = me.styleDataForIndex(me.getSubStyle(), i);
  themeSubStyle = me.styleDataForIndex(theme && theme.subStyle, i);
  Ext.apply(result, themeStyle);
  Ext.apply(result, themeSubStyle);
  Ext.apply(result, style);
  Ext.apply(result, subStyle);
  return result;
}, getMarkerStyleByIndex:function(i) {
  var me = this, theme = me.getThemeStyle(), style, themeStyle, subStyle, themeSubStyle, markerStyle, themeMarkerStyle, markerSubStyle, themeMarkerSubStyle, result = {};
  style = me.getStyle();
  themeStyle = theme && theme.style || {};
  subStyle = me.styleDataForIndex(me.getSubStyle(), i);
  if (subStyle.hasOwnProperty('hidden')) {
    subStyle.hidden = subStyle.hidden || !this.getConfig('showMarkers', true);
  }
  themeSubStyle = me.styleDataForIndex(theme && theme.subStyle, i);
  markerStyle = me.getMarker();
  themeMarkerStyle = theme && theme.marker || {};
  markerSubStyle = me.getMarkerSubStyle();
  themeMarkerSubStyle = me.styleDataForIndex(theme && theme.markerSubStyle, i);
  Ext.apply(result, themeStyle);
  Ext.apply(result, themeSubStyle);
  Ext.apply(result, themeMarkerStyle);
  Ext.apply(result, themeMarkerSubStyle);
  Ext.apply(result, style);
  Ext.apply(result, subStyle);
  Ext.apply(result, markerStyle);
  Ext.apply(result, markerSubStyle);
  return result;
}, styleDataForIndex:function(style, i) {
  var value, name, result = {};
  if (style) {
    for (name in style) {
      value = style[name];
      if (Ext.isArray(value)) {
        result[name] = value[i % value.length];
      } else {
        result[name] = value;
      }
    }
  }
  return result;
}, getItemForPoint:Ext.emptyFn, getItemByIndex:function(index, category) {
  var me = this, sprites = me.getSprites(), sprite = sprites && sprites[0], item;
  if (!sprite) {
    return;
  }
  if (category === undefined && sprite.isMarkerHolder) {
    category = me.getItemInstancing() ? 'items' : 'markers';
  } else {
    if (!category || category === '' || category === 'sprites') {
      sprite = sprites[index];
    }
  }
  if (sprite) {
    item = {series:me, category:category, index:index, record:me.getStore().getData().items[index], field:me.getYField(), sprite:sprite};
    return item;
  }
}, onSpriteAnimationStart:function(sprite) {
  this.fireEvent('animationstart', this, sprite);
}, onSpriteAnimationEnd:function(sprite) {
  this.fireEvent('animationend', this, sprite);
}, resolveListenerScope:function(defaultScope) {
  var me = this, namedScope = Ext._namedScopes[defaultScope], chart = me.getChart(), scope;
  if (!namedScope) {
    scope = chart ? chart.resolveListenerScope(defaultScope, false) : defaultScope || me;
  } else {
    if (namedScope.isThis) {
      scope = me;
    } else {
      if (namedScope.isController) {
        scope = chart ? chart.resolveListenerScope(defaultScope, false) : me;
      } else {
        if (namedScope.isSelf) {
          scope = chart ? chart.resolveListenerScope(defaultScope, false) : me;
          if (scope === chart && !chart.getInheritedConfig('defaultListenerScope')) {
            scope = me;
          }
        }
      }
    }
  }
  return scope;
}, provideLegendInfo:function(target) {
  target.push({name:this.getTitle() || this.getId(), mark:'black', disabled:this.getHidden(), series:this.getId(), index:0});
}, clearSprites:function() {
  var sprites = this.sprites, sprite, i, ln;
  for (i = 0, ln = sprites.length; i < ln; i++) {
    sprite = sprites[i];
    if (sprite && sprite.isSprite) {
      sprite.destroy();
    }
  }
  this.sprites = [];
}, destroy:function() {
  var me = this, store = me._store, tooltip = me.getConfig('tooltip', true);
  if (store && store.getAutoDestroy()) {
    Ext.destroy(store);
  }
  me.setChart(null);
  me.clearListeners();
  if (tooltip) {
    Ext.destroy(tooltip);
    clearTimeout(me.tooltipTimeout);
  }
  me.callParent();
}});
Ext.define('Ext.chart.interactions.Abstract', {xtype:'interaction', mixins:{observable:Ext.mixin.Observable}, config:{gestures:{tap:'onGesture'}, chart:null, enabled:true}, throttleGap:0, stopAnimationBeforeSync:false, constructor:function(config) {
  var me = this, id;
  config = config || {};
  if ('id' in config) {
    id = config.id;
  } else {
    if ('id' in me.config) {
      id = me.config.id;
    } else {
      id = me.getId();
    }
  }
  me.setId(id);
  me.mixins.observable.constructor.call(me, config);
}, initialize:Ext.emptyFn, updateChart:function(newChart, oldChart) {
  var me = this;
  if (oldChart === newChart) {
    return;
  }
  if (oldChart) {
    oldChart.unregister(me);
    me.removeChartListener(oldChart);
  }
  if (newChart) {
    newChart.register(me);
    me.addChartListener();
  }
}, updateEnabled:function(enabled) {
  var me = this, chart = me.getChart();
  if (chart) {
    if (enabled) {
      me.addChartListener();
    } else {
      me.removeChartListener(chart);
    }
  }
}, onGesture:Ext.emptyFn, getItemForEvent:function(e) {
  var me = this, chart = me.getChart(), chartXY = chart.getEventXY(e);
  return chart.getItemForPoint(chartXY[0], chartXY[1]);
}, getItemsForEvent:function(e) {
  var me = this, chart = me.getChart(), chartXY = chart.getEventXY(e);
  return chart.getItemsForPoint(chartXY[0], chartXY[1]);
}, addChartListener:function() {
  var me = this, chart = me.getChart(), gestures = me.getGestures(), gesture;
  if (!me.getEnabled()) {
    return;
  }
  function insertGesture(name, fn) {
    chart.addElementListener(name, me.listeners[name] = function(e) {
      var locks = me.getLocks(), result;
      if (me.getEnabled() && (!(name in locks) || locks[name] === me)) {
        result = (Ext.isFunction(fn) ? fn : me[fn]).apply(this, arguments);
        if (result === false && e && e.stopPropagation) {
          e.stopPropagation();
        }
        return result;
      }
    }, me);
  }
  me.listeners = me.listeners || {};
  for (gesture in gestures) {
    insertGesture(gesture, gestures[gesture]);
  }
}, removeChartListener:function(chart) {
  var me = this, gestures = me.getGestures(), gesture;
  function removeGesture(name) {
    var fn = me.listeners[name];
    if (fn) {
      chart.removeElementListener(name, fn);
      delete me.listeners[name];
    }
  }
  if (me.listeners) {
    for (gesture in gestures) {
      removeGesture(gesture);
    }
  }
}, lockEvents:function() {
  var me = this, locks = me.getLocks(), args = Array.prototype.slice.call(arguments), i = args.length;
  while (i--) {
    locks[args[i]] = me;
  }
}, unlockEvents:function() {
  var locks = this.getLocks(), args = Array.prototype.slice.call(arguments), i = args.length;
  while (i--) {
    delete locks[args[i]];
  }
}, getLocks:function() {
  var chart = this.getChart();
  return chart.lockedEvents || (chart.lockedEvents = {});
}, isMultiTouch:function() {
  if (Ext.browser.is.IE10) {
    return true;
  }
  return !Ext.os.is.Desktop;
}, initializeDefaults:Ext.emptyFn, doSync:function() {
  var me = this, chart = me.getChart();
  if (me.syncTimer) {
    clearTimeout(me.syncTimer);
    me.syncTimer = null;
  }
  if (me.stopAnimationBeforeSync) {
    chart.animationSuspendCount++;
  }
  chart.redraw();
  if (me.stopAnimationBeforeSync) {
    chart.animationSuspendCount--;
  }
  me.syncThrottle = Date.now() + me.throttleGap;
}, sync:function() {
  var me = this;
  if (me.throttleGap && Ext.frameStartTime < me.syncThrottle) {
    if (me.syncTimer) {
      return;
    }
    me.syncTimer = Ext.defer(function() {
      me.doSync();
    }, me.throttleGap);
  } else {
    me.doSync();
  }
}, getItemId:function() {
  return this.getId();
}, isXType:function(xtype) {
  return xtype === 'interaction';
}, destroy:function() {
  var me = this;
  me.setChart(null);
  delete me.listeners;
  me.callParent();
}}, function() {
  if (Ext.os.is.Android4) {
    this.prototype.throttleGap = 40;
  }
});
Ext.define('Ext.chart.MarkerHolder', {extend:Ext.Mixin, mixinConfig:{id:'markerHolder', after:{constructor:'constructor', preRender:'preRender'}, before:{destroy:'destroy'}}, isMarkerHolder:true, surfaceMatrix:null, inverseSurfaceMatrix:null, deprecated:{6:{methods:{getBoundMarker:{message:"Please use the 'getMarker' method instead.", fn:function(name) {
  var marker = this.boundMarkers[name];
  return marker ? [marker] : marker;
}}}}}, constructor:function() {
  this.boundMarkers = {};
  this.cleanRedraw = false;
}, bindMarker:function(name, marker) {
  var me = this, markers = me.boundMarkers;
  if (marker && marker.isMarkers) {
    if (markers[name] && markers[name] === marker) {
      Ext.log.warn(me.getId(), " (MarkerHolder): the Markers instance '", marker.getId(), "' is already bound under the name '", name, "'.");
    }
    me.releaseMarker(name);
    markers[name] = marker;
    marker.on('destroy', me.onMarkerDestroy, me);
  }
}, onMarkerDestroy:function(marker) {
  this.releaseMarker(marker);
}, releaseMarker:function(marker) {
  var markers = this.boundMarkers, name;
  if (marker && marker.isMarkers) {
    for (name in markers) {
      if (markers[name] === marker) {
        delete markers[name];
        break;
      }
    }
  } else {
    name = marker;
    marker = markers[name];
    delete markers[name];
  }
  return marker || null;
}, getMarker:function(name) {
  return this.boundMarkers[name] || null;
}, preRender:function() {
  var me = this, id = me.getId(), boundMarkers = me.boundMarkers, parent = me.getParent(), name, marker, matrix;
  if (me.surfaceMatrix) {
    matrix = me.surfaceMatrix.set(1, 0, 0, 1, 0, 0);
  } else {
    matrix = me.surfaceMatrix = new Ext.draw.Matrix;
  }
  me.cleanRedraw = !me.attr.dirty;
  if (!me.cleanRedraw) {
    for (name in boundMarkers) {
      marker = boundMarkers[name];
      if (marker) {
        marker.clear(id);
      }
    }
  }
  while (parent && parent.attr && parent.attr.matrix) {
    matrix.prependMatrix(parent.attr.matrix);
    parent = parent.getParent();
  }
  matrix.prependMatrix(parent.matrix);
  me.surfaceMatrix = matrix;
  me.inverseSurfaceMatrix = matrix.inverse(me.inverseSurfaceMatrix);
}, putMarker:function(name, attr, index, bypassNormalization, keepRevision) {
  var marker = this.boundMarkers[name], id = this.getId();
  if (marker) {
    marker.putMarkerFor(id, attr, index, bypassNormalization, keepRevision);
  }
}, getMarkerBBox:function(name, index, isWithoutTransform) {
  var marker = this.boundMarkers[name], id = this.getId();
  if (marker) {
    return marker.getMarkerBBoxFor(id, index, isWithoutTransform);
  }
}, destroy:function() {
  var boundMarkers = this.boundMarkers, name, marker;
  for (name in boundMarkers) {
    marker = boundMarkers[name];
    marker.destroy();
  }
}});
Ext.define('Ext.chart.axis.sprite.Axis', {extend:Ext.draw.sprite.Sprite, alias:'sprite.axis', type:'axis', mixins:{markerHolder:Ext.chart.MarkerHolder}, inheritableStatics:{def:{processors:{grid:'bool', axisLine:'bool', minorTicks:'bool', minorTickSize:'number', majorTicks:'bool', majorTickSize:'number', length:'number', startGap:'number', endGap:'number', dataMin:'number', dataMax:'number', visibleMin:'number', visibleMax:'number', position:'enums(left,right,top,bottom,angular,radial,gauge)', minStepSize:'number', 
estStepSize:'number', titleOffset:'number', textPadding:'number', min:'number', max:'number', centerX:'number', centerY:'number', radius:'number', totalAngle:'number', baseRotation:'number', data:'default', enlargeEstStepSizeByText:'bool'}, defaults:{grid:false, axisLine:true, minorTicks:false, minorTickSize:3, majorTicks:true, majorTickSize:5, length:0, startGap:0, endGap:0, visibleMin:0, visibleMax:1, dataMin:0, dataMax:1, position:'', minStepSize:0, estStepSize:20, min:0, max:1, centerX:0, centerY:0, 
radius:1, baseRotation:0, data:null, titleOffset:0, textPadding:0, scalingCenterY:0, scalingCenterX:0, strokeStyle:'black', enlargeEstStepSizeByText:false}, triggers:{minorTickSize:'bbox', majorTickSize:'bbox', position:'bbox,layout', axisLine:'bbox,layout', min:'layout', max:'layout', length:'layout', minStepSize:'layout', estStepSize:'layout', data:'layout', dataMin:'layout', dataMax:'layout', visibleMin:'layout', visibleMax:'layout', enlargeEstStepSizeByText:'layout'}, updaters:{layout:'layoutUpdater'}}}, 
config:{label:null, layout:null, segmenter:null, renderer:null, layoutContext:null, axis:null}, thickness:0, stepSize:0, getBBox:function() {
  return null;
}, defaultRenderer:function(v) {
  return this.segmenter.renderer(v, this);
}, layoutUpdater:function() {
  var me = this, chart = me.getAxis().getChart();
  if (chart.isInitializing) {
    return;
  }
  var attr = me.attr, layout = me.getLayout(), isRtl = chart.getInherited().rtl, min = attr.dataMin + (attr.dataMax - attr.dataMin) * attr.visibleMin, max = attr.dataMin + (attr.dataMax - attr.dataMin) * attr.visibleMax, position = attr.position, context = {attr:attr, segmenter:me.getSegmenter(), renderer:me.defaultRenderer};
  if (position === 'left' || position === 'right') {
    attr.translationX = 0;
    attr.translationY = max * attr.length / (max - min);
    attr.scalingX = 1;
    attr.scalingY = -attr.length / (max - min);
    attr.scalingCenterY = 0;
    attr.scalingCenterX = 0;
    me.applyTransformations(true);
  } else {
    if (position === 'top' || position === 'bottom') {
      if (isRtl) {
        attr.translationX = attr.length + min * attr.length / (max - min) + 1;
      } else {
        attr.translationX = -min * attr.length / (max - min);
      }
      attr.translationY = 0;
      attr.scalingX = (isRtl ? -1 : 1) * attr.length / (max - min);
      attr.scalingY = 1;
      attr.scalingCenterY = 0;
      attr.scalingCenterX = 0;
      me.applyTransformations(true);
    }
  }
  if (layout) {
    layout.calculateLayout(context);
    me.setLayoutContext(context);
  }
}, iterate:function(snaps, fn) {
  var i, position, id, axis, floatingAxes, floatingValues, some = Ext.Array.some, abs = Math.abs, threshold;
  if (snaps.getLabel) {
    if (snaps.min < snaps.from) {
      fn.call(this, snaps.min, snaps.getLabel(snaps.min), -1, snaps);
    }
    for (i = 0; i <= snaps.steps; i++) {
      fn.call(this, snaps.get(i), snaps.getLabel(i), i, snaps);
    }
    if (snaps.max > snaps.to) {
      fn.call(this, snaps.max, snaps.getLabel(snaps.max), snaps.steps + 1, snaps);
    }
  } else {
    var isTickVisible = function(position) {
      return !floatingValues.length || some(floatingValues, function(value) {
        return abs(value - position) > threshold;
      });
    };
    axis = this.getAxis();
    floatingAxes = axis.floatingAxes;
    floatingValues = [];
    threshold = (snaps.to - snaps.from) / (snaps.steps + 1);
    if (axis.getFloating()) {
      for (id in floatingAxes) {
        floatingValues.push(floatingAxes[id]);
      }
    }
    if (snaps.min < snaps.from && isTickVisible(snaps.min)) {
      fn.call(this, snaps.min, snaps.min, -1, snaps);
    }
    for (i = 0; i <= snaps.steps; i++) {
      position = snaps.get(i);
      if (isTickVisible(position)) {
        fn.call(this, position, position, i, snaps);
      }
    }
    if (snaps.max > snaps.to && isTickVisible(snaps.max)) {
      fn.call(this, snaps.max, snaps.max, snaps.steps + 1, snaps);
    }
  }
}, renderTicks:function(surface, ctx, layout, clipRect) {
  var me = this, attr = me.attr, docked = attr.position, matrix = attr.matrix, halfLineWidth = 0.5 * attr.lineWidth, xx = matrix.getXX(), dx = matrix.getDX(), yy = matrix.getYY(), dy = matrix.getDY(), majorTicks = layout.majorTicks, majorTickSize = attr.majorTickSize, minorTicks = layout.minorTicks, minorTickSize = attr.minorTickSize;
  if (majorTicks) {
    switch(docked) {
      case 'right':
        var getRightTickFn = function(size) {
          return function(position, labelText, i) {
            position = surface.roundPixel(position * yy + dy) + halfLineWidth;
            ctx.moveTo(0, position);
            ctx.lineTo(size, position);
          };
        };
        me.iterate(majorTicks, getRightTickFn(majorTickSize));
        minorTicks && me.iterate(minorTicks, getRightTickFn(minorTickSize));
        break;
      case 'left':
        var getLeftTickFn = function(size) {
          return function(position, labelText, i) {
            position = surface.roundPixel(position * yy + dy) + halfLineWidth;
            ctx.moveTo(clipRect[2] - size, position);
            ctx.lineTo(clipRect[2], position);
          };
        };
        me.iterate(majorTicks, getLeftTickFn(majorTickSize));
        minorTicks && me.iterate(minorTicks, getLeftTickFn(minorTickSize));
        break;
      case 'bottom':
        var getBottomTickFn = function(size) {
          return function(position, labelText, i) {
            position = surface.roundPixel(position * xx + dx) - halfLineWidth;
            ctx.moveTo(position, 0);
            ctx.lineTo(position, size);
          };
        };
        me.iterate(majorTicks, getBottomTickFn(majorTickSize));
        minorTicks && me.iterate(minorTicks, getBottomTickFn(minorTickSize));
        break;
      case 'top':
        var getTopTickFn = function(size) {
          return function(position, labelText, i) {
            position = surface.roundPixel(position * xx + dx) - halfLineWidth;
            ctx.moveTo(position, clipRect[3]);
            ctx.lineTo(position, clipRect[3] - size);
          };
        };
        me.iterate(majorTicks, getTopTickFn(majorTickSize));
        minorTicks && me.iterate(minorTicks, getTopTickFn(minorTickSize));
        break;
      case 'angular':
        me.iterate(majorTicks, function(position, labelText, i) {
          position = position / (attr.max + 1) * Math.PI * 2 + attr.baseRotation;
          ctx.moveTo(attr.centerX + attr.length * Math.cos(position), attr.centerY + attr.length * Math.sin(position));
          ctx.lineTo(attr.centerX + (attr.length + majorTickSize) * Math.cos(position), attr.centerY + (attr.length + majorTickSize) * Math.sin(position));
        });
        break;
      case 'gauge':
        var gaugeAngles = me.getGaugeAngles();
        me.iterate(majorTicks, function(position, labelText, i) {
          position = (position - attr.min) / (attr.max - attr.min + 1) * attr.totalAngle - attr.totalAngle + gaugeAngles.start;
          ctx.moveTo(attr.centerX + attr.length * Math.cos(position), attr.centerY + attr.length * Math.sin(position));
          ctx.lineTo(attr.centerX + (attr.length + majorTickSize) * Math.cos(position), attr.centerY + (attr.length + majorTickSize) * Math.sin(position));
        });
        break;
    }
  }
}, renderLabels:function(surface, ctx, layoutContext, clipRect) {
  var me = this, attr = me.attr, halfLineWidth = 0.5 * attr.lineWidth, docked = attr.position, matrix = attr.matrix, textPadding = attr.textPadding, xx = matrix.getXX(), dx = matrix.getDX(), yy = matrix.getYY(), dy = matrix.getDY(), thickness = 0, majorTicks = layoutContext.majorTicks, tickPadding = Math.max(attr.majorTickSize, attr.minorTickSize) + attr.lineWidth, isBBoxIntersect = Ext.draw.Draw.isBBoxIntersect, label = me.getLabel(), font, labelOffset, lastLabelText = null, textSize = 0, textCount = 
  0, segmenter = layoutContext.segmenter, renderer = me.getRenderer(), axis = me.getAxis(), title = axis.getTitle(), titleBBox = title && title.attr.text !== '' && title.getBBox(), labelInverseMatrix, lastBBox = null, bbox, fly, text, titlePadding, translation;
  if (majorTicks && label && !label.attr.hidden) {
    font = label.attr.font;
    if (ctx.font !== font) {
      ctx.font = font;
    }
    label.setAttributes({translationX:0, translationY:0}, true);
    label.applyTransformations();
    labelInverseMatrix = label.attr.inverseMatrix.elements.slice(0);
    switch(docked) {
      case 'left':
        titlePadding = titleBBox ? titleBBox.x + titleBBox.width : 0;
        switch(label.attr.textAlign) {
          case 'start':
            translation = surface.roundPixel(titlePadding + dx) - halfLineWidth;
            break;
          case 'end':
            translation = surface.roundPixel(clipRect[2] - tickPadding + dx) - halfLineWidth;
            break;
          default:
            translation = surface.roundPixel(titlePadding + (clipRect[2] - titlePadding - tickPadding) / 2 + dx) - halfLineWidth;
        }label.setAttributes({translationX:translation}, true);
        break;
      case 'right':
        titlePadding = titleBBox ? clipRect[2] - titleBBox.x : 0;
        switch(label.attr.textAlign) {
          case 'start':
            translation = surface.roundPixel(tickPadding + dx) + halfLineWidth;
            break;
          case 'end':
            translation = surface.roundPixel(clipRect[2] - titlePadding + dx) + halfLineWidth;
            break;
          default:
            translation = surface.roundPixel(tickPadding + (clipRect[2] - tickPadding - titlePadding) / 2 + dx) + halfLineWidth;
        }label.setAttributes({translationX:translation}, true);
        break;
      case 'top':
        titlePadding = titleBBox ? titleBBox.y + titleBBox.height : 0;
        label.setAttributes({translationY:surface.roundPixel(titlePadding + (clipRect[3] - titlePadding - tickPadding) / 2) - halfLineWidth}, true);
        break;
      case 'bottom':
        titlePadding = titleBBox ? clipRect[3] - titleBBox.y : 0;
        label.setAttributes({translationY:surface.roundPixel(tickPadding + (clipRect[3] - tickPadding - titlePadding) / 2) + halfLineWidth}, true);
        break;
      case 'radial':
        label.setAttributes({translationX:attr.centerX}, true);
        break;
      case 'angular':
        label.setAttributes({translationY:attr.centerY}, true);
        break;
      case 'gauge':
        label.setAttributes({translationY:attr.centerY}, true);
        break;
    }
    if (docked === 'left' || docked === 'right') {
      me.iterate(majorTicks, function(position, labelText, i) {
        if (labelText === undefined) {
          return;
        }
        if (renderer) {
          text = Ext.callback(renderer, null, [axis, labelText, layoutContext, lastLabelText], 0, axis);
        } else {
          text = segmenter.renderer(labelText, layoutContext, lastLabelText);
        }
        lastLabelText = labelText;
        label.setAttributes({text:String(text), translationY:surface.roundPixel(position * yy + dy)}, true);
        label.applyTransformations();
        thickness = Math.max(thickness, label.getBBox().width + tickPadding);
        if (thickness <= me.thickness) {
          fly = Ext.draw.Matrix.fly(label.attr.matrix.elements.slice(0));
          bbox = fly.prepend.apply(fly, labelInverseMatrix).transformBBox(label.getBBox(true));
          if (lastBBox && !isBBoxIntersect(bbox, lastBBox, textPadding)) {
            return;
          }
          surface.renderSprite(label);
          lastBBox = bbox;
          textSize += bbox.height;
          textCount++;
        }
      });
    } else {
      if (docked === 'top' || docked === 'bottom') {
        me.iterate(majorTicks, function(position, labelText, i) {
          if (labelText === undefined) {
            return;
          }
          if (renderer) {
            text = Ext.callback(renderer, null, [axis, labelText, layoutContext, lastLabelText], 0, axis);
          } else {
            text = segmenter.renderer(labelText, layoutContext, lastLabelText);
          }
          lastLabelText = labelText;
          label.setAttributes({text:String(text), translationX:surface.roundPixel(position * xx + dx)}, true);
          label.applyTransformations();
          thickness = Math.max(thickness, label.getBBox().height + tickPadding);
          if (thickness <= me.thickness) {
            fly = Ext.draw.Matrix.fly(label.attr.matrix.elements.slice(0));
            bbox = fly.prepend.apply(fly, labelInverseMatrix).transformBBox(label.getBBox(true));
            if (lastBBox && !isBBoxIntersect(bbox, lastBBox, textPadding)) {
              return;
            }
            surface.renderSprite(label);
            lastBBox = bbox;
            textSize += bbox.width;
            textCount++;
          }
        });
      } else {
        if (docked === 'radial') {
          me.iterate(majorTicks, function(position, labelText, i) {
            if (labelText === undefined) {
              return;
            }
            if (renderer) {
              text = Ext.callback(renderer, null, [axis, labelText, layoutContext, lastLabelText], 0, axis);
            } else {
              text = segmenter.renderer(labelText, layoutContext, lastLabelText);
            }
            lastLabelText = labelText;
            if (typeof text !== 'undefined') {
              label.setAttributes({text:String(text), translationX:attr.centerX - surface.roundPixel(position) / attr.max * attr.length * Math.cos(attr.baseRotation + Math.PI / 2), translationY:attr.centerY - surface.roundPixel(position) / attr.max * attr.length * Math.sin(attr.baseRotation + Math.PI / 2)}, true);
              label.applyTransformations();
              bbox = label.attr.matrix.transformBBox(label.getBBox(true));
              if (lastBBox && !isBBoxIntersect(bbox, lastBBox)) {
                return;
              }
              surface.renderSprite(label);
              lastBBox = bbox;
              textSize += bbox.width;
              textCount++;
            }
          });
        } else {
          if (docked === 'angular') {
            labelOffset = attr.majorTickSize + attr.lineWidth * 0.5 + (parseInt(label.attr.fontSize, 10) || 10) / 2;
            me.iterate(majorTicks, function(position, labelText, i) {
              if (labelText === undefined) {
                return;
              }
              if (renderer) {
                text = Ext.callback(renderer, null, [axis, labelText, layoutContext, lastLabelText], 0, axis);
              } else {
                text = segmenter.renderer(labelText, layoutContext, lastLabelText);
              }
              lastLabelText = labelText;
              thickness = Math.max(thickness, Math.max(attr.majorTickSize, attr.minorTickSize) + (attr.lineCap !== 'butt' ? attr.lineWidth * 0.5 : 0));
              if (typeof text !== 'undefined') {
                var angle = position / (attr.max + 1) * Math.PI * 2 + attr.baseRotation;
                label.setAttributes({text:String(text), translationX:attr.centerX + (attr.length + labelOffset) * Math.cos(angle), translationY:attr.centerY + (attr.length + labelOffset) * Math.sin(angle)}, true);
                label.applyTransformations();
                bbox = label.attr.matrix.transformBBox(label.getBBox(true));
                if (lastBBox && !isBBoxIntersect(bbox, lastBBox)) {
                  return;
                }
                surface.renderSprite(label);
                lastBBox = bbox;
                textSize += bbox.width;
                textCount++;
              }
            });
          } else {
            if (docked === 'gauge') {
              var gaugeAngles = me.getGaugeAngles();
              me.iterate(majorTicks, function(position, labelText, i) {
                if (labelText === undefined) {
                  return;
                }
                if (renderer) {
                  text = Ext.callback(renderer, null, [axis, labelText, layoutContext, lastLabelText], 0, axis);
                } else {
                  text = segmenter.renderer(labelText, layoutContext, lastLabelText);
                }
                lastLabelText = labelText;
                if (typeof text !== 'undefined') {
                  var angle = (position - attr.min) / (attr.max - attr.min + 1) * attr.totalAngle - attr.totalAngle + gaugeAngles.start;
                  label.setAttributes({text:String(text), translationX:attr.centerX + (attr.length + 10) * Math.cos(angle), translationY:attr.centerY + (attr.length + 10) * Math.sin(angle)}, true);
                  label.applyTransformations();
                  bbox = label.attr.matrix.transformBBox(label.getBBox(true));
                  if (lastBBox && !isBBoxIntersect(bbox, lastBBox)) {
                    return;
                  }
                  surface.renderSprite(label);
                  lastBBox = bbox;
                  textSize += bbox.width;
                  textCount++;
                }
              });
            }
          }
        }
      }
    }
    if (attr.enlargeEstStepSizeByText && textCount) {
      textSize /= textCount;
      textSize += tickPadding;
      textSize *= 2;
      if (attr.estStepSize < textSize) {
        attr.estStepSize = textSize;
      }
    }
    if (Math.abs(me.thickness - thickness) > 1) {
      me.thickness = thickness;
      attr.bbox.plain.dirty = true;
      attr.bbox.transform.dirty = true;
      me.doThicknessChanged();
      return false;
    }
  }
}, renderAxisLine:function(surface, ctx, layout, clipRect) {
  var me = this, attr = me.attr, halfLineWidth = attr.lineWidth * 0.5, docked = attr.position, position, gaugeAngles;
  if (attr.axisLine && attr.length) {
    switch(docked) {
      case 'left':
        position = surface.roundPixel(clipRect[2]) - halfLineWidth;
        ctx.moveTo(position, -attr.endGap);
        ctx.lineTo(position, attr.length + attr.startGap + 1);
        break;
      case 'right':
        ctx.moveTo(halfLineWidth, -attr.endGap);
        ctx.lineTo(halfLineWidth, attr.length + attr.startGap + 1);
        break;
      case 'bottom':
        ctx.moveTo(-attr.startGap, halfLineWidth);
        ctx.lineTo(attr.length + attr.endGap, halfLineWidth);
        break;
      case 'top':
        position = surface.roundPixel(clipRect[3]) - halfLineWidth;
        ctx.moveTo(-attr.startGap, position);
        ctx.lineTo(attr.length + attr.endGap, position);
        break;
      case 'angular':
        ctx.moveTo(attr.centerX + attr.length, attr.centerY);
        ctx.arc(attr.centerX, attr.centerY, attr.length, 0, Math.PI * 2, true);
        break;
      case 'gauge':
        gaugeAngles = me.getGaugeAngles();
        ctx.moveTo(attr.centerX + Math.cos(gaugeAngles.start) * attr.length, attr.centerY + Math.sin(gaugeAngles.start) * attr.length);
        ctx.arc(attr.centerX, attr.centerY, attr.length, gaugeAngles.start, gaugeAngles.end, true);
        break;
    }
  }
}, getGaugeAngles:function() {
  var me = this, angle = me.attr.totalAngle, offset;
  if (angle <= Math.PI) {
    offset = (Math.PI - angle) * 0.5;
  } else {
    offset = -(Math.PI * 2 - angle) * 0.5;
  }
  offset = Math.PI * 2 - offset;
  return {start:offset, end:offset - angle};
}, renderGridLines:function(surface, ctx, layout, clipRect) {
  var me = this, axis = me.getAxis(), attr = me.attr, matrix = attr.matrix, startGap = attr.startGap, endGap = attr.endGap, xx = matrix.getXX(), yy = matrix.getYY(), dx = matrix.getDX(), dy = matrix.getDY(), position = attr.position, alignment = axis.getGridAlignment(), majorTicks = layout.majorTicks, anchor, j, lastAnchor;
  if (attr.grid) {
    if (majorTicks) {
      if (position === 'left' || position === 'right') {
        lastAnchor = attr.min * yy + dy + endGap + startGap;
        me.iterate(majorTicks, function(position, labelText, i) {
          anchor = position * yy + dy + endGap;
          me.putMarker(alignment + '-' + (i % 2 ? 'odd' : 'even'), {y:anchor, height:lastAnchor - anchor}, j = i, true);
          lastAnchor = anchor;
        });
        j++;
        anchor = 0;
        me.putMarker(alignment + '-' + (j % 2 ? 'odd' : 'even'), {y:anchor, height:lastAnchor - anchor}, j, true);
      } else {
        if (position === 'top' || position === 'bottom') {
          lastAnchor = attr.min * xx + dx + startGap;
          if (startGap) {
            me.putMarker(alignment + '-even', {x:0, width:lastAnchor}, -1, true);
          }
          me.iterate(majorTicks, function(position, labelText, i) {
            anchor = position * xx + dx + startGap;
            me.putMarker(alignment + '-' + (i % 2 ? 'odd' : 'even'), {x:anchor, width:lastAnchor - anchor}, j = i, true);
            lastAnchor = anchor;
          });
          j++;
          anchor = attr.length + attr.startGap + attr.endGap;
          me.putMarker(alignment + '-' + (j % 2 ? 'odd' : 'even'), {x:anchor, width:lastAnchor - anchor}, j, true);
        } else {
          if (position === 'radial') {
            me.iterate(majorTicks, function(position, labelText, i) {
              if (!position) {
                return;
              }
              anchor = position / attr.max * attr.length;
              me.putMarker(alignment + '-' + (i % 2 ? 'odd' : 'even'), {scalingX:anchor, scalingY:anchor}, i, true);
              lastAnchor = anchor;
            });
          } else {
            if (position === 'angular') {
              me.iterate(majorTicks, function(position, labelText, i) {
                if (!attr.length) {
                  return;
                }
                anchor = position / (attr.max + 1) * Math.PI * 2 + attr.baseRotation;
                me.putMarker(alignment + '-' + (i % 2 ? 'odd' : 'even'), {rotationRads:anchor, rotationCenterX:0, rotationCenterY:0, scalingX:attr.length, scalingY:attr.length}, i, true);
                lastAnchor = anchor;
              });
            }
          }
        }
      }
    }
  }
}, renderLimits:function(clipRect) {
  var me = this, axis = me.getAxis(), chart = axis.getChart(), innerPadding = chart.getInnerPadding(), limits = Ext.Array.from(axis.getLimits());
  if (!limits.length) {
    return;
  }
  var limitsRect = axis.limits.surface.getRect(), attr = me.attr, matrix = attr.matrix, position = attr.position, chain = Ext.Object.chain, titles = axis.limits.titles, titleBBox, titlePosition, titleFlip, limit, value, i, ln, x, y;
  titles.instances = [];
  titles.position = 0;
  if (position === 'left' || position === 'right') {
    for (i = 0, ln = limits.length; i < ln; i++) {
      limit = chain(limits[i]);
      !limit.line && (limit.line = {});
      value = Ext.isString(limit.value) ? axis.getCoordFor(limit.value) : limit.value;
      value = value * matrix.getYY() + matrix.getDY();
      limit.line.y = value + innerPadding.top;
      limit.line.strokeStyle = limit.line.strokeStyle || attr.strokeStyle;
      me.putMarker('horizontal-limit-lines', limit.line, i, true);
      if (limit.line.title) {
        titles.createInstance(limit.line.title);
        titleBBox = titles.getBBoxFor(titles.position - 1);
        titlePosition = limit.line.title.position || (position === 'left' ? 'start' : 'end');
        switch(titlePosition) {
          case 'start':
            x = 10;
            break;
          case 'end':
            x = limitsRect[2] - 10;
            break;
          case 'middle':
            x = limitsRect[2] / 2;
            break;
        }
        titles.setAttributesFor(titles.position - 1, {x:x, y:limit.line.y - titleBBox.height / 2, textAlign:titlePosition, fillStyle:limit.line.title.fillStyle || limit.line.strokeStyle});
      }
    }
  } else {
    if (position === 'top' || position === 'bottom') {
      for (i = 0, ln = limits.length; i < ln; i++) {
        limit = chain(limits[i]);
        !limit.line && (limit.line = {});
        value = Ext.isString(limit.value) ? axis.getCoordFor(limit.value) : limit.value;
        value = value * matrix.getXX() + matrix.getDX();
        limit.line.x = value + innerPadding.left;
        limit.line.strokeStyle = limit.line.strokeStyle || attr.strokeStyle;
        me.putMarker('vertical-limit-lines', limit.line, i, true);
        if (limit.line.title) {
          titles.createInstance(limit.line.title);
          titleBBox = titles.getBBoxFor(titles.position - 1);
          titlePosition = limit.line.title.position || (position === 'top' ? 'end' : 'start');
          switch(titlePosition) {
            case 'start':
              y = limitsRect[3] - titleBBox.width / 2 - 10;
              break;
            case 'end':
              y = titleBBox.width / 2 + 10;
              break;
            case 'middle':
              y = limitsRect[3] / 2;
              break;
          }
          titles.setAttributesFor(titles.position - 1, {x:limit.line.x + titleBBox.height / 2, y:y, fillStyle:limit.line.title.fillStyle || limit.line.strokeStyle, rotationRads:Math.PI / 2});
        }
      }
    } else {
      if (position === 'radial') {
        for (i = 0, ln = limits.length; i < ln; i++) {
          limit = chain(limits[i]);
          !limit.line && (limit.line = {});
          value = Ext.isString(limit.value) ? axis.getCoordFor(limit.value) : limit.value;
          if (value > attr.max) {
            continue;
          }
          value = value / attr.max * attr.length;
          limit.line.cx = attr.centerX;
          limit.line.cy = attr.centerY;
          limit.line.scalingX = value;
          limit.line.scalingY = value;
          limit.line.strokeStyle = limit.line.strokeStyle || attr.strokeStyle;
          me.putMarker('circular-limit-lines', limit.line, i, true);
          if (limit.line.title) {
            titles.createInstance(limit.line.title);
            titleBBox = titles.getBBoxFor(titles.position - 1);
            titles.setAttributesFor(titles.position - 1, {x:attr.centerX, y:attr.centerY - value - titleBBox.height / 2, fillStyle:limit.line.title.fillStyle || limit.line.strokeStyle});
          }
        }
      } else {
        if (position === 'angular') {
          for (i = 0, ln = limits.length; i < ln; i++) {
            limit = chain(limits[i]);
            !limit.line && (limit.line = {});
            value = Ext.isString(limit.value) ? axis.getCoordFor(limit.value) : limit.value;
            value = value / (attr.max + 1) * Math.PI * 2 + attr.baseRotation;
            limit.line.translationX = attr.centerX;
            limit.line.translationY = attr.centerY;
            limit.line.rotationRads = value;
            limit.line.rotationCenterX = 0;
            limit.line.rotationCenterY = 0;
            limit.line.scalingX = attr.length;
            limit.line.scalingY = attr.length;
            limit.line.strokeStyle = limit.line.strokeStyle || attr.strokeStyle;
            me.putMarker('radial-limit-lines', limit.line, i, true);
            if (limit.line.title) {
              titles.createInstance(limit.line.title);
              titleBBox = titles.getBBoxFor(titles.position - 1);
              titleFlip = value > -0.5 * Math.PI && value < 0.5 * Math.PI || value > 1.5 * Math.PI && value < 2 * Math.PI ? 1 : -1;
              titles.setAttributesFor(titles.position - 1, {x:attr.centerX + 0.5 * attr.length * Math.cos(value) + titleFlip * titleBBox.height / 2 * Math.sin(value), y:attr.centerY + 0.5 * attr.length * Math.sin(value) - titleFlip * titleBBox.height / 2 * Math.cos(value), rotationRads:titleFlip === 1 ? value : value - Math.PI, fillStyle:limit.line.title.fillStyle || limit.line.strokeStyle});
            }
          }
        } else {
          if (position === 'gauge') {
          }
        }
      }
    }
  }
}, doThicknessChanged:function() {
  var axis = this.getAxis();
  if (axis) {
    axis.onThicknessChanged();
  }
}, render:function(surface, ctx, clipRect) {
  var me = this, layoutContext = me.getLayoutContext();
  if (layoutContext) {
    if (false === me.renderLabels(surface, ctx, layoutContext, clipRect)) {
      return false;
    }
    ctx.beginPath();
    me.renderTicks(surface, ctx, layoutContext, clipRect);
    me.renderAxisLine(surface, ctx, layoutContext, clipRect);
    me.renderGridLines(surface, ctx, layoutContext, clipRect);
    me.renderLimits(clipRect);
    ctx.stroke();
  }
}});
Ext.define('Ext.chart.axis.segmenter.Segmenter', {config:{axis:null}, constructor:function(config) {
  this.initConfig(config);
}, renderer:function(value, context) {
  return String(value);
}, from:function(value) {
  return value;
}, diff:Ext.emptyFn, align:Ext.emptyFn, add:Ext.emptyFn, preferredStep:Ext.emptyFn});
Ext.define('Ext.chart.axis.segmenter.Names', {extend:Ext.chart.axis.segmenter.Segmenter, alias:'segmenter.names', renderer:function(value, context) {
  return value;
}, diff:function(min, max, unit) {
  return Math.floor(max - min);
}, align:function(value, step, unit) {
  return Math.floor(value);
}, add:function(value, step, unit) {
  return value + step;
}, preferredStep:function(min, estStepSize, minIdx, data) {
  return {unit:1, step:1};
}});
Ext.define('Ext.chart.axis.segmenter.Numeric', {extend:Ext.chart.axis.segmenter.Segmenter, alias:'segmenter.numeric', isNumeric:true, renderer:function(value, context) {
  return value.toFixed(Math.max(0, context.majorTicks.unit.fixes));
}, diff:function(min, max, unit) {
  return Math.floor((max - min) / unit.scale);
}, align:function(value, step, unit) {
  return Math.floor(value / (unit.scale * step)) * unit.scale * step;
}, add:function(value, step, unit) {
  return value + step * unit.scale;
}, preferredStep:function(min, estStepSize) {
  var order = Math.floor(Math.log(estStepSize) * Math.LOG10E), scale = Math.pow(10, order);
  estStepSize /= scale;
  if (estStepSize < 2) {
    estStepSize = 2;
  } else {
    if (estStepSize < 5) {
      estStepSize = 5;
    } else {
      if (estStepSize < 10) {
        estStepSize = 10;
        order++;
      }
    }
  }
  return {unit:{fixes:-order, scale:scale}, step:estStepSize};
}, exactStep:function(min, estStepSize) {
  var order = Math.floor(Math.log(estStepSize) * Math.LOG10E), scale = Math.pow(10, order);
  return {unit:{fixes:-order + (estStepSize % scale === 0 ? 0 : 1), scale:1}, step:estStepSize};
}, adjustByMajorUnit:function(step, scale, range) {
  var min = range[0], max = range[1], increment = step * scale, remainder = min % increment;
  if (remainder !== 0) {
    range[0] = min - remainder + (min < 0 ? -increment : 0);
  }
  remainder = max % increment;
  if (remainder !== 0) {
    range[1] = max - remainder + (max > 0 ? increment : 0);
  }
}});
Ext.define('Ext.chart.axis.segmenter.Time', {extend:Ext.chart.axis.segmenter.Segmenter, alias:'segmenter.time', config:{step:null}, renderer:function(value, context) {
  var ExtDate = Ext.Date;
  switch(context.majorTicks.unit) {
    case 'y':
      return ExtDate.format(value, 'Y');
    case 'mo':
      return ExtDate.format(value, 'Y-m');
    case 'd':
      return ExtDate.format(value, 'Y-m-d');
  }
  return ExtDate.format(value, 'Y-m-d\nH:i:s');
}, from:function(value) {
  return new Date(value);
}, diff:function(min, max, unit) {
  if (isFinite(min)) {
    min = new Date(min);
  }
  if (isFinite(max)) {
    max = new Date(max);
  }
  return Ext.Date.diff(min, max, unit);
}, align:function(date, step, unit) {
  if (unit === 'd' && step >= 7) {
    date = Ext.Date.align(date, 'd', step);
    date.setDate(date.getDate() - date.getDay() + 1);
    return date;
  } else {
    return Ext.Date.align(date, unit, step);
  }
}, add:function(value, step, unit) {
  return Ext.Date.add(new Date(value), unit, step);
}, stepUnits:[[Ext.Date.YEAR, 1, 2, 5, 10, 20, 50, 100, 200, 500], [Ext.Date.MONTH, 1, 3, 6], [Ext.Date.DAY, 1, 7, 14], [Ext.Date.HOUR, 1, 6, 12], [Ext.Date.MINUTE, 1, 5, 15, 30], [Ext.Date.SECOND, 1, 5, 15, 30], [Ext.Date.MILLI, 1, 2, 5, 10, 20, 50, 100, 200, 500]], preferredStep:function(min, estStepSize) {
  if (this.getStep()) {
    return this.getStep();
  }
  var from = new Date(+min), to = new Date(+min + Math.ceil(estStepSize)), units = this.stepUnits, result, unit, diff, i, j;
  for (i = 0; i < units.length; i++) {
    unit = units[i][0];
    diff = this.diff(from, to, unit);
    if (diff > 0) {
      for (j = 1; j < units[i].length; j++) {
        if (diff <= units[i][j]) {
          result = {unit:unit, step:units[i][j]};
          break;
        }
      }
      if (!result) {
        i--;
        result = {unit:units[i][0], step:1};
      }
      break;
    }
  }
  if (!result) {
    result = {unit:Ext.Date.DAY, step:1};
  }
  return result;
}});
Ext.define('Ext.chart.axis.layout.Layout', {mixins:{observable:Ext.mixin.Observable}, config:{axis:null}, constructor:function(config) {
  this.mixins.observable.constructor.call(this, config);
}, processData:function(series) {
  var me = this, axis = me.getAxis(), direction = axis.getDirection(), boundSeries = axis.boundSeries, i, ln;
  if (series) {
    series['coordinate' + direction]();
  } else {
    for (i = 0, ln = boundSeries.length; i < ln; i++) {
      boundSeries[i]['coordinate' + direction]();
    }
  }
}, calculateMajorTicks:function(context) {
  var me = this, attr = context.attr, range = attr.max - attr.min, zoom = range / Math.max(1, attr.length) * (attr.visibleMax - attr.visibleMin), viewMin = attr.min + range * attr.visibleMin, viewMax = attr.min + range * attr.visibleMax, estStepSize = attr.estStepSize * zoom, out = me.snapEnds(context, attr.min, attr.max, estStepSize);
  if (out) {
    me.trimByRange(context, out, viewMin, viewMax);
    context.majorTicks = out;
  }
}, calculateMinorTicks:function(context) {
  if (this.snapMinorEnds) {
    context.minorTicks = this.snapMinorEnds(context);
  }
}, calculateLayout:function(context) {
  var me = this, attr = context.attr;
  if (attr.length === 0) {
    return null;
  }
  if (attr.majorTicks) {
    me.calculateMajorTicks(context);
    if (attr.minorTicks) {
      me.calculateMinorTicks(context);
    }
  }
}, snapEnds:Ext.emptyFn, trimByRange:function(context, out, trimMin, trimMax) {
  var segmenter = context.segmenter, unit = out.unit, beginIdx = segmenter.diff(out.from, trimMin, unit), endIdx = segmenter.diff(out.from, trimMax, unit), begin = Math.max(0, Math.ceil(beginIdx / out.step)), end = Math.min(out.steps, Math.floor(endIdx / out.step));
  if (end < out.steps) {
    out.to = segmenter.add(out.from, end * out.step, unit);
  }
  if (out.max > trimMax) {
    out.max = out.to;
  }
  if (out.from < trimMin) {
    out.from = segmenter.add(out.from, begin * out.step, unit);
    while (out.from < trimMin) {
      begin++;
      out.from = segmenter.add(out.from, out.step, unit);
    }
  }
  if (out.min < trimMin) {
    out.min = out.from;
  }
  out.steps = end - begin;
}});
Ext.define('Ext.chart.axis.layout.Discrete', {extend:Ext.chart.axis.layout.Layout, alias:'axisLayout.discrete', isDiscrete:true, processData:function() {
  var me = this, axis = me.getAxis(), seriesList = axis.boundSeries, direction = axis.getDirection(), i, ln, series;
  me.labels = [];
  me.labelMap = {};
  for (i = 0, ln = seriesList.length; i < ln; i++) {
    series = seriesList[i];
    if (series['get' + direction + 'Axis']() === axis) {
      series['coordinate' + direction]();
    }
  }
  axis.getSprites()[0].setAttributes({data:me.labels});
  me.fireEvent('datachange', me.labels);
}, calculateLayout:function(context) {
  context.data = this.labels;
  this.callParent([context]);
}, calculateMajorTicks:function(context) {
  var me = this, attr = context.attr, data = context.data, range = attr.max - attr.min, zoom = range / Math.max(1, attr.length) * (attr.visibleMax - attr.visibleMin), viewMin = attr.min + range * attr.visibleMin, viewMax = attr.min + range * attr.visibleMax, estStepSize = attr.estStepSize * zoom;
  var out = me.snapEnds(context, Math.max(0, attr.min), Math.min(attr.max, data.length - 1), estStepSize);
  if (out) {
    me.trimByRange(context, out, viewMin, viewMax);
    context.majorTicks = out;
  }
}, snapEnds:function(context, min, max, estStepSize) {
  estStepSize = Math.ceil(estStepSize);
  var steps = Math.floor((max - min) / estStepSize), data = context.data;
  return {min:min, max:max, from:min, to:steps * estStepSize + min, step:estStepSize, steps:steps, unit:1, getLabel:function(current) {
    return data[this.from + this.step * current];
  }, get:function(current) {
    return this.from + this.step * current;
  }};
}, trimByRange:function(context, out, trimMin, trimMax) {
  var unit = out.unit, beginIdx = Math.ceil((trimMin - out.from) / unit) * unit, endIdx = Math.floor((trimMax - out.from) / unit) * unit, begin = Math.max(0, Math.ceil(beginIdx / out.step)), end = Math.min(out.steps, Math.floor(endIdx / out.step));
  if (end < out.steps) {
    out.to = end;
  }
  if (out.max > trimMax) {
    out.max = out.to;
  }
  if (out.from < trimMin && out.step > 0) {
    out.from = out.from + begin * out.step * unit;
    while (out.from < trimMin) {
      begin++;
      out.from += out.step * unit;
    }
  }
  if (out.min < trimMin) {
    out.min = out.from;
  }
  out.steps = end - begin;
}, getCoordFor:function(value, field, idx, items) {
  this.labels.push(value);
  return this.labels.length - 1;
}});
Ext.define('Ext.chart.axis.layout.CombineDuplicate', {extend:Ext.chart.axis.layout.Discrete, alias:'axisLayout.combineDuplicate', getCoordFor:function(value, field, idx, items) {
  if (!(value in this.labelMap)) {
    var result = this.labelMap[value] = this.labels.length;
    this.labels.push(value);
    return result;
  }
  return this.labelMap[value];
}});
Ext.define('Ext.chart.axis.layout.Continuous', {extend:Ext.chart.axis.layout.Layout, alias:'axisLayout.continuous', isContinuous:true, config:{adjustMinimumByMajorUnit:false, adjustMaximumByMajorUnit:false}, getCoordFor:function(value, field, idx, items) {
  return +value;
}, snapEnds:function(context, min, max, estStepSize) {
  var segmenter = context.segmenter, axis = this.getAxis(), majorTickSteps = axis.getMajorTickSteps(), out = majorTickSteps && segmenter.exactStep ? segmenter.exactStep(min, (max - min) / majorTickSteps) : segmenter.preferredStep(min, estStepSize), unit = out.unit, step = out.step, from = segmenter.align(min, step, unit), steps = (majorTickSteps || segmenter.diff(min, max, unit)) + 1;
  return {min:segmenter.from(min), max:segmenter.from(max), from:from, to:segmenter.add(from, steps * step, unit), step:step, steps:steps, unit:unit, get:function(current) {
    return segmenter.add(this.from, this.step * current, unit);
  }};
}, snapMinorEnds:function(context) {
  var majorTicks = context.majorTicks, minorTickSteps = this.getAxis().getMinorTickSteps(), segmenter = context.segmenter, min = majorTicks.min, max = majorTicks.max, from = majorTicks.from, unit = majorTicks.unit, step = majorTicks.step / minorTickSteps, scaledStep = step * unit.scale, fromMargin = from - min, offset = Math.floor(fromMargin / scaledStep), extraSteps = offset + Math.floor((max - majorTicks.to) / scaledStep) + 1, steps = majorTicks.steps * minorTickSteps + extraSteps;
  return {min:min, max:max, from:min + fromMargin % scaledStep, to:segmenter.add(from, steps * step, unit), step:step, steps:steps, unit:unit, get:function(current) {
    return current % minorTickSteps + offset + 1 !== 0 ? segmenter.add(this.from, this.step * current, unit) : null;
  }};
}});
Ext.define('Ext.chart.axis.Axis', {xtype:'axis', mixins:{observable:Ext.mixin.Observable}, isAxis:true, config:{position:'bottom', fields:[], label:undefined, grid:false, limits:null, renderer:null, chart:null, style:null, margin:0, titleMargin:4, background:null, minimum:NaN, maximum:NaN, reconcileRange:false, minZoom:1, maxZoom:10000, layout:'continuous', segmenter:'numeric', hidden:false, majorTickSteps:0, minorTickSteps:0, adjustByMajorUnit:true, title:null, increment:0.5, length:0, center:null, 
radius:null, totalAngle:Math.PI, rotation:null, labelInSpan:null, visibleRange:[0, 1], needHighPrecision:false, linkedTo:null, floating:null}, titleOffset:0, spriteAnimationCount:0, prevMin:0, prevMax:1, boundSeries:[], sprites:null, surface:null, range:null, xValues:[], yValues:[], masterAxis:null, applyRotation:function(rotation) {
  var twoPie = Math.PI * 2;
  return (rotation % twoPie + Math.PI) % twoPie - Math.PI;
}, updateRotation:function(rotation) {
  var sprites = this.getSprites(), position = this.getPosition();
  if (!this.getHidden() && position === 'angular' && sprites[0]) {
    sprites[0].setAttributes({baseRotation:rotation});
  }
}, applyTitle:function(title, oldTitle) {
  var surface;
  if (Ext.isString(title)) {
    title = {text:title};
  }
  if (!oldTitle) {
    oldTitle = Ext.create('sprite.text', title);
    if (surface = this.getSurface()) {
      surface.add(oldTitle);
    }
  } else {
    oldTitle.setAttributes(title);
  }
  return oldTitle;
}, applyFloating:function(floating, oldFloating) {
  if (floating === null) {
    floating = {value:null, alongAxis:null};
  } else {
    if (Ext.isNumber(floating)) {
      floating = {value:floating, alongAxis:null};
    }
  }
  if (Ext.isObject(floating)) {
    if (oldFloating && oldFloating.alongAxis) {
      delete this.getChart().getAxis(oldFloating.alongAxis).floatingAxes[this.getId()];
    }
    return floating;
  }
  return oldFloating;
}, constructor:function(config) {
  var me = this, id;
  me.sprites = [];
  me.labels = [];
  me.floatingAxes = {};
  config = config || {};
  if (config.position === 'angular') {
    config.style = config.style || {};
    config.style.estStepSize = 1;
  }
  if ('id' in config) {
    id = config.id;
  } else {
    if ('id' in me.config) {
      id = me.config.id;
    } else {
      id = me.getId();
    }
  }
  me.setId(id);
  me.mixins.observable.constructor.apply(me, arguments);
}, getAlignment:function() {
  switch(this.getPosition()) {
    case 'left':
    case 'right':
      return 'vertical';
    case 'top':
    case 'bottom':
      return 'horizontal';
    case 'radial':
      return 'radial';
    case 'angular':
      return 'angular';
  }
}, getGridAlignment:function() {
  switch(this.getPosition()) {
    case 'left':
    case 'right':
      return 'horizontal';
    case 'top':
    case 'bottom':
      return 'vertical';
    case 'radial':
      return 'circular';
    case 'angular':
      return 'radial';
  }
}, getSurface:function() {
  var me = this, chart = me.getChart();
  if (chart && !me.surface) {
    var surface = me.surface = chart.getSurface(me.getId(), 'axis'), gridSurface = me.gridSurface = chart.getSurface('main'), axisSprite = me.getSprites()[0], gridAlignment = me.getGridAlignment();
    gridSurface.waitFor(surface);
    me.getGrid();
    if (me.getLimits() && gridAlignment) {
      gridAlignment = gridAlignment.replace('3d', '');
      me.limits = {surface:chart.getSurface('overlay'), lines:new Ext.chart.Markers, titles:new Ext.draw.sprite.Instancing};
      me.limits.lines.setTemplate({xclass:'grid.' + gridAlignment});
      me.limits.lines.getTemplate().setAttributes({strokeStyle:'black'}, true);
      me.limits.surface.add(me.limits.lines);
      axisSprite.bindMarker(gridAlignment + '-limit-lines', me.limits.lines);
      me.limitTitleTpl = new Ext.draw.sprite.Text;
      me.limits.titles.setTemplate(me.limitTitleTpl);
      me.limits.surface.add(me.limits.titles);
      chart.on('redraw', me.renderLimits, me);
    }
  }
  return me.surface;
}, applyGrid:function(grid) {
  if (grid === true) {
    return {};
  }
  return grid;
}, updateGrid:function(grid) {
  var me = this, chart = me.getChart();
  if (!chart) {
    me.on({chartattached:Ext.bind(me.updateGrid, me, [grid]), single:true});
    return;
  }
  var gridSurface = me.gridSurface, axisSprite = me.getSprites()[0], gridAlignment = me.getGridAlignment(), gridSprite;
  if (grid) {
    gridSprite = me.gridSpriteEven;
    if (!gridSprite) {
      gridSprite = me.gridSpriteEven = new Ext.chart.Markers;
      gridSprite.setTemplate({xclass:'grid.' + gridAlignment});
      gridSurface.add(gridSprite);
      axisSprite.bindMarker(gridAlignment + '-even', gridSprite);
    }
    if (Ext.isObject(grid)) {
      gridSprite.getTemplate().setAttributes(grid);
      if (Ext.isObject(grid.even)) {
        gridSprite.getTemplate().setAttributes(grid.even);
      }
    }
    gridSprite = me.gridSpriteOdd;
    if (!gridSprite) {
      gridSprite = me.gridSpriteOdd = new Ext.chart.Markers;
      gridSprite.setTemplate({xclass:'grid.' + gridAlignment});
      gridSurface.add(gridSprite);
      axisSprite.bindMarker(gridAlignment + '-odd', gridSprite);
    }
    if (Ext.isObject(grid)) {
      gridSprite.getTemplate().setAttributes(grid);
      if (Ext.isObject(grid.odd)) {
        gridSprite.getTemplate().setAttributes(grid.odd);
      }
    }
  }
}, renderLimits:function() {
  this.getSprites()[0].renderLimits();
}, getCoordFor:function(value, field, idx, items) {
  return this.getLayout().getCoordFor(value, field, idx, items);
}, applyPosition:function(pos) {
  return pos.toLowerCase();
}, applyLength:function(length, oldLength) {
  return length > 0 ? length : oldLength;
}, applyLabel:function(newText, oldText) {
  if (!oldText) {
    oldText = new Ext.draw.sprite.Text({});
  }
  if (this.limitTitleTpl) {
    this.limitTitleTpl.setAttributes(newText);
  }
  oldText.setAttributes(newText);
  return oldText;
}, applyLayout:function(layout, oldLayout) {
  layout = Ext.factory(layout, null, oldLayout, 'axisLayout');
  layout.setAxis(this);
  return layout;
}, applySegmenter:function(segmenter, oldSegmenter) {
  segmenter = Ext.factory(segmenter, null, oldSegmenter, 'segmenter');
  segmenter.setAxis(this);
  return segmenter;
}, updateMinimum:function() {
  this.range = null;
}, updateMaximum:function() {
  this.range = null;
}, hideLabels:function() {
  this.getSprites()[0].setDirty(true);
  this.setLabel({hidden:true});
}, showLabels:function() {
  this.getSprites()[0].setDirty(true);
  this.setLabel({hidden:false});
}, renderFrame:function() {
  this.getSurface().renderFrame();
}, updateChart:function(newChart, oldChart) {
  var me = this, surface;
  if (oldChart) {
    oldChart.unregister(me);
    oldChart.un('serieschange', me.onSeriesChange, me);
    oldChart.un('redraw', me.renderLimits, me);
    me.linkAxis();
    me.fireEvent('chartdetached', oldChart, me);
  }
  if (newChart) {
    newChart.on('serieschange', me.onSeriesChange, me);
    me.surface = null;
    surface = me.getSurface();
    me.getLabel().setSurface(surface);
    surface.add(me.getSprites());
    surface.add(me.getTitle());
    newChart.register(me);
    me.fireEvent('chartattached', newChart, me);
  }
}, applyBackground:function(background) {
  var rect = Ext.ClassManager.getByAlias('sprite.rect');
  return rect.def.normalize(background);
}, processData:function() {
  this.getLayout().processData();
  this.range = null;
}, getDirection:function() {
  return this.getChart().getDirectionForAxis(this.getPosition());
}, isSide:function() {
  var position = this.getPosition();
  return position === 'left' || position === 'right';
}, applyFields:function(fields) {
  return Ext.Array.from(fields);
}, applyVisibleRange:function(visibleRange, oldVisibleRange) {
  this.getChart();
  if (visibleRange[0] > visibleRange[1]) {
    var temp = visibleRange[0];
    visibleRange[0] = visibleRange[1];
    visibleRange[0] = temp;
  }
  if (visibleRange[1] === visibleRange[0]) {
    visibleRange[1] += 1 / this.getMaxZoom();
  }
  if (visibleRange[1] > visibleRange[0] + 1) {
    visibleRange[0] = 0;
    visibleRange[1] = 1;
  } else {
    if (visibleRange[0] < 0) {
      visibleRange[1] -= visibleRange[0];
      visibleRange[0] = 0;
    } else {
      if (visibleRange[1] > 1) {
        visibleRange[0] -= visibleRange[1] - 1;
        visibleRange[1] = 1;
      }
    }
  }
  if (oldVisibleRange && visibleRange[0] === oldVisibleRange[0] && visibleRange[1] === oldVisibleRange[1]) {
    return undefined;
  }
  return visibleRange;
}, updateVisibleRange:function(visibleRange) {
  this.fireEvent('visiblerangechange', this, visibleRange);
}, onSeriesChange:function(chart) {
  var me = this, series = chart.getSeries(), getAxisMethod = 'get' + me.getDirection() + 'Axis', boundSeries = [], i, ln = series.length, linkedTo, masterAxis;
  for (i = 0; i < ln; i++) {
    if (this === series[i][getAxisMethod]()) {
      boundSeries.push(series[i]);
    }
  }
  me.boundSeries = boundSeries;
  linkedTo = me.getLinkedTo();
  masterAxis = !Ext.isEmpty(linkedTo) && chart.getAxis(linkedTo);
  if (masterAxis) {
    me.linkAxis(masterAxis);
  } else {
    me.getLayout().processData();
  }
}, linkAxis:function(masterAxis) {
  var me = this;
  function link(action, slave, master) {
    master.getLayout()[action]('datachange', 'onDataChange', slave);
    master[action]('rangechange', 'onMasterAxisRangeChange', slave);
  }
  if (me.masterAxis) {
    link('un', me, me.masterAxis);
    me.masterAxis = null;
  }
  if (masterAxis) {
    if (masterAxis.type !== this.type) {
      Ext.Error.raise('Linked axes must be of the same type.');
    }
    link('on', me, masterAxis);
    me.onDataChange(masterAxis.getLayout().labels);
    me.onMasterAxisRangeChange(masterAxis, masterAxis.range);
    me.setStyle(Ext.apply({}, me.config.style, masterAxis.config.style));
    me.setTitle(Ext.apply({}, me.config.title, masterAxis.config.title));
    me.setLabel(Ext.apply({}, me.config.label, masterAxis.config.label));
    me.masterAxis = masterAxis;
  }
}, onDataChange:function(data) {
  this.getLayout().labels = data;
}, onMasterAxisRangeChange:function(masterAxis, range) {
  this.range = range;
}, applyRange:function(newRange) {
  if (!newRange) {
    return this.dataRange.slice(0);
  } else {
    return [newRange[0] === null ? this.dataRange[0] : newRange[0], newRange[1] === null ? this.dataRange[1] : newRange[1]];
  }
}, getRange:function() {
  var me = this;
  if (me.range) {
    return me.range;
  } else {
    if (me.masterAxis) {
      return me.masterAxis.range;
    }
  }
  if (Ext.isNumber(me.getMinimum() + me.getMaximum())) {
    return me.range = [me.getMinimum(), me.getMaximum()];
  }
  var min = Infinity, max = -Infinity, boundSeries = me.boundSeries, layout = me.getLayout(), segmenter = me.getSegmenter(), visibleRange = me.getVisibleRange(), getRangeMethod = 'get' + me.getDirection() + 'Range', context, attr, majorTicks, series, i, ln;
  for (i = 0, ln = boundSeries.length; i < ln; i++) {
    series = boundSeries[i];
    var minMax = series[getRangeMethod]();
    if (minMax) {
      if (minMax[0] < min) {
        min = minMax[0];
      }
      if (minMax[1] > max) {
        max = minMax[1];
      }
    }
  }
  if (!isFinite(max)) {
    max = me.prevMax;
  }
  if (!isFinite(min)) {
    min = me.prevMin;
  }
  if (me.getLabelInSpan() || min === max) {
    max += me.getIncrement();
    min -= me.getIncrement();
  }
  if (Ext.isNumber(me.getMinimum())) {
    min = me.getMinimum();
  } else {
    me.prevMin = min;
  }
  if (Ext.isNumber(me.getMaximum())) {
    max = me.getMaximum();
  } else {
    me.prevMax = max;
  }
  me.range = [Ext.Number.correctFloat(min), Ext.Number.correctFloat(max)];
  if (me.getReconcileRange()) {
    me.reconcileRange();
  }
  if (me.getAdjustByMajorUnit() && segmenter.adjustByMajorUnit && !me.getMajorTickSteps()) {
    attr = Ext.Object.chain(me.getSprites()[0].attr);
    attr.min = me.range[0];
    attr.max = me.range[1];
    attr.visibleMin = visibleRange[0];
    attr.visibleMax = visibleRange[1];
    context = {attr:attr, segmenter:segmenter};
    layout.calculateLayout(context);
    majorTicks = context.majorTicks;
    if (majorTicks) {
      segmenter.adjustByMajorUnit(majorTicks.step, majorTicks.unit.scale, me.range);
      attr.min = me.range[0];
      attr.max = me.range[1];
      delete context.majorTicks;
      layout.calculateLayout(context);
      majorTicks = context.majorTicks;
      segmenter.adjustByMajorUnit(majorTicks.step, majorTicks.unit.scale, me.range);
    } else {
      if (!me.hasClearRangePending) {
        me.hasClearRangePending = true;
        me.getChart().on('layout', 'clearRange', me);
      }
    }
  }
  if (!Ext.Array.equals(me.range, me.oldRange || [])) {
    me.fireEvent('rangechange', me, me.range);
    me.oldRange = me.range;
  }
  return me.range;
}, clearRange:function() {
  delete this.hasClearRangePending;
  this.range = null;
}, reconcileRange:function() {
  var me = this, axes = me.getChart().getAxes(), direction = me.getDirection(), i, ln, axis, range;
  if (!axes) {
    return;
  }
  for (i = 0, ln = axes.length; i < ln; i++) {
    axis = axes[i];
    range = axis.getRange();
    if (axis === me || axis.getDirection() !== direction || !range || !axis.getReconcileRange()) {
      continue;
    }
    if (range[0] < me.range[0]) {
      me.range[0] = range[0];
    }
    if (range[1] > me.range[1]) {
      me.range[1] = range[1];
    }
  }
}, applyStyle:function(style, oldStyle) {
  var cls = Ext.ClassManager.getByAlias('sprite.' + this.seriesType);
  if (cls && cls.def) {
    style = cls.def.normalize(style);
  }
  oldStyle = Ext.apply(oldStyle || {}, style);
  return oldStyle;
}, themeOnlyIfConfigured:{grid:true}, updateTheme:function(theme) {
  var me = this, axisTheme = theme.getAxis(), position = me.getPosition(), initialConfig = me.getInitialConfig(), defaultConfig = me.defaultConfig, configs = me.getConfigurator().configs, genericAxisTheme = axisTheme.defaults, specificAxisTheme = axisTheme[position], themeOnlyIfConfigured = me.themeOnlyIfConfigured, key, value, isObjValue, isUnusedConfig, initialValue, cfg;
  axisTheme = Ext.merge({}, genericAxisTheme, specificAxisTheme);
  for (key in axisTheme) {
    value = axisTheme[key];
    cfg = configs[key];
    if (value !== null && value !== undefined && cfg) {
      initialValue = initialConfig[key];
      isObjValue = Ext.isObject(value);
      isUnusedConfig = initialValue === defaultConfig[key];
      if (isObjValue) {
        if (isUnusedConfig && themeOnlyIfConfigured[key]) {
          continue;
        }
        value = Ext.merge({}, value, initialValue);
      }
      if (isUnusedConfig || isObjValue) {
        me[cfg.names.set](value);
      }
    }
  }
}, updateCenter:function(center) {
  var sprites = this.getSprites(), axisSprite = sprites[0], centerX = center[0], centerY = center[1];
  if (axisSprite) {
    axisSprite.setAttributes({centerX:centerX, centerY:centerY});
  }
  if (this.gridSpriteEven) {
    this.gridSpriteEven.getTemplate().setAttributes({translationX:centerX, translationY:centerY, rotationCenterX:centerX, rotationCenterY:centerY});
  }
  if (this.gridSpriteOdd) {
    this.gridSpriteOdd.getTemplate().setAttributes({translationX:centerX, translationY:centerY, rotationCenterX:centerX, rotationCenterY:centerY});
  }
}, getSprites:function() {
  if (!this.getChart()) {
    return;
  }
  var me = this, range = me.getRange(), position = me.getPosition(), chart = me.getChart(), animation = chart.getAnimation(), baseSprite, style, length = me.getLength(), axisClass = me.superclass;
  if (animation === false) {
    animation = {duration:0};
  }
  if (range) {
    style = Ext.applyIf({position:position, axis:me, min:range[0], max:range[1], length:length, grid:me.getGrid(), hidden:me.getHidden(), titleOffset:me.titleOffset, layout:me.getLayout(), segmenter:me.getSegmenter(), totalAngle:me.getTotalAngle(), label:me.getLabel()}, me.getStyle());
    if (!me.sprites.length) {
      while (!axisClass.xtype) {
        axisClass = axisClass.superclass;
      }
      baseSprite = Ext.create('sprite.' + axisClass.xtype, style);
      baseSprite.fx.setCustomDurations({baseRotation:0});
      baseSprite.fx.on('animationstart', 'onAnimationStart', me);
      baseSprite.fx.on('animationend', 'onAnimationEnd', me);
      baseSprite.setLayout(me.getLayout());
      baseSprite.setSegmenter(me.getSegmenter());
      baseSprite.setLabel(me.getLabel());
      me.sprites.push(baseSprite);
      me.updateTitleSprite();
    } else {
      baseSprite = me.sprites[0];
      baseSprite.setAnimation(animation);
      baseSprite.setAttributes(style);
    }
    if (me.getRenderer()) {
      baseSprite.setRenderer(me.getRenderer());
    }
  }
  return me.sprites;
}, updateTitleSprite:function() {
  var me = this, length = me.getLength();
  if (!me.sprites[0] || !Ext.isNumber(length)) {
    return;
  }
  var thickness = this.sprites[0].thickness, surface = me.getSurface(), title = me.getTitle(), position = me.getPosition(), margin = me.getMargin(), titleMargin = me.getTitleMargin(), anchor = surface.roundPixel(length / 2);
  if (title) {
    switch(position) {
      case 'top':
        title.setAttributes({x:anchor, y:margin + titleMargin / 2, textBaseline:'top', textAlign:'center'}, true);
        title.applyTransformations();
        me.titleOffset = title.getBBox().height + titleMargin;
        break;
      case 'bottom':
        title.setAttributes({x:anchor, y:thickness + titleMargin / 2, textBaseline:'top', textAlign:'center'}, true);
        title.applyTransformations();
        me.titleOffset = title.getBBox().height + titleMargin;
        break;
      case 'left':
        title.setAttributes({x:margin + titleMargin / 2, y:anchor, textBaseline:'top', textAlign:'center', rotationCenterX:margin + titleMargin / 2, rotationCenterY:anchor, rotationRads:-Math.PI / 2}, true);
        title.applyTransformations();
        me.titleOffset = title.getBBox().width + titleMargin;
        break;
      case 'right':
        title.setAttributes({x:thickness - margin + titleMargin / 2, y:anchor, textBaseline:'bottom', textAlign:'center', rotationCenterX:thickness + titleMargin / 2, rotationCenterY:anchor, rotationRads:Math.PI / 2}, true);
        title.applyTransformations();
        me.titleOffset = title.getBBox().width + titleMargin;
        break;
    }
  }
}, onThicknessChanged:function() {
  this.getChart().onThicknessChanged();
}, getThickness:function() {
  if (this.getHidden()) {
    return 0;
  }
  return (this.sprites[0] && this.sprites[0].thickness || 1) + this.titleOffset + this.getMargin();
}, onAnimationStart:function() {
  this.spriteAnimationCount++;
  if (this.spriteAnimationCount === 1) {
    this.fireEvent('animationstart', this);
  }
}, onAnimationEnd:function() {
  this.spriteAnimationCount--;
  if (this.spriteAnimationCount === 0) {
    this.fireEvent('animationend', this);
  }
}, getItemId:function() {
  return this.getId();
}, getAncestorIds:function() {
  return [this.getChart().getId()];
}, isXType:function(xtype) {
  return xtype === 'axis';
}, resolveListenerScope:function(defaultScope) {
  var me = this, namedScope = Ext._namedScopes[defaultScope], chart = me.getChart(), scope;
  if (!namedScope) {
    scope = chart ? chart.resolveListenerScope(defaultScope, false) : defaultScope || me;
  } else {
    if (namedScope.isThis) {
      scope = me;
    } else {
      if (namedScope.isController) {
        scope = chart ? chart.resolveListenerScope(defaultScope, false) : me;
      } else {
        if (namedScope.isSelf) {
          scope = chart ? chart.resolveListenerScope(defaultScope, false) : me;
          if (scope === chart && !chart.getInheritedConfig('defaultListenerScope')) {
            scope = me;
          }
        }
      }
    }
  }
  return scope;
}, destroy:function() {
  var me = this;
  me.setChart(null);
  me.surface.destroy();
  me.surface = null;
  me.callParent();
}});
Ext.define('Ext.chart.LegendBase', {extend:Ext.dataview.DataView, config:{itemTpl:['\x3cspan class\x3d"', Ext.baseCSSPrefix, "legend-item-marker {[ values.disabled ? Ext.baseCSSPrefix + 'legend-inactive' : '' ]}\" style\x3d\"background:{mark};\"\x3e\x3c/span\x3e{name}"], inline:true, horizontalHeight:48, verticalWidth:150, position:''}, constructor:function(config) {
  this.callParent([config]);
  var scroller = this.getScrollable(), onDrag = scroller.onDrag;
  scroller.onDrag = function(e) {
    e.stopPropagation();
    onDrag.call(this, e);
  };
}, applyPosition:function(position) {
  if (!position) {
    Ext.raise('Legend position must be "top", "right", "bottom" or "left".');
  }
  return position;
}, updatePosition:function(position) {
  this.setDocked(position);
}, updateDocked:function(docked, oldDocked) {
  var me = this;
  me.callParent([docked, oldDocked]);
  if (docked === 'top' || docked === 'bottom') {
    me.setLayout({type:'hbox', pack:'center'});
    me.setInline(true);
    me.setWidth(null);
    me.setHeight(me.getHorizontalHeight());
    if (me.getScrollable()) {
      me.setScrollable({direction:'horizontal'});
    }
  } else {
    me.setLayout({pack:'center'});
    me.setInline(false);
    me.setWidth(me.getVerticalWidth());
    me.setHeight(null);
    if (me.getScrollable()) {
      me.setScrollable({direction:'vertical'});
    }
  }
}, onItemTap:function(container, target, index, e) {
  this.callParent(arguments);
  this.toggleItem(index);
}});
Ext.define('Ext.chart.Legend', {xtype:'legend', extend:Ext.chart.LegendBase, config:{baseCls:Ext.baseCSSPrefix + 'legend', padding:5, rect:null, disableSelection:true, toggleable:true}, toggleItem:function(index) {
  if (!this.getToggleable()) {
    return;
  }
  var store = this.getStore(), disabledCount = 0, disabled, canToggle = true, i, count, record;
  if (store) {
    count = store.getCount();
    for (i = 0; i < count; i++) {
      record = store.getAt(i);
      if (record.get('disabled')) {
        disabledCount++;
      }
    }
    canToggle = count - disabledCount > 1;
    record = store.getAt(index);
    if (record) {
      disabled = record.get('disabled');
      if (disabled || canToggle) {
        record.set('disabled', !disabled);
      }
    }
  }
}});
Ext.define('Ext.chart.AbstractChart', {extend:Ext.draw.Container, isChart:true, defaultBindProperty:'store', config:{store:'ext-empty-store', theme:'default', style:null, animation:!Ext.isIE8, series:[], axes:[], legend:null, colors:null, insetPadding:{top:10, left:10, right:10, bottom:10}, background:null, interactions:[], mainRect:null, resizeHandler:null, highlightItem:null}, animationSuspendCount:0, chartLayoutSuspendCount:0, axisThicknessSuspendCount:0, isThicknessChanged:false, surfaceZIndexes:{background:0, 
main:1, grid:2, series:3, axis:4, chart:5, overlay:6, events:7}, constructor:function(config) {
  var me = this;
  me.itemListeners = {};
  me.surfaceMap = {};
  me.chartComponents = {};
  me.isInitializing = true;
  me.suspendChartLayout();
  me.animationSuspendCount++;
  me.callParent(arguments);
  delete me.isInitializing;
  me.getSurface('main');
  me.getSurface('chart').setFlipRtlText(me.getInherited().rtl);
  me.getSurface('overlay').waitFor(me.getSurface('series'));
  me.animationSuspendCount--;
  me.resumeChartLayout();
}, applyAnimation:function(newAnimation, oldAnimation) {
  if (!newAnimation) {
    newAnimation = {duration:0};
  } else {
    if (newAnimation === true) {
      newAnimation = {easing:'easeInOut', duration:500};
    }
  }
  return oldAnimation ? Ext.apply({}, newAnimation, oldAnimation) : newAnimation;
}, getAnimation:function() {
  if (this.animationSuspendCount) {
    return {duration:0};
  } else {
    return this.callParent();
  }
}, applyInsetPadding:function(padding, oldPadding) {
  if (!Ext.isObject(padding)) {
    return Ext.util.Format.parseBox(padding);
  } else {
    if (!oldPadding) {
      return padding;
    } else {
      return Ext.apply(oldPadding, padding);
    }
  }
}, suspendAnimation:function() {
  var me = this, seriesList = me.getSeries(), n = seriesList.length, i = -1, series;
  me.animationSuspendCount++;
  if (me.animationSuspendCount === 1) {
    while (++i < n) {
      series = seriesList[i];
      series.setAnimation(series.getAnimation());
    }
  }
}, resumeAnimation:function() {
  var me = this, seriesList = me.getSeries(), n = seriesList.length, i = -1, series, animation;
  me.animationSuspendCount--;
  if (me.animationSuspendCount === 0) {
    while (++i < n) {
      series = seriesList[i];
      animation = series.getAnimation();
      series.setAnimation(animation.duration && animation || me.getAnimation());
    }
  }
}, suspendChartLayout:function() {
  this.chartLayoutSuspendCount++;
  if (this.chartLayoutSuspendCount === 1) {
    if (this.scheduledLayoutId) {
      this.layoutInSuspension = true;
      this.cancelChartLayout();
    } else {
      this.layoutInSuspension = false;
    }
  }
}, resumeChartLayout:function() {
  this.chartLayoutSuspendCount--;
  if (this.chartLayoutSuspendCount === 0) {
    if (this.layoutInSuspension) {
      this.scheduleLayout();
    }
  }
}, cancelChartLayout:function() {
  if (this.scheduledLayoutId) {
    Ext.draw.Animator.cancel(this.scheduledLayoutId);
    this.scheduledLayoutId = null;
  }
}, scheduleLayout:function() {
  var me = this;
  if (me.allowSchedule() && !me.scheduledLayoutId) {
    me.scheduledLayoutId = Ext.draw.Animator.schedule('doScheduleLayout', me);
  }
}, allowSchedule:function() {
  return true;
}, doScheduleLayout:function() {
  if (this.chartLayoutSuspendCount) {
    this.layoutInSuspension = true;
  } else {
    this.performLayout();
  }
}, suspendThicknessChanged:function() {
  this.axisThicknessSuspendCount++;
}, resumeThicknessChanged:function() {
  if (this.axisThicknessSuspendCount > 0) {
    this.axisThicknessSuspendCount--;
    if (this.axisThicknessSuspendCount === 0 && this.isThicknessChanged) {
      this.onThicknessChanged();
    }
  }
}, onThicknessChanged:function() {
  if (this.axisThicknessSuspendCount === 0) {
    this.isThicknessChanged = false;
    this.performLayout();
  } else {
    this.isThicknessChanged = true;
  }
}, applySprites:function(sprites) {
  var surface = this.getSurface('chart');
  sprites = Ext.Array.from(sprites);
  surface.removeAll(true);
  surface.add(sprites);
  return sprites;
}, initItems:function() {
  var items = this.items, i, ln, item;
  if (items && !items.isMixedCollection) {
    this.items = [];
    items = Ext.Array.from(items);
    for (i = 0, ln = items.length; i < ln; i++) {
      item = items[i];
      if (item.type) {
        Ext.raise("To add custom sprites to the chart use the 'sprites' config.");
      } else {
        this.items.push(item);
      }
    }
  }
  this.callParent();
}, applyBackground:function(newBackground, oldBackground) {
  var surface = this.getSurface('background'), width, height, isUpdateOld;
  if (newBackground) {
    if (oldBackground) {
      width = oldBackground.attr.width;
      height = oldBackground.attr.height;
      isUpdateOld = oldBackground.type === (newBackground.type || 'rect');
    }
    if (newBackground.isSprite) {
      oldBackground = newBackground;
    } else {
      if (newBackground.type === 'image' && Ext.isString(newBackground.src)) {
        if (isUpdateOld) {
          oldBackground.setAttributes({src:newBackground.src});
        } else {
          surface.remove(oldBackground, true);
          oldBackground = surface.add(newBackground);
        }
      } else {
        if (isUpdateOld) {
          oldBackground.setAttributes({fillStyle:newBackground});
        } else {
          surface.remove(oldBackground, true);
          oldBackground = surface.add({type:'rect', fillStyle:newBackground, fx:{customDurations:{x:0, y:0, width:0, height:0}}});
        }
      }
    }
  }
  if (width && height) {
    oldBackground.setAttributes({width:width, height:height});
  }
  oldBackground.setAnimation(this.getAnimation());
  return oldBackground;
}, getLegendStore:function() {
  return this.legendStore;
}, refreshLegendStore:function() {
  if (this.getLegendStore()) {
    var i, ln, series = this.getSeries(), seriesItem, legendData = [];
    if (series) {
      for (i = 0, ln = series.length; i < ln; i++) {
        seriesItem = series[i];
        if (seriesItem.getShowInLegend()) {
          seriesItem.provideLegendInfo(legendData);
        }
      }
    }
    this.getLegendStore().setData(legendData);
  }
}, resetLegendStore:function() {
  var store = this.getLegendStore(), data, i, len, record;
  if (store) {
    data = this.getLegendStore().getData().items;
    for (i = 0, len = data.length; i < len; i++) {
      record = data[i];
      record.beginEdit();
      record.set('disabled', false);
      record.commit();
    }
  }
}, onUpdateLegendStore:function(store, record) {
  var series = this.getSeries(), seriesItem;
  if (record && series) {
    seriesItem = series.map[record.get('series')];
    if (seriesItem) {
      seriesItem.setHiddenByIndex(record.get('index'), record.get('disabled'));
      this.redraw();
    }
  }
}, defaultResizeHandler:function(size) {
  this.scheduleLayout();
  return false;
}, applyMainRect:function(newRect, rect) {
  if (!rect) {
    return newRect;
  }
  this.getSeries();
  this.getAxes();
  if (newRect[0] === rect[0] && newRect[1] === rect[1] && newRect[2] === rect[2] && newRect[3] === rect[3]) {
    return rect;
  } else {
    return newRect;
  }
}, register:function(component) {
  var map = this.chartComponents, id = component.getId();
  if (id === undefined) {
    Ext.raise('Chart component id is undefined. ' + 'Please ensure the component has an id.');
  }
  if (id in map) {
    Ext.raise('Registering duplicate chart component id "' + id + '"');
  }
  map[id] = component;
}, unregister:function(component) {
  var map = this.chartComponents, id = component.getId();
  delete map[id];
}, get:function(id) {
  return this.chartComponents[id];
}, getAxis:function(axis) {
  if (axis instanceof Ext.chart.axis.Axis) {
    return axis;
  } else {
    if (Ext.isNumber(axis)) {
      return this.getAxes()[axis];
    } else {
      if (Ext.isString(axis)) {
        return this.get(axis);
      }
    }
  }
}, getSurface:function(name, type) {
  name = name || 'main';
  type = type || name;
  var me = this, surface = this.callParent([name]), zIndexes = me.surfaceZIndexes, map = me.surfaceMap;
  if (type in zIndexes) {
    surface.element.setStyle('zIndex', zIndexes[type]);
  }
  if (!map[type]) {
    map[type] = [];
  }
  if (Ext.Array.indexOf(map[type], surface) < 0) {
    surface.type = type;
    map[type].push(surface);
    surface.on('destroy', me.forgetSurface, me);
  }
  return surface;
}, forgetSurface:function(surface) {
  var map = this.surfaceMap;
  if (!map || this.isDestroying) {
    return;
  }
  var group = map[surface.type], index = group ? Ext.Array.indexOf(group, surface) : -1;
  if (index >= 0) {
    group.splice(index, 1);
  }
}, applyAxes:function(newAxes, oldAxes) {
  var me = this, positions = {left:'right', right:'left'}, result = [], axis, oldAxis, linkedTo, id, i, ln, oldMap;
  me.animationSuspendCount++;
  me.getStore();
  if (!oldAxes) {
    oldAxes = [];
    oldAxes.map = {};
  }
  oldMap = oldAxes.map;
  result.map = {};
  newAxes = Ext.Array.from(newAxes, true);
  for (i = 0, ln = newAxes.length; i < ln; i++) {
    axis = newAxes[i];
    if (!axis) {
      continue;
    }
    if (axis instanceof Ext.chart.axis.Axis) {
      oldAxis = oldMap[axis.getId()];
      axis.setChart(me);
    } else {
      axis = Ext.Object.chain(axis);
      linkedTo = axis.linkedTo;
      id = axis.id;
      if (Ext.isNumber(linkedTo)) {
        axis = Ext.merge({}, newAxes[linkedTo], axis);
      } else {
        if (Ext.isString(linkedTo)) {
          Ext.Array.each(newAxes, function(item) {
            if (item.id === axis.linkedTo) {
              axis = Ext.merge({}, item, axis);
              return false;
            }
          });
        }
      }
      axis.id = id;
      axis.chart = me;
      if (me.getInherited().rtl) {
        axis.position = positions[axis.position] || axis.position;
      }
      id = axis.getId && axis.getId() || axis.id;
      axis = Ext.factory(axis, null, oldAxis = oldMap[id], 'axis');
    }
    if (axis) {
      result.push(axis);
      result.map[axis.getId()] = axis;
      if (!oldAxis) {
        axis.on('animationstart', 'onAnimationStart', me);
        axis.on('animationend', 'onAnimationEnd', me);
      }
    }
  }
  for (i in oldMap) {
    if (!result.map[i]) {
      oldMap[i].destroy();
    }
  }
  me.animationSuspendCount--;
  return result;
}, updateAxes:function() {
  if (!this.isDestroying) {
    this.scheduleLayout();
  }
}, circularCopyArray:function(inArray, startIndex, count) {
  var outArray = [], i, len = inArray && inArray.length;
  if (len) {
    for (i = 0; i < count; i++) {
      outArray.push(inArray[(startIndex + i) % len]);
    }
  }
  return outArray;
}, circularCopyObject:function(inObject, startIndex, count) {
  var me = this, name, value, outObject = {};
  if (count) {
    for (name in inObject) {
      if (inObject.hasOwnProperty(name)) {
        value = inObject[name];
        if (Ext.isArray(value)) {
          outObject[name] = me.circularCopyArray(value, startIndex, count);
        } else {
          outObject[name] = value;
        }
      }
    }
  }
  return outObject;
}, getColors:function() {
  var me = this, configColors = me.config.colors, theme = me.getTheme();
  if (Ext.isArray(configColors) && configColors.length > 0) {
    configColors = me.applyColors(configColors);
  }
  return configColors || theme && theme.getColors();
}, applyColors:function(newColors) {
  newColors = Ext.Array.map(newColors, function(color) {
    if (Ext.isString(color)) {
      return color;
    } else {
      return color.toString();
    }
  });
  return newColors;
}, updateColors:function(newColors) {
  var me = this, theme = me.getTheme(), colors = newColors || theme && theme.getColors(), colorIndex = 0, series = me.getSeries(), seriesCount = series && series.length, i, seriesItem, seriesColors, seriesColorCount;
  if (colors.length) {
    for (i = 0; i < seriesCount; i++) {
      seriesItem = series[i];
      seriesColorCount = seriesItem.themeColorCount();
      seriesColors = me.circularCopyArray(colors, colorIndex, seriesColorCount);
      colorIndex += seriesColorCount;
      seriesItem.updateChartColors(seriesColors);
    }
  }
  me.refreshLegendStore();
}, applyTheme:function(theme) {
  if (theme && theme.isTheme) {
    return theme;
  }
  return Ext.Factory.chartTheme(theme);
}, updateTheme:function(theme) {
  var me = this, axes = me.getAxes(), seriesList = me.getSeries(), colors = me.getColors(), series, i;
  me.updateChartTheme(theme);
  for (i = 0; i < axes.length; i++) {
    axes[i].updateTheme(theme);
  }
  for (i = 0; i < seriesList.length; i++) {
    series = seriesList[i];
    series.updateTheme(theme);
  }
  me.updateSpriteTheme(theme);
  me.updateColors(colors);
  me.redraw();
}, themeOnlyIfConfigured:{}, updateChartTheme:function(theme) {
  var me = this, chartTheme = theme.getChart(), initialConfig = me.getInitialConfig(), defaultConfig = me.defaultConfig, configs = me.getConfigurator().configs, genericChartTheme = chartTheme.defaults, specificChartTheme = chartTheme[me.xtype], themeOnlyIfConfigured = me.themeOnlyIfConfigured, key, value, isObjValue, isUnusedConfig, initialValue, cfg;
  chartTheme = Ext.merge({}, genericChartTheme, specificChartTheme);
  for (key in chartTheme) {
    value = chartTheme[key];
    cfg = configs[key];
    if (value !== null && value !== undefined && cfg) {
      initialValue = initialConfig[key];
      isObjValue = Ext.isObject(value);
      isUnusedConfig = initialValue === defaultConfig[key];
      if (isObjValue) {
        if (isUnusedConfig && themeOnlyIfConfigured[key]) {
          continue;
        }
        value = Ext.merge({}, value, initialValue);
      }
      if (isUnusedConfig || isObjValue) {
        me[cfg.names.set](value);
      }
    }
  }
}, updateSpriteTheme:function(theme) {
  this.getSprites();
  var me = this, chartSurface = me.getSurface('chart'), sprites = chartSurface.getItems(), styles = theme.getSprites(), sprite, style, key, attr, isText, i, ln;
  for (i = 0, ln = sprites.length; i < ln; i++) {
    sprite = sprites[i];
    style = styles[sprite.type];
    if (style) {
      attr = {};
      isText = sprite.type === 'text';
      for (key in style) {
        if (!(key in sprite.config)) {
          if (!(isText && key.indexOf('font') === 0 && sprite.config.font)) {
            attr[key] = style[key];
          }
        }
      }
      sprite.setAttributes(attr);
    }
  }
}, addSeries:function(newSeries) {
  var series = this.getSeries();
  Ext.Array.push(series, newSeries);
  this.setSeries(series);
}, removeSeries:function(series) {
  series = Ext.Array.from(series);
  var existingSeries = this.getSeries(), newSeries = [], len = series.length, removeMap = {}, i, s;
  for (i = 0; i < len; i++) {
    s = series[i];
    if (typeof s !== 'string') {
      s = s.getId();
    }
    removeMap[s] = true;
  }
  for (i = 0, len = existingSeries.length; i < len; i++) {
    if (!removeMap[existingSeries[i].getId()]) {
      newSeries.push(existingSeries[i]);
    }
  }
  this.setSeries(newSeries);
}, applySeries:function(newSeries, oldSeries) {
  var me = this, result = [], oldMap, oldSeriesItem, i, ln, series;
  me.animationSuspendCount++;
  me.getAxes();
  if (oldSeries) {
    oldMap = oldSeries.map;
  } else {
    oldSeries = [];
    oldMap = oldSeries.map = {};
  }
  result.map = {};
  newSeries = Ext.Array.from(newSeries, true);
  for (i = 0, ln = newSeries.length; i < ln; i++) {
    series = newSeries[i];
    if (!series) {
      continue;
    }
    oldSeriesItem = oldMap[series.getId && series.getId() || series.id];
    if (series instanceof Ext.chart.series.Series) {
      if (oldSeriesItem && oldSeriesItem !== series) {
        oldSeriesItem.destroy();
      }
      series.setChart(me);
    } else {
      if (Ext.isObject(series)) {
        if (oldSeriesItem) {
          oldSeriesItem.setConfig(series);
          series = oldSeriesItem;
        } else {
          if (Ext.isString(series)) {
            series = {type:series};
          }
          series.chart = me;
          series = Ext.create(series.xclass || 'series.' + series.type, series);
          series.on('animationstart', 'onAnimationStart', me);
          series.on('animationend', 'onAnimationEnd', me);
        }
      }
    }
    result.push(series);
    result.map[series.getId()] = series;
  }
  for (i in oldMap) {
    if (!result.map[oldMap[i].getId()]) {
      oldMap[i].destroy();
    }
  }
  me.animationSuspendCount--;
  return result;
}, applyLegend:function(newLegend, oldLegend) {
  return Ext.factory(newLegend, Ext.chart.Legend, oldLegend);
}, updateLegend:function(legend, oldLegend) {
  if (oldLegend) {
    oldLegend.destroy();
  }
  if (legend) {
    this.getItems();
    this.legendStore = new Ext.data.Store({autoDestroy:true, fields:['id', 'name', 'mark', 'disabled', 'series', 'index']});
    legend.setStore(this.legendStore);
    this.refreshLegendStore();
    this.legendStore.on('update', 'onUpdateLegendStore', this);
  }
}, updateSeries:function(newSeries, oldSeries) {
  var me = this;
  if (me.isDestroying) {
    return;
  }
  me.animationSuspendCount++;
  me.fireEvent('serieschange', me, newSeries, oldSeries);
  me.refreshLegendStore();
  if (!Ext.isEmpty(newSeries)) {
    me.updateTheme(me.getTheme());
  }
  me.scheduleLayout();
  me.animationSuspendCount--;
}, applyInteractions:function(interactions, oldInteractions) {
  if (!oldInteractions) {
    oldInteractions = [];
    oldInteractions.map = {};
  }
  var me = this, result = [], oldMap = oldInteractions.map, i, ln, interaction;
  result.map = {};
  interactions = Ext.Array.from(interactions, true);
  for (i = 0, ln = interactions.length; i < ln; i++) {
    interaction = interactions[i];
    if (!interaction) {
      continue;
    }
    interaction = Ext.factory(interaction, null, oldMap[interaction.getId && interaction.getId() || interaction.id], 'interaction');
    if (interaction) {
      interaction.setChart(me);
      result.push(interaction);
      result.map[interaction.getId()] = interaction;
    }
  }
  for (i in oldMap) {
    if (!result.map[i]) {
      oldMap[i].destroy();
    }
  }
  return result;
}, getInteraction:function(type) {
  var interactions = this.getInteractions(), len = interactions && interactions.length, out = null, interaction, i;
  if (len) {
    for (i = 0; i < len; ++i) {
      interaction = interactions[i];
      if (interaction.type === type) {
        out = interaction;
        break;
      }
    }
  }
  return out;
}, applyStore:function(store) {
  return store && Ext.StoreManager.lookup(store);
}, updateStore:function(newStore, oldStore) {
  var me = this;
  if (oldStore) {
    oldStore.un({datachanged:'onDataChanged', update:'onDataChanged', scope:me, order:'after'});
    if (oldStore.autoDestroy) {
      oldStore.destroy();
    }
  }
  if (newStore) {
    newStore.on({datachanged:'onDataChanged', update:'onDataChanged', scope:me, order:'after'});
  }
  me.fireEvent('storechange', me, newStore, oldStore);
  me.onDataChanged();
}, redraw:function() {
  this.fireEvent('redraw', this);
}, performLayout:function() {
  var me = this, size = me.getChartSize(true), chartRect = [0, 0, size.width, size.height], background = me.getBackground();
  me.hasFirstLayout = true;
  me.fireEvent('layout', me);
  me.cancelChartLayout();
  me.getSurface('background').setRect(chartRect);
  me.getSurface('chart').setRect(chartRect);
  background.setAttributes({width:size.width, height:size.height});
}, getChartSize:function(isRecompute) {
  var me = this;
  if (isRecompute) {
    me.chartSize = null;
  }
  return me.chartSize || (me.chartSize = me.innerElement.getSize());
}, getEventXY:function(e) {
  return this.getSurface().getEventXY(e);
}, getItemForPoint:function(x, y) {
  var me = this, seriesList = me.getSeries(), mainRect = me.getMainRect(), ln = seriesList.length, i = me.hasFirstLayout ? ln - 1 : -1, series, item;
  if (!(mainRect && x >= 0 && x <= mainRect[2] && y >= 0 && y <= mainRect[3])) {
    return null;
  }
  for (; i >= 0; i--) {
    series = seriesList[i];
    item = series.getItemForPoint(x, y);
    if (item) {
      return item;
    }
  }
  return null;
}, getItemsForPoint:function(x, y) {
  var me = this, seriesList = me.getSeries(), ln = seriesList.length, i = me.hasFirstLayout ? ln - 1 : -1, items = [], series, item;
  for (; i >= 0; i--) {
    series = seriesList[i];
    item = series.getItemForPoint(x, y);
    if (item) {
      items.push(item);
    }
  }
  return items;
}, onAnimationStart:function() {
  this.fireEvent('animationstart', this);
}, onAnimationEnd:function() {
  this.fireEvent('animationend', this);
}, onDataChanged:function() {
  var me = this;
  if (me.isInitializing) {
    return;
  }
  var rect = me.getMainRect(), store = me.getStore(), series = me.getSeries(), axes = me.getAxes();
  if (!store || !axes || !series) {
    return;
  }
  if (!rect) {
    me.on({redraw:me.onDataChanged, scope:me, single:true});
    return;
  }
  me.processData();
  me.redraw();
}, recordCount:0, processData:function() {
  var me = this, recordCount = me.getStore().getCount(), seriesList = me.getSeries(), ln = seriesList.length, isNeedUpdateColors = false, i = 0, series;
  for (; i < ln; i++) {
    series = seriesList[i];
    series.processData();
    if (!isNeedUpdateColors && series.isStoreDependantColorCount) {
      isNeedUpdateColors = true;
    }
  }
  if (isNeedUpdateColors && recordCount > me.recordCount) {
    me.updateColors(me.getColors());
    me.recordCount = recordCount;
  }
}, bindStore:function(store) {
  this.setStore(store);
}, applyHighlightItem:function(newHighlightItem, oldHighlightItem) {
  if (newHighlightItem === oldHighlightItem) {
    return;
  }
  if (Ext.isObject(newHighlightItem) && Ext.isObject(oldHighlightItem)) {
    var i1 = newHighlightItem, i2 = oldHighlightItem, s1 = i1.sprite && (i1.sprite[0] || i1.sprite), s2 = i2.sprite && (i2.sprite[0] || i2.sprite);
    if (s1 === s2 && i1.index === i2.index) {
      return;
    }
  }
  return newHighlightItem;
}, updateHighlightItem:function(newHighlightItem, oldHighlightItem) {
  if (oldHighlightItem) {
    oldHighlightItem.series.setAttributesForItem(oldHighlightItem, {highlighted:false});
  }
  if (newHighlightItem) {
    newHighlightItem.series.setAttributesForItem(newHighlightItem, {highlighted:true});
    this.fireEvent('itemhighlight', this, newHighlightItem, oldHighlightItem);
  }
  this.fireEvent('itemhighlightchange', this, newHighlightItem, oldHighlightItem);
}, destroyChart:function() {
  var me = this, legend = me.getLegend(), axes = me.getAxes(), series = me.getSeries(), interactions = me.getInteractions(), emptyArray = [], i, ln;
  me.surfaceMap = null;
  for (i = 0, ln = interactions.length; i < ln; i++) {
    interactions[i].destroy();
  }
  for (i = 0, ln = axes.length; i < ln; i++) {
    axes[i].destroy();
  }
  for (i = 0, ln = series.length; i < ln; i++) {
    series[i].destroy();
  }
  me.setInteractions(emptyArray);
  me.setAxes(emptyArray);
  me.setSeries(emptyArray);
  if (legend) {
    legend.destroy();
    me.setLegend(null);
  }
  me.legendStore = null;
  me.setStore(null);
  me.cancelChartLayout();
}, getRefItems:function(deep) {
  var me = this, series = me.getSeries(), axes = me.getAxes(), interaction = me.getInteractions(), ans = [], i, ln;
  for (i = 0, ln = series.length; i < ln; i++) {
    ans.push(series[i]);
    if (series[i].getRefItems) {
      ans.push.apply(ans, series[i].getRefItems(deep));
    }
  }
  for (i = 0, ln = axes.length; i < ln; i++) {
    ans.push(axes[i]);
    if (axes[i].getRefItems) {
      ans.push.apply(ans, axes[i].getRefItems(deep));
    }
  }
  for (i = 0, ln = interaction.length; i < ln; i++) {
    ans.push(interaction[i]);
    if (interaction[i].getRefItems) {
      ans.push.apply(ans, interaction[i].getRefItems(deep));
    }
  }
  return ans;
}});
Ext.define('Ext.chart.overrides.AbstractChart', {override:'Ext.chart.AbstractChart', updateLegend:function(legend, oldLegend) {
  this.callParent([legend, oldLegend]);
  if (legend) {
    this.add(legend);
  }
}, onAdded:function(parent, instanced) {
  var legend = this.getLegend();
  this.callParent([parent, instanced]);
  if (legend) {
    parent.add(legend);
  }
}, onItemRemove:function(item, index, destroy) {
  var map = this.surfaceMap, type = item.type, items = map && map[type];
  this.callParent([item, index, destroy]);
  if (items) {
    Ext.Array.remove(items, item);
    if (items.length === 0) {
      delete map[type];
    }
  }
}, destroy:function() {
  var me = this;
  me.isDestroying = me.destroying = true;
  me.destroyChart();
  me.callParent();
}});
Ext.define('Ext.chart.grid.CircularGrid', {extend:Ext.draw.sprite.Circle, alias:'grid.circular', inheritableStatics:{def:{defaults:{r:1, strokeStyle:'#DDD'}}}});
Ext.define('Ext.chart.grid.RadialGrid', {extend:Ext.draw.sprite.Path, alias:'grid.radial', inheritableStatics:{def:{processors:{startRadius:'number', endRadius:'number'}, defaults:{startRadius:0, endRadius:1, scalingCenterX:0, scalingCenterY:0, strokeStyle:'#DDD'}, triggers:{startRadius:'path,bbox', endRadius:'path,bbox'}}}, render:function() {
  this.callParent(arguments);
}, updatePath:function(path, attr) {
  var startRadius = attr.startRadius, endRadius = attr.endRadius;
  path.moveTo(startRadius, 0);
  path.lineTo(endRadius, 0);
}});
Ext.define('Ext.chart.PolarChart', {extend:Ext.chart.AbstractChart, xtype:'polar', isPolar:true, config:{center:[0, 0], radius:0, innerPadding:0}, getDirectionForAxis:function(position) {
  return position === 'radial' ? 'Y' : 'X';
}, applyCenter:function(center, oldCenter) {
  if (oldCenter && center[0] === oldCenter[0] && center[1] === oldCenter[1]) {
    return;
  }
  return [+center[0], +center[1]];
}, updateCenter:function(center) {
  var me = this, axes = me.getAxes(), series = me.getSeries(), i, ln, axis, seriesItem;
  for (i = 0, ln = axes.length; i < ln; i++) {
    axis = axes[i];
    axis.setCenter(center);
  }
  for (i = 0, ln = series.length; i < ln; i++) {
    seriesItem = series[i];
    seriesItem.setCenter(center);
  }
}, applyInnerPadding:function(padding, oldPadding) {
  return Ext.isNumber(padding) ? padding : oldPadding;
}, doSetSurfaceRect:function(surface, rect) {
  var mainRect = this.getMainRect();
  surface.setRect(rect);
  surface.matrix.set(1, 0, 0, 1, mainRect[0] - rect[0], mainRect[1] - rect[1]);
  surface.inverseMatrix.set(1, 0, 0, 1, rect[0] - mainRect[0], rect[1] - mainRect[1]);
}, applyAxes:function(newAxes, oldAxes) {
  var me = this, firstSeries = Ext.Array.from(me.config.series)[0], i, ln, axis, foundAngular;
  if (firstSeries.type === 'radar' && newAxes && newAxes.length) {
    for (i = 0, ln = newAxes.length; i < ln; i++) {
      axis = newAxes[i];
      if (axis.position === 'angular') {
        foundAngular = true;
        break;
      }
    }
    if (!foundAngular) {
      newAxes.push({type:'category', position:'angular', fields:firstSeries.xField || firstSeries.angleField, style:{estStepSize:1}, grid:true});
    }
  }
  return this.callParent(arguments);
}, performLayout:function() {
  var me = this, applyThickness = true;
  try {
    me.animationSuspendCount++;
    if (this.callParent() === false) {
      applyThickness = false;
      return;
    }
    me.suspendThicknessChanged();
    var chartRect = me.getSurface('chart').getRect(), inset = me.getInsetPadding(), inner = me.getInnerPadding(), shrinkBox = Ext.apply({}, inset), side, width = chartRect[2] - inset.left - inset.right, height = chartRect[3] - inset.top - inset.bottom, mainRect = [inset.left, inset.top, width, height], seriesList = me.getSeries(), series, innerWidth = width - inner * 2, innerHeight = height - inner * 2, center = [innerWidth * 0.5 + inner, innerHeight * 0.5 + inner], radius = Math.min(innerWidth, 
    innerHeight) * 0.5, axes = me.getAxes(), axis, thickness, halfLineWidth, angularAxes = [], radialAxes = [], seriesRadius = radius - inner, i, ln, shrinkRadius, floating, floatingValue, gaugeSeries, gaugeRadius;
    me.setMainRect(mainRect);
    me.doSetSurfaceRect(me.getSurface(), mainRect);
    for (i = 0, ln = me.surfaceMap.grid && me.surfaceMap.grid.length; i < ln; i++) {
      me.doSetSurfaceRect(me.surfaceMap.grid[i], chartRect);
    }
    for (i = 0, ln = axes.length; i < ln; i++) {
      axis = axes[i];
      switch(axis.getPosition()) {
        case 'angular':
          angularAxes.push(axis);
          break;
        case 'radial':
          radialAxes.push(axis);
          break;
      }
    }
    for (i = 0, ln = angularAxes.length; i < ln; i++) {
      axis = angularAxes[i];
      floating = axis.getFloating();
      floatingValue = floating ? floating.value : null;
      me.doSetSurfaceRect(axis.getSurface(), chartRect);
      thickness = axis.getThickness();
      for (side in shrinkBox) {
        shrinkBox[side] += thickness;
      }
      width = chartRect[2] - shrinkBox.left - shrinkBox.right;
      height = chartRect[3] - shrinkBox.top - shrinkBox.bottom;
      shrinkRadius = Math.min(width, height) * 0.5;
      if (i === 0) {
        seriesRadius = shrinkRadius - inner;
      }
      axis.setMinimum(0);
      axis.setLength(shrinkRadius);
      axis.getSprites();
      halfLineWidth = axis.sprites[0].attr.lineWidth * 0.5;
      for (side in shrinkBox) {
        shrinkBox[side] += halfLineWidth;
      }
    }
    for (i = 0, ln = radialAxes.length; i < ln; i++) {
      axis = radialAxes[i];
      me.doSetSurfaceRect(axis.getSurface(), chartRect);
      axis.setMinimum(0);
      axis.setLength(seriesRadius);
      axis.getSprites();
    }
    for (i = 0, ln = seriesList.length; i < ln; i++) {
      series = seriesList[i];
      if (series.type === 'gauge' && !gaugeSeries) {
        gaugeSeries = series;
      } else {
        series.setRadius(seriesRadius);
      }
      me.doSetSurfaceRect(series.getSurface(), mainRect);
    }
    me.doSetSurfaceRect(me.getSurface('overlay'), chartRect);
    if (gaugeSeries) {
      gaugeSeries.setRect(mainRect);
      gaugeRadius = gaugeSeries.getRadius() - inner;
      me.setRadius(gaugeRadius);
      me.setCenter(gaugeSeries.getCenter());
      gaugeSeries.setRadius(gaugeRadius);
      if (axes.length && axes[0].getPosition() === 'gauge') {
        axis = axes[0];
        me.doSetSurfaceRect(axis.getSurface(), chartRect);
        axis.setTotalAngle(gaugeSeries.getTotalAngle());
        axis.setLength(gaugeRadius);
      }
    } else {
      me.setRadius(radius);
      me.setCenter(center);
    }
    me.redraw();
  } catch (e$27) {
    Ext.log.error(me.$className + ': Unhandled Exception: ', e$27.description || e$27.message);
    throw e$27;
  } finally {
    me.animationSuspendCount--;
    if (applyThickness) {
      me.resumeThicknessChanged();
    }
  }
}, refloatAxes:function() {
  var me = this, axes = me.getAxes(), mainRect = me.getMainRect(), floating, value, alongAxis, i, n, axis, radius;
  if (!mainRect) {
    return;
  }
  radius = 0.5 * Math.min(mainRect[2], mainRect[3]);
  for (i = 0, n = axes.length; i < n; i++) {
    axis = axes[i];
    floating = axis.getFloating();
    value = floating ? floating.value : null;
    if (value !== null) {
      alongAxis = me.getAxis(floating.alongAxis);
      if (axis.getPosition() === 'angular') {
        if (alongAxis) {
          value = alongAxis.getLength() * value / alongAxis.getRange()[1];
        } else {
          value = 0.01 * value * radius;
        }
        axis.sprites[0].setAttributes({length:value}, true);
      } else {
        if (alongAxis) {
          if (Ext.isString(value)) {
            value = alongAxis.getCoordFor(value);
          }
          value = value / (alongAxis.getRange()[1] + 1) * Math.PI * 2 - Math.PI * 1.5 + axis.getRotation();
        } else {
          value = Ext.draw.Draw.rad(value);
        }
        axis.sprites[0].setAttributes({baseRotation:value}, true);
      }
    }
  }
}, redraw:function() {
  var me = this, axes = me.getAxes(), axis, seriesList = me.getSeries(), series, i, ln;
  for (i = 0, ln = axes.length; i < ln; i++) {
    axis = axes[i];
    axis.getSprites();
  }
  for (i = 0, ln = seriesList.length; i < ln; i++) {
    series = seriesList[i];
    series.getSprites();
  }
  me.renderFrame();
  me.callParent(arguments);
}, renderFrame:function() {
  this.refloatAxes();
  this.callParent();
}});
Ext.define('Ext.chart.interactions.ItemHighlight', {extend:Ext.chart.interactions.Abstract, type:'itemhighlight', alias:'interaction.itemhighlight', isItemHighlight:true, config:{gestures:{tap:'onTapGesture', mousemove:'onMouseMoveGesture', mousedown:'onMouseDownGesture', mouseup:'onMouseUpGesture', mouseleave:'onMouseUpGesture'}, sticky:false}, stickyHighlightItem:null, onMouseMoveGesture:function(e) {
  var me = this, tipItem = me.tipItem, isMousePointer = e.pointerType === 'mouse', item, tooltip, chart;
  if (me.getSticky()) {
    return true;
  }
  if (me.isDragging) {
    if (tipItem && isMousePointer) {
      tipItem.series.hideTooltip(tipItem);
      me.tipItem = null;
    }
  } else {
    if (!me.stickyHighlightItem) {
      item = me.getItemForEvent(e);
      chart = me.getChart();
      if (item !== chart.getHighlightItem()) {
        me.highlight(item);
        me.sync();
      }
      if (isMousePointer) {
        if (tipItem && (!item || tipItem.field !== item.field || tipItem.record !== item.record)) {
          tipItem.series.hideTooltip(tipItem);
          me.tipItem = tipItem = null;
        }
        if (item && (tooltip = item.series.getTooltip())) {
          if (tooltip.trackMouse || !tipItem) {
            item.series.showTooltip(item, e.getXY());
          }
          me.tipItem = item;
        }
      }
      return false;
    }
  }
}, highlight:function(item) {
  this.getChart().setHighlightItem(item);
}, showTooltip:function(e, item) {
  item.series.showTooltip(item, e.getXY());
  this.tipItem = item;
}, onMouseDownGesture:function() {
  this.isDragging = true;
}, onMouseUpGesture:function() {
  this.isDragging = false;
}, onTapGesture:function(e) {
  var me = this;
  if (e.pointerType === 'mouse' && !me.getSticky()) {
    return;
  }
  var item = me.getItemForEvent(e);
  if (me.stickyHighlightItem && item && me.stickyHighlightItem.index === item.index) {
    item = null;
  }
  me.stickyHighlightItem = item;
  me.highlight(item);
}});
Ext.define('Ext.chart.interactions.Rotate', {extend:Ext.chart.interactions.Abstract, type:'rotate', alias:'interaction.rotate', config:{gesture:'rotate', gestures:{rotate:'onRotate', rotateend:'onRotate', dragstart:'onGestureStart', drag:'onGesture', dragend:'onGestureEnd'}, rotation:0}, oldRotations:null, getAngle:function(e) {
  var me = this, chart = me.getChart(), xy = chart.getEventXY(e), center = chart.getCenter();
  return Math.atan2(xy[1] - center[1], xy[0] - center[0]);
}, getRadius:function(e) {
  return this.getChart().getRadius();
}, getEventRadius:function(e) {
  var me = this, chart = me.getChart(), xy = chart.getEventXY(e), center = chart.getCenter(), dx = xy[0] - center[0], dy = xy[1] - center[1];
  return Math.sqrt(dx * dx + dy * dy);
}, onGestureStart:function(e) {
  var me = this, radius = me.getRadius(e), eventRadius = me.getEventRadius(e);
  if (radius >= eventRadius) {
    me.lockEvents('drag');
    me.angle = me.getAngle(e);
    me.oldRotations = {};
    return false;
  }
}, onGesture:function(e) {
  var me = this, angle = me.getAngle(e) - me.angle;
  if (me.getLocks().drag === me) {
    me.doRotateTo(angle, true);
    return false;
  }
}, doRotateTo:function(angle, relative, animate) {
  var me = this, chart = me.getChart(), axes = chart.getAxes(), series = chart.getSeries(), oldRotations = me.oldRotations, axis, seriesItem, oldRotation, i, ln;
  if (!animate) {
    chart.suspendAnimation();
  }
  for (i = 0, ln = axes.length; i < ln; i++) {
    axis = axes[i];
    oldRotation = oldRotations[axis.getId()] || (oldRotations[axis.getId()] = axis.getRotation());
    axis.setRotation(angle + (relative ? oldRotation : 0));
  }
  for (i = 0, ln = series.length; i < ln; i++) {
    seriesItem = series[i];
    oldRotation = oldRotations[seriesItem.getId()] || (oldRotations[seriesItem.getId()] = seriesItem.getRotation());
    seriesItem.setRotation(angle + (relative ? oldRotation : 0));
  }
  me.setRotation(angle + (relative ? oldRotation : 0));
  me.fireEvent('rotate', me, me.getRotation());
  me.sync();
  if (!animate) {
    chart.resumeAnimation();
  }
}, rotateTo:function(angle, relative, animate) {
  this.doRotateTo(angle, relative, animate);
  this.oldRotations = {};
}, onGestureEnd:function(e) {
  var me = this;
  if (me.getLocks().drag === me) {
    me.onGesture(e);
    me.unlockEvents('drag');
    me.fireEvent('rotationEnd', me, me.getRotation());
    return false;
  }
}, onRotate:function(e) {
}});
Ext.define('Ext.chart.interactions.RotatePie3D', {extend:Ext.chart.interactions.Rotate, type:'rotatePie3d', alias:'interaction.rotatePie3d', getAngle:function(e) {
  var chart = this.getChart(), rtl = chart.getInherited().rtl, direction = rtl ? -1 : 1, pageXY = e.getXY(), xy = chart.element.getXY(), rect = chart.getMainRect();
  return direction * Math.atan2(pageXY[1] - xy[1] - rect[3] * 0.5, pageXY[0] - xy[0] - rect[2] * 0.5);
}, getRadius:function(e) {
  var chart = this.getChart(), radius = chart.getRadius(), seriesList = chart.getSeries(), ln = seriesList.length, i = 0, series, seriesRadius;
  for (; i < ln; i++) {
    series = seriesList[i];
    if (series.isPie3D) {
      seriesRadius = series.getRadius();
      if (seriesRadius > radius) {
        radius = seriesRadius;
      }
    }
  }
  return radius;
}});
Ext.define('Ext.chart.series.Polar', {extend:Ext.chart.series.Series, config:{rotation:0, radius:null, center:[0, 0], offsetX:0, offsetY:0, showInLegend:true, xField:null, yField:null, angleField:null, radiusField:null, xAxis:null, yAxis:null}, directions:['X', 'Y'], fieldCategoryX:['X'], fieldCategoryY:['Y'], deprecatedConfigs:{field:'angleField', lengthField:'radiusField'}, constructor:function(config) {
  var me = this, configurator = me.getConfigurator(), configs = configurator.configs, p;
  if (config) {
    for (p in me.deprecatedConfigs) {
      if (p in config && !(config in configs)) {
        Ext.raise("'" + p + "' config has been deprecated. Please use the '" + me.deprecatedConfigs[p] + "' config instead.");
      }
    }
  }
  me.callParent([config]);
}, getXField:function() {
  return this.getAngleField();
}, updateXField:function(value) {
  this.setAngleField(value);
}, getYField:function() {
  return this.getRadiusField();
}, updateYField:function(value) {
  this.setRadiusField(value);
}, applyXAxis:function(newAxis, oldAxis) {
  return this.getChart().getAxis(newAxis) || oldAxis;
}, applyYAxis:function(newAxis, oldAxis) {
  return this.getChart().getAxis(newAxis) || oldAxis;
}, getXRange:function() {
  return [this.dataRange[0], this.dataRange[2]];
}, getYRange:function() {
  return [this.dataRange[1], this.dataRange[3]];
}, themeColorCount:function() {
  var me = this, store = me.getStore(), count = store && store.getCount() || 0;
  return count;
}, isStoreDependantColorCount:true, getDefaultSpriteConfig:function() {
  return {type:this.seriesType, renderer:this.getRenderer(), centerX:0, centerY:0, rotationCenterX:0, rotationCenterY:0};
}, applyRotation:function(rotation) {
  return Ext.draw.sprite.AttributeParser.angle(rotation);
}, updateRotation:function(rotation) {
  var sprites = this.getSprites();
  if (sprites && sprites[0]) {
    sprites[0].setAttributes({baseRotation:rotation});
  }
}});
Ext.define('Ext.chart.series.sprite.PieSlice', {extend:Ext.draw.sprite.Sector, mixins:{markerHolder:Ext.chart.MarkerHolder}, alias:'sprite.pieslice', inheritableStatics:{def:{processors:{doCallout:'bool', label:'string', rotateLabels:'bool', labelOverflowPadding:'number', renderer:'default'}, defaults:{doCallout:true, rotateLabels:true, label:'', labelOverflowPadding:10, renderer:null}}}, config:{rendererData:null, rendererIndex:0, series:null}, setGradientBBox:function(ctx, rect) {
  var me = this, attr = me.attr, hasGradients = attr.fillStyle && attr.fillStyle.isGradient || attr.strokeStyle && attr.strokeStyle.isGradient;
  if (hasGradients && !attr.constrainGradients) {
    var midAngle = me.getMidAngle(), margin = attr.margin, cx = attr.centerX, cy = attr.centerY, r = attr.endRho, matrix = attr.matrix, scaleX = matrix.getScaleX(), scaleY = matrix.getScaleY(), w = scaleX * r, h = scaleY * r, bbox = {width:w + w, height:h + h};
    if (margin) {
      cx += margin * Math.cos(midAngle);
      cy += margin * Math.sin(midAngle);
    }
    bbox.x = matrix.x(cx, cy) - w;
    bbox.y = matrix.y(cx, cy) - h;
    ctx.setGradientBBox(bbox);
  } else {
    me.callParent([ctx, rect]);
  }
}, render:function(surface, ctx, clip, rect) {
  var me = this, attr = me.attr, itemCfg = {}, changes;
  if (attr.renderer) {
    itemCfg = {type:'sector', text:attr.text, centerX:attr.centerX, centerY:attr.centerY, margin:attr.margin, startAngle:Math.min(attr.startAngle, attr.endAngle), endAngle:Math.max(attr.startAngle, attr.endAngle), startRho:Math.min(attr.startRho, attr.endRho), endRho:Math.max(attr.startRho, attr.endRho)};
    changes = Ext.callback(attr.renderer, null, [me, itemCfg, me.rendererData, me.rendererIndex], 0, me.getSeries());
    me.setAttributes(changes);
    me.useAttributes(ctx, clip);
  }
  me.callParent([surface, ctx, clip, rect]);
  if (attr.label && me.getMarker('labels')) {
    me.placeLabel();
  }
}, placeLabel:function() {
  var me = this, attr = me.attr, attributeId = attr.attributeId, startAngle = Math.min(attr.startAngle, attr.endAngle), endAngle = Math.max(attr.startAngle, attr.endAngle), midAngle = (startAngle + endAngle) * 0.5, margin = attr.margin, centerX = attr.centerX, centerY = attr.centerY, sinMidAngle = Math.sin(midAngle), cosMidAngle = Math.cos(midAngle), startRho = Math.min(attr.startRho, attr.endRho) + margin, endRho = Math.max(attr.startRho, attr.endRho) + margin, midRho = (startRho + endRho) * 0.5, 
  surfaceMatrix = me.surfaceMatrix, labelCfg = me.labelCfg || (me.labelCfg = {}), label = me.getMarker('labels'), labelTpl = label.getTemplate(), calloutLine = labelTpl.getCalloutLine(), calloutLineLength = calloutLine && calloutLine.length || 40, labelBox, x, y, changes, params;
  surfaceMatrix.appendMatrix(attr.matrix);
  labelCfg.text = attr.label;
  x = centerX + cosMidAngle * midRho;
  y = centerY + sinMidAngle * midRho;
  labelCfg.x = surfaceMatrix.x(x, y);
  labelCfg.y = surfaceMatrix.y(x, y);
  x = centerX + cosMidAngle * endRho;
  y = centerY + sinMidAngle * endRho;
  labelCfg.calloutStartX = surfaceMatrix.x(x, y);
  labelCfg.calloutStartY = surfaceMatrix.y(x, y);
  x = centerX + cosMidAngle * (endRho + calloutLineLength);
  y = centerY + sinMidAngle * (endRho + calloutLineLength);
  labelCfg.calloutPlaceX = surfaceMatrix.x(x, y);
  labelCfg.calloutPlaceY = surfaceMatrix.y(x, y);
  if (!attr.rotateLabels) {
    labelCfg.rotationRads = 0;
    Ext.log.warn("'series.style.rotateLabels' config is deprecated. " + "Use 'series.label.orientation' config instead.");
  } else {
    switch(labelTpl.attr.orientation) {
      case 'horizontal':
        labelCfg.rotationRads = midAngle + Math.atan2(surfaceMatrix.y(1, 0) - surfaceMatrix.y(0, 0), surfaceMatrix.x(1, 0) - surfaceMatrix.x(0, 0)) + Math.PI / 2;
        break;
      case 'vertical':
        labelCfg.rotationRads = midAngle + Math.atan2(surfaceMatrix.y(1, 0) - surfaceMatrix.y(0, 0), surfaceMatrix.x(1, 0) - surfaceMatrix.x(0, 0));
        break;
    }
  }
  labelCfg.calloutColor = calloutLine && calloutLine.color || me.attr.fillStyle;
  if (calloutLine) {
    if (calloutLine.width) {
      labelCfg.calloutWidth = calloutLine.width;
    }
  } else {
    labelCfg.calloutHasLine = false;
  }
  labelCfg.globalAlpha = attr.globalAlpha * attr.fillOpacity;
  labelCfg.hidden = attr.startAngle == attr.endAngle;
  if (labelTpl.attr.renderer) {
    params = [me.attr.label, label, labelCfg, me.rendererData, me.rendererIndex];
    changes = Ext.callback(labelTpl.attr.renderer, null, params, 0, me.getSeries());
    if (typeof changes === 'string') {
      labelCfg.text = changes;
    } else {
      Ext.apply(labelCfg, changes);
    }
  }
  me.putMarker('labels', labelCfg, attributeId);
  labelBox = me.getMarkerBBox('labels', attributeId, true);
  if (labelBox) {
    if (attr.doCallout) {
      if (labelTpl.attr.display === 'outside') {
        me.putMarker('labels', {callout:1}, attributeId);
      } else {
        if (labelTpl.attr.display === 'inside') {
          me.putMarker('labels', {callout:0}, attributeId);
        } else {
          me.putMarker('labels', {callout:1 - me.sliceContainsLabel(attr, labelBox)}, attributeId);
        }
      }
    } else {
      me.putMarker('labels', {globalAlpha:me.sliceContainsLabel(attr, labelBox)}, attributeId);
    }
  }
}, sliceContainsLabel:function(attr, bbox) {
  var padding = attr.labelOverflowPadding, middle = (attr.endRho + attr.startRho) / 2, outer = middle + (bbox.width + padding) / 2, inner = middle - (bbox.width + padding) / 2, sliceAngle, l1, l2, l3;
  if (padding < 0) {
    return 1;
  }
  if (bbox.width + padding * 2 > attr.endRho - attr.startRho) {
    return 0;
  }
  l1 = Math.sqrt(attr.endRho * attr.endRho - outer * outer);
  l2 = Math.sqrt(attr.endRho * attr.endRho - inner * inner);
  sliceAngle = Math.abs(attr.endAngle - attr.startAngle);
  l3 = sliceAngle > Math.PI / 2 ? inner : Math.abs(Math.tan(sliceAngle / 2)) * inner;
  if (bbox.height + padding * 2 > Math.min(l1, l2, l3) * 2) {
    return 0;
  }
  return 1;
}});
Ext.define('Ext.chart.series.Pie', {extend:Ext.chart.series.Polar, type:'pie', alias:'series.pie', seriesType:'pieslice', config:{donut:0, rotation:0, clockwise:true, totalAngle:2 * Math.PI, hidden:[], radiusFactor:100, highlightCfg:{margin:20}, style:{}}, directions:['X'], applyLabel:function(newLabel, oldLabel) {
  if (Ext.isObject(newLabel) && !Ext.isString(newLabel.orientation)) {
    Ext.apply(newLabel = Ext.Object.chain(newLabel), {orientation:'vertical'});
  }
  return this.callParent([newLabel, oldLabel]);
}, updateLabelData:function() {
  var me = this, store = me.getStore(), items = store.getData().items, sprites = me.getSprites(), labelField = me.getLabel().getTemplate().getField(), hidden = me.getHidden(), i, ln, labels, sprite;
  if (sprites.length && labelField) {
    labels = [];
    for (i = 0, ln = items.length; i < ln; i++) {
      labels.push(items[i].get(labelField));
    }
    for (i = 0, ln = sprites.length; i < ln; i++) {
      sprite = sprites[i];
      sprite.setAttributes({label:labels[i]});
      sprite.putMarker('labels', {hidden:hidden[i]}, sprite.attr.attributeId);
    }
  }
}, coordinateX:function() {
  var me = this, store = me.getStore(), records = store.getData().items, recordCount = records.length, xField = me.getXField(), yField = me.getYField(), x, sumX = 0, unit, y, maxY = 0, hidden = me.getHidden(), summation = [], i, lastAngle = 0, totalAngle = me.getTotalAngle(), clockwise = me.getClockwise() ? 1 : -1, sprites = me.getSprites(), sprite;
  if (!sprites) {
    return;
  }
  for (i = 0; i < recordCount; i++) {
    x = Math.abs(Number(records[i].get(xField))) || 0;
    y = yField && Math.abs(Number(records[i].get(yField))) || 0;
    if (!hidden[i]) {
      sumX += x;
      if (y > maxY) {
        maxY = y;
      }
    }
    summation[i] = sumX;
    if (i >= hidden.length) {
      hidden[i] = false;
    }
  }
  hidden.length = recordCount;
  me.maxY = maxY;
  if (sumX !== 0) {
    unit = totalAngle / sumX;
  }
  for (i = 0; i < recordCount; i++) {
    sprites[i].setAttributes({startAngle:lastAngle, endAngle:lastAngle = unit ? clockwise * summation[i] * unit : 0, globalAlpha:1});
  }
  if (recordCount < me.sprites.length) {
    for (i = recordCount; i < me.sprites.length; i++) {
      sprite = me.sprites[i];
      sprite.getMarker('labels').clear(sprite.getId());
      sprite.releaseMarker('labels');
      sprite.destroy();
    }
    me.sprites.length = recordCount;
  }
  for (i = recordCount; i < me.sprites.length; i++) {
    sprites[i].setAttributes({startAngle:totalAngle, endAngle:totalAngle, globalAlpha:0});
  }
  me.getChart().refreshLegendStore();
}, updateCenter:function(center) {
  this.setStyle({translationX:center[0] + this.getOffsetX(), translationY:center[1] + this.getOffsetY()});
  this.doUpdateStyles();
}, updateRadius:function(radius) {
  this.setStyle({startRho:radius * this.getDonut() * 0.01, endRho:radius * this.getRadiusFactor() * 0.01});
  this.doUpdateStyles();
}, getStyleByIndex:function(i) {
  var me = this, store = me.getStore(), item = store.getAt(i), yField = me.getYField(), radius = me.getRadius(), style = {}, startRho, endRho, y;
  if (item) {
    y = yField && Math.abs(Number(item.get(yField))) || 0;
    startRho = radius * me.getDonut() * 0.01;
    endRho = radius * me.getRadiusFactor() * 0.01;
    style = me.callParent([i]);
    style.startRho = startRho;
    style.endRho = me.maxY ? startRho + (endRho - startRho) * y / me.maxY : endRho;
  }
  return style;
}, updateDonut:function(donut) {
  var radius = this.getRadius();
  this.setStyle({startRho:radius * donut * 0.01, endRho:radius * this.getRadiusFactor() * 0.01});
  this.doUpdateStyles();
}, rotationOffset:-Math.PI / 2, updateRotation:function(rotation) {
  this.setStyle({rotationRads:rotation + this.rotationOffset});
  this.doUpdateStyles();
}, updateTotalAngle:function(totalAngle) {
  this.processData();
}, getSprites:function() {
  var me = this, chart = me.getChart(), store = me.getStore();
  if (!chart || !store) {
    return [];
  }
  me.getColors();
  me.getSubStyle();
  var items = store.getData().items, length = items.length, animation = me.getAnimation() || chart && chart.getAnimation(), sprites = me.sprites, sprite, spriteIndex = 0, rendererData, i, spriteCreated = false, label = me.getLabel(), labelTpl = label.getTemplate();
  rendererData = {store:store, field:me.getXField(), angleField:me.getXField(), radiusField:me.getYField(), series:me};
  for (i = 0; i < length; i++) {
    sprite = sprites[i];
    if (!sprite) {
      sprite = me.createSprite();
      if (me.getHighlight()) {
        sprite.config.highlight = me.getHighlight();
        sprite.addModifier('highlight', true);
      }
      if (labelTpl.getField()) {
        labelTpl.setAttributes({labelOverflowPadding:me.getLabelOverflowPadding()});
        labelTpl.fx.setCustomDurations({'callout':200});
      }
      sprite.setAttributes(me.getStyleByIndex(i));
      sprite.rendererData = rendererData;
      sprite.rendererIndex = spriteIndex++;
      spriteCreated = true;
    }
    sprite.setAnimation(animation);
  }
  if (spriteCreated) {
    me.doUpdateStyles();
  }
  return me.sprites;
}, betweenAngle:function(x, a, b) {
  var pp = Math.PI * 2, offset = this.rotationOffset;
  if (!this.getClockwise()) {
    x *= -1;
    a *= -1;
    b *= -1;
    a -= offset;
    b -= offset;
  } else {
    a += offset;
    b += offset;
  }
  x -= a;
  b -= a;
  x %= pp;
  b %= pp;
  x += pp;
  b += pp;
  x %= pp;
  b %= pp;
  return x < b || b === 0;
}, getItemForAngle:function(angle) {
  var me = this, sprites = me.getSprites(), attr;
  angle %= Math.PI * 2;
  while (angle < 0) {
    angle += Math.PI * 2;
  }
  if (sprites) {
    var store = me.getStore(), items = store.getData().items, hidden = me.getHidden(), i = 0, ln = store.getCount();
    for (; i < ln; i++) {
      if (!hidden[i]) {
        attr = sprites[i].attr;
        if (attr.startAngle <= angle && attr.endAngle >= angle) {
          return {series:me, sprite:sprites[i], index:i, record:items[i], field:me.getXField()};
        }
      }
    }
  }
  return null;
}, getItemForPoint:function(x, y) {
  var me = this, sprites = me.getSprites();
  if (sprites) {
    var center = me.getCenter(), offsetX = me.getOffsetX(), offsetY = me.getOffsetY(), dx = x - center[0] + offsetX, dy = y - center[1] + offsetY, store = me.getStore(), donut = me.getDonut(), records = store.getData().items, direction = Math.atan2(dy, dx) - me.getRotation(), radius = Math.sqrt(dx * dx + dy * dy), startRadius = me.getRadius() * donut * 0.01, hidden = me.getHidden(), i, ln, attr;
    for (i = 0, ln = records.length; i < ln; i++) {
      if (!hidden[i]) {
        attr = sprites[i].attr;
        if (radius >= startRadius + attr.margin && radius <= attr.endRho + attr.margin) {
          if (me.betweenAngle(direction, attr.startAngle, attr.endAngle)) {
            return {series:me, sprite:sprites[i], index:i, record:records[i], field:me.getXField()};
          }
        }
      }
    }
    return null;
  }
}, provideLegendInfo:function(target) {
  var me = this, store = me.getStore();
  if (store) {
    var items = store.getData().items, labelField = me.getLabel().getTemplate().getField(), xField = me.getXField(), hidden = me.getHidden(), i, style, fill;
    for (i = 0; i < items.length; i++) {
      style = me.getStyleByIndex(i);
      fill = style.fillStyle;
      if (Ext.isObject(fill)) {
        fill = fill.stops && fill.stops[0].color;
      }
      target.push({name:labelField ? String(items[i].get(labelField)) : xField + ' ' + i, mark:fill || style.strokeStyle || 'black', disabled:hidden[i], series:me.getId(), index:i});
    }
  }
}});
Ext.define('Ext.chart.series.sprite.Pie3DPart', {extend:Ext.draw.sprite.Path, mixins:{markerHolder:Ext.chart.MarkerHolder}, alias:'sprite.pie3dPart', inheritableStatics:{def:{processors:{centerX:'number', centerY:'number', startAngle:'number', endAngle:'number', startRho:'number', endRho:'number', margin:'number', thickness:'number', bevelWidth:'number', distortion:'number', baseColor:'color', colorSpread:'number', baseRotation:'number', part:'enums(top,bottom,start,end,innerFront,innerBack,outerFront,outerBack)', 
label:'string'}, aliases:{rho:'endRho'}, triggers:{centerX:'path,bbox', centerY:'path,bbox', startAngle:'path,partZIndex', endAngle:'path,partZIndex', startRho:'path', endRho:'path,bbox', margin:'path,bbox', thickness:'path', distortion:'path', baseRotation:'path,partZIndex', baseColor:'partZIndex,partColor', colorSpread:'partColor', part:'path,partZIndex', globalAlpha:'canvas,alpha'}, defaults:{centerX:0, centerY:0, startAngle:Math.PI * 2, endAngle:Math.PI * 2, startRho:0, endRho:150, margin:0, 
thickness:35, distortion:0.5, baseRotation:0, baseColor:'white', colorSpread:1, miterLimit:1, bevelWidth:5, strokeOpacity:0, part:'top', label:''}, updaters:{alpha:'alphaUpdater', partColor:'partColorUpdater', partZIndex:'partZIndexUpdater'}}}, bevelParams:[], constructor:function(config) {
  this.callParent([config]);
  this.bevelGradient = new Ext.draw.gradient.Linear({stops:[{offset:0, color:'rgba(255,255,255,0)'}, {offset:0.7, color:'rgba(255,255,255,0.6)'}, {offset:1, color:'rgba(255,255,255,0)'}]});
}, alphaUpdater:function(attr) {
  var me = this, opacity = attr.globalAlpha, oldOpacity = me.oldOpacity;
  if (opacity !== oldOpacity && (opacity === 1 || oldOpacity === 1)) {
    me.scheduleUpdater(attr, 'path', ['globalAlpha']);
    me.oldOpacity = opacity;
  }
}, partColorUpdater:function(attr) {
  var color = Ext.draw.Color.fly(attr.baseColor), colorString = color.toString(), colorSpread = attr.colorSpread, fillStyle;
  switch(attr.part) {
    case 'top':
      fillStyle = new Ext.draw.gradient.Radial({start:{x:0, y:0, r:0}, end:{x:0, y:0, r:1}, stops:[{offset:0, color:color.createLighter(0.1 * colorSpread)}, {offset:1, color:color.createDarker(0.1 * colorSpread)}]});
      break;
    case 'bottom':
      fillStyle = new Ext.draw.gradient.Radial({start:{x:0, y:0, r:0}, end:{x:0, y:0, r:1}, stops:[{offset:0, color:color.createDarker(0.2 * colorSpread)}, {offset:1, color:color.toString()}]});
      break;
    case 'outerFront':
    case 'outerBack':
      fillStyle = new Ext.draw.gradient.Linear({stops:[{offset:0, color:color.createDarker(0.15 * colorSpread).toString()}, {offset:0.3, color:colorString}, {offset:0.8, color:color.createLighter(0.2 * colorSpread).toString()}, {offset:1, color:color.createDarker(0.25 * colorSpread).toString()}]});
      break;
    case 'start':
      fillStyle = new Ext.draw.gradient.Linear({stops:[{offset:0, color:color.createDarker(0.1 * colorSpread).toString()}, {offset:1, color:color.createLighter(0.2 * colorSpread).toString()}]});
      break;
    case 'end':
      fillStyle = new Ext.draw.gradient.Linear({stops:[{offset:0, color:color.createDarker(0.1 * colorSpread).toString()}, {offset:1, color:color.createLighter(0.2 * colorSpread).toString()}]});
      break;
    case 'innerFront':
    case 'innerBack':
      fillStyle = new Ext.draw.gradient.Linear({stops:[{offset:0, color:color.createDarker(0.1 * colorSpread).toString()}, {offset:0.2, color:color.createLighter(0.2 * colorSpread).toString()}, {offset:0.7, color:colorString}, {offset:1, color:color.createDarker(0.1 * colorSpread).toString()}]});
      break;
  }
  attr.fillStyle = fillStyle;
  attr.canvasAttributes.fillStyle = fillStyle;
}, partZIndexUpdater:function(attr) {
  var normalize = Ext.draw.sprite.AttributeParser.angle, rotation = attr.baseRotation, startAngle = attr.startAngle, endAngle = attr.endAngle, depth;
  switch(attr.part) {
    case 'top':
      attr.zIndex = 5;
      break;
    case 'outerFront':
      startAngle = normalize(startAngle + rotation);
      endAngle = normalize(endAngle + rotation);
      if (startAngle >= 0 && endAngle < 0) {
        depth = Math.sin(startAngle);
      } else {
        if (startAngle <= 0 && endAngle > 0) {
          depth = Math.sin(endAngle);
        } else {
          if (startAngle >= 0 && endAngle > 0) {
            if (startAngle > endAngle) {
              depth = 0;
            } else {
              depth = Math.max(Math.sin(startAngle), Math.sin(endAngle));
            }
          } else {
            depth = 1;
          }
        }
      }
      attr.zIndex = 4 + depth;
      break;
    case 'outerBack':
      attr.zIndex = 1;
      break;
    case 'start':
      attr.zIndex = 4 + Math.sin(normalize(startAngle + rotation));
      break;
    case 'end':
      attr.zIndex = 4 + Math.sin(normalize(endAngle + rotation));
      break;
    case 'innerFront':
      attr.zIndex = 2;
      break;
    case 'innerBack':
      attr.zIndex = 4 + Math.sin(normalize((startAngle + endAngle) / 2 + rotation));
      break;
    case 'bottom':
      attr.zIndex = 0;
      break;
  }
  attr.dirtyZIndex = true;
}, updatePlainBBox:function(plain) {
  var attr = this.attr, part = attr.part, baseRotation = attr.baseRotation, centerX = attr.centerX, centerY = attr.centerY, rho, angle, x, y, sin, cos;
  if (part === 'start') {
    angle = attr.startAngle + baseRotation;
  } else {
    if (part === 'end') {
      angle = attr.endAngle + baseRotation;
    }
  }
  if (Ext.isNumber(angle)) {
    sin = Math.sin(angle);
    cos = Math.cos(angle);
    x = Math.min(centerX + cos * attr.startRho, centerX + cos * attr.endRho);
    y = centerY + sin * attr.startRho * attr.distortion;
    plain.x = x;
    plain.y = y;
    plain.width = cos * (attr.endRho - attr.startRho);
    plain.height = attr.thickness + sin * (attr.endRho - attr.startRho) * 2;
    return;
  }
  if (part === 'innerFront' || part === 'innerBack') {
    rho = attr.startRho;
  } else {
    rho = attr.endRho;
  }
  plain.width = rho * 2;
  plain.height = rho * attr.distortion * 2 + attr.thickness;
  plain.x = attr.centerX - rho;
  plain.y = attr.centerY - rho * attr.distortion;
}, updateTransformedBBox:function(transform) {
  if (this.attr.part === 'start' || this.attr.part === 'end') {
    return this.callParent(arguments);
  }
  return this.updatePlainBBox(transform);
}, updatePath:function(path) {
  if (!this.attr.globalAlpha) {
    return;
  }
  if (this.attr.endAngle < this.attr.startAngle) {
    return;
  }
  this[this.attr.part + 'Renderer'](path);
}, render:function(surface, ctx) {
  var me = this, attr = me.attr;
  if (!attr.globalAlpha) {
    return;
  }
  me.callParent([surface, ctx]);
  me.bevelRenderer(surface, ctx);
  if (attr.label && me.getMarker('labels')) {
    me.placeLabel();
  }
}, placeLabel:function() {
  var me = this, attr = me.attr, attributeId = attr.attributeId, margin = attr.margin, distortion = attr.distortion, centerX = attr.centerX, centerY = attr.centerY, baseRotation = attr.baseRotation, startAngle = attr.startAngle + baseRotation, endAngle = attr.endAngle + baseRotation, midAngle = (startAngle + endAngle) / 2, startRho = attr.startRho + margin, endRho = attr.endRho + margin, midRho = (startRho + endRho) / 2, sin = Math.sin(midAngle), cos = Math.cos(midAngle), surfaceMatrix = me.surfaceMatrix, 
  label = me.getMarker('labels'), labelTpl = label.getTemplate(), calloutLine = labelTpl.getCalloutLine(), calloutLineLength = calloutLine && calloutLine.length || 40, labelCfg = {}, x, y;
  surfaceMatrix.appendMatrix(attr.matrix);
  labelCfg.text = attr.label;
  x = centerX + cos * midRho;
  y = centerY + sin * midRho * distortion;
  labelCfg.x = surfaceMatrix.x(x, y);
  labelCfg.y = surfaceMatrix.y(x, y);
  x = centerX + cos * endRho;
  y = centerY + sin * endRho * distortion;
  labelCfg.calloutStartX = surfaceMatrix.x(x, y);
  labelCfg.calloutStartY = surfaceMatrix.y(x, y);
  x = centerX + cos * (endRho + calloutLineLength);
  y = centerY + sin * (endRho + calloutLineLength) * distortion;
  labelCfg.calloutPlaceX = surfaceMatrix.x(x, y);
  labelCfg.calloutPlaceY = surfaceMatrix.y(x, y);
  labelCfg.calloutWidth = 2;
  me.putMarker('labels', labelCfg, attributeId);
  me.putMarker('labels', {callout:1}, attributeId);
}, bevelRenderer:function(surface, ctx) {
  var me = this, attr = me.attr, bevelWidth = attr.bevelWidth, params = me.bevelParams, i;
  for (i = 0; i < params.length; i++) {
    ctx.beginPath();
    ctx.ellipse.apply(ctx, params[i]);
    ctx.save();
    ctx.lineWidth = bevelWidth;
    ctx.strokeOpacity = bevelWidth ? 1 : 0;
    ctx.strokeGradient = me.bevelGradient;
    ctx.stroke(attr);
    ctx.restore();
  }
}, lidRenderer:function(path, thickness) {
  var attr = this.attr, margin = attr.margin, distortion = attr.distortion, centerX = attr.centerX, centerY = attr.centerY, baseRotation = attr.baseRotation, startAngle = attr.startAngle + baseRotation, endAngle = attr.endAngle + baseRotation, midAngle = (startAngle + endAngle) / 2, startRho = attr.startRho, endRho = attr.endRho, sinEnd = Math.sin(endAngle), cosEnd = Math.cos(endAngle);
  centerX += Math.cos(midAngle) * margin;
  centerY += Math.sin(midAngle) * margin * distortion;
  path.ellipse(centerX, centerY + thickness, startRho, startRho * distortion, 0, startAngle, endAngle, false);
  path.lineTo(centerX + cosEnd * endRho, centerY + thickness + sinEnd * endRho * distortion);
  path.ellipse(centerX, centerY + thickness, endRho, endRho * distortion, 0, endAngle, startAngle, true);
  path.closePath();
}, topRenderer:function(path) {
  this.lidRenderer(path, 0);
}, bottomRenderer:function(path) {
  var attr = this.attr;
  if (attr.globalAlpha < 1 || attr.shadowColor !== Ext.draw.Color.RGBA_NONE) {
    this.lidRenderer(path, attr.thickness);
  }
}, sideRenderer:function(path, position) {
  var attr = this.attr, margin = attr.margin, centerX = attr.centerX, centerY = attr.centerY, distortion = attr.distortion, baseRotation = attr.baseRotation, startAngle = attr.startAngle + baseRotation, endAngle = attr.endAngle + baseRotation, thickness = attr.thickness, startRho = attr.startRho, endRho = attr.endRho, angle = position === 'start' && startAngle || position === 'end' && endAngle, sin = Math.sin(angle), cos = Math.cos(angle), isTranslucent = attr.globalAlpha < 1, isVisible = position === 
  'start' && cos < 0 || position === 'end' && cos > 0 || isTranslucent, midAngle;
  if (isVisible) {
    midAngle = (startAngle + endAngle) / 2;
    centerX += Math.cos(midAngle) * margin;
    centerY += Math.sin(midAngle) * margin * distortion;
    path.moveTo(centerX + cos * startRho, centerY + sin * startRho * distortion);
    path.lineTo(centerX + cos * endRho, centerY + sin * endRho * distortion);
    path.lineTo(centerX + cos * endRho, centerY + sin * endRho * distortion + thickness);
    path.lineTo(centerX + cos * startRho, centerY + sin * startRho * distortion + thickness);
    path.closePath();
  }
}, startRenderer:function(path) {
  this.sideRenderer(path, 'start');
}, endRenderer:function(path) {
  this.sideRenderer(path, 'end');
}, rimRenderer:function(path, radius, isDonut, isFront) {
  var me = this, attr = me.attr, margin = attr.margin, centerX = attr.centerX, centerY = attr.centerY, distortion = attr.distortion, baseRotation = attr.baseRotation, normalize = Ext.draw.sprite.AttributeParser.angle, startAngle = attr.startAngle + baseRotation, endAngle = attr.endAngle + baseRotation, midAngle = normalize((startAngle + endAngle) / 2), thickness = attr.thickness, isTranslucent = attr.globalAlpha < 1, isAllFront, isAllBack, params;
  me.bevelParams = [];
  startAngle = normalize(startAngle);
  endAngle = normalize(endAngle);
  centerX += Math.cos(midAngle) * margin;
  centerY += Math.sin(midAngle) * margin * distortion;
  isAllFront = startAngle >= 0 && endAngle >= 0;
  isAllBack = startAngle <= 0 && endAngle <= 0;
  function renderLeftFrontChunk() {
    path.ellipse(centerX, centerY + thickness, radius, radius * distortion, 0, Math.PI, startAngle, true);
    path.lineTo(centerX + Math.cos(startAngle) * radius, centerY + Math.sin(startAngle) * radius * distortion);
    params = [centerX, centerY, radius, radius * distortion, 0, startAngle, Math.PI, false];
    if (!isDonut) {
      me.bevelParams.push(params);
    }
    path.ellipse.apply(path, params);
    path.closePath();
  }
  function renderRightFrontChunk() {
    path.ellipse(centerX, centerY + thickness, radius, radius * distortion, 0, 0, endAngle, false);
    path.lineTo(centerX + Math.cos(endAngle) * radius, centerY + Math.sin(endAngle) * radius * distortion);
    params = [centerX, centerY, radius, radius * distortion, 0, endAngle, 0, true];
    if (!isDonut) {
      me.bevelParams.push(params);
    }
    path.ellipse.apply(path, params);
    path.closePath();
  }
  function renderLeftBackChunk() {
    path.ellipse(centerX, centerY + thickness, radius, radius * distortion, 0, Math.PI, endAngle, false);
    path.lineTo(centerX + Math.cos(endAngle) * radius, centerY + Math.sin(endAngle) * radius * distortion);
    params = [centerX, centerY, radius, radius * distortion, 0, endAngle, Math.PI, true];
    if (isDonut) {
      me.bevelParams.push(params);
    }
    path.ellipse.apply(path, params);
    path.closePath();
  }
  function renderRightBackChunk() {
    path.ellipse(centerX, centerY + thickness, radius, radius * distortion, 0, startAngle, 0, false);
    path.lineTo(centerX + radius, centerY);
    params = [centerX, centerY, radius, radius * distortion, 0, 0, startAngle, true];
    if (isDonut) {
      me.bevelParams.push(params);
    }
    path.ellipse.apply(path, params);
    path.closePath();
  }
  if (isFront) {
    if (!isDonut || isTranslucent) {
      if (startAngle >= 0 && endAngle < 0) {
        renderLeftFrontChunk();
      } else {
        if (startAngle <= 0 && endAngle > 0) {
          renderRightFrontChunk();
        } else {
          if (startAngle <= 0 && endAngle < 0) {
            if (startAngle > endAngle) {
              path.ellipse(centerX, centerY + thickness, radius, radius * distortion, 0, 0, Math.PI, false);
              path.lineTo(centerX - radius, centerY);
              params = [centerX, centerY, radius, radius * distortion, 0, Math.PI, 0, true];
              if (!isDonut) {
                me.bevelParams.push(params);
              }
              path.ellipse.apply(path, params);
              path.closePath();
            }
          } else {
            if (startAngle > endAngle) {
              renderLeftFrontChunk();
              renderRightFrontChunk();
            } else {
              params = [centerX, centerY, radius, radius * distortion, 0, startAngle, endAngle, false];
              if (isAllFront && !isDonut || isAllBack && isDonut) {
                me.bevelParams.push(params);
              }
              path.ellipse.apply(path, params);
              path.lineTo(centerX + Math.cos(endAngle) * radius, centerY + Math.sin(endAngle) * radius * distortion + thickness);
              path.ellipse(centerX, centerY + thickness, radius, radius * distortion, 0, endAngle, startAngle, true);
              path.closePath();
            }
          }
        }
      }
    }
  } else {
    if (isDonut || isTranslucent) {
      if (startAngle >= 0 && endAngle < 0) {
        renderLeftBackChunk();
      } else {
        if (startAngle <= 0 && endAngle > 0) {
          renderRightBackChunk();
        } else {
          if (startAngle <= 0 && endAngle < 0) {
            if (startAngle > endAngle) {
              renderLeftBackChunk();
              renderRightBackChunk();
            } else {
              path.ellipse(centerX, centerY + thickness, radius, radius * distortion, 0, startAngle, endAngle, false);
              path.lineTo(centerX + Math.cos(endAngle) * radius, centerY + Math.sin(endAngle) * radius * distortion);
              params = [centerX, centerY, radius, radius * distortion, 0, endAngle, startAngle, true];
              if (isDonut) {
                me.bevelParams.push(params);
              }
              path.ellipse.apply(path, params);
              path.closePath();
            }
          } else {
            if (startAngle > endAngle) {
              path.ellipse(centerX, centerY + thickness, radius, radius * distortion, 0, -Math.PI, 0, false);
              path.lineTo(centerX + radius, centerY);
              params = [centerX, centerY, radius, radius * distortion, 0, 0, -Math.PI, true];
              if (isDonut) {
                me.bevelParams.push(params);
              }
              path.ellipse.apply(path, params);
              path.closePath();
            }
          }
        }
      }
    }
  }
}, innerFrontRenderer:function(path) {
  this.rimRenderer(path, this.attr.startRho, true, true);
}, innerBackRenderer:function(path) {
  this.rimRenderer(path, this.attr.startRho, true, false);
}, outerFrontRenderer:function(path) {
  this.rimRenderer(path, this.attr.endRho, false, true);
}, outerBackRenderer:function(path) {
  this.rimRenderer(path, this.attr.endRho, false, false);
}});
Ext.define('Ext.draw.PathUtil', function() {
  var abs = Math.abs, pow = Math.pow, cos = Math.cos, acos = Math.acos, sqrt = Math.sqrt, PI = Math.PI;
  return {singleton:true, cubicRoots:function(P) {
    var a = P[0], b = P[1], c = P[2], d = P[3];
    if (a === 0) {
      return this.quadraticRoots(b, c, d);
    }
    var A = b / a, B = c / a, C = d / a, Q = (3 * B - pow(A, 2)) / 9, R = (9 * A * B - 27 * C - 2 * pow(A, 3)) / 54, D = pow(Q, 3) + pow(R, 2), t = [], S, T, Im, th, i, sign = Ext.Number.sign;
    if (D >= 0) {
      S = sign(R + sqrt(D)) * pow(abs(R + sqrt(D)), 1 / 3);
      T = sign(R - sqrt(D)) * pow(abs(R - sqrt(D)), 1 / 3);
      t[0] = -A / 3 + (S + T);
      t[1] = -A / 3 - (S + T) / 2;
      t[2] = t[1];
      Im = abs(sqrt(3) * (S - T) / 2);
      if (Im !== 0) {
        t[1] = -1;
        t[2] = -1;
      }
    } else {
      th = acos(R / sqrt(-pow(Q, 3)));
      t[0] = 2 * sqrt(-Q) * cos(th / 3) - A / 3;
      t[1] = 2 * sqrt(-Q) * cos((th + 2 * PI) / 3) - A / 3;
      t[2] = 2 * sqrt(-Q) * cos((th + 4 * PI) / 3) - A / 3;
    }
    for (i = 0; i < 3; i++) {
      if (t[i] < 0 || t[i] > 1) {
        t[i] = -1;
      }
    }
    return t;
  }, quadraticRoots:function(a, b, c) {
    var D, rD, t, i;
    if (a === 0) {
      return this.linearRoot(b, c);
    }
    D = b * b - 4 * a * c;
    if (D === 0) {
      t = [-b / (2 * a)];
    } else {
      if (D > 0) {
        rD = sqrt(D);
        t = [(-b - rD) / (2 * a), (-b + rD) / (2 * a)];
      } else {
        return [];
      }
    }
    for (i = 0; i < t.length; i++) {
      if (t[i] < 0 || t[i] > 1) {
        t[i] = -1;
      }
    }
    return t;
  }, linearRoot:function(a, b) {
    var t = -b / a;
    if (a === 0 || t < 0 || t > 1) {
      return [];
    }
    return [t];
  }, bezierCoeffs:function(P0, P1, P2, P3) {
    var Z = [];
    Z[0] = -P0 + 3 * P1 - 3 * P2 + P3;
    Z[1] = 3 * P0 - 6 * P1 + 3 * P2;
    Z[2] = -3 * P0 + 3 * P1;
    Z[3] = P0;
    return Z;
  }, cubicLineIntersections:function(px1, px2, px3, px4, py1, py2, py3, py4, x1, y1, x2, y2) {
    var P = [], intersections = [], A = y1 - y2, B = x2 - x1, C = x1 * (y2 - y1) - y1 * (x2 - x1), bx = this.bezierCoeffs(px1, px2, px3, px4), by = this.bezierCoeffs(py1, py2, py3, py4), i, r, s, t, tt, ttt, cx, cy;
    P[0] = A * bx[0] + B * by[0];
    P[1] = A * bx[1] + B * by[1];
    P[2] = A * bx[2] + B * by[2];
    P[3] = A * bx[3] + B * by[3] + C;
    r = this.cubicRoots(P);
    for (i = 0; i < r.length; i++) {
      t = r[i];
      if (t < 0 || t > 1) {
        continue;
      }
      tt = t * t;
      ttt = tt * t;
      cx = bx[0] * ttt + bx[1] * tt + bx[2] * t + bx[3];
      cy = by[0] * ttt + by[1] * tt + by[2] * t + by[3];
      if (x2 - x1 !== 0) {
        s = (cx - x1) / (x2 - x1);
      } else {
        s = (cy - y1) / (y2 - y1);
      }
      if (!(s < 0 || s > 1)) {
        intersections.push([cx, cy]);
      }
    }
    return intersections;
  }, splitCubic:function(P1, P2, P3, P4, z) {
    var zz = z * z, zzz = z * zz, iz = z - 1, izz = iz * iz, izzz = iz * izz, P = zzz * P4 - 3 * zz * iz * P3 + 3 * z * izz * P2 - izzz * P1;
    return [[P1, z * P2 - iz * P1, zz * P3 - 2 * z * iz * P2 + izz * P1, P], [P, zz * P4 - 2 * z * iz * P3 + izz * P2, z * P4 - iz * P3, P4]];
  }, cubicDimension:function(a, b, c, d) {
    var qa = 3 * (-a + 3 * (b - c) + d), qb = 6 * (a - 2 * b + c), qc = -3 * (a - b), x, y, min = Math.min(a, d), max = Math.max(a, d), delta;
    if (qa === 0) {
      if (qb === 0) {
        return [min, max];
      } else {
        x = -qc / qb;
        if (0 < x && x < 1) {
          y = this.interpolateCubic(a, b, c, d, x);
          min = Math.min(min, y);
          max = Math.max(max, y);
        }
      }
    } else {
      delta = qb * qb - 4 * qa * qc;
      if (delta >= 0) {
        delta = sqrt(delta);
        x = (delta - qb) / 2 / qa;
        if (0 < x && x < 1) {
          y = this.interpolateCubic(a, b, c, d, x);
          min = Math.min(min, y);
          max = Math.max(max, y);
        }
        if (delta > 0) {
          x -= delta / qa;
          if (0 < x && x < 1) {
            y = this.interpolateCubic(a, b, c, d, x);
            min = Math.min(min, y);
            max = Math.max(max, y);
          }
        }
      }
    }
    return [min, max];
  }, interpolateCubic:function(a, b, c, d, t) {
    if (t === 0) {
      return a;
    }
    if (t === 1) {
      return d;
    }
    var rate = (1 - t) / t;
    return t * t * t * (d + rate * (3 * c + rate * (3 * b + rate * a)));
  }, cubicsIntersections:function(ax1, ax2, ax3, ax4, ay1, ay2, ay3, ay4, bx1, bx2, bx3, bx4, by1, by2, by3, by4) {
    var me = this, axDim = me.cubicDimension(ax1, ax2, ax3, ax4), ayDim = me.cubicDimension(ay1, ay2, ay3, ay4), bxDim = me.cubicDimension(bx1, bx2, bx3, bx4), byDim = me.cubicDimension(by1, by2, by3, by4), splitAx, splitAy, splitBx, splitBy, points = [];
    if (axDim[0] > bxDim[1] || axDim[1] < bxDim[0] || ayDim[0] > byDim[1] || ayDim[1] < byDim[0]) {
      return [];
    }
    if (abs(ay1 - ay2) < 1 && abs(ay3 - ay4) < 1 && abs(ax1 - ax4) < 1 && abs(ax2 - ax3) < 1 && abs(by1 - by2) < 1 && abs(by3 - by4) < 1 && abs(bx1 - bx4) < 1 && abs(bx2 - bx3) < 1) {
      return [[(ax1 + ax4) * 0.5, (ay1 + ay2) * 0.5]];
    }
    splitAx = me.splitCubic(ax1, ax2, ax3, ax4, 0.5);
    splitAy = me.splitCubic(ay1, ay2, ay3, ay4, 0.5);
    splitBx = me.splitCubic(bx1, bx2, bx3, bx4, 0.5);
    splitBy = me.splitCubic(by1, by2, by3, by4, 0.5);
    points.push.apply(points, me.cubicsIntersections.apply(me, splitAx[0].concat(splitAy[0], splitBx[0], splitBy[0])));
    points.push.apply(points, me.cubicsIntersections.apply(me, splitAx[0].concat(splitAy[0], splitBx[1], splitBy[1])));
    points.push.apply(points, me.cubicsIntersections.apply(me, splitAx[1].concat(splitAy[1], splitBx[0], splitBy[0])));
    points.push.apply(points, me.cubicsIntersections.apply(me, splitAx[1].concat(splitAy[1], splitBx[1], splitBy[1])));
    return points;
  }, linesIntersection:function(x1, y1, x2, y2, x3, y3, x4, y4) {
    var d = (x2 - x1) * (y4 - y3) - (y2 - y1) * (x4 - x3), ua, ub;
    if (d === 0) {
      return null;
    }
    ua = ((x4 - x3) * (y1 - y3) - (x1 - x3) * (y4 - y3)) / d;
    ub = ((x2 - x1) * (y1 - y3) - (y2 - y1) * (x1 - x3)) / d;
    if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {
      return [x1 + ua * (x2 - x1), y1 + ua * (y2 - y1)];
    }
    return null;
  }, pointOnLine:function(x1, y1, x2, y2, x, y) {
    var t, _;
    if (abs(x2 - x1) < abs(y2 - y1)) {
      _ = x1;
      x1 = y1;
      y1 = _;
      _ = x2;
      x2 = y2;
      y2 = _;
      _ = x;
      x = y;
      y = _;
    }
    t = (x - x1) / (x2 - x1);
    if (t < 0 || t > 1) {
      return false;
    }
    return abs(y1 + t * (y2 - y1) - y) < 4;
  }, pointOnCubic:function(px1, px2, px3, px4, py1, py2, py3, py4, x, y) {
    var me = this, bx = me.bezierCoeffs(px1, px2, px3, px4), by = me.bezierCoeffs(py1, py2, py3, py4), i, j, rx, ry, t;
    bx[3] -= x;
    by[3] -= y;
    rx = me.cubicRoots(bx);
    ry = me.cubicRoots(by);
    for (i = 0; i < rx.length; i++) {
      t = rx[i];
      for (j = 0; j < ry.length; j++) {
        if (t >= 0 && t <= 1 && abs(t - ry[j]) < 0.05) {
          return true;
        }
      }
    }
    return false;
  }};
});
Ext.define('Ext.chart.series.Pie3D', {extend:Ext.chart.series.Polar, type:'pie3d', seriesType:'pie3d', alias:'series.pie3d', isPie3D:true, config:{rect:[0, 0, 0, 0], thickness:35, distortion:0.5, donut:false, hidden:[], highlightCfg:{margin:20}, shadow:false}, rotationOffset:-Math.PI / 2, setField:function(value) {
  return this.setXField(value);
}, getField:function() {
  return this.getXField();
}, updateRotation:function(rotation) {
  this.setStyle({baseRotation:rotation + this.rotationOffset});
  this.doUpdateStyles();
}, updateDistortion:function() {
  this.setRadius();
}, updateThickness:function() {
  this.setRadius();
}, updateColors:function(colors) {
  this.setSubStyle({baseColor:colors});
}, applyShadow:function(shadow) {
  if (shadow === true) {
    shadow = {shadowColor:'rgba(0,0,0,0.8)', shadowBlur:30};
  } else {
    if (!Ext.isObject(shadow)) {
      shadow = {shadowColor:Ext.draw.Color.RGBA_NONE};
    }
  }
  return shadow;
}, updateShadow:function(shadow) {
  var me = this, sprites = me.getSprites(), spritesPerSlice = me.spritesPerSlice, ln = sprites && sprites.length, i, sprite;
  for (i = 1; i < ln; i += spritesPerSlice) {
    sprite = sprites[i];
    if (sprite.attr.part = 'bottom') {
      sprite.setAttributes(shadow);
    }
  }
}, getStyleByIndex:function(i) {
  var indexStyle = this.callParent([i]), style = this.getStyle(), fillStyle = indexStyle.fillStyle || indexStyle.fill || indexStyle.color, strokeStyle = style.strokeStyle || style.stroke;
  if (fillStyle) {
    indexStyle.baseColor = fillStyle;
    delete indexStyle.fillStyle;
    delete indexStyle.fill;
    delete indexStyle.color;
  }
  if (strokeStyle) {
    indexStyle.strokeStyle = strokeStyle;
  }
  return indexStyle;
}, doUpdateStyles:function() {
  var me = this, sprites = me.getSprites(), spritesPerSlice = me.spritesPerSlice, ln = sprites && sprites.length, i = 0, j = 0, k, style;
  for (; i < ln; i += spritesPerSlice, j++) {
    style = me.getStyleByIndex(j);
    for (k = 0; k < spritesPerSlice; k++) {
      sprites[i + k].setAttributes(style);
    }
  }
}, coordinateX:function() {
  var me = this, chart = me.getChart(), animation = chart && chart.getAnimation(), store = me.getStore(), records = store.getData().items, recordCount = records.length, xField = me.getXField(), rotation = me.getRotation(), hidden = me.getHidden(), value, sum = 0, ratio, summation = [], sprites = me.getSprites(), spriteCount = sprites.length, spritesPerSlice = me.spritesPerSlice, lastAngle = 0, twoPi = Math.PI * 2, delta = 1.0E-10, i, j;
  for (i = 0; i < recordCount; i++) {
    value = Math.abs(Number(records[i].get(xField))) || 0;
    if (!hidden[i]) {
      sum += value;
    }
    summation[i] = sum;
    if (i >= hidden.length) {
      hidden[i] = false;
    }
  }
  hidden.length = recordCount;
  if (sum === 0) {
    return;
  }
  ratio = 2 * Math.PI / sum;
  for (i = 0; i < recordCount; i++) {
    summation[i] *= ratio;
  }
  for (i = 0; i < spriteCount; i++) {
    sprites[i].setAnimation(animation);
  }
  for (i = 0; i < recordCount; i++) {
    for (j = 0; j < spritesPerSlice; j++) {
      sprites[i * spritesPerSlice + j].setAttributes({startAngle:lastAngle, endAngle:summation[i] - delta, globalAlpha:1, baseRotation:rotation});
    }
    lastAngle = summation[i];
  }
  for (i *= spritesPerSlice; i < spriteCount; i++) {
    sprites[i].setAnimation(animation);
    sprites[i].setAttributes({startAngle:twoPi, endAngle:twoPi, globalAlpha:0, baseRotation:rotation});
  }
}, updateLabelData:function() {
  var me = this, store = me.getStore(), items = store.getData().items, sprites = me.getSprites(), labelField = me.getLabel().getTemplate().getField(), hidden = me.getHidden(), spritesPerSlice = me.spritesPerSlice, i, j, ln, labels, sprite;
  if (sprites.length && labelField) {
    labels = [];
    for (i = 0, ln = items.length; i < ln; i++) {
      labels.push(items[i].get(labelField));
    }
    for (i = 0, j = 0, ln = sprites.length; i < ln; i += spritesPerSlice, j++) {
      sprite = sprites[i];
      sprite.setAttributes({label:labels[j]});
      sprite.putMarker('labels', {hidden:hidden[j]}, sprite.attr.attributeId);
    }
  }
}, applyRadius:function() {
  var me = this, chart = me.getChart(), padding = chart.getInnerPadding(), rect = chart.getMainRect() || [0, 0, 1, 1], width = rect[2] - padding * 2, height = rect[3] - padding * 2 - me.getThickness(), horizontalRadius = width / 2, verticalRadius = horizontalRadius * me.getDistortion();
  if (verticalRadius > height / 2) {
    return height / (me.getDistortion() * 2);
  } else {
    return horizontalRadius;
  }
}, getSprites:function() {
  var me = this, store = me.getStore();
  if (!store) {
    return [];
  }
  var chart = me.getChart(), surface = me.getSurface(), records = store.getData().items, spritesPerSlice = me.spritesPerSlice, recordCount = records.length, animation = me.getAnimation() || chart && chart.getAnimation(), center = me.getCenter(), offsetX = me.getOffsetX(), offsetY = me.getOffsetY(), radius = me.getRadius(), rotation = me.getRotation(), highlight = me.getHighlight(), commonAttributes = {centerX:center[0] + offsetX, centerY:center[1] + offsetY - me.getThickness() / 2, endRho:radius, 
  startRho:radius * me.getDonut() / 100, thickness:me.getThickness(), distortion:me.getDistortion()}, sprites = me.sprites, label = me.getLabel(), labelTpl = label.getTemplate(), sliceSprites, sliceAttributes, sprite, i, j;
  for (i = 0; i < recordCount; i++) {
    sliceAttributes = Ext.apply({}, this.getStyleByIndex(i), commonAttributes);
    if (!sprites[i * spritesPerSlice]) {
      for (j = 0; j < me.partNames.length; j++) {
        sprite = surface.add({type:'pie3dPart', part:me.partNames[j]});
        if (j === 0 && labelTpl.getField()) {
          sprite.bindMarker('labels', label);
        }
        sprite.fx.setDurationOn('baseRotation', rotation);
        if (highlight) {
          sprite.config.highlight = highlight;
          sprite.addModifier('highlight', true);
        }
        sprite.setAttributes(sliceAttributes);
        sprites.push(sprite);
      }
    } else {
      sliceSprites = sprites.slice(i * spritesPerSlice, (i + 1) * spritesPerSlice);
      for (j = 0; j < sliceSprites.length; j++) {
        sprite = sliceSprites[j];
        if (animation) {
          sprite.setAnimation(animation);
        }
        sprite.setAttributes(sliceAttributes);
      }
    }
  }
  return sprites;
}, betweenAngle:function(x, a, b) {
  var pp = Math.PI * 2, offset = this.rotationOffset;
  a += offset;
  b += offset;
  x -= a;
  b -= a;
  x %= pp;
  b %= pp;
  x += pp;
  b += pp;
  x %= pp;
  b %= pp;
  return x < b || b === 0;
}, getItemForPoint:function(x, y) {
  var me = this, sprites = me.getSprites();
  if (sprites) {
    var store = me.getStore(), records = store.getData().items, spritesPerSlice = me.spritesPerSlice, hidden = me.getHidden(), i, ln, sprite, topPartIndex;
    for (i = 0, ln = records.length; i < ln; i++) {
      if (!hidden[i]) {
        topPartIndex = i * spritesPerSlice;
        sprite = sprites[topPartIndex];
        if (sprite.hitTest([x, y])) {
          return {series:me, sprite:sprites.slice(topPartIndex, topPartIndex + spritesPerSlice), index:i, record:records[i], category:'sprites', field:me.getXField()};
        }
      }
    }
    return null;
  }
}, provideLegendInfo:function(target) {
  var me = this, store = me.getStore();
  if (store) {
    var items = store.getData().items, labelField = me.getLabel().getTemplate().getField(), field = me.getField(), hidden = me.getHidden(), i, style, color;
    for (i = 0; i < items.length; i++) {
      style = me.getStyleByIndex(i);
      color = style.baseColor;
      target.push({name:labelField ? String(items[i].get(labelField)) : field + ' ' + i, mark:color || 'black', disabled:hidden[i], series:me.getId(), index:i});
    }
  }
}}, function() {
  var proto = this.prototype, definition = Ext.chart.series.sprite.Pie3DPart.def.getInitialConfig().processors.part;
  proto.partNames = definition.replace(/^enums\(|\)/g, '').split(',');
  proto.spritesPerSlice = proto.partNames.length;
});
Ext.define('MobileJudge.model.Code', {extend:Ext.data.Model, fields:[{name:'id', type:'int', convert:null}, {name:'name', type:'string'}, {name:'abbr', type:'string'}]});
Ext.define('MobileJudge.model.email.Contact', {extend:Ext.data.Model, fields:[{name:'id', type:'int', convert:null}, {name:'fullName', type:'string'}, {name:'email', type:'string'}, {name:'termId', type:'int', convert:null}, {name:'role', type:'int', convert:null}, {name:'state', type:'int', convert:null}]});
Ext.define('MobileJudge.model.email.Placeholder', {extend:Ext.data.Model, fields:[{name:'id', type:'int', persist:false, useNull:true, convert:null}, {name:'code', type:'string'}, {name:'text', type:'string'}, {name:'value', type:'string'}], validators:{code:{type:'length', min:1}, text:{type:'length', min:1}, value:{type:'length', min:1}}});
Ext.define('MobileJudge.model.email.Sent', {extend:Ext.data.Model, fields:[{name:'id', type:'int', convert:null}, {name:'address', type:'string'}, {name:'subject', type:'string'}, {name:'fullName', type:'string'}, {name:'profileImgUrl', type:'string'}, {name:'state', type:'string'}, {name:'sent', type:'date'}, {name:'replied', type:'date'}]});
Ext.define('MobileJudge.model.email.Template', {extend:Ext.data.Model, fields:[{name:'id', type:'int', persist:false, useNull:true, convert:null}, {name:'name', type:'string'}, {name:'subject', type:'string'}, {name:'body', type:'string'}], validators:{name:{type:'length', min:1}, subject:{type:'length', min:1}, body:{type:'length', min:1}}});
Ext.define('MobileJudge.model.grade.Judge', {extend:Ext.data.Model, fields:[{name:'id', type:'int', convert:null}, {name:'state', type:'string'}, {name:'abbr', type:'string'}, {name:'fullName', type:'string', persist:false}, {name:'email', type:'string'}, {name:'profileImgUrl', type:'string'}, {name:'title', type:'string'}, {name:'affiliation', type:'string'}]});
Ext.define('MobileJudge.model.grade.Student', {extend:Ext.data.Model, fields:[{name:'id', type:'int', convert:null}, {name:'state', type:'string'}, {name:'abbr', type:'string'}, {name:'fullName', type:'string', persist:false}, {name:'email', type:'string'}, {name:'profileImgUrl', type:'string'}, {name:'project', type:'string'}, {name:'location', type:'string'}, {name:'grade', type:'float', convert:null}, {name:'rawGrade', type:'float', convert:null}, {name:'max', type:'int', convert:null}, {name:'filterStatus', 
type:'string', convert:null}]});
Ext.define('MobileJudge.model.grades.Student', {extend:Ext.data.Model, fields:[{name:'id', type:'int', convert:null}, {name:'state', type:'string'}, {name:'abbr', type:'string'}, {name:'fullName', type:'string', persist:false}, {name:'email', type:'string'}, {name:'profileImgUrl', type:'string'}, {name:'project', type:'string'}, {name:'location', type:'string'}, {name:'grade', type:'float', convert:null}, {name:'max', type:'int', convert:null}, {name:'grade_display', type:'string'}]});
Ext.define('MobileJudge.model.people.Judge', {extend:Ext.data.Model, fields:[{name:'id', type:'int', convert:null}, {name:'state', type:'string'}, {name:'abbr', type:'string'}, {name:'fullName', type:'string', persist:false}, {name:'email', type:'string'}, {name:'profileImgUrl', type:'string'}, {name:'title', type:'string'}, {name:'affiliation', type:'string'}]});
Ext.define('MobileJudge.model.grade.JudgeGradesView', {extend:Ext.data.Model, fields:[{name:'judgeId', type:'int', convert:null}, {name:'state', type:'string', convert:null}, {name:'email', type:'string', convert:null}, {name:'fullName', type:'string'}]});
Ext.define('MobileJudge.model.people.Student', {extend:Ext.data.Model, fields:[{name:'id', type:'int', convert:null}, {name:'state', type:'string'}, {name:'abbr', type:'string'}, {name:'fullName', type:'string', persist:false}, {name:'email', type:'string'}, {name:'profileImgUrl', type:'string'}, {name:'project', type:'string'}, {name:'location', type:'string'}, {name:'grade', type:'float', convert:null}, {name:'max', type:'int', convert:null}, {name:'grade_display', type:'string'}]});
Ext.define('MobileJudge.model.people.StudentGradesView', {extend:Ext.data.Model, fields:[{name:'id', type:'int', convert:null}, {name:'state', type:'string', convert:null}, {name:'abbr', type:'string', convert:null}, {name:'studentId', type:'int'}, {name:'termId', type:'int', convert:null}, {name:'fullName', type:'string'}, {name:'grade_display', type:'string'}, {name:'project', type:'string'}, {name:'accepted', type:'boolean'}, {name:'pending', type:'boolean'}, {name:'rejected', type:'boolean'}, 
{name:'grade', type:'float', convert:null}, {name:'max', type:'float', persist:false}]});
Ext.define('MobileJudge.model.people.User', {extend:Ext.data.Model, proxy:{type:'api', url:'/api/users'}, fields:[{name:'id', type:'int', convert:null}, {name:'role', type:'int', convert:null}, {name:'state', type:'int', convert:null}, {name:'fullName', type:'string', persist:false}, {name:'firstName', type:'string'}, {name:'lastName', type:'string'}, {name:'email', type:'string'}, {name:'salutation', type:'string'}, {name:'title', type:'string'}, {name:'affiliation', type:'string'}, {name:'location', 
type:'int', convert:null}, {name:'profileImgUrl', type:'string'}, {name:'projectId', type:'int', convert:null}, {name:'termId', type:'int', convert:null}]});
Ext.define('MobileJudge.model.settings.Question', {extend:Ext.data.Model, fields:[{name:'id', type:'int', convert:null, persist:false, useNull:true}, {name:'text', type:'string', convert:null}, {name:'value', type:'int', convert:null}, {name:'display', type:'int', convert:null}, {name:'enabled', type:'boolean', convert:null, defaultValue:true}], validators:{text:{type:'length', min:1}, value:{type:'range', min:1, max:10}, display:{type:'range', min:1}}});
Ext.define('MobileJudge.model.settings.Term', {extend:Ext.data.Model, fields:[{name:'id', type:'int', convert:null}, {name:'name', type:'string'}, {name:'start', type:'date', dateWriteFormat:'C'}, {name:'end', type:'date', dateWriteFormat:'C'}, {name:'deadline', type:'date', dateWriteFormat:'C'}, {name:'active', type:'boolean', defaultValue:false, convert:null}, {name:'allowJudgeLogin', type:'boolean', defaultValue:false, convert:null}, {name:'showGrades', type:'boolean', defaultValue:false, convert:null}, 
{name:'studentsPerJudge', type:'int', defaultValue:5, convert:null}, {name:'location', type:'string', defaultValue:'SCIS JCCL Lab (ECS 241), which is located on the second floor of the ECS building on the Main Campus (also known as Modesto A. Maidique Campus)'}, {name:'mapImageUrl', type:'string'}, {name:'srProjectUrl', type:'string', defaultValue:'http://spws.cis.fiu.edu:8080/SPW2-RegisterAPI/rest/SPWRegister'}, {name:'srProjectToken', type:'string', defaultValue:'123FIUspw'}, {name:'liveUrl', type:'string', 
defaultValue:'http://mj.cis.fiu.edu/'}, {name:'developmentUrl', type:'string', defaultValue:'http://mj-dev.cis.fiu.edu/'}, {name:'noProfileImageUrl', type:'string', defaultValue:'http://spws.cis.fiu.edu/Senior-Project-Web-Site-Ver-5/img/no-photo.jpeg'}, {name:'display', type:'int', defaultValue:0, convert:null}, {name:'mailFrom', type:'string', defaultValue:'Masoud Sadjadi \x3csadjadi@cs.fiu.edu\x3e'}, {name:'resetPasswordTemplate', type:'int', defaultValue:3, convert:null}, {name:'confirmTemplate', 
type:'int', defaultValue:38, convert:null}, {name:'rejectInviteTemplate', type:'int', defaultValue:36, convert:null}, {name:'removeInviteTemplate', type:'int', defaultValue:37, convert:null}, {name:'startDate', type:'date', depends:'start', persist:false, convert:function(v, r) {
  return r.setDate('start', v);
}}, {name:'startTime', type:'date', depends:'start', persist:false, convert:function(v, r) {
  return r.setTime('start', v);
}}, {name:'endDate', type:'date', depends:'end', persist:false, convert:function(v, r) {
  return r.setDate('end', v);
}}, {name:'endTime', type:'date', depends:'end', persist:false, convert:function(v, r) {
  return r.setTime('end', v);
}}, {name:'deadlineDate', type:'date', depends:'deadline', persist:false, convert:function(v, r) {
  return r.setDate('deadline', v);
}}, {name:'deadlineTime', type:'date', depends:'deadline', persist:false, convert:function(v, r) {
  return r.setTime('deadline', v);
}}], validators:{name:[{type:'presence'}, {type:'length', min:1}], studentsPerJudge:[{type:'presence'}, {type:'range', min:1, max:10}], startDate:'presence', startTime:'presence', endDate:'presence', endTime:'presence', deadlineDate:'presence', deadlineTime:'presence', mailFrom:[{type:'presence'}, {type:'format', matcher:/^([\w\s]+)?(\<([\w\.\-_]+)?\w+@\w+(\.\w+){1,}\>)$|^(([\w\.\-_]+)?\w+@\w+(\.\w+){1,})$/}], resetPasswordTemplate:'presence', confirmTemplate:'presence', rejectInviteTemplate:'presence', 
removeInviteTemplate:'presence'}, setDateTime:function(field, v) {
  var me = this, modified = me.modified || (me.modified = {}), previousValues = me.previousValues || (me.previousValues = {}), comparator = me.fieldsMap[field];
  if (comparator.isEqual(me.data[field], v)) {
    return;
  }
  previousValues[field] = v;
  if (comparator.isEqual(modified[field], v)) {
    delete modified[field];
    me.dirty = Object.keys(modified).length > 0;
  } else {
    modified[field] = me.data[field];
    me.dirty = true;
  }
  me.data[field] = v;
}, setDate:function(field, v) {
  var me = this, nv = new Date(me.data[field]);
  if (v) {
    nv.setFullYear(v.getFullYear());
    nv.setMonth(v.getMonth());
    nv.setDate(v.getDate());
    me.setDateTime(field, nv);
  }
  return nv;
}, setTime:function(field, v) {
  var me = this, nv = new Date(me.data[field]);
  if (v) {
    nv.setHours(v.getHours());
    nv.setMinutes(v.getMinutes());
    me.setDateTime(field, nv);
  }
  return nv;
}});
Ext.define('MobileJudge.proxy.API', {extend:Ext.data.proxy.Rest, alias:'proxy.api', noCache:false, startParam:'offset', limitParam:'count', pageParam:'', remoteSort:true, simpleSortMode:true, reader:{type:'api'}, writer:{type:'json'}, encodeFilters:function(filters) {
  return filters.map(function(f) {
    return f.serialize();
  });
}, getParams:function(operation) {
  var me = this, params = me.callParent([operation]), filterParam = me.getFilterParam(), filters = params[filterParam], sortParam = me.getSortParam(), directionParam = me.getDirectionParam();
  if (params[directionParam] == 'DESC') {
    params[sortParam] = '-' + params[sortParam];
  }
  delete params[directionParam];
  if (filters) {
    filters.forEach(function(f) {
      params[f.property] = f.value;
    });
    delete params[filterParam];
  }
  return params;
}});
Ext.define('MobileJudge.reader.Api', {extend:Ext.data.reader.Json, alias:'reader.api', read:function(response, readOptions) {
  var me = this, result = me.callParent([response, readOptions]), range = parseInt((response.getResponseHeader('Content-Range') || '/0').split('/')[1]);
  if (range > 0 && range != result.total) {
    result.total = range;
  }
  return result;
}});
Ext.define('MobileJudge.store.NavigationTree', {extend:Ext.data.TreeStore, storeId:'NavigationTree', proxy:{type:'ajax', noCache:false, url:'/api/navtree'}, fields:[{name:'text'}], listeners:{load:function() {
  Ext.GlobalEvents.fireEvent('navTreeReady');
}}});
Ext.define('MobileJudge.store.charts.States', {extend:Ext.data.Store, alias:'store.chartStates', fields:['state', 'total'], autoLoad:true, pageSize:0});
Ext.define('MobileJudge.store.codes.AdminStates', {extend:Ext.data.Store, alias:'store.adminstates', model:'MobileJudge.model.Code', autoLoad:true, pageSize:0, proxy:{type:'api', url:'/api/codes/admins'}});
Ext.define('MobileJudge.store.codes.Grades', {extend:Ext.data.Store, alias:'store.grades', model:'MobileJudge.model.Code', autoLoad:true, pageSize:0, proxy:{type:'api', url:'/api/codes/grades'}});
Ext.define('MobileJudge.store.codes.JudgeStates', {extend:Ext.data.Store, alias:'store.judgeStates', model:'MobileJudge.model.Code', autoLoad:true, pageSize:0, proxy:{type:'api', url:'/api/codes/judges'}});
Ext.define('MobileJudge.store.codes.Locations', {extend:Ext.data.Store, alias:'store.locations', model:'MobileJudge.model.Code', autoLoad:true, pageSize:0, proxy:{type:'api', url:'/api/codes/locations'}});
Ext.define('MobileJudge.store.codes.Projects', {extend:Ext.data.Store, alias:'store.projects', model:'MobileJudge.model.Code', autoLoad:true, pageSize:0, proxy:{type:'api', url:'/api/projects'}});
Ext.define('MobileJudge.store.codes.Roles', {extend:Ext.data.Store, alias:'store.roles', model:'MobileJudge.model.Code', autoLoad:true, pageSize:0, proxy:{type:'api', url:'/api/codes/roles'}});
Ext.define('MobileJudge.store.codes.StudentStates', {extend:Ext.data.Store, alias:'store.studentStates', model:'MobileJudge.model.Code', autoLoad:true, pageSize:0, proxy:{type:'api', url:'/api/codes/students'}});
Ext.define('MobileJudge.store.email.Contacts', {extend:Ext.data.Store, alias:'store.contacts', model:'MobileJudge.model.email.Contact', proxy:{type:'api', url:'/api/emails/contacts'}, pageSize:0});
Ext.define('MobileJudge.store.email.Lists', {extend:Ext.data.Store, alias:'store.emaillists', proxy:{type:'api', url:'/api/emails/lists'}, fields:[{name:'id', type:'int', convert:null}, {name:'name', type:'string'}, {name:'students', convert:eval}, {name:'judges', convert:eval}], autoLoad:true, pageSize:0});
Ext.define('MobileJudge.store.email.Outbox', {extend:Ext.data.Store, alias:'store.outbox', model:'MobileJudge.model.email.Sent', proxy:{type:'api', url:'/api/emails'}, autoLoad:true, remoteSort:true, remoteFilter:true, pageSize:25, sorters:[{property:'sent', direction:'DESC'}]});
Ext.define('MobileJudge.store.email.Placeholders', {extend:Ext.data.Store, alias:'store.placeholders', model:'MobileJudge.model.email.Placeholder', proxy:{type:'api', url:'/api/placeholders'}, autoLoad:true, autoSync:true, pageSize:0});
Ext.define('MobileJudge.store.email.Templates', {extend:Ext.data.Store, alias:'store.templates', model:'MobileJudge.model.email.Template', proxy:{type:'api', url:'/api/templates'}, autoLoad:true, autoSync:true, pageSize:0});
Ext.define('MobileJudge.store.grade.Grades', {extend:Ext.data.Store, alias:'store.gradeGrades', proxy:{type:'api', url:'/api/grades'}, autoLoad:true, pageSize:0, fields:[{name:'id', type:'string', convert:null}, {name:'state', type:'int', convert:null}, {name:'comment', type:'string', convert:null}, {name:'value', type:'int', convert:function(v) {
  return v && Ext.isArray(v) ? v[0] : v;
}}]});
Ext.define('MobileJudge.store.grade.Judges', {extend:Ext.data.Store, alias:'store.judges', model:'MobileJudge.model.grade.Judge', proxy:{type:'api', url:'/api/judges'}, remoteSort:true, remoteFilter:true, autoLoad:true, pageSize:25});
Ext.define('MobileJudge.store.grade.Students', {extend:Ext.data.Store, alias:'store.students', model:'MobileJudge.model.grade.Student', proxy:{type:'api', url:'/api/students'}, remoteSort:true, remoteFilter:true, pageSize:999});
Ext.define('MobileJudge.store.judges.Grades', {extend:Ext.data.Store, alias:'store.judgeGrades', proxy:{type:'api', url:'/api/grades'}, autoLoad:true, pageSize:0, fields:[{name:'id', type:'string', convert:null}, {name:'state', type:'int', convert:null}, {name:'comment', type:'string', convert:null}, {name:'value', type:'int', convert:function(v) {
  return v && Ext.isArray(v) ? v[0] : v;
}}]});
Ext.define('MobileJudge.store.judges.Students', {extend:Ext.data.Store, alias:'store.judgeStudents', autoLoad:true, pageSize:0, fields:[{name:'id', type:'int', convert:null}, {name:'fullName', type:'string', convert:null}, {name:'profileImgUrl', type:'string', convert:null}, {name:'project', type:'string', convert:null}, {name:'location', type:'string', convert:null}, {name:'total', type:'int', convert:null}, {name:'graded', type:'int', convert:null}, {name:'accepted', type:'int', convert:null}, 
{name:'progress', type:'float', depends:'graded', persist:false, convert:function(v, r) {
  return r.data.graded / r.data.total;
}}, {name:'iconCls', type:'string', depends:'graded', convert:function(v, r) {
  var done = r.data.graded == r.data.total, accepted = r.data.accepted == r.data.total;
  return 'x-fa fa-' + (done ? 'check' : 'edit') + (accepted ? ' disabled' : '');
}}], proxy:{type:'api', url:'/api/grades/students'}});
Ext.define('MobileJudge.store.grade.Grades', {extend:Ext.data.Store, alias:'store.studentGrades', proxy:{type:'api', url:'/api/grades'}, autoLoad:true, pageSize:0, fields:[{name:'id', type:'string', convert:null}, {name:'state', type:'int', convert:null}, {name:'comment', type:'string', convert:null}, {name:'value', type:'int', convert:function(v) {
  return v && Ext.isArray(v) ? v[0] : v;
}}]});
Ext.define('MobileJudge.store.grade.JudgeGradesView', {extend:Ext.data.Store, alias:'store.judgegradesview', model:'MobileJudge.model.grade.JudgeGradesView', proxy:{type:'api', url:'/api/judges_grade_view', noCache:false}, autoSync:true, autoLoad:true, remoteSort:true, remoteFilter:true, pageSize:999});
Ext.define('MobileJudge.store.people.Judges', {extend:Ext.data.Store, alias:'store.judges', model:'MobileJudge.model.people.Judge', proxy:{type:'api', url:'/api/judges'}, remoteSort:true, remoteFilter:true, autoLoad:true, pageSize:25});
Ext.define('MobileJudge.store.people.StudentGradesView', {extend:Ext.data.Store, alias:'store.studentgradesview', model:'MobileJudge.model.people.StudentGradesView', proxy:{type:'api', url:'/api/views_table', noCache:false}, autoSync:true, autoLoad:true, remoteSort:true, remoteFilter:true, pageSize:999});
Ext.define('MobileJudge.store.people.Students', {extend:Ext.data.Store, alias:'store.students', model:'MobileJudge.model.people.Student', proxy:{type:'api', url:'/api/students'}, remoteSort:true, remoteFilter:true, autoLoad:true, pageSize:25});
Ext.define('MobileJudge.store.settings.Questions', {extend:Ext.data.Store, alias:'store.questions', model:'MobileJudge.model.settings.Question', proxy:{type:'api', url:'/api/questions'}, autoLoad:true, autoSync:true, pageSize:0});
Ext.define('MobileJudge.store.settings.Terms', {extend:Ext.data.Store, alias:'store.terms', model:'MobileJudge.model.settings.Term', proxy:{type:'api', url:'/api/terms'}, autoLoad:true, pageSize:0, sorters:{direction:'ASC', property:'display'}});
Ext.define('MobileJudge.view.authentication.Controller', {extend:Ext.app.ViewController, alias:'controller.authentication', loginInProcess:false, init:function(view) {
  OAuth.setOAuthdURL('http://mj.cis.fiu.edu/oauthd');
  OAuth.initialize('uSO6GBdeGO_y9Bdas5jNHTLxBd8');
  var model = view.getViewModel();
  if (model) {
    Ext.each(['activeTerm', 'userName', 'profilePic', 'title', 'affiliation', 'email'], function(key) {
      model.set(key, localStorage.getItem(key));
    });
  }
}, onLoginRender:function(view) {
  var me = this, win = view.mask ? view : Ext.Viewport;
  $('.btn-oauth').click(function(e) {
    e.preventDefault();
    var cls = e.currentTarget.className.split(' '), provider = cls.pop();
    provider = (provider == 'x-btn-over' ? cls.pop() : provider).split('-')[2];
    if (me.loginInProcess) {
      return;
    }
    me.loginInProcess = true;
    OAuth.popup(provider, function(err, res) {
      if (err) {
        me.loginInProcess = false;
        Ext.Msg.alert('Error', Ext.isString(err) ? err : err.message);
      } else {
        res.me().done(function(data) {
          console.log(data);
          me.requestToken(win, {provider:provider, id:data.id, email:data.email});
        });
      }
    });
  });
}, onLoginButton:function(button) {
  var me = this, model = this.getViewModel();
  if (me.loginInProcess) {
    return;
  }
  me.loginInProcess = true;
  me.requestToken(button.up('lockingwindow') || Ext.Viewport, {email:model.data.email, password:model.data.password});
}, requestToken:function(win, data) {
  var me = this;
  win.mask();
  Ext.Ajax.request({url:'/api/login', method:'POST', jsonData:data, callback:function() {
    me.loginInProcess = false;
  }, success:function(resp) {
    var obj = Ext.decode(resp.responseText);
    win.unmask();
    if (!obj.result) {
      Ext.Msg.alert('Error', obj.error);
    } else {
      Ext.Object.each(obj.profile, localStorage.setItem, localStorage);
      localStorage.setItem('token', obj.token);
      Ext.GlobalEvents.fireEvent('login');
    }
  }});
}, onRegisterRender:function() {
  var me = this, model = me.getViewModel();
  model.set('profilePic', null);
  localStorage.removeItem('profilePic');
  $('.btn-oauth').click(function(e) {
    e.preventDefault();
    var cls = e.currentTarget.className.split(' '), provider = cls.pop();
    provider = (provider == 'x-btn-over' ? cls.pop() : provider).split('-')[2];
    OAuth.popup(provider, function(err, res) {
      if (err) {
      } else {
        res.me().done(function(data) {
          var oauth = model.get('oauth') || {};
          if (data.name) {
            model.set('userName', data.name);
            var s = data.name.split(' ');
            if (s.length > 1) {
              model.set('firstName', s[0] || model.get('firstName'));
              model.set('lastName', s.pop() || model.get('lastName'));
            }
          }
          model.set('firstName', data.firstname || model.get('firstName'));
          model.set('lastName', data.lastname || model.get('lastName'));
          model.set('profilePic', data.avatar || model.get('profilePic'));
          oauth[provider] = data.id;
          model.set('oauth', oauth);
          me.getReferences()['link' + provider].setDisabled(true);
        });
      }
    });
  });
}, onSetPageOne:function(btn) {
  var refs = this.getReferences(), wzd = refs && refs.regWizard || btn.up('register');
  wzd.setActiveItem(0);
}, onSetPageTwo:function(btn) {
  var refs = this.getReferences(), wzd = refs && refs.regWizard || btn.up('register');
  wzd.setActiveItem(1);
}, onSetPageThree:function(btn) {
  var refs = this.getReferences(), wzd = refs && refs.regWizard || btn.up('register');
  wzd.setActiveItem(2);
}, onDoneRegister:function(btn) {
  var me = this, model = me.getViewModel(), grid = me.getReferences().gridConflicts, isPhone = Ext.manifest.toolkit === 'modern', win = isPhone ? btn.up('register') : Ext.getBody(), conflicts = isPhone ? grid.getSelections() : grid.getSelection(), userInfo = {id:localStorage.getItem('userId'), email:model.get('email'), firstName:model.get('firstName'), lastName:model.get('lastName'), fullName:model.get('userName'), salutation:model.get('salutation'), affiliation:model.get('affiliation'), title:model.get('title'), 
  password:model.get('password'), profilePic:model.get('profilePic'), oauth:model.get('oauth'), conflicts:conflicts.map(function(r) {
    return r.get('id');
  })};
  win.mask();
  Ext.Ajax.request({url:'/api/register', method:'POST', jsonData:userInfo, callback:function() {
    win.unmask();
  }, failure:function(resp) {
    Ext.Msg.alert('Error', resp.responseText);
  }, success:function(resp) {
    var obj = Ext.decode(resp.responseText);
    localStorage.removeItem('userId');
    if (!obj.result) {
      Ext.Msg.alert('Success', obj.error, function() {
        me.redirectTo('login');
      });
    } else {
      Ext.Object.each(obj.profile, localStorage.setItem, localStorage);
      localStorage.setItem('token', obj.token);
      Ext.GlobalEvents.fireEvent('login');
    }
    window.location.reload();
  }});
}, onReset:function(btn) {
  var me = this, model = me.getViewModel(), isPhone = Ext.manifest.toolkit === 'modern', win = isPhone ? btn.up('passwordreset') : Ext.getBody(), userInfo = {email:model.get('email')};
  win.mask();
  Ext.Ajax.request({url:'/api/reset', method:'POST', jsonData:userInfo, callback:function() {
    win.unmask();
  }, failure:function(resp) {
    Ext.Msg.alert('Error', resp.responseText);
  }, success:function(resp) {
    var obj = Ext.decode(resp.responseText);
    Ext.Msg.alert(!obj.result ? 'Error' : 'Success', obj.error, function() {
      me.redirectTo('login');
    });
  }});
}, onChangePassword:function(btn) {
  var me = this, model = me.getViewModel(), isPhone = Ext.manifest.toolkit === 'modern', win = isPhone ? btn.up('passwordchange') : Ext.getBody(), userInfo = {id:localStorage.getItem('userId'), newPassword:model.get('newPassword'), confirmPassword:model.get('confirmPassword')};
  win.mask();
  Ext.Ajax.request({url:'/api/reset', method:'PUT', jsonData:userInfo, callback:function() {
    win.unmask();
  }, failure:function(resp) {
    Ext.Msg.alert('Error', resp.responseText);
  }, success:function(resp) {
    var obj = Ext.decode(resp.responseText);
    localStorage.removeItem('userId');
    if (!obj.result) {
      Ext.Msg.alert('Success', obj.error, function() {
        me.redirectTo('login');
      });
    } else {
      Ext.Object.each(obj.profile, localStorage.setItem, localStorage);
      localStorage.setItem('token', obj.token);
      Ext.GlobalEvents.fireEvent('login');
    }
    window.location.reload();
  }});
  window.location.reload();
}});
Ext.define('MobileJudge.view.authentication.Model', {extend:Ext.app.ViewModel, alias:'viewmodel.authentication', data:{userid:'', salutation:'', firstName:'', lastName:'', affiliation:'', title:'', password:'', email:'', oauth:null, persist:false}});
Ext.define('MobileJudge.view.authentication.Registration', {extend:Ext.app.ViewModel, alias:'viewmodel.registration', data:{userid:'', salutation:'', firstName:'', lastName:'', affiliation:'', title:'', password:'', email:'', oauth:null, persist:false}, stores:{conflicts:{type:'students', storeId:'conflicts', autoLoad:true, remoteSort:false, remoteFilter:false, pageSize:0, sorters:[{property:'fullName', direction:'ASC'}], grouper:{groupFn:function(record) {
  return record.get('fullName')[0];
}}, filters:[{filterFn:function(item) {
  return item.get('abbr') == 'AC';
}}]}}, formulas:{isValid:{bind:{deep:true, title:'{title}', fullName:'{userName}', salutation:'{salutation}', affiliation:'{affiliation}', email:'{email}', password:'{password}'}, get:function(data) {
  return !Ext.isEmpty(data.fullName) && !Ext.isEmpty(data.password) && !Ext.isEmpty(data.email) && /^([\w-]+(?:\.[\w-]+)*)@((?:[\w-]+\.)*\w[\w-]{0,66})\.([a-z]{2,6}(?:\.[a-z]{2})?)$/i.test(data.email);
}}}});
Ext.define('MobileJudge.view.charts.Base', {extend:Ext.Panel, xtype:'basepie', cls:'quick-graph-panel shadow', ui:'light', layout:'fit', platformConfig:{classic:{headerPosition:'top'}, modern:{header:{docked:'top'}}}, tools:[{type:'refresh', tooltip:'Refresh', callback:'onRefreshChart'}], defaults:{width:'100%'}});
Ext.define('MobileJudge.view.charts.Controller', {extend:Ext.app.ViewController, alias:'controller.charts', model:null, init:function(view) {
  this.model = view.getViewModel();
  if (view.xtype == 'studenthome') {
    this.loadProfile();
  }
}, loadProfile:function(btn) {
  var me = this;
  if (btn) {
    btn.setDisabled(true);
  }
  Ext.Ajax.request({url:'/api/profile', method:'GET', callback:function() {
    if (btn) {
      btn.setDisabled(false);
    }
  }, success:function(resp) {
    var profile = Ext.decode(resp.responseText);
    Ext.each(profile, function(key) {
      me.model.set(key, profile[key]);
    });
  }});
}, tipRenderer:function(tooltip, record) {
  var total = 0;
  record.store.each(function(r) {
    total += r.get('total');
  });
  var percent = Math.floor(record.get('total') / total * 100), state = record.get('state').split(':')[0];
  tooltip.setHtml(state + ': ' + percent + '%');
}, onRefreshChart:function(panel) {
  panel.down('polar').getStore().reload();
}});
Ext.define('MobileJudge.view.charts.Grades', {extend:MobileJudge.view.charts.Base, xtype:'livegrades', title:'Live Grades', items:[{xtype:'polar', bind:'{judges}', platformConfig:{classic:{interactions:'rotate', insetPadding:20, innerPadding:20, legend:{docked:'right'}, series:[{type:'pie', angleField:'total', donut:50, highlight:{margin:40}, label:{field:'state', calloutLine:{length:60, width:3}}, tooltip:{trackMouse:true, renderer:'tipRenderer'}}]}, modern:{interactions:'rotate', insetPadding:10, 
innerPadding:10, series:[{type:'pie', angleField:'total', donut:50, highlight:true, label:{field:'state'}}]}}}]});
Ext.define('MobileJudge.view.charts.Judges', {extend:MobileJudge.view.charts.Base, xtype:'chartjudges', title:'Judge States', items:[{xtype:'polar', bind:'{judges}', platformConfig:{classic:{interactions:'rotatePie3d', insetPadding:20, innerPadding:20, legend:{docked:'right'}, series:[{type:'pie3d', angleField:'total', donut:30, highlight:{margin:40}, label:{field:'state', calloutLine:{length:60, width:3}}, tooltip:{trackMouse:true, renderer:'tipRenderer'}}]}, modern:{interactions:'rotate', insetPadding:10, 
innerPadding:10, series:[{type:'pie3d', angleField:'total', donut:30, highlight:true, label:{field:'state'}}]}}}]});
Ext.define('MobileJudge.view.charts.ChartsModel', {extend:Ext.app.ViewModel, alias:'viewmodel.charts', stores:{judges:{type:'chartStates', storeId:'chartJudgeStates', proxy:{type:'api', url:'/api/charts/judges'}}, students:{type:'chartStates', storeId:'chartStudentStates', proxy:{type:'api', url:'/api/charts/students'}}, graded:{type:'chartStates', storeId:'chartGradedStates', proxy:{type:'api', url:'/api/charts/graded'}}, accepted:{type:'chartStates', storeId:'chartAcceptedStates', proxy:{type:'api', 
url:'/api/charts/accepted'}}}});
Ext.define('MobileJudge.view.charts.SmallPie', {extend:Ext.chart.PolarChart, xtype:'smallpie', interactions:'rotate', platformConfig:{classic:{insetPadding:10, innerPadding:10, legend:{docked:'bottom'}}, modern:{insetPadding:20, innerPadding:20}}, series:[{type:'pie3d', donut:30, angleField:'total', highlight:true, label:{field:'state', calloutLine:{width:3}}, platformConfig:{classic:{tooltip:{trackMouse:true, renderer:'tipRenderer'}}}}]});
Ext.define('MobileJudge.view.email.EmailModel', {extend:Ext.app.ViewModel, alias:'viewmodel.email', stores:{outbox:{type:'outbox', storeId:'outbox'}, templates:{type:'templates', storeId:'templates'}, placeholders:{type:'placeholders', storeId:'placeholders'}}});
Ext.define('MobileJudge.view.judges.Controller', {extend:Ext.app.ViewController, alias:'controller.judge', model:null, init:function(view) {
  this.model = view.getViewModel();
}, onQuestionsLoaded:function(store, records) {
  var questions = [];
  records.forEach(function(q) {
    if (q.get('enabled')) {
      questions.push({id:q.get('id'), text:q.get('text'), value:q.get('value')});
    }
  });
  this.model.set('questions', questions);
}, onStudentsRefresh:function() {
  this.model.getStore('questions').reload();
  this.model.getStore('students').reload();
  this.model.getStore('grades').reload();
}, onGrade:function(grid, rowIndex, colIndex, item, e, record) {
  this.startGrading(this.getReferences().wizard, record);
}, onItemTap:function(view, index, target, record) {
  if (record.get('accepted') != record.get('total')) {
    this.startGrading(view.up('judgehome'), record);
  }
}, startGrading:function(wizard, record) {
  var me = this, model = me.model;
  model.set('student', record);
  model.set('index', 0);
  wizard.setActiveItem(1);
}, onPrevBtn:function(btn) {
  var me = this, model = me.model;
  if (!model.get('atStart')) {
    model.set('index', model.get('index') - 1);
    var scroll = btn.up('judgequestion').getScrollable();
    if (scroll) {
      scroll.scrollTo(null, 0);
    }
  } else {
    var refs = me.getReferences(), wizard = refs && refs.wizard || btn.up('judgehome');
    wizard.setActiveItem(0);
  }
}, onNextBtn:function(btn) {
  var me = this, model = me.model, refs = me.getReferences(), wizard = refs && refs.wizard || btn.up('judgehome');
  if (!model.get('atEnd')) {
    model.set('index', model.get('index') + 1);
    var scroll = btn.up('judgequestion').getScrollable();
    if (scroll) {
      scroll.scrollTo(null, 0);
    }
  } else {
    var student = model.get('student'), studentId = student.get('id'), questions = model.get('questions'), grades = model.getStore('grades'), batch = [];
    questions.forEach(function(q) {
      var grade = grades.getById(studentId + '-' + q.id);
      batch.push({studentId:studentId, questionId:q.id, value:grade.get('value'), comment:grade.get('comment') || ''});
    });
    btn.setDisabled(true);
    Ext.Ajax.request({url:'/api/grades', method:'PUT', jsonData:batch, callback:function() {
      btn.setDisabled(false);
    }, failure:function(resp) {
      Ext.Msg.alert('Error', resp.responseText);
    }, success:function() {
      student.set('graded', student.get('total'));
      wizard.setActiveItem(0);
    }});
  }
}});
Ext.define('MobileJudge.view.judges.Model', {extend:Ext.app.ViewModel, alias:'viewmodel.judge', data:{questions:[], index:0, student:{}}, stores:{questions:{type:'questions', storeId:'activeQuestions', listeners:{load:'onQuestionsLoaded'}}, students:{type:'judgeStudents', storeId:'myStudents'}, grades:{type:'judgeGrades', storeId:'myGrades'}}, formulas:{progress:{bind:{total:'{student.total}', index:'{index}'}, get:function(data) {
  return data.index + 1 + ' of ' + data.total;
}}, atStart:{bind:{bindTo:'{index}'}, get:function(index) {
  return index == 0;
}}, atEnd:{bind:{total:'{student.total}', index:'{index}'}, get:function(data) {
  return data.index + 1 >= data.total;
}}, next:{bind:{bindTo:'{atEnd}'}, get:function(atEnd) {
  return {text:atEnd ? 'Submit' : 'Next', icon:'x-fa fa-' + (atEnd ? 'check' : 'angle-right'), ui:atEnd ? 'soft-green' : 'soft-blue'};
}}, question:{bind:{index:'{index}', questions:'{questions}'}, get:function(data) {
  return data.questions[data.index];
}}, grade:{bind:{bindTo:'{student.id}-{question.id}'}, get:function(id) {
  return this.getStore('grades').getById(id);
}}, gradeDisplay:{bind:{grade:'{grade.value}', max:'{question.value}', deep:true}, get:function(data) {
  return data.grade + ' / ' + data.max;
}}, isAccepted:{bind:{bindTo:'{grade}', deep:true}, get:function(grade) {
  return grade && grade.isModel && grade.get('state') == 1;
}}}});
Ext.define('MobileJudge.view.main.BaseController', {extend:Ext.app.ViewController, listen:{global:{login:'onLogIn', logout:'onLogout', termChanged:'onActiveTermChanged', navTreeReady:'onNavTreeReady', requestError:'onRequestError'}, controller:{'#':{unmatchedroute:'onRouteChange'}}}, routes:{':node':'onRouteChange'}, stores:['NavigationTree'], menuStore:null, model:null, profile:['activeTerm', 'userName', 'profilePic', 'title', 'affiliation', 'email'], commonPages:['login', 'register', 'passwordreset', 
'passwordchange', 'lockscreen', 'page404', 'page500'], init:function(view) {
  this.model = view.getViewModel();
  this.loadProfileModel();
  this.menuStore = Ext.getStore('NavigationTree');
}, isMenuLoaded:function() {
  return this.menuStore.isLoaded() && !this.menuStore.isLoading();
}, onNavigationTreeSelectionChange:function(tree, node) {
  var to = node && (node.get('routeId') || node.get('viewType'));
  if (to) {
    this.redirectTo(to);
  }
}, onRouteChange:function(id) {
  var token = localStorage.getItem('token'), isLockScreen = Ext.Array.contains(this.commonPages, id);
  if (Ext.isEmpty(token) && !isLockScreen) {
    localStorage.setItem('redirect', id);
    this.redirectTo('login');
  } else {
    if (!this.isMenuLoaded() && !isLockScreen) {
      this.menuStore.load();
    } else {
      if ((id == 'register' || id == 'passwordchange') && !localStorage.getItem('userId')) {
        this.redirectTo(Ext.isEmpty(token) ? 'login' : 'home');
      } else {
        this.setCurrentView(id);
      }
    }
  }
}, loadProfileModel:function() {
  var me = this;
  Ext.each(me.profile, function(key) {
    me.model.set(key, localStorage.getItem(key));
  });
}, reloadAllStores:function(but) {
  Ext.data.StoreManager.each(function(store) {
    if (but && Ext.Array.contains(but, store.getStoreId())) {
      return;
    }
    if (store.getStoreId() !== 'ext-empty-store') {
      if (store.getStoreId() == 'NavigationTree') {
        store.removeAll();
        store.load();
      } else {
        store.reload();
      }
    }
  });
}, onNavTreeReady:function() {
  this.redirectTo(Ext.util.History.getToken(), true);
}, onLogIn:function() {
  this.loadProfileModel();
  this.getReferences().mainCard.removeAll();
  this.reloadAllStores();
  var redirect = localStorage.getItem('redirect') || 'home';
  this.redirectTo(redirect == 'login' ? 'home' : redirect);
  localStorage.removeItem('redirect');
}, onLogout:function() {
  localStorage.removeItem('redirect');
  localStorage.removeItem('token');
  Ext.each(this.profile, localStorage.removeItem, localStorage);
  this.redirectTo('login');
}, onActiveTermChanged:function(term) {
  localStorage.setItem('activeTerm', term);
  this.model.set('activeTerm', term);
  this.reloadAllStores(['placeholders', 'templates', 'outbox', 'questions', 'NavigationTree']);
}, onRequestError:function(conn, resp) {
  switch(resp.status) {
    case 401:
      localStorage.removeItem('token');
      var back = Ext.util.History.getToken();
      if (back !== 'lockscreen' && back !== 'login') {
        localStorage.setItem('redirect', back);
      }
      break;
    case 500:
      this.redirectTo('page500');
      break;
  }
}});
Ext.define('MobileJudge.view.main.Model', {extend:Ext.app.ViewModel, alias:'viewmodel.main', data:{currentView:null, activeTerm:null, userName:null, profilePic:null}});
Ext.define('MobileJudge.view.students.Controller', {extend:Ext.app.ViewController, alias:'controller.student', model:null, init:function(view) {
  this.model = view.getViewModel();
  this.loadProfile();
}, loadProfile:function(btn) {
  var me = this;
  if (btn) {
    btn.setDisabled(true);
  }
  Ext.Ajax.request({url:'/api/profile', method:'GET', callback:function() {
    if (btn) {
      btn.setDisabled(false);
    }
  }, success:function(resp) {
    var profile = Ext.decode(resp.responseText);
    Ext.each(profile, function(key) {
      me.model.set(key, profile[key]);
    });
  }});
}});
Ext.define('MobileJudge.view.students.Profile', {extend:Ext.panel.Panel, xtype:'profile', layout:{type:'vbox', align:'middle'}, height:350, bodyPadding:20, items:[{xtype:'image', cls:'userProfilePic', height:120, width:120, alt:'profile-picture', bind:{src:'{profileImgUrl}'}}, {xtype:'component', cls:'userProfileName', height:'', bind:{html:'{fullName}'}}, {xtype:'component', cls:'userProfileDesc', bind:{html:'{email}'}}, {xtype:'component', cls:'userProfileDesc', bind:{html:'{id}'}}, {xtype:'component', 
margin:'10 0 0 0', cls:'userProfileDesc', bind:{html:'{project}'}}, {xtype:'component', cls:'userProfileDesc', bind:{html:'\x3ca href\x3d"#map"\x3e{location}\x3c/a\x3e'}}, {xtype:'component', margin:'10', cls:'userProfileDesc', bind:{html:'Grade: {grade_display}'}}, {xtype:'button', margin:5, width:220, text:'Refresh', handler:'loadProfile', platformConfig:{classic:{scale:'large'}, modern:{ui:'action'}}}]});
Ext.define('MobileJudge.view.main.Index', {extend:Ext.Container, controller:'main', viewModel:'main', layout:'hbox', items:[{xtype:'maintoolbar', docked:'top', id:'maintoolbar', reference:'maintoolbar', userCls:'main-toolbar shadow'}, {xtype:'container', userCls:'main-nav-container', reference:'navigation', scrollable:true, items:[{xtype:'treelist', reference:'navigationTree', ui:'navigation', store:'NavigationTree', expanderFirst:false, expanderOnly:false, listeners:{itemclick:'onNavigationItemClick', 
selectionchange:'onNavigationTreeSelectionChange'}}]}, {xtype:'navigationview', flex:1, reference:'mainCard', userCls:'main-container', navigationBar:false}]});
Ext.define('MobileJudge.Application', {extend:Ext.app.Application, name:'MobileJudge', defaultToken:'home', mainView:'MobileJudge.view.main.Index', stores:['NavigationTree'], launch:function() {
  Ext.getBody().addCls('phone');
}});
Ext.define('MobileJudge.ux.ImageViewer', {extend:Ext.Container, xtype:'imageviewer', alias:'widget.imageviewer', config:{doubleTapScale:1, maxScale:4, loadingMask:true, previewSrc:false, resizeOnLoad:true, imageSrc:false, initOnActivate:false, cls:'imageBox', scrollable:'both', loadingMessage:'Loading ...', html:'\x3cfigure\x3e\x3cimg\x3e\x3c/figure\x3e', errorImage:false, hideOnMaskTap:false}, duringDestroy:false, initialize:function() {
  var me = this;
  if (me.getInitOnActivate()) {
    me.on('activate', me.initViewer, me, {delay:10, single:true});
  } else {
    me.on('painted', me.initViewer, me, {delay:10, single:true});
  }
}, initViewer:function() {
  var me = this, scroller = me.getScrollable(), element = me.element;
  scroller.setDisabled(true);
  if (me.getLoadingMask()) {
    me.setMasked({xtype:'loadmask', message:me.getLoadingMessage()});
  }
  me.figEl = element.down('figure');
  me.imgEl = me.figEl.down('img');
  me.figEl.setStyle({overflow:'hidden', display:'block', margin:0});
  me.imgEl.setStyle({'-webkit-user-drag':'none', '-webkit-transform-origin':'0 0', 'visibility':'hidden'});
  if (me.getPreviewSrc()) {
    element.setStyle({backgroundImage:'url(' + me.getPreviewSrc() + ')', backgroundPosition:'center center', backgroundRepeat:'no-repeat', webkitBackgroundSize:'contain'});
  }
  me.on('load', me.onImageLoad, me);
  me.imgEl.addListener({scope:me, doubletap:me.onDoubleTap, pinchstart:me.onImagePinchStart, pinch:me.onImagePinch, pinchend:me.onImagePinchEnd});
  if (me.getHideOnMaskTap()) {
    me.figEl.addListener({scope:me, singletap:me.onMaskTap});
  }
  if (me.getImageSrc()) {
    me.loadImage(me.getImageSrc());
  }
}, loadImage:function(src) {
  var me = this;
  if (me.imgEl) {
    me.imgEl.dom.src = src;
    me.imgEl.dom.onload = Ext.Function.bind(me.onLoad, me, me.imgEl, 0);
    if (me.getErrorImage()) {
      me.imgEl.dom.onerror = function() {
        this.src = me.getErrorImage();
      };
    }
  } else {
    me.setImageSrc(src);
  }
}, unloadImage:function() {
  var me = this;
  if (me.getLoadingMask()) {
    me.setMasked({xtype:'loadmask', message:me.getLoadingMessage()});
  }
  if (me.imgEl) {
    me.imgEl.dom.src = '';
    me.imgEl.setStyle({visibility:'hidden'});
  } else {
    me.setImageSrc('');
    me.imgEl.setStyle({visibility:'hidden'});
  }
}, onLoad:function(el, e) {
  var me = this;
  me.fireEvent('load', me, el, e);
}, onImageLoad:function() {
  var me = this, parentElement = me.parent.element;
  me.viewportWidth = me.viewportWidth || me.getWidth() || parentElement.getWidth();
  me.viewportHeight = me.viewportHeight || me.getHeight() || parentElement.getHeight();
  me.imgWidth = me.imgEl.dom.width;
  me.imgHeight = me.imgEl.dom.height;
  if (me.getResizeOnLoad()) {
    me.scale = me.baseScale = Math.min(me.viewportWidth / me.imgWidth, me.viewportHeight / me.imgHeight);
    me.setMaxScale(me.scale * 4);
  } else {
    me.scale = me.baseScale = 1;
  }
  var tmpTranslateX = (me.viewportWidth - me.baseScale * me.imgWidth) / 2, tmpTranslateY = (me.viewportHeight - me.baseScale * me.imgHeight) / 2;
  me.setTranslation(tmpTranslateX, tmpTranslateY);
  me.translateBaseX = me.translateX;
  me.translateBaseY = me.translateY;
  me.applyTransform();
  me.adjustScroller();
  me.imgEl.setStyle({visibility:'visible'});
  if (me.getPreviewSrc()) {
    me.element.setStyle({backgroundImage:'none'});
  }
  if (me.getLoadingMask()) {
    me.setMasked(false);
  }
  me.fireEvent('imageLoaded', me);
}, onImagePinchStart:function(ev) {
  var me = this, scroller = me.getScrollable(), scrollPosition = scroller.position, touches = ev.touches, element = me.element, scale = me.scale;
  scroller.stopAnimation();
  scroller.setDisabled(true);
  me.startScale = scale;
  me.originViewportX = (touches[0].pageX + touches[1].pageX) / 2 - element.getX();
  me.originViewportY = (touches[0].pageY + touches[1].pageY) / 2 - element.getY();
  me.originScaledImgX = me.originViewportX + scrollPosition.x - me.translateX;
  me.originScaledImgY = me.originViewportY + scrollPosition.y - me.translateY;
  me.originFullImgX = me.originScaledImgX / scale;
  me.originFullImgY = me.originScaledImgY / scale;
  me.translateX += -1 * (me.imgWidth * (1 - scale) * (me.originFullImgX / me.imgWidth));
  me.translateY += -1 * (me.imgHeight * (1 - scale) * (me.originFullImgY / me.imgHeight));
  me.setOrigin(me.originFullImgX, me.originFullImgY);
  me.applyTransform();
}, onImagePinch:function(ev) {
  var me = this;
  me.scale = Ext.Number.constrain(ev.scale * me.startScale, me.baseScale - 2, me.getMaxScale());
  me.applyTransform();
}, onImagePinchEnd:function(ev) {
  var me = this;
  if (me.scale == me.baseScale) {
    me.setTranslation(me.translateBaseX, me.translateBaseY);
  } else {
    if (me.scale < me.baseScale && me.getResizeOnLoad()) {
      me.resetZoom();
      return;
    }
    me.originReScaledImgX = me.originScaledImgX * (me.scale / me.startScale);
    me.originReScaledImgY = me.originScaledImgY * (me.scale / me.startScale);
    me.setTranslation(me.originViewportX - me.originReScaledImgX, me.originViewportY - me.originReScaledImgY);
  }
  me.setOrigin(0, 0);
  me.applyTransform();
  me.adjustScroller();
}, onZoomIn:function() {
  var me = this, ev = {pageX:0, pageY:0}, myScale = me.scale;
  if (myScale < me.getMaxScale()) {
    myScale = me.scale + 0.05;
  }
  if (myScale >= me.getMaxScale()) {
    myScale = me.getMaxScale();
  }
  ev.pageX = me.viewportWidth / 2;
  ev.pageY = me.viewportHeight / 2;
  me.zoomImage(ev, myScale);
}, onZoomOut:function() {
  var me = this, ev = {pageX:0, pageY:0}, myScale = me.scale;
  if (myScale > me.baseScale) {
    myScale = me.scale - 0.05;
  }
  if (myScale <= me.baseScale) {
    myScale = me.baseScale;
  }
  ev.pageX = me.viewportWidth / 2;
  ev.pageY = me.viewportHeight / 2;
  me.zoomImage(ev, myScale);
}, zoomImage:function(ev, scale, scope) {
  var me = this, scroller = me.getScrollable(), scrollPosition = scroller.position, element = me.element;
  var oldScale = me.scale, newScale = scale, originViewportX = ev ? ev.pageX - element.getX() : 0, originViewportY = ev ? ev.pageY - element.getY() : 0, originScaledImgX = originViewportX + scrollPosition.x - me.translateX, originScaledImgY = originViewportY + scrollPosition.y - me.translateY, originReScaledImgX = originScaledImgX * (newScale / oldScale), originReScaledImgY = originScaledImgY * (newScale / oldScale);
  me.scale = newScale;
  setTimeout(function() {
    me.setTranslation(originViewportX - originReScaledImgX, originViewportY - originReScaledImgY);
    me.applyTransform();
    me.adjustScroller();
    if (Ext.repaint) {
      Ext.repaint();
    }
  }, 50);
}, onDoubleTap:function(ev, t) {
  var me = this, scroller = me.getScrollable(), scrollPosition = scroller.position, element = me.element;
  if (!me.getDoubleTapScale()) {
    return false;
  }
  if (me.scale > me.baseScale) {
    me.scale = me.baseScale;
    me.setTranslation(me.translateBaseX, me.translateBaseY);
    me.applyTransform();
    me.adjustScroller();
    if (Ext.repaint) {
      Ext.repaint();
    }
  } else {
    var oldScale = me.scale, newScale = me.baseScale * 4, originViewportX = ev ? ev.pageX - element.getX() : 0, originViewportY = ev ? ev.pageY - element.getY() : 0, originScaledImgX = originViewportX + scrollPosition.x - me.translateX, originScaledImgY = originViewportY + scrollPosition.y - me.translateY, originReScaledImgX = originScaledImgX * (newScale / oldScale), originReScaledImgY = originScaledImgY * (newScale / oldScale);
    me.scale = newScale;
    setTimeout(function() {
      me.setTranslation(originViewportX - originReScaledImgX, originViewportY - originReScaledImgY);
      me.applyTransform();
      me.adjustScroller();
      if (Ext.repaint) {
        Ext.repaint();
      }
    }, 50);
  }
}, onMaskTap:function() {
  var me = this;
  me.hide();
}, setOrigin:function(x, y) {
  this.imgEl.dom.style.webkitTransformOrigin = x + 'px ' + y + 'px';
}, setTranslation:function(translateX, translateY) {
  var me = this;
  me.translateX = translateX;
  me.translateY = translateY;
  me.scrollX = me.scrollY = 0;
  if (me.translateX < 0) {
    me.scrollX = me.translateX;
    me.translateX = 0;
  }
  if (me.translateY < 0) {
    me.scrollY = me.translateY;
    me.translateY = 0;
  }
}, resetZoom:function() {
  var me = this;
  if (me.duringDestroy) {
    return;
  }
  me.scale = me.baseScale;
  me.setTranslation(me.translateBaseX, me.translateBaseY);
  me.setOrigin(0, 0);
  me.applyTransform();
  me.adjustScroller();
}, resize:function() {
  var me = this;
  me.viewportWidth = me.parent.element.getWidth() || me.viewportWidth || me.getWidth();
  me.viewportHeight = me.parent.element.getHeight() || me.viewportHeight || me.getHeight();
  me.imgWidth = me.imgEl.dom.width;
  me.imgHeight = me.imgEl.dom.height;
  if (me.getResizeOnLoad()) {
    me.scale = me.baseScale = Math.min(me.viewportWidth / me.imgWidth, me.viewportHeight / me.imgHeight);
    me.setMaxScale(me.scale * 4);
  } else {
    me.scale = me.baseScale = 1;
  }
  me.translateX = me.translateBaseX = (me.viewportWidth - me.baseScale * me.imgWidth) / 2;
  me.translateY = me.translateBaseY = (me.viewportHeight - me.baseScale * me.imgHeight) / 2;
  me.applyTransform();
  me.adjustScroller();
}, applyTransform:function() {
  var me = this, fixedX = Ext.Number.toFixed(me.translateX, 5), fixedY = Ext.Number.toFixed(me.translateY, 5), fixedScale = Ext.Number.toFixed(me.scale, 8);
  if (Ext.os.is.Android) {
    me.imgEl.dom.style.webkitTransform = 'matrix(' + fixedScale + ',0,0,' + fixedScale + ',' + fixedX + ',' + fixedY + ')';
  } else {
    me.imgEl.dom.style.webkitTransform = 'translate3d(' + fixedX + 'px, ' + fixedY + 'px, 0)' + ' scale3d(' + fixedScale + ',' + fixedScale + ',1)';
  }
}, adjustScroller:function() {
  var me = this, scroller = me.getScrollable(), scale = me.scale;
  if (scale == me.baseScale) {
    scroller.setDisabled(true);
  } else {
    scroller.setDisabled(false);
  }
  var boundWidth = Math.max(me.imgWidth * scale + 2 * me.translateX, me.viewportWidth);
  var boundHeight = Math.max(me.imgHeight * scale + 2 * me.translateY, me.viewportHeight);
  me.figEl.setStyle({width:boundWidth + 'px', height:boundHeight + 'px'});
  scroller.refresh();
  var x = 0;
  if (me.scrollX) {
    x = me.scrollX;
  }
  var y = 0;
  if (me.scrollY) {
    y = me.scrollY;
  }
  scroller.scrollTo(x * -1, y * -1);
}, destroy:function() {
  var me = this;
  me.duringDestroy = true;
  me.un('activate', me.initViewer, me);
  me.un('painted', me.initViewer, me);
  Ext.destroy(me.getScrollable(), me.imgEl);
  me.callParent();
}});
Ext.define('MobileJudge.ux.SelectPlus', {extend:Ext.field.Select, xtype:'selectfieldplus', alternateClassName:'Ext.field.SelectPlus', config:{displayFieldValue:'', valueFieldValue:''}, onStoreDataChanged:function(store) {
  if (store.findExact(this.getValueField(), this.getValueFieldValue()) === -1) {
    var item = Ext.create(store.getModel());
    item.set(this.getValueField(), this.getValueFieldValue());
    item.set(this.getDisplayField(), this.getDisplayFieldValue());
    store.insert(0, item);
  }
  this.callParent([store]);
}});
Ext.define('MobileJudge.view.admin.Home', {extend:Ext.Container, xtype:'adminhome', controller:'charts', viewModel:{type:'charts'}, cls:'dashboard', scrollable:true, defaultType:'basepie', defaults:{iconCls:'x-fa fa-pie-chart', userCls:'big-33 small-100 dashboard-item shadow', height:300}, items:[{xtype:'chartjudges', userCls:'big-100 small-100 dashboard-item shadow'}, {title:'Students', items:[{xtype:'smallpie', bind:'{students}'}]}, {title:'Graded', items:[{xtype:'smallpie', bind:'{graded}'}]}, 
{title:'Accepted', items:[{xtype:'smallpie', bind:'{accepted}'}]}]});
Ext.define('MobileJudge.view.authentication.AuthBase', {extend:Ext.Panel, baseCls:'auth-locked', layout:{type:'vbox', align:'center', pack:'center'}, scrollable:true, controller:'authentication', viewModel:{type:'authentication'}});
Ext.define('MobileJudge.view.authentication.LockScreen', {extend:MobileJudge.view.authentication.AuthBase, xtype:'lockscreen', padding:20, items:[{xtype:'panel', items:[{xtype:'container', userCls:'lockscreen-header', padding:20, layout:'hbox', items:[{xtype:'img', height:64, width:64, userCls:'circular', bind:{src:'{profilePic}'}}, {xtype:'container', bind:{html:'\x3cb\x3e{userName}\x3c/b\x3e\x3cbr\x3e{title}'}, padding:15}]}, {padding:'20 20 0 20', html:"It's been awhile.  Please enter your password to resume"}, 
{xtype:'container', padding:20, defaults:{margin:'0 0 10 0'}, items:[{xtype:'passwordfield', placeHolder:'Password', userCls:'text-border', bind:'{password}'}, {xtype:'button', text:'Login', iconAlign:'right', iconCls:'x-fa fa-angle-right', ui:'gray-button', handler:'onLoginButton'}, {html:'\x3ca href\x3d"#login"\x3eSign in using a different account\x3c/a\x3e'}]}]}]});
Ext.define('MobileJudge.view.authentication.Login', {extend:MobileJudge.view.authentication.AuthBase, xtype:'login', listeners:{painted:'onLoginRender'}, items:[{xtype:'panel', items:[{padding:'20 0 0 20', html:'Sign into your account'}, {xtype:'container', padding:20, defaults:{margin:'0 0 10 0'}, items:[{xtype:'emailfield', placeHolder:'Email', vtype:'email', bind:'{email}', userCls:'text-border'}, {xtype:'passwordfield', placeHolder:'Password', bind:'{password}', userCls:'text-border'}, {layout:'hbox', 
items:[{xtype:'checkboxfield', bind:'{persist}'}, {html:'Remember Me', userCls:'checkbox-text-adjustment', style:'marginRight:20px'}, {html:'\x3ca href\x3d"#passwordreset"\x3eForgot Password\x3c/a\x3e', userCls:'checkbox-text-adjustment'}]}, {xtype:'button', text:'Login', iconAlign:'right', iconCls:'x-fa fa-angle-right', ui:'confirm', handler:'onLoginButton'}, {xtype:'button', text:'Login with FIU', iconAlign:'right', iconCls:'fiu', userCls:'btn-oauth', ui:'fiu'}, {xtype:'button', text:'Login with Google', 
iconAlign:'right', iconCls:'x-fa fa-google-plus', userCls:'btn-oauth', ui:'google'}, {xtype:'button', text:'Login with LinkedIn', iconAlign:'right', iconCls:'x-fa fa-linkedin', userCls:'btn-oauth', ui:'linkedin2'}, {xtype:'button', text:'Login with Facebook', iconAlign:'right', iconCls:'x-fa fa-facebook', userCls:'btn-oauth', ui:'facebook'}, {xtype:'button', text:'Login with Twitter', iconAlign:'right', iconCls:'x-fa fa-twitter', userCls:'btn-oauth', ui:'twitter'}]}]}]});
Ext.define('MobileJudge.view.authentication.PasswordChange', {extend:MobileJudge.view.authentication.AuthBase, xtype:'passwordchange', items:[{xtype:'panel', padding:20, items:[{html:'Choose a new Password', padding:'0 0 10 0'}, {xtype:'container', defaults:{margin:'0 0 10 0'}, items:[{xtype:'passwordfield', placeHolder:'New Password', bind:'{newPassword}', userCls:'text-border'}, {xtype:'passwordfield', placeHolder:'Confirm Password', bind:'{confirmPassword}', userCls:'text-border'}, {xtype:'button', 
iconAlign:'right', iconCls:'x-fa fa-angle-right', ui:'action', text:'Change Password', handler:'onChangePassword'}]}]}]});
Ext.define('MobileJudge.view.authentication.PasswordReset', {extend:MobileJudge.view.authentication.AuthBase, xtype:'passwordreset', items:[{xtype:'panel', padding:20, items:[{html:'Forgot Password', padding:'0 0 10 0'}, {xtype:'container', defaults:{margin:'0 0 10 0'}, items:[{xtype:'textfield', placeHolder:'example@example.com', bind:'{email}', userCls:'text-border'}, {xtype:'button', text:'Reset Password', iconAlign:'right', iconCls:'x-fa fa-angle-right', ui:'action', handler:'onReset'}, {html:'\x3ca href\x3d"#login"\x3eBack to Login\x3c/a\x3e'}]}]}]});
Ext.define('MobileJudge.view.authentication.Register', {extend:MobileJudge.view.authentication.AuthBase, xtype:'register', viewModel:{type:'registration'}, listeners:{painted:'onRegisterRender'}, layout:'card', reference:'regWizard', defaultType:'panel', defaults:{scrollable:'y'}, items:[{items:[{padding:'10 0 0 10', html:'Create an Account'}, {xtype:'panel', padding:'10 20', defaults:{margin:'0 0 10 0', allowBlank:false}, items:[{xtype:'textfield', bind:'{title}', placeHolder:'Title'}, {xtype:'textfield', 
bind:'{userName}', placeHolder:'Full Name', userCls:'text-border'}, {xtype:'textfield', bind:'{affiliation}', placeHolder:'Affiliation', userCls:'text-border'}, {xtype:'emailfield', bind:'{email}', vtype:'email', placeHolder:'user@example.com', userCls:'text-border'}, {xtype:'passwordfield', placeHolder:'Password', bind:'{password}', userCls:'text-border'}, {xtype:'button', text:'Signup', iconAlign:'right', iconCls:'x-fa fa-angle-right', ui:'confirm', handler:'onSetPageTwo', bind:{disabled:'{!isValid}'}}]}]}, 
{items:[{padding:'10 0 0 10', html:'Optionaly link your account with us'}, {xtype:'container', padding:'10 20', defaults:{margin:'0 0 10 0'}, items:[{xtype:'button', reference:'linkfiu', text:'Link with FIU', iconAlign:'right', iconCls:'fiu', userCls:'btn-oauth', ui:'fiu'}, {xtype:'button', reference:'linkgoogle', text:'Link with Google', iconAlign:'right', iconCls:'x-fa fa-google-plus', userCls:'btn-oauth', ui:'google'}, {xtype:'button', reference:'linklinkedin2', text:'Link with LinkedIn', iconAlign:'right', 
iconCls:'x-fa fa-linkedin', userCls:'btn-oauth', ui:'linkedin2'}, {xtype:'button', reference:'linkfacebook', text:'Link with Facebook', iconAlign:'right', iconCls:'x-fa fa-facebook', userCls:'btn-oauth', ui:'facebook'}, {xtype:'button', reference:'linktwitter', text:'Link with Twitter', iconAlign:'right', iconCls:'x-fa fa-twitter', userCls:'btn-oauth', ui:'twitter'}]}, {xtype:'container', layout:'hbox', margin:'0 0 10 0', items:[{html:'\x3cdiv\x3e\x3c/div\x3e', flex:1}, {xtype:'button', ui:'soft-blue', 
iconCls:'x-fa fa-angle-left', text:'Back', handler:'onSetPageOne'}, {html:'\x3cdiv\x3e\x3c/div\x3e', flex:1}, {xtype:'button', ui:'soft-green', iconAlign:'right', iconCls:'x-fa fa-angle-right', text:'Next', handler:'onSetPageThree'}, {html:'\x3cdiv\x3e\x3c/div\x3e', flex:1}]}]}, {layout:'vbox', items:[{padding:'10 0 0 10', html:'Select Conflicts'}, {margin:'0 10', xtype:'list', reference:'gridConflicts', cls:'conflictSelector', flex:1, grouped:true, indexBar:true, mode:'SIMPLE', bind:{store:'{conflicts}'}, 
itemTpl:'\x3cdiv class\x3d"search-user-item"\x3e' + '\x3cdiv class\x3d"search-user-image"\x3e' + '\x3cimg src\x3d"{profileImgUrl}" class\x3d"circular" width\x3d"50" height\x3d"50"/\x3e' + '\x3c/div\x3e' + '\x3cdiv class\x3d"search-user-content"\x3e' + '\x3cdiv class\x3d"search-user-title"\x3e{fullName}\x3c/div\x3e' + '\x3cdiv class\x3d"search-user-email"\x3e{project}\x3c/div\x3e' + '\x3c/div\x3e' + '\x3c/div\x3e'}, {xtype:'container', margin:'5 0 10 0', layout:'hbox', items:[{html:'\x3cdiv\x3e\x3c/div\x3e', 
flex:1}, {xtype:'button', ui:'soft-blue', iconCls:'x-fa fa-angle-left', text:'Back', handler:'onSetPageTwo'}, {html:'\x3cdiv\x3e\x3c/div\x3e', flex:1}, {xtype:'button', ui:'soft-green', iconAlign:'right', iconCls:'x-fa fa-flag-checkered', text:'Done', handler:'onDoneRegister'}, {html:'\x3cdiv\x3e\x3c/div\x3e', flex:1}]}]}]});
Ext.define('MobileJudge.view.email.Compose', {extend:Ext.form.Panel, xtype:'compose', cls:'email-compose', layout:'vbox', padding:20, title:'Compose', scrollable:'y', tools:[{iconCls:'x-fa fa-trash-o', handler:'onCloseMessage'}, {}, {iconCls:'x-fa fa-send', handler:'onSendMessage'}], items:[{xtype:'emailfield', name:'email', placeHolder:'user@example.com', bind:'{toField}', margin:'0 0 20 0'}, {xtype:'selectfieldplus', store:'templates', placeHolder:'Select a Template', displayField:'name', valueField:'id', 
value:' ', bind:{value:'{template}'}, listeners:{change:'onTemplateChange'}, margin:'0 0 20 0'}, {xtype:'component', cls:'rounded', html:'Subject', bind:{html:'{preview.subject}'}, margin:'0 0 20 0'}, {xtype:'component', cls:'bodyTemplate rounded', styleHtmlContent:true, html:'Email Content', bind:{html:'\x3cdiv class\x3d"bodyWrapper"\x3e\x3ciframe id\x3d"previewFrame" frameborder\x3d"0" src\x3d"{previewMobile}"\x3e\x3c/iframe\x3e\x3c/div\x3e'}, margin:'0 0 10 0'}]});
Ext.define('MobileJudge.view.email.Controller', {extend:Ext.app.ViewController, alias:'controller.email', actionsVisible:false, closeComposer:function() {
  var me = this, composer = me.composer, view = me.getView(), viewModel = me.getViewModel();
  if (composer) {
    view.remove(composer);
    me.composer = null;
    viewModel.set('composing', false);
  }
}, onPlusButtonTap:function() {
  if (!this.actionsVisible) {
    this.doCompose();
  }
}, doCompose:function(to) {
  var me = this, composer = me.composer, view = me.getView(), viewModel = me.getViewModel();
  if (!composer) {
    me.composer = composer = view.add({xtype:'compose', flex:1});
    viewModel.set('composing', true);
  }
}, onCloseMessage:function() {
  this.closeComposer();
}, onSendMessage:function(win) {
  var me = this, model = me.getViewModel(), address = model.get('toField'), template = model.get('template');
  var error = !/^(")?(?:[^\."])(?:(?:[\.])?(?:[\w\-!#$%&'*+\/=?\^_`{|}~]))*\1@(\w[\-\w]*\.){1,5}([A-Za-z]){2,6}$/.test(address) ? 'Invalid email address' : !template || !template.isModel || Ext.isEmpty(template.id) ? 'Please select a template' : false;
  if (error) {
    Ext.Msg.alert('Error', error);
  } else {
    win.mask();
    Ext.Ajax.request({url:'/api/emails', method:'POST', jsonData:{templateId:template.id, importJudges:model.get('importJudges'), emails:[{address:address}]}, callback:function() {
      win.unmask();
      me.closeComposer();
    }, success:function() {
      model.getStore('outbox').reload();
    }});
  }
}, onTemplateChange:function(field, newValue) {
  var me = this, model = me.getViewModel();
  if (newValue && newValue.isModel) {
    Ext.Ajax.request({url:'/api/templates/' + newValue.id + '/preview', disableCaching:false, success:function(res) {
      model.set('preview', Ext.decode(res.responseText));
      setTimeout(me.resizePreview, 500);
    }});
  }
}, resizePreview:function() {
  var iframe = $('#previewFrame'), initialWidth = iframe.width();
  var newWidth, newHeight;
  var width = iframe.width();
  var height = iframe.height();
  var parentWidth = iframe.parent().width();
  var parentHeight = iframe.parent().height();
  var aspect = width / height;
  var parentAspect = parentWidth / parentHeight;
  if (aspect > parentAspect) {
    newWidth = parentWidth;
    newHeight = newWidth / aspect;
  } else {
    newHeight = parentHeight;
    newWidth = newHeight * aspect;
  }
  var scaleFactor = newWidth / initialWidth;
  iframe.css({'-webkit-transform':'scale(' + scaleFactor + ')'});
}});
Ext.define('MobileJudge.view.email.Inbox', {extend:Ext.dataview.List, xtype:'inbox', plugins:[{xclass:'Ext.plugin.PullRefresh'}, {xclass:'Ext.plugin.ListPaging', autoPaging:true}], cls:'email-list', disableSelection:true, itemTpl:new Ext.XTemplate('\x3cdiv class\x3d"inbox-item"\x3e', "\x3cdiv class\x3d\"inbox-inner-row inbox-{replied:pick('read','unread')}\"\x3e", '\x3cdiv class\x3d"list-cls inbox-from"\x3e{address}\x3c/div\x3e', '\x3cdiv class\x3d"inbox-date"\x3e', '{[this.formatDate(values.sent)]}', 
'\x3c/div\x3e', '\x3c/div\x3e', '\x3cdiv class\x3d"inbox-inner-row"\x3e', '\x3cdiv class\x3d"inbox-summary"\x3e{subject}\x3c/div\x3e', '\x3c/div\x3e' + '\x3c/div\x3e', {formatDate:function(date) {
  var check = new Date(date), today = new Date, start = new Date(today.getTime() + (-1 - today.getDay()) * 24 * 60 * 60 * 1000), end = new Date(today.getTime() + (6 - today.getDay()) * 24 * 60 * 60 * 1000), format = check.setHours(0, 0, 0, 0) == today.setHours(0, 0, 0, 0) ? 'g:i a' : start < date && date < end ? 'l' : 'M d';
  return Ext.Date.format(date, format);
}})});
Ext.define('MobileJudge.view.email.Index', {extend:Ext.Container, xtype:'email', controller:'email', viewModel:{type:'emailmobile'}, layout:{type:'hbox', align:'stretch'}, items:[{xtype:'button', iconCls:'x-fa fa-plus', ui:'bright-blue round', userCls:'pop-out', bind:{hidden:'{composing}'}, width:50, height:50, bottom:10, right:10, handler:'onPlusButtonTap'}, {xtype:'inbox', flex:1, bind:{store:'{outbox}', hidden:'{composing}'}, reference:'messages'}]});
Ext.define('MobileJudge.view.email.Model', {extend:Ext.app.ViewModel, alias:'viewmodel.emailmobile', stores:{outbox:{type:'outbox', storeId:'outbox'}, templates:{type:'templates', autoSync:false, storeId:'templates'}}, formulas:{previewMobile:{bind:{bindTo:'{preview.body}', deep:true}, get:function(html) {
  return 'data:text/html;charset\x3dUTF-8,' + encodeURIComponent(html);
}}, importJudges:{bind:{bindTo:'{template}', deep:true}, get:function(template) {
  if (!template || !template.isModel) {
    return false;
  }
  template = this.getStore('templates').getById(template.id);
  if (!template) {
    return false;
  }
  return template.get('body').indexOf('[[accept]]') >= 0;
}}}});
Ext.define('MobileJudge.view.judges.Home', {extend:Ext.Container, xtype:'judgehome', controller:'judge', viewModel:{type:'judge'}, cls:'dashboard', reference:'wizard', layout:'card', listeners:{activeitemchange:function(wzd, pnl) {
  var scroll = pnl.getScrollable();
  if (scroll) {
    scroll.scrollTo(null, 0);
  }
}}, items:[{xtype:'judgestudents'}, {xtype:'judgequestion'}]});
Ext.define('MobileJudge.view.judges.Question', {extend:Ext.Panel, xtype:'judgequestion', cls:'questionWizard shadow', scrollable:'y', bodyPadding:10, layout:{type:'vbox', align:'stretch'}, header:{titleAlign:'center'}, bind:{title:'{question.text}'}, items:[{xtype:'component', margin:'0 0 10 0', bind:'\x3cdiv class\x3d"search-user-item"\x3e' + '\x3cdiv class\x3d"search-user-image"\x3e' + '\x3cimg src\x3d"{student.profileImgUrl}" class\x3d"circular" width\x3d"50" height\x3d"50" /\x3e' + '\x3c/div\x3e' + 
'\x3cdiv class\x3d"search-user-content"\x3e' + '\x3cdiv class\x3d"search-user-title"\x3e{student.fullName}\x3c/div\x3e' + '\x3cdiv class\x3d"search-user-email"\x3e{student.project}\x3c/div\x3e' + '\x3cdiv class\x3d"search-user-date"\x3e{student.location}\x3c/div\x3e' + '\x3c/div\x3e' + '\x3c/div\x3e'}, {xtype:'component', html:'Grade'}, {xtype:'container', layout:'hbox', items:[{xtype:'sliderfield', name:'grade', flex:1, increment:1, minValue:1, bind:{value:'{grade.value}', maxValue:'{question.value}', 
hidden:'{isAccepted}'}}, {xtype:'container', padding:'14 0', bind:{html:'{gradeDisplay}'}}]}, {xtype:'component', margin:'0 0 5 0', html:'Comments'}, {xtype:'textareafield', name:'comment', bind:{value:'{grade.comment}', hidden:'{isAccepted}'}}, {xtype:'component', bind:{html:'{grade.comment}', hidden:'{!isAccepted}'}}, {xtype:'container', margin:'10 0', layout:'hbox', items:[{html:'\x3cdiv\x3e\x3c/div\x3e', flex:1}, {xtype:'button', ui:'soft-blue', iconCls:'x-fa fa-angle-left', text:'Back', handler:'onPrevBtn'}, 
{html:'\x3cdiv\x3e\x3c/div\x3e', flex:1}, {xtype:'button', ui:'soft-blue', iconAlign:'right', handler:'onNextBtn', bind:{text:'{next.text}', iconCls:'{next.icon}'}}, {html:'\x3cdiv\x3e\x3c/div\x3e', flex:1}]}]});
Ext.define('MobileJudge.view.judges.Students', {extend:Ext.Panel, xtype:'judgestudents', layout:'vbox', title:'Students', items:[{xtype:'list', cls:'studentSelector', disableSelection:true, flex:1, plugins:[{xclass:'Ext.plugin.PullRefresh'}], bind:{store:'{students}'}, listeners:{itemtap:'onItemTap'}, itemTpl:'\x3cdiv class\x3d"search-user-item"\x3e' + '\x3cdiv class\x3d"search-user-image"\x3e' + '\x3cimg src\x3d"{profileImgUrl}" class\x3d"circular" width\x3d"50" height\x3d"50"/\x3e' + '\x3c/div\x3e' + 
'\x3cdiv class\x3d"search-user-icon {iconCls}"\x3e\x3c/div\x3e' + '\x3cdiv class\x3d"search-user-content"\x3e' + '\x3cdiv class\x3d"search-user-title"\x3e{fullName}\x3c/div\x3e' + '\x3cdiv class\x3d"search-user-email"\x3e{project}\x3c/div\x3e' + '\x3cdiv class\x3d"search-user-date"\x3e{location}\x3c/div\x3e' + '\x3c/div\x3e' + '\x3c/div\x3e'}]});
Ext.define('MobileJudge.view.main.Controller', {extend:MobileJudge.view.main.BaseController, alias:'controller.main', config:{showNavigation:true}, collapsedCls:'main-nav-collapsed', slidOutCls:'main-nav-slid-out', showNavigation:false, init:function(view) {
  var me = this, refs = me.getReferences(), logo = refs.logo, nav = refs.navigation;
  me.nav = nav;
  me.callParent([view]);
  nav.getParent().remove(nav, false);
  nav.addCls(['x-floating', 'main-nav-floated', me.slidOutCls]);
  nav.setScrollable(true);
  nav.getRefOwner = function() {
    return view;
  };
  nav.add(logo);
  logo.setDocked('top');
  Ext.getBody().appendChild(nav.element);
}, onNavigationItemClick:function(tree, info) {
  if (info.select) {
    this.setShowNavigation(false);
  }
}, onNavigationTreeSelectionChange:function(tree, node) {
  this.setShowNavigation(false);
  this.callParent(arguments);
}, onToggleNavigationSize:function() {
  this.setShowNavigation(!this.getShowNavigation());
}, updateShowNavigation:function(showNavigation, oldValue) {
  if (oldValue !== undefined) {
    var me = this, nav = me.nav, mask = me.mask;
    if (showNavigation) {
      me.mask = mask = Ext.Viewport.add({xtype:'loadmask', userCls:'main-nav-mask'});
      mask.element.on({tap:me.onToggleNavigationSize, scope:me, single:true});
    } else {
      if (mask) {
        mask.destroy();
        me.mask = null;
      }
    }
    nav.toggleCls(me.slidOutCls, !showNavigation);
  }
}, setCurrentView:function(hashTag) {
  hashTag = (hashTag || '').toLowerCase();
  var me = this, refs = me.getReferences(), isLockScreen = Ext.Array.contains(me.commonPages, hashTag), mainCard = refs.mainCard, navigationTree = refs.navigationTree, store = navigationTree.getStore();
  if (!me.isMenuLoaded() && !isLockScreen) {
    return;
  }
  var node = store.findNode('routeId', hashTag) || store.findNode('viewType', hashTag), view = isLockScreen ? hashTag : node && (node.get('viewType') || node.get('routeId')) || 'page404', existingItem = mainCard.child('component[routeId\x3d' + hashTag + ']'), newView;
  refs.maintoolbar.setHidden(isLockScreen);
  if (!existingItem) {
    try {
      newView = mainCard.add({xtype:view, routeId:hashTag});
    } catch (e$28) {
      console.log(e$28);
      newView = mainCard.add({xtype:'page404', routeId:hashTag});
    }
  } else {
    newView = existingItem;
  }
  mainCard.setActiveItem(newView);
  navigationTree.setSelection(node);
}});
Ext.define('MobileJudge.view.main.Toolbar', {extend:Ext.Toolbar, xtype:'maintoolbar', items:[{xtype:'component', reference:'logo', userCls:'main-logo', html:'Mobile Judge'}, {xtype:'button', ui:'header', iconCls:'x-fa fa-bars', margin:'0 0 0 10', listeners:{tap:'onToggleNavigationSize'}}, {xtype:'component', bind:{html:'{activeTerm}'}, margin:'0 12 0 4', userCls:'main-user-name'}, '-\x3e', {xtype:'image', userCls:'main-user-image small-image circular', bind:{src:'{profilePic}'}}, {iconCls:'x-fa fa-sign-out', 
ui:'header', handler:'onLogout', tooltip:'Logout'}]});
Ext.define('MobileJudge.view.pages.BlankPage', {extend:Ext.Container, xtype:'pageblank', layout:{type:'vbox', pack:'center', align:'center'}, items:[{cls:'blank-page-container', html:"\x3cdiv class\x3d'fa-outer-class'\x3e\x3cspan class\x3d'x-fa fa-clock-o'\x3e\x3c/span\x3e\x3c/div\x3e" + "\x3ch1\x3eComing Soon!\x3c/h1\x3e\x3cspan class\x3d'blank-page-text'\x3eStay tuned for updates\x3c/span\x3e"}]});
Ext.define('MobileJudge.view.pages.ErrorBase', {extend:Ext.Container, layout:{type:'vbox', align:'center', pack:'center'}, cls:'error-page-container', defaults:{xtype:'label'}});
Ext.define('MobileJudge.view.pages.Error404', {extend:MobileJudge.view.pages.ErrorBase, xtype:'page404', items:[{cls:'error-page-top-text', html:'404'}, {cls:'error-page-desc', html:"\x3cp\x3eSeems you've hit a wall!\x3c/p\x3e\x3cp\x3eTry going back to our " + '\x3ca href\x3d"#home"\x3e Home page \x3c/a\x3e\x3c/p\x3e'}]});
Ext.define('MobileJudge.view.pages.Error500', {extend:MobileJudge.view.pages.ErrorBase, xtype:'page500', items:[{cls:'error-page-top-text', html:'500'}, {cls:'error-page-desc', html:'\x3cp\x3eSomething went wrong and server could not process your request.\x3c/p\x3e' + '\x3cp\x3eTry going back to our \x3ca href\x3d"#home"\x3e Home page \x3c/a\x3e\x3c/p\x3e'}]});
Ext.define('MobileJudge.view.pages.Map', {extend:Ext.TabPanel, xtype:'eventmap', listeners:{initialize:function(panel) {
  Ext.Ajax.request({url:'/api/maps', success:function(resp) {
    var locations = Ext.decode(resp.responseText);
    panel.add(locations.map(function(l) {
      return {xtype:'imageviewer', iconCls:'x-fa fa-map-o', title:l.name, imageSrc:l.url};
    }));
  }});
}}});
Ext.define('MobileJudge.view.students.Home', {extend:Ext.Container, xtype:'studenthome', cls:'userProfile-container dashboard', scrollable:'y', controller:'student', viewModel:{data:{}}, items:[{xtype:'profile', userCls:'big-100 small-100 dashboard-item shadow'}]});
(function(global, factory) {
  if (typeof module === 'object' && typeof module.exports === 'object') {
    module.exports = global.document ? factory(global, true) : function(w) {
      if (!w.document) {
        throw new Error('jQuery requires a window with a document');
      }
      return factory(w);
    };
  } else {
    factory(global);
  }
})(typeof window !== 'undefined' ? window : this, function(window, noGlobal) {
  var deletedIds = [];
  var slice = deletedIds.slice;
  var concat = deletedIds.concat;
  var push = deletedIds.push;
  var indexOf = deletedIds.indexOf;
  var class2type = {};
  var toString = class2type.toString;
  var hasOwn = class2type.hasOwnProperty;
  var support = {};
  var version = '1.11.1', jQuery = function(selector, context) {
    return new jQuery.fn.init(selector, context);
  }, rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, rmsPrefix = /^-ms-/, rdashAlpha = /-([\da-z])/gi, fcamelCase = function(all, letter) {
    return letter.toUpperCase();
  };
  jQuery.fn = jQuery.prototype = {jquery:version, constructor:jQuery, selector:'', length:0, toArray:function() {
    return slice.call(this);
  }, get:function(num) {
    return num != null ? num < 0 ? this[num + this.length] : this[num] : slice.call(this);
  }, pushStack:function(elems) {
    var ret = jQuery.merge(this.constructor(), elems);
    ret.prevObject = this;
    ret.context = this.context;
    return ret;
  }, each:function(callback, args) {
    return jQuery.each(this, callback, args);
  }, map:function(callback) {
    return this.pushStack(jQuery.map(this, function(elem, i) {
      return callback.call(elem, i, elem);
    }));
  }, slice:function() {
    return this.pushStack(slice.apply(this, arguments));
  }, first:function() {
    return this.eq(0);
  }, last:function() {
    return this.eq(-1);
  }, eq:function(i) {
    var len = this.length, j = +i + (i < 0 ? len : 0);
    return this.pushStack(j >= 0 && j < len ? [this[j]] : []);
  }, end:function() {
    return this.prevObject || this.constructor(null);
  }, push:push, sort:deletedIds.sort, splice:deletedIds.splice};
  jQuery.extend = jQuery.fn.extend = function() {
    var src, copyIsArray, copy, name, options, clone, target = arguments[0] || {}, i = 1, length = arguments.length, deep = false;
    if (typeof target === 'boolean') {
      deep = target;
      target = arguments[i] || {};
      i++;
    }
    if (typeof target !== 'object' && !jQuery.isFunction(target)) {
      target = {};
    }
    if (i === length) {
      target = this;
      i--;
    }
    for (; i < length; i++) {
      if ((options = arguments[i]) != null) {
        for (name in options) {
          src = target[name];
          copy = options[name];
          if (target === copy) {
            continue;
          }
          if (deep && copy && (jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)))) {
            if (copyIsArray) {
              copyIsArray = false;
              clone = src && jQuery.isArray(src) ? src : [];
            } else {
              clone = src && jQuery.isPlainObject(src) ? src : {};
            }
            target[name] = jQuery.extend(deep, clone, copy);
          } else {
            if (copy !== undefined) {
              target[name] = copy;
            }
          }
        }
      }
    }
    return target;
  };
  jQuery.extend({expando:'jQuery' + (version + Math.random()).replace(/\D/g, ''), isReady:true, error:function(msg) {
    throw new Error(msg);
  }, noop:function() {
  }, isFunction:function(obj) {
    return jQuery.type(obj) === 'function';
  }, isArray:Array.isArray || function(obj) {
    return jQuery.type(obj) === 'array';
  }, isWindow:function(obj) {
    return obj != null && obj == obj.window;
  }, isNumeric:function(obj) {
    return !jQuery.isArray(obj) && obj - parseFloat(obj) >= 0;
  }, isEmptyObject:function(obj) {
    var name;
    for (name in obj) {
      return false;
    }
    return true;
  }, isPlainObject:function(obj) {
    var key;
    if (!obj || jQuery.type(obj) !== 'object' || obj.nodeType || jQuery.isWindow(obj)) {
      return false;
    }
    try {
      if (obj.constructor && !hasOwn.call(obj, 'constructor') && !hasOwn.call(obj.constructor.prototype, 'isPrototypeOf')) {
        return false;
      }
    } catch (e$29) {
      return false;
    }
    if (support.ownLast) {
      for (key in obj) {
        return hasOwn.call(obj, key);
      }
    }
    for (key in obj) {
    }
    return key === undefined || hasOwn.call(obj, key);
  }, type:function(obj) {
    if (obj == null) {
      return obj + '';
    }
    return typeof obj === 'object' || typeof obj === 'function' ? class2type[toString.call(obj)] || 'object' : typeof obj;
  }, globalEval:function(data) {
    if (data && jQuery.trim(data)) {
      (window.execScript || function(data) {
        window['eval'].call(window, data);
      })(data);
    }
  }, camelCase:function(string) {
    return string.replace(rmsPrefix, 'ms-').replace(rdashAlpha, fcamelCase);
  }, nodeName:function(elem, name) {
    return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
  }, each:function(obj, callback, args) {
    var value, i = 0, length = obj.length, isArray = isArraylike(obj);
    if (args) {
      if (isArray) {
        for (; i < length; i++) {
          value = callback.apply(obj[i], args);
          if (value === false) {
            break;
          }
        }
      } else {
        for (i in obj) {
          value = callback.apply(obj[i], args);
          if (value === false) {
            break;
          }
        }
      }
    } else {
      if (isArray) {
        for (; i < length; i++) {
          value = callback.call(obj[i], i, obj[i]);
          if (value === false) {
            break;
          }
        }
      } else {
        for (i in obj) {
          value = callback.call(obj[i], i, obj[i]);
          if (value === false) {
            break;
          }
        }
      }
    }
    return obj;
  }, trim:function(text) {
    return text == null ? '' : (text + '').replace(rtrim, '');
  }, makeArray:function(arr, results) {
    var ret = results || [];
    if (arr != null) {
      if (isArraylike(Object(arr))) {
        jQuery.merge(ret, typeof arr === 'string' ? [arr] : arr);
      } else {
        push.call(ret, arr);
      }
    }
    return ret;
  }, inArray:function(elem, arr, i) {
    var len;
    if (arr) {
      if (indexOf) {
        return indexOf.call(arr, elem, i);
      }
      len = arr.length;
      i = i ? i < 0 ? Math.max(0, len + i) : i : 0;
      for (; i < len; i++) {
        if (i in arr && arr[i] === elem) {
          return i;
        }
      }
    }
    return -1;
  }, merge:function(first, second) {
    var len = +second.length, j = 0, i = first.length;
    while (j < len) {
      first[i++] = second[j++];
    }
    if (len !== len) {
      while (second[j] !== undefined) {
        first[i++] = second[j++];
      }
    }
    first.length = i;
    return first;
  }, grep:function(elems, callback, invert) {
    var callbackInverse, matches = [], i = 0, length = elems.length, callbackExpect = !invert;
    for (; i < length; i++) {
      callbackInverse = !callback(elems[i], i);
      if (callbackInverse !== callbackExpect) {
        matches.push(elems[i]);
      }
    }
    return matches;
  }, map:function(elems, callback, arg) {
    var value, i = 0, length = elems.length, isArray = isArraylike(elems), ret = [];
    if (isArray) {
      for (; i < length; i++) {
        value = callback(elems[i], i, arg);
        if (value != null) {
          ret.push(value);
        }
      }
    } else {
      for (i in elems) {
        value = callback(elems[i], i, arg);
        if (value != null) {
          ret.push(value);
        }
      }
    }
    return concat.apply([], ret);
  }, guid:1, proxy:function(fn, context) {
    var args, proxy, tmp;
    if (typeof context === 'string') {
      tmp = fn[context];
      context = fn;
      fn = tmp;
    }
    if (!jQuery.isFunction(fn)) {
      return undefined;
    }
    args = slice.call(arguments, 2);
    proxy = function() {
      return fn.apply(context || this, args.concat(slice.call(arguments)));
    };
    proxy.guid = fn.guid = fn.guid || jQuery.guid++;
    return proxy;
  }, now:function() {
    return +new Date;
  }, support:support});
  jQuery.each('Boolean Number String Function Array Date RegExp Object Error'.split(' '), function(i, name) {
    class2type['[object ' + name + ']'] = name.toLowerCase();
  });
  function isArraylike(obj) {
    var length = obj.length, type = jQuery.type(obj);
    if (type === 'function' || jQuery.isWindow(obj)) {
      return false;
    }
    if (obj.nodeType === 1 && length) {
      return true;
    }
    return type === 'array' || length === 0 || typeof length === 'number' && length > 0 && length - 1 in obj;
  }
  var Sizzle = function(window) {
    var i, support, Expr, getText, isXML, tokenize, compile, select, outermostContext, sortInput, hasDuplicate, setDocument, document, docElem, documentIsHTML, rbuggyQSA, rbuggyMatches, matches, contains, expando = 'sizzle' + -new Date, preferredDoc = window.document, dirruns = 0, done = 0, classCache = createCache(), tokenCache = createCache(), compilerCache = createCache(), sortOrder = function(a, b) {
      if (a === b) {
        hasDuplicate = true;
      }
      return 0;
    }, strundefined = typeof undefined, MAX_NEGATIVE = 1 << 31, hasOwn = {}.hasOwnProperty, arr = [], pop = arr.pop, push_native = arr.push, push = arr.push, slice = arr.slice, indexOf = arr.indexOf || function(elem) {
      var i = 0, len = this.length;
      for (; i < len; i++) {
        if (this[i] === elem) {
          return i;
        }
      }
      return -1;
    }, booleans = 'checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped', whitespace = '[\\x20\\t\\r\\n\\f]', characterEncoding = '(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+', identifier = characterEncoding.replace('w', 'w#'), attributes = '\\[' + whitespace + '*(' + characterEncoding + ')(?:' + whitespace + '*([*^$|!~]?\x3d)' + whitespace + '*(?:\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)"|(' + identifier + '))|)' + whitespace + '*\\]', 
    pseudos = ':(' + characterEncoding + ')(?:\\((' + '(\'((?:\\\\.|[^\\\\\'])*)\'|"((?:\\\\.|[^\\\\"])*)")|' + '((?:\\\\.|[^\\\\()[\\]]|' + attributes + ')*)|' + '.*' + ')\\)|)', rtrim = new RegExp('^' + whitespace + '+|((?:^|[^\\\\])(?:\\\\.)*)' + whitespace + '+$', 'g'), rcomma = new RegExp('^' + whitespace + '*,' + whitespace + '*'), rcombinators = new RegExp('^' + whitespace + '*([\x3e+~]|' + whitespace + ')' + whitespace + '*'), rattributeQuotes = new RegExp('\x3d' + whitespace + '*([^\\]\'"]*?)' + 
    whitespace + '*\\]', 'g'), rpseudo = new RegExp(pseudos), ridentifier = new RegExp('^' + identifier + '$'), matchExpr = {'ID':new RegExp('^#(' + characterEncoding + ')'), 'CLASS':new RegExp('^\\.(' + characterEncoding + ')'), 'TAG':new RegExp('^(' + characterEncoding.replace('w', 'w*') + ')'), 'ATTR':new RegExp('^' + attributes), 'PSEUDO':new RegExp('^' + pseudos), 'CHILD':new RegExp('^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(' + whitespace + '*(even|odd|(([+-]|)(\\d*)n|)' + whitespace + 
    '*(?:([+-]|)' + whitespace + '*(\\d+)|))' + whitespace + '*\\)|)', 'i'), 'bool':new RegExp('^(?:' + booleans + ')$', 'i'), 'needsContext':new RegExp('^' + whitespace + '*[\x3e+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(' + whitespace + '*((?:-\\d)?\\d*)' + whitespace + '*\\)|)(?\x3d[^-]|$)', 'i')}, rinputs = /^(?:input|select|textarea|button)$/i, rheader = /^h\d$/i, rnative = /^[^{]+\{\s*\[native \w/, rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/, rsibling = /[+~]/, rescape = /'|\\/g, runescape = 
    new RegExp('\\\\([\\da-f]{1,6}' + whitespace + '?|(' + whitespace + ')|.)', 'ig'), funescape = function(_, escaped, escapedWhitespace) {
      var high = '0x' + escaped - 65536;
      return high !== high || escapedWhitespace ? escaped : high < 0 ? String.fromCharCode(high + 65536) : String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320);
    };
    try {
      push.apply(arr = slice.call(preferredDoc.childNodes), preferredDoc.childNodes);
      arr[preferredDoc.childNodes.length].nodeType;
    } catch (e$30) {
      push = {apply:arr.length ? function(target, els) {
        push_native.apply(target, slice.call(els));
      } : function(target, els) {
        var j = target.length, i = 0;
        while (target[j++] = els[i++]) {
        }
        target.length = j - 1;
      }};
    }
    function Sizzle(selector, context, results, seed) {
      var match, elem, m, nodeType, i, groups, old, nid, newContext, newSelector;
      if ((context ? context.ownerDocument || context : preferredDoc) !== document) {
        setDocument(context);
      }
      context = context || document;
      results = results || [];
      if (!selector || typeof selector !== 'string') {
        return results;
      }
      if ((nodeType = context.nodeType) !== 1 && nodeType !== 9) {
        return [];
      }
      if (documentIsHTML && !seed) {
        if (match = rquickExpr.exec(selector)) {
          if (m = match[1]) {
            if (nodeType === 9) {
              elem = context.getElementById(m);
              if (elem && elem.parentNode) {
                if (elem.id === m) {
                  results.push(elem);
                  return results;
                }
              } else {
                return results;
              }
            } else {
              if (context.ownerDocument && (elem = context.ownerDocument.getElementById(m)) && contains(context, elem) && elem.id === m) {
                results.push(elem);
                return results;
              }
            }
          } else {
            if (match[2]) {
              push.apply(results, context.getElementsByTagName(selector));
              return results;
            } else {
              if ((m = match[3]) && support.getElementsByClassName && context.getElementsByClassName) {
                push.apply(results, context.getElementsByClassName(m));
                return results;
              }
            }
          }
        }
        if (support.qsa && (!rbuggyQSA || !rbuggyQSA.test(selector))) {
          nid = old = expando;
          newContext = context;
          newSelector = nodeType === 9 && selector;
          if (nodeType === 1 && context.nodeName.toLowerCase() !== 'object') {
            groups = tokenize(selector);
            if (old = context.getAttribute('id')) {
              nid = old.replace(rescape, '\\$\x26');
            } else {
              context.setAttribute('id', nid);
            }
            nid = "[id\x3d'" + nid + "'] ";
            i = groups.length;
            while (i--) {
              groups[i] = nid + toSelector(groups[i]);
            }
            newContext = rsibling.test(selector) && testContext(context.parentNode) || context;
            newSelector = groups.join(',');
          }
          if (newSelector) {
            try {
              push.apply(results, newContext.querySelectorAll(newSelector));
              return results;
            } catch (qsaError) {
            } finally {
              if (!old) {
                context.removeAttribute('id');
              }
            }
          }
        }
      }
      return select(selector.replace(rtrim, '$1'), context, results, seed);
    }
    function createCache() {
      var keys = [];
      function cache(key, value) {
        if (keys.push(key + ' ') > Expr.cacheLength) {
          delete cache[keys.shift()];
        }
        return cache[key + ' '] = value;
      }
      return cache;
    }
    function markFunction(fn) {
      fn[expando] = true;
      return fn;
    }
    function assert(fn) {
      var div = document.createElement('div');
      try {
        return !!fn(div);
      } catch (e$31) {
        return false;
      } finally {
        if (div.parentNode) {
          div.parentNode.removeChild(div);
        }
        div = null;
      }
    }
    function addHandle(attrs, handler) {
      var arr = attrs.split('|'), i = attrs.length;
      while (i--) {
        Expr.attrHandle[arr[i]] = handler;
      }
    }
    function siblingCheck(a, b) {
      var cur = b && a, diff = cur && a.nodeType === 1 && b.nodeType === 1 && (~b.sourceIndex || MAX_NEGATIVE) - (~a.sourceIndex || MAX_NEGATIVE);
      if (diff) {
        return diff;
      }
      if (cur) {
        while (cur = cur.nextSibling) {
          if (cur === b) {
            return -1;
          }
        }
      }
      return a ? 1 : -1;
    }
    function createInputPseudo(type) {
      return function(elem) {
        var name = elem.nodeName.toLowerCase();
        return name === 'input' && elem.type === type;
      };
    }
    function createButtonPseudo(type) {
      return function(elem) {
        var name = elem.nodeName.toLowerCase();
        return (name === 'input' || name === 'button') && elem.type === type;
      };
    }
    function createPositionalPseudo(fn) {
      return markFunction(function(argument) {
        argument = +argument;
        return markFunction(function(seed, matches) {
          var j, matchIndexes = fn([], seed.length, argument), i = matchIndexes.length;
          while (i--) {
            if (seed[j = matchIndexes[i]]) {
              seed[j] = !(matches[j] = seed[j]);
            }
          }
        });
      });
    }
    function testContext(context) {
      return context && typeof context.getElementsByTagName !== strundefined && context;
    }
    support = Sizzle.support = {};
    isXML = Sizzle.isXML = function(elem) {
      var documentElement = elem && (elem.ownerDocument || elem).documentElement;
      return documentElement ? documentElement.nodeName !== 'HTML' : false;
    };
    setDocument = Sizzle.setDocument = function(node) {
      var hasCompare, doc = node ? node.ownerDocument || node : preferredDoc, parent = doc.defaultView;
      if (doc === document || doc.nodeType !== 9 || !doc.documentElement) {
        return document;
      }
      document = doc;
      docElem = doc.documentElement;
      documentIsHTML = !isXML(doc);
      if (parent && parent !== parent.top) {
        if (parent.addEventListener) {
          parent.addEventListener('unload', function() {
            setDocument();
          }, false);
        } else {
          if (parent.attachEvent) {
            parent.attachEvent('onunload', function() {
              setDocument();
            });
          }
        }
      }
      support.attributes = assert(function(div) {
        div.className = 'i';
        return !div.getAttribute('className');
      });
      support.getElementsByTagName = assert(function(div) {
        div.appendChild(doc.createComment(''));
        return !div.getElementsByTagName('*').length;
      });
      support.getElementsByClassName = rnative.test(doc.getElementsByClassName) && assert(function(div) {
        div.innerHTML = "\x3cdiv class\x3d'a'\x3e\x3c/div\x3e\x3cdiv class\x3d'a i'\x3e\x3c/div\x3e";
        div.firstChild.className = 'i';
        return div.getElementsByClassName('i').length === 2;
      });
      support.getById = assert(function(div) {
        docElem.appendChild(div).id = expando;
        return !doc.getElementsByName || !doc.getElementsByName(expando).length;
      });
      if (support.getById) {
        Expr.find['ID'] = function(id, context) {
          if (typeof context.getElementById !== strundefined && documentIsHTML) {
            var m = context.getElementById(id);
            return m && m.parentNode ? [m] : [];
          }
        };
        Expr.filter['ID'] = function(id) {
          var attrId = id.replace(runescape, funescape);
          return function(elem) {
            return elem.getAttribute('id') === attrId;
          };
        };
      } else {
        delete Expr.find['ID'];
        Expr.filter['ID'] = function(id) {
          var attrId = id.replace(runescape, funescape);
          return function(elem) {
            var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode('id');
            return node && node.value === attrId;
          };
        };
      }
      Expr.find['TAG'] = support.getElementsByTagName ? function(tag, context) {
        if (typeof context.getElementsByTagName !== strundefined) {
          return context.getElementsByTagName(tag);
        }
      } : function(tag, context) {
        var elem, tmp = [], i = 0, results = context.getElementsByTagName(tag);
        if (tag === '*') {
          while (elem = results[i++]) {
            if (elem.nodeType === 1) {
              tmp.push(elem);
            }
          }
          return tmp;
        }
        return results;
      };
      Expr.find['CLASS'] = support.getElementsByClassName && function(className, context) {
        if (typeof context.getElementsByClassName !== strundefined && documentIsHTML) {
          return context.getElementsByClassName(className);
        }
      };
      rbuggyMatches = [];
      rbuggyQSA = [];
      if (support.qsa = rnative.test(doc.querySelectorAll)) {
        assert(function(div) {
          div.innerHTML = "\x3cselect msallowclip\x3d''\x3e\x3coption selected\x3d''\x3e\x3c/option\x3e\x3c/select\x3e";
          if (div.querySelectorAll("[msallowclip^\x3d'']").length) {
            rbuggyQSA.push('[*^$]\x3d' + whitespace + '*(?:\'\'|"")');
          }
          if (!div.querySelectorAll('[selected]').length) {
            rbuggyQSA.push('\\[' + whitespace + '*(?:value|' + booleans + ')');
          }
          if (!div.querySelectorAll(':checked').length) {
            rbuggyQSA.push(':checked');
          }
        });
        assert(function(div) {
          var input = doc.createElement('input');
          input.setAttribute('type', 'hidden');
          div.appendChild(input).setAttribute('name', 'D');
          if (div.querySelectorAll('[name\x3dd]').length) {
            rbuggyQSA.push('name' + whitespace + '*[*^$|!~]?\x3d');
          }
          if (!div.querySelectorAll(':enabled').length) {
            rbuggyQSA.push(':enabled', ':disabled');
          }
          div.querySelectorAll('*,:x');
          rbuggyQSA.push(',.*:');
        });
      }
      if (support.matchesSelector = rnative.test(matches = docElem.matches || docElem.webkitMatchesSelector || docElem.mozMatchesSelector || docElem.oMatchesSelector || docElem.msMatchesSelector)) {
        assert(function(div) {
          support.disconnectedMatch = matches.call(div, 'div');
          matches.call(div, "[s!\x3d'']:x");
          rbuggyMatches.push('!\x3d', pseudos);
        });
      }
      rbuggyQSA = rbuggyQSA.length && new RegExp(rbuggyQSA.join('|'));
      rbuggyMatches = rbuggyMatches.length && new RegExp(rbuggyMatches.join('|'));
      hasCompare = rnative.test(docElem.compareDocumentPosition);
      contains = hasCompare || rnative.test(docElem.contains) ? function(a, b) {
        var adown = a.nodeType === 9 ? a.documentElement : a, bup = b && b.parentNode;
        return a === bup || !!(bup && bup.nodeType === 1 && (adown.contains ? adown.contains(bup) : a.compareDocumentPosition && a.compareDocumentPosition(bup) & 16));
      } : function(a, b) {
        if (b) {
          while (b = b.parentNode) {
            if (b === a) {
              return true;
            }
          }
        }
        return false;
      };
      sortOrder = hasCompare ? function(a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
        if (compare) {
          return compare;
        }
        compare = (a.ownerDocument || a) === (b.ownerDocument || b) ? a.compareDocumentPosition(b) : 1;
        if (compare & 1 || !support.sortDetached && b.compareDocumentPosition(a) === compare) {
          if (a === doc || a.ownerDocument === preferredDoc && contains(preferredDoc, a)) {
            return -1;
          }
          if (b === doc || b.ownerDocument === preferredDoc && contains(preferredDoc, b)) {
            return 1;
          }
          return sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
        }
        return compare & 4 ? -1 : 1;
      } : function(a, b) {
        if (a === b) {
          hasDuplicate = true;
          return 0;
        }
        var cur, i = 0, aup = a.parentNode, bup = b.parentNode, ap = [a], bp = [b];
        if (!aup || !bup) {
          return a === doc ? -1 : b === doc ? 1 : aup ? -1 : bup ? 1 : sortInput ? indexOf.call(sortInput, a) - indexOf.call(sortInput, b) : 0;
        } else {
          if (aup === bup) {
            return siblingCheck(a, b);
          }
        }
        cur = a;
        while (cur = cur.parentNode) {
          ap.unshift(cur);
        }
        cur = b;
        while (cur = cur.parentNode) {
          bp.unshift(cur);
        }
        while (ap[i] === bp[i]) {
          i++;
        }
        return i ? siblingCheck(ap[i], bp[i]) : ap[i] === preferredDoc ? -1 : bp[i] === preferredDoc ? 1 : 0;
      };
      return doc;
    };
    Sizzle.matches = function(expr, elements) {
      return Sizzle(expr, null, null, elements);
    };
    Sizzle.matchesSelector = function(elem, expr) {
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      expr = expr.replace(rattributeQuotes, "\x3d'$1']");
      if (support.matchesSelector && documentIsHTML && (!rbuggyMatches || !rbuggyMatches.test(expr)) && (!rbuggyQSA || !rbuggyQSA.test(expr))) {
        try {
          var ret = matches.call(elem, expr);
          if (ret || support.disconnectedMatch || elem.document && elem.document.nodeType !== 11) {
            return ret;
          }
        } catch (e$32) {
        }
      }
      return Sizzle(expr, document, null, [elem]).length > 0;
    };
    Sizzle.contains = function(context, elem) {
      if ((context.ownerDocument || context) !== document) {
        setDocument(context);
      }
      return contains(context, elem);
    };
    Sizzle.attr = function(elem, name) {
      if ((elem.ownerDocument || elem) !== document) {
        setDocument(elem);
      }
      var fn = Expr.attrHandle[name.toLowerCase()], val = fn && hasOwn.call(Expr.attrHandle, name.toLowerCase()) ? fn(elem, name, !documentIsHTML) : undefined;
      return val !== undefined ? val : support.attributes || !documentIsHTML ? elem.getAttribute(name) : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
    };
    Sizzle.error = function(msg) {
      throw new Error('Syntax error, unrecognized expression: ' + msg);
    };
    Sizzle.uniqueSort = function(results) {
      var elem, duplicates = [], j = 0, i = 0;
      hasDuplicate = !support.detectDuplicates;
      sortInput = !support.sortStable && results.slice(0);
      results.sort(sortOrder);
      if (hasDuplicate) {
        while (elem = results[i++]) {
          if (elem === results[i]) {
            j = duplicates.push(i);
          }
        }
        while (j--) {
          results.splice(duplicates[j], 1);
        }
      }
      sortInput = null;
      return results;
    };
    getText = Sizzle.getText = function(elem) {
      var node, ret = '', i = 0, nodeType = elem.nodeType;
      if (!nodeType) {
        while (node = elem[i++]) {
          ret += getText(node);
        }
      } else {
        if (nodeType === 1 || nodeType === 9 || nodeType === 11) {
          if (typeof elem.textContent === 'string') {
            return elem.textContent;
          } else {
            for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
              ret += getText(elem);
            }
          }
        } else {
          if (nodeType === 3 || nodeType === 4) {
            return elem.nodeValue;
          }
        }
      }
      return ret;
    };
    Expr = Sizzle.selectors = {cacheLength:50, createPseudo:markFunction, match:matchExpr, attrHandle:{}, find:{}, relative:{'\x3e':{dir:'parentNode', first:true}, ' ':{dir:'parentNode'}, '+':{dir:'previousSibling', first:true}, '~':{dir:'previousSibling'}}, preFilter:{'ATTR':function(match) {
      match[1] = match[1].replace(runescape, funescape);
      match[3] = (match[3] || match[4] || match[5] || '').replace(runescape, funescape);
      if (match[2] === '~\x3d') {
        match[3] = ' ' + match[3] + ' ';
      }
      return match.slice(0, 4);
    }, 'CHILD':function(match) {
      match[1] = match[1].toLowerCase();
      if (match[1].slice(0, 3) === 'nth') {
        if (!match[3]) {
          Sizzle.error(match[0]);
        }
        match[4] = +(match[4] ? match[5] + (match[6] || 1) : 2 * (match[3] === 'even' || match[3] === 'odd'));
        match[5] = +(match[7] + match[8] || match[3] === 'odd');
      } else {
        if (match[3]) {
          Sizzle.error(match[0]);
        }
      }
      return match;
    }, 'PSEUDO':function(match) {
      var excess, unquoted = !match[6] && match[2];
      if (matchExpr['CHILD'].test(match[0])) {
        return null;
      }
      if (match[3]) {
        match[2] = match[4] || match[5] || '';
      } else {
        if (unquoted && rpseudo.test(unquoted) && (excess = tokenize(unquoted, true)) && (excess = unquoted.indexOf(')', unquoted.length - excess) - unquoted.length)) {
          match[0] = match[0].slice(0, excess);
          match[2] = unquoted.slice(0, excess);
        }
      }
      return match.slice(0, 3);
    }}, filter:{'TAG':function(nodeNameSelector) {
      var nodeName = nodeNameSelector.replace(runescape, funescape).toLowerCase();
      return nodeNameSelector === '*' ? function() {
        return true;
      } : function(elem) {
        return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
      };
    }, 'CLASS':function(className) {
      var pattern = classCache[className + ' '];
      return pattern || (pattern = new RegExp('(^|' + whitespace + ')' + className + '(' + whitespace + '|$)')) && classCache(className, function(elem) {
        return pattern.test(typeof elem.className === 'string' && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute('class') || '');
      });
    }, 'ATTR':function(name, operator, check) {
      return function(elem) {
        var result = Sizzle.attr(elem, name);
        if (result == null) {
          return operator === '!\x3d';
        }
        if (!operator) {
          return true;
        }
        result += '';
        return operator === '\x3d' ? result === check : operator === '!\x3d' ? result !== check : operator === '^\x3d' ? check && result.indexOf(check) === 0 : operator === '*\x3d' ? check && result.indexOf(check) > -1 : operator === '$\x3d' ? check && result.slice(-check.length) === check : operator === '~\x3d' ? (' ' + result + ' ').indexOf(check) > -1 : operator === '|\x3d' ? result === check || result.slice(0, check.length + 1) === check + '-' : false;
      };
    }, 'CHILD':function(type, what, argument, first, last) {
      var simple = type.slice(0, 3) !== 'nth', forward = type.slice(-4) !== 'last', ofType = what === 'of-type';
      return first === 1 && last === 0 ? function(elem) {
        return !!elem.parentNode;
      } : function(elem, context, xml) {
        var cache, outerCache, node, diff, nodeIndex, start, dir = simple !== forward ? 'nextSibling' : 'previousSibling', parent = elem.parentNode, name = ofType && elem.nodeName.toLowerCase(), useCache = !xml && !ofType;
        if (parent) {
          if (simple) {
            while (dir) {
              node = elem;
              while (node = node[dir]) {
                if (ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) {
                  return false;
                }
              }
              start = dir = type === 'only' && !start && 'nextSibling';
            }
            return true;
          }
          start = [forward ? parent.firstChild : parent.lastChild];
          if (forward && useCache) {
            outerCache = parent[expando] || (parent[expando] = {});
            cache = outerCache[type] || [];
            nodeIndex = cache[0] === dirruns && cache[1];
            diff = cache[0] === dirruns && cache[2];
            node = nodeIndex && parent.childNodes[nodeIndex];
            while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
              if (node.nodeType === 1 && ++diff && node === elem) {
                outerCache[type] = [dirruns, nodeIndex, diff];
                break;
              }
            }
          } else {
            if (useCache && (cache = (elem[expando] || (elem[expando] = {}))[type]) && cache[0] === dirruns) {
              diff = cache[1];
            } else {
              while (node = ++nodeIndex && node && node[dir] || (diff = nodeIndex = 0) || start.pop()) {
                if ((ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1) && ++diff) {
                  if (useCache) {
                    (node[expando] || (node[expando] = {}))[type] = [dirruns, diff];
                  }
                  if (node === elem) {
                    break;
                  }
                }
              }
            }
          }
          diff -= last;
          return diff === first || diff % first === 0 && diff / first >= 0;
        }
      };
    }, 'PSEUDO':function(pseudo, argument) {
      var args, fn = Expr.pseudos[pseudo] || Expr.setFilters[pseudo.toLowerCase()] || Sizzle.error('unsupported pseudo: ' + pseudo);
      if (fn[expando]) {
        return fn(argument);
      }
      if (fn.length > 1) {
        args = [pseudo, pseudo, '', argument];
        return Expr.setFilters.hasOwnProperty(pseudo.toLowerCase()) ? markFunction(function(seed, matches) {
          var idx, matched = fn(seed, argument), i = matched.length;
          while (i--) {
            idx = indexOf.call(seed, matched[i]);
            seed[idx] = !(matches[idx] = matched[i]);
          }
        }) : function(elem) {
          return fn(elem, 0, args);
        };
      }
      return fn;
    }}, pseudos:{'not':markFunction(function(selector) {
      var input = [], results = [], matcher = compile(selector.replace(rtrim, '$1'));
      return matcher[expando] ? markFunction(function(seed, matches, context, xml) {
        var elem, unmatched = matcher(seed, null, xml, []), i = seed.length;
        while (i--) {
          if (elem = unmatched[i]) {
            seed[i] = !(matches[i] = elem);
          }
        }
      }) : function(elem, context, xml) {
        input[0] = elem;
        matcher(input, null, xml, results);
        return !results.pop();
      };
    }), 'has':markFunction(function(selector) {
      return function(elem) {
        return Sizzle(selector, elem).length > 0;
      };
    }), 'contains':markFunction(function(text) {
      return function(elem) {
        return (elem.textContent || elem.innerText || getText(elem)).indexOf(text) > -1;
      };
    }), 'lang':markFunction(function(lang) {
      if (!ridentifier.test(lang || '')) {
        Sizzle.error('unsupported lang: ' + lang);
      }
      lang = lang.replace(runescape, funescape).toLowerCase();
      return function(elem) {
        var elemLang;
        do {
          if (elemLang = documentIsHTML ? elem.lang : elem.getAttribute('xml:lang') || elem.getAttribute('lang')) {
            elemLang = elemLang.toLowerCase();
            return elemLang === lang || elemLang.indexOf(lang + '-') === 0;
          }
        } while ((elem = elem.parentNode) && elem.nodeType === 1);
        return false;
      };
    }), 'target':function(elem) {
      var hash = window.location && window.location.hash;
      return hash && hash.slice(1) === elem.id;
    }, 'root':function(elem) {
      return elem === docElem;
    }, 'focus':function(elem) {
      return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
    }, 'enabled':function(elem) {
      return elem.disabled === false;
    }, 'disabled':function(elem) {
      return elem.disabled === true;
    }, 'checked':function(elem) {
      var nodeName = elem.nodeName.toLowerCase();
      return nodeName === 'input' && !!elem.checked || nodeName === 'option' && !!elem.selected;
    }, 'selected':function(elem) {
      if (elem.parentNode) {
        elem.parentNode.selectedIndex;
      }
      return elem.selected === true;
    }, 'empty':function(elem) {
      for (elem = elem.firstChild; elem; elem = elem.nextSibling) {
        if (elem.nodeType < 6) {
          return false;
        }
      }
      return true;
    }, 'parent':function(elem) {
      return !Expr.pseudos['empty'](elem);
    }, 'header':function(elem) {
      return rheader.test(elem.nodeName);
    }, 'input':function(elem) {
      return rinputs.test(elem.nodeName);
    }, 'button':function(elem) {
      var name = elem.nodeName.toLowerCase();
      return name === 'input' && elem.type === 'button' || name === 'button';
    }, 'text':function(elem) {
      var attr;
      return elem.nodeName.toLowerCase() === 'input' && elem.type === 'text' && ((attr = elem.getAttribute('type')) == null || attr.toLowerCase() === 'text');
    }, 'first':createPositionalPseudo(function() {
      return [0];
    }), 'last':createPositionalPseudo(function(matchIndexes, length) {
      return [length - 1];
    }), 'eq':createPositionalPseudo(function(matchIndexes, length, argument) {
      return [argument < 0 ? argument + length : argument];
    }), 'even':createPositionalPseudo(function(matchIndexes, length) {
      var i = 0;
      for (; i < length; i += 2) {
        matchIndexes.push(i);
      }
      return matchIndexes;
    }), 'odd':createPositionalPseudo(function(matchIndexes, length) {
      var i = 1;
      for (; i < length; i += 2) {
        matchIndexes.push(i);
      }
      return matchIndexes;
    }), 'lt':createPositionalPseudo(function(matchIndexes, length, argument) {
      var i = argument < 0 ? argument + length : argument;
      for (; --i >= 0;) {
        matchIndexes.push(i);
      }
      return matchIndexes;
    }), 'gt':createPositionalPseudo(function(matchIndexes, length, argument) {
      var i = argument < 0 ? argument + length : argument;
      for (; ++i < length;) {
        matchIndexes.push(i);
      }
      return matchIndexes;
    })}};
    Expr.pseudos['nth'] = Expr.pseudos['eq'];
    for (i in{radio:true, checkbox:true, file:true, password:true, image:true}) {
      Expr.pseudos[i] = createInputPseudo(i);
    }
    for (i in{submit:true, reset:true}) {
      Expr.pseudos[i] = createButtonPseudo(i);
    }
    function setFilters() {
    }
    setFilters.prototype = Expr.filters = Expr.pseudos;
    Expr.setFilters = new setFilters;
    tokenize = Sizzle.tokenize = function(selector, parseOnly) {
      var matched, match, tokens, type, soFar, groups, preFilters, cached = tokenCache[selector + ' '];
      if (cached) {
        return parseOnly ? 0 : cached.slice(0);
      }
      soFar = selector;
      groups = [];
      preFilters = Expr.preFilter;
      while (soFar) {
        if (!matched || (match = rcomma.exec(soFar))) {
          if (match) {
            soFar = soFar.slice(match[0].length) || soFar;
          }
          groups.push(tokens = []);
        }
        matched = false;
        if (match = rcombinators.exec(soFar)) {
          matched = match.shift();
          tokens.push({value:matched, type:match[0].replace(rtrim, ' ')});
          soFar = soFar.slice(matched.length);
        }
        for (type in Expr.filter) {
          if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] || (match = preFilters[type](match)))) {
            matched = match.shift();
            tokens.push({value:matched, type:type, matches:match});
            soFar = soFar.slice(matched.length);
          }
        }
        if (!matched) {
          break;
        }
      }
      return parseOnly ? soFar.length : soFar ? Sizzle.error(selector) : tokenCache(selector, groups).slice(0);
    };
    function toSelector(tokens) {
      var i = 0, len = tokens.length, selector = '';
      for (; i < len; i++) {
        selector += tokens[i].value;
      }
      return selector;
    }
    function addCombinator(matcher, combinator, base) {
      var dir = combinator.dir, checkNonElements = base && dir === 'parentNode', doneName = done++;
      return combinator.first ? function(elem, context, xml) {
        while (elem = elem[dir]) {
          if (elem.nodeType === 1 || checkNonElements) {
            return matcher(elem, context, xml);
          }
        }
      } : function(elem, context, xml) {
        var oldCache, outerCache, newCache = [dirruns, doneName];
        if (xml) {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              if (matcher(elem, context, xml)) {
                return true;
              }
            }
          }
        } else {
          while (elem = elem[dir]) {
            if (elem.nodeType === 1 || checkNonElements) {
              outerCache = elem[expando] || (elem[expando] = {});
              if ((oldCache = outerCache[dir]) && oldCache[0] === dirruns && oldCache[1] === doneName) {
                return newCache[2] = oldCache[2];
              } else {
                outerCache[dir] = newCache;
                if (newCache[2] = matcher(elem, context, xml)) {
                  return true;
                }
              }
            }
          }
        }
      };
    }
    function elementMatcher(matchers) {
      return matchers.length > 1 ? function(elem, context, xml) {
        var i = matchers.length;
        while (i--) {
          if (!matchers[i](elem, context, xml)) {
            return false;
          }
        }
        return true;
      } : matchers[0];
    }
    function multipleContexts(selector, contexts, results) {
      var i = 0, len = contexts.length;
      for (; i < len; i++) {
        Sizzle(selector, contexts[i], results);
      }
      return results;
    }
    function condense(unmatched, map, filter, context, xml) {
      var elem, newUnmatched = [], i = 0, len = unmatched.length, mapped = map != null;
      for (; i < len; i++) {
        if (elem = unmatched[i]) {
          if (!filter || filter(elem, context, xml)) {
            newUnmatched.push(elem);
            if (mapped) {
              map.push(i);
            }
          }
        }
      }
      return newUnmatched;
    }
    function setMatcher(preFilter, selector, matcher, postFilter, postFinder, postSelector) {
      if (postFilter && !postFilter[expando]) {
        postFilter = setMatcher(postFilter);
      }
      if (postFinder && !postFinder[expando]) {
        postFinder = setMatcher(postFinder, postSelector);
      }
      return markFunction(function(seed, results, context, xml) {
        var temp, i, elem, preMap = [], postMap = [], preexisting = results.length, elems = seed || multipleContexts(selector || '*', context.nodeType ? [context] : context, []), matcherIn = preFilter && (seed || !selector) ? condense(elems, preMap, preFilter, context, xml) : elems, matcherOut = matcher ? postFinder || (seed ? preFilter : preexisting || postFilter) ? [] : results : matcherIn;
        if (matcher) {
          matcher(matcherIn, matcherOut, context, xml);
        }
        if (postFilter) {
          temp = condense(matcherOut, postMap);
          postFilter(temp, [], context, xml);
          i = temp.length;
          while (i--) {
            if (elem = temp[i]) {
              matcherOut[postMap[i]] = !(matcherIn[postMap[i]] = elem);
            }
          }
        }
        if (seed) {
          if (postFinder || preFilter) {
            if (postFinder) {
              temp = [];
              i = matcherOut.length;
              while (i--) {
                if (elem = matcherOut[i]) {
                  temp.push(matcherIn[i] = elem);
                }
              }
              postFinder(null, matcherOut = [], temp, xml);
            }
            i = matcherOut.length;
            while (i--) {
              if ((elem = matcherOut[i]) && (temp = postFinder ? indexOf.call(seed, elem) : preMap[i]) > -1) {
                seed[temp] = !(results[temp] = elem);
              }
            }
          }
        } else {
          matcherOut = condense(matcherOut === results ? matcherOut.splice(preexisting, matcherOut.length) : matcherOut);
          if (postFinder) {
            postFinder(null, results, matcherOut, xml);
          } else {
            push.apply(results, matcherOut);
          }
        }
      });
    }
    function matcherFromTokens(tokens) {
      var checkContext, matcher, j, len = tokens.length, leadingRelative = Expr.relative[tokens[0].type], implicitRelative = leadingRelative || Expr.relative[' '], i = leadingRelative ? 1 : 0, matchContext = addCombinator(function(elem) {
        return elem === checkContext;
      }, implicitRelative, true), matchAnyContext = addCombinator(function(elem) {
        return indexOf.call(checkContext, elem) > -1;
      }, implicitRelative, true), matchers = [function(elem, context, xml) {
        return !leadingRelative && (xml || context !== outermostContext) || ((checkContext = context).nodeType ? matchContext(elem, context, xml) : matchAnyContext(elem, context, xml));
      }];
      for (; i < len; i++) {
        if (matcher = Expr.relative[tokens[i].type]) {
          matchers = [addCombinator(elementMatcher(matchers), matcher)];
        } else {
          matcher = Expr.filter[tokens[i].type].apply(null, tokens[i].matches);
          if (matcher[expando]) {
            j = ++i;
            for (; j < len; j++) {
              if (Expr.relative[tokens[j].type]) {
                break;
              }
            }
            return setMatcher(i > 1 && elementMatcher(matchers), i > 1 && toSelector(tokens.slice(0, i - 1).concat({value:tokens[i - 2].type === ' ' ? '*' : ''})).replace(rtrim, '$1'), matcher, i < j && matcherFromTokens(tokens.slice(i, j)), j < len && matcherFromTokens(tokens = tokens.slice(j)), j < len && toSelector(tokens));
          }
          matchers.push(matcher);
        }
      }
      return elementMatcher(matchers);
    }
    function matcherFromGroupMatchers(elementMatchers, setMatchers) {
      var bySet = setMatchers.length > 0, byElement = elementMatchers.length > 0, superMatcher = function(seed, context, xml, results, outermost) {
        var elem, j, matcher, matchedCount = 0, i = '0', unmatched = seed && [], setMatched = [], contextBackup = outermostContext, elems = seed || byElement && Expr.find['TAG']('*', outermost), dirrunsUnique = dirruns += contextBackup == null ? 1 : Math.random() || 0.1, len = elems.length;
        if (outermost) {
          outermostContext = context !== document && context;
        }
        for (; i !== len && (elem = elems[i]) != null; i++) {
          if (byElement && elem) {
            j = 0;
            while (matcher = elementMatchers[j++]) {
              if (matcher(elem, context, xml)) {
                results.push(elem);
                break;
              }
            }
            if (outermost) {
              dirruns = dirrunsUnique;
            }
          }
          if (bySet) {
            if (elem = !matcher && elem) {
              matchedCount--;
            }
            if (seed) {
              unmatched.push(elem);
            }
          }
        }
        matchedCount += i;
        if (bySet && i !== matchedCount) {
          j = 0;
          while (matcher = setMatchers[j++]) {
            matcher(unmatched, setMatched, context, xml);
          }
          if (seed) {
            if (matchedCount > 0) {
              while (i--) {
                if (!(unmatched[i] || setMatched[i])) {
                  setMatched[i] = pop.call(results);
                }
              }
            }
            setMatched = condense(setMatched);
          }
          push.apply(results, setMatched);
          if (outermost && !seed && setMatched.length > 0 && matchedCount + setMatchers.length > 1) {
            Sizzle.uniqueSort(results);
          }
        }
        if (outermost) {
          dirruns = dirrunsUnique;
          outermostContext = contextBackup;
        }
        return unmatched;
      };
      return bySet ? markFunction(superMatcher) : superMatcher;
    }
    compile = Sizzle.compile = function(selector, match) {
      var i, setMatchers = [], elementMatchers = [], cached = compilerCache[selector + ' '];
      if (!cached) {
        if (!match) {
          match = tokenize(selector);
        }
        i = match.length;
        while (i--) {
          cached = matcherFromTokens(match[i]);
          if (cached[expando]) {
            setMatchers.push(cached);
          } else {
            elementMatchers.push(cached);
          }
        }
        cached = compilerCache(selector, matcherFromGroupMatchers(elementMatchers, setMatchers));
        cached.selector = selector;
      }
      return cached;
    };
    select = Sizzle.select = function(selector, context, results, seed) {
      var i, tokens, token, type, find, compiled = typeof selector === 'function' && selector, match = !seed && tokenize(selector = compiled.selector || selector);
      results = results || [];
      if (match.length === 1) {
        tokens = match[0] = match[0].slice(0);
        if (tokens.length > 2 && (token = tokens[0]).type === 'ID' && support.getById && context.nodeType === 9 && documentIsHTML && Expr.relative[tokens[1].type]) {
          context = (Expr.find['ID'](token.matches[0].replace(runescape, funescape), context) || [])[0];
          if (!context) {
            return results;
          } else {
            if (compiled) {
              context = context.parentNode;
            }
          }
          selector = selector.slice(tokens.shift().value.length);
        }
        i = matchExpr['needsContext'].test(selector) ? 0 : tokens.length;
        while (i--) {
          token = tokens[i];
          if (Expr.relative[type = token.type]) {
            break;
          }
          if (find = Expr.find[type]) {
            if (seed = find(token.matches[0].replace(runescape, funescape), rsibling.test(tokens[0].type) && testContext(context.parentNode) || context)) {
              tokens.splice(i, 1);
              selector = seed.length && toSelector(tokens);
              if (!selector) {
                push.apply(results, seed);
                return results;
              }
              break;
            }
          }
        }
      }
      (compiled || compile(selector, match))(seed, context, !documentIsHTML, results, rsibling.test(selector) && testContext(context.parentNode) || context);
      return results;
    };
    support.sortStable = expando.split('').sort(sortOrder).join('') === expando;
    support.detectDuplicates = !!hasDuplicate;
    setDocument();
    support.sortDetached = assert(function(div1) {
      return div1.compareDocumentPosition(document.createElement('div')) & 1;
    });
    if (!assert(function(div) {
      div.innerHTML = "\x3ca href\x3d'#'\x3e\x3c/a\x3e";
      return div.firstChild.getAttribute('href') === '#';
    })) {
      addHandle('type|href|height|width', function(elem, name, isXML) {
        if (!isXML) {
          return elem.getAttribute(name, name.toLowerCase() === 'type' ? 1 : 2);
        }
      });
    }
    if (!support.attributes || !assert(function(div) {
      div.innerHTML = '\x3cinput/\x3e';
      div.firstChild.setAttribute('value', '');
      return div.firstChild.getAttribute('value') === '';
    })) {
      addHandle('value', function(elem, name, isXML) {
        if (!isXML && elem.nodeName.toLowerCase() === 'input') {
          return elem.defaultValue;
        }
      });
    }
    if (!assert(function(div) {
      return div.getAttribute('disabled') == null;
    })) {
      addHandle(booleans, function(elem, name, isXML) {
        var val;
        if (!isXML) {
          return elem[name] === true ? name.toLowerCase() : (val = elem.getAttributeNode(name)) && val.specified ? val.value : null;
        }
      });
    }
    return Sizzle;
  }(window);
  jQuery.find = Sizzle;
  jQuery.expr = Sizzle.selectors;
  jQuery.expr[':'] = jQuery.expr.pseudos;
  jQuery.unique = Sizzle.uniqueSort;
  jQuery.text = Sizzle.getText;
  jQuery.isXMLDoc = Sizzle.isXML;
  jQuery.contains = Sizzle.contains;
  var rneedsContext = jQuery.expr.match.needsContext;
  var rsingleTag = /^<(\w+)\s*\/?>(?:<\/\1>|)$/;
  var risSimple = /^.[^:#\[\.,]*$/;
  function winnow(elements, qualifier, not) {
    if (jQuery.isFunction(qualifier)) {
      return jQuery.grep(elements, function(elem, i) {
        return !!qualifier.call(elem, i, elem) !== not;
      });
    }
    if (qualifier.nodeType) {
      return jQuery.grep(elements, function(elem) {
        return elem === qualifier !== not;
      });
    }
    if (typeof qualifier === 'string') {
      if (risSimple.test(qualifier)) {
        return jQuery.filter(qualifier, elements, not);
      }
      qualifier = jQuery.filter(qualifier, elements);
    }
    return jQuery.grep(elements, function(elem) {
      return jQuery.inArray(elem, qualifier) >= 0 !== not;
    });
  }
  jQuery.filter = function(expr, elems, not) {
    var elem = elems[0];
    if (not) {
      expr = ':not(' + expr + ')';
    }
    return elems.length === 1 && elem.nodeType === 1 ? jQuery.find.matchesSelector(elem, expr) ? [elem] : [] : jQuery.find.matches(expr, jQuery.grep(elems, function(elem) {
      return elem.nodeType === 1;
    }));
  };
  jQuery.fn.extend({find:function(selector) {
    var i, ret = [], self = this, len = self.length;
    if (typeof selector !== 'string') {
      return this.pushStack(jQuery(selector).filter(function() {
        for (i = 0; i < len; i++) {
          if (jQuery.contains(self[i], this)) {
            return true;
          }
        }
      }));
    }
    for (i = 0; i < len; i++) {
      jQuery.find(selector, self[i], ret);
    }
    ret = this.pushStack(len > 1 ? jQuery.unique(ret) : ret);
    ret.selector = this.selector ? this.selector + ' ' + selector : selector;
    return ret;
  }, filter:function(selector) {
    return this.pushStack(winnow(this, selector || [], false));
  }, not:function(selector) {
    return this.pushStack(winnow(this, selector || [], true));
  }, is:function(selector) {
    return !!winnow(this, typeof selector === 'string' && rneedsContext.test(selector) ? jQuery(selector) : selector || [], false).length;
  }});
  var rootjQuery, document = window.document, rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/, init = jQuery.fn.init = function(selector, context) {
    var match, elem;
    if (!selector) {
      return this;
    }
    if (typeof selector === 'string') {
      if (selector.charAt(0) === '\x3c' && selector.charAt(selector.length - 1) === '\x3e' && selector.length >= 3) {
        match = [null, selector, null];
      } else {
        match = rquickExpr.exec(selector);
      }
      if (match && (match[1] || !context)) {
        if (match[1]) {
          context = context instanceof jQuery ? context[0] : context;
          jQuery.merge(this, jQuery.parseHTML(match[1], context && context.nodeType ? context.ownerDocument || context : document, true));
          if (rsingleTag.test(match[1]) && jQuery.isPlainObject(context)) {
            for (match in context) {
              if (jQuery.isFunction(this[match])) {
                this[match](context[match]);
              } else {
                this.attr(match, context[match]);
              }
            }
          }
          return this;
        } else {
          elem = document.getElementById(match[2]);
          if (elem && elem.parentNode) {
            if (elem.id !== match[2]) {
              return rootjQuery.find(selector);
            }
            this.length = 1;
            this[0] = elem;
          }
          this.context = document;
          this.selector = selector;
          return this;
        }
      } else {
        if (!context || context.jquery) {
          return (context || rootjQuery).find(selector);
        } else {
          return this.constructor(context).find(selector);
        }
      }
    } else {
      if (selector.nodeType) {
        this.context = this[0] = selector;
        this.length = 1;
        return this;
      } else {
        if (jQuery.isFunction(selector)) {
          return typeof rootjQuery.ready !== 'undefined' ? rootjQuery.ready(selector) : selector(jQuery);
        }
      }
    }
    if (selector.selector !== undefined) {
      this.selector = selector.selector;
      this.context = selector.context;
    }
    return jQuery.makeArray(selector, this);
  };
  init.prototype = jQuery.fn;
  rootjQuery = jQuery(document);
  var rparentsprev = /^(?:parents|prev(?:Until|All))/, guaranteedUnique = {children:true, contents:true, next:true, prev:true};
  jQuery.extend({dir:function(elem, dir, until) {
    var matched = [], cur = elem[dir];
    while (cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery(cur).is(until))) {
      if (cur.nodeType === 1) {
        matched.push(cur);
      }
      cur = cur[dir];
    }
    return matched;
  }, sibling:function(n, elem) {
    var r = [];
    for (; n; n = n.nextSibling) {
      if (n.nodeType === 1 && n !== elem) {
        r.push(n);
      }
    }
    return r;
  }});
  jQuery.fn.extend({has:function(target) {
    var i, targets = jQuery(target, this), len = targets.length;
    return this.filter(function() {
      for (i = 0; i < len; i++) {
        if (jQuery.contains(this, targets[i])) {
          return true;
        }
      }
    });
  }, closest:function(selectors, context) {
    var cur, i = 0, l = this.length, matched = [], pos = rneedsContext.test(selectors) || typeof selectors !== 'string' ? jQuery(selectors, context || this.context) : 0;
    for (; i < l; i++) {
      for (cur = this[i]; cur && cur !== context; cur = cur.parentNode) {
        if (cur.nodeType < 11 && (pos ? pos.index(cur) > -1 : cur.nodeType === 1 && jQuery.find.matchesSelector(cur, selectors))) {
          matched.push(cur);
          break;
        }
      }
    }
    return this.pushStack(matched.length > 1 ? jQuery.unique(matched) : matched);
  }, index:function(elem) {
    if (!elem) {
      return this[0] && this[0].parentNode ? this.first().prevAll().length : -1;
    }
    if (typeof elem === 'string') {
      return jQuery.inArray(this[0], jQuery(elem));
    }
    return jQuery.inArray(elem.jquery ? elem[0] : elem, this);
  }, add:function(selector, context) {
    return this.pushStack(jQuery.unique(jQuery.merge(this.get(), jQuery(selector, context))));
  }, addBack:function(selector) {
    return this.add(selector == null ? this.prevObject : this.prevObject.filter(selector));
  }});
  function sibling(cur, dir) {
    do {
      cur = cur[dir];
    } while (cur && cur.nodeType !== 1);
    return cur;
  }
  jQuery.each({parent:function(elem) {
    var parent = elem.parentNode;
    return parent && parent.nodeType !== 11 ? parent : null;
  }, parents:function(elem) {
    return jQuery.dir(elem, 'parentNode');
  }, parentsUntil:function(elem, i, until) {
    return jQuery.dir(elem, 'parentNode', until);
  }, next:function(elem) {
    return sibling(elem, 'nextSibling');
  }, prev:function(elem) {
    return sibling(elem, 'previousSibling');
  }, nextAll:function(elem) {
    return jQuery.dir(elem, 'nextSibling');
  }, prevAll:function(elem) {
    return jQuery.dir(elem, 'previousSibling');
  }, nextUntil:function(elem, i, until) {
    return jQuery.dir(elem, 'nextSibling', until);
  }, prevUntil:function(elem, i, until) {
    return jQuery.dir(elem, 'previousSibling', until);
  }, siblings:function(elem) {
    return jQuery.sibling((elem.parentNode || {}).firstChild, elem);
  }, children:function(elem) {
    return jQuery.sibling(elem.firstChild);
  }, contents:function(elem) {
    return jQuery.nodeName(elem, 'iframe') ? elem.contentDocument || elem.contentWindow.document : jQuery.merge([], elem.childNodes);
  }}, function(name, fn) {
    jQuery.fn[name] = function(until, selector) {
      var ret = jQuery.map(this, fn, until);
      if (name.slice(-5) !== 'Until') {
        selector = until;
      }
      if (selector && typeof selector === 'string') {
        ret = jQuery.filter(selector, ret);
      }
      if (this.length > 1) {
        if (!guaranteedUnique[name]) {
          ret = jQuery.unique(ret);
        }
        if (rparentsprev.test(name)) {
          ret = ret.reverse();
        }
      }
      return this.pushStack(ret);
    };
  });
  var rnotwhite = /\S+/g;
  var optionsCache = {};
  function createOptions(options) {
    var object = optionsCache[options] = {};
    jQuery.each(options.match(rnotwhite) || [], function(_, flag) {
      object[flag] = true;
    });
    return object;
  }
  jQuery.Callbacks = function(options) {
    options = typeof options === 'string' ? optionsCache[options] || createOptions(options) : jQuery.extend({}, options);
    var firing, memory, fired, firingLength, firingIndex, firingStart, list = [], stack = !options.once && [], fire = function(data) {
      memory = options.memory && data;
      fired = true;
      firingIndex = firingStart || 0;
      firingStart = 0;
      firingLength = list.length;
      firing = true;
      for (; list && firingIndex < firingLength; firingIndex++) {
        if (list[firingIndex].apply(data[0], data[1]) === false && options.stopOnFalse) {
          memory = false;
          break;
        }
      }
      firing = false;
      if (list) {
        if (stack) {
          if (stack.length) {
            fire(stack.shift());
          }
        } else {
          if (memory) {
            list = [];
          } else {
            self.disable();
          }
        }
      }
    }, self = {add:function() {
      if (list) {
        var start = list.length;
        (function add(args) {
          jQuery.each(args, function(_, arg) {
            var type = jQuery.type(arg);
            if (type === 'function') {
              if (!options.unique || !self.has(arg)) {
                list.push(arg);
              }
            } else {
              if (arg && arg.length && type !== 'string') {
                add(arg);
              }
            }
          });
        })(arguments);
        if (firing) {
          firingLength = list.length;
        } else {
          if (memory) {
            firingStart = start;
            fire(memory);
          }
        }
      }
      return this;
    }, remove:function() {
      if (list) {
        jQuery.each(arguments, function(_, arg) {
          var index;
          while ((index = jQuery.inArray(arg, list, index)) > -1) {
            list.splice(index, 1);
            if (firing) {
              if (index <= firingLength) {
                firingLength--;
              }
              if (index <= firingIndex) {
                firingIndex--;
              }
            }
          }
        });
      }
      return this;
    }, has:function(fn) {
      return fn ? jQuery.inArray(fn, list) > -1 : !!(list && list.length);
    }, empty:function() {
      list = [];
      firingLength = 0;
      return this;
    }, disable:function() {
      list = stack = memory = undefined;
      return this;
    }, disabled:function() {
      return !list;
    }, lock:function() {
      stack = undefined;
      if (!memory) {
        self.disable();
      }
      return this;
    }, locked:function() {
      return !stack;
    }, fireWith:function(context, args) {
      if (list && (!fired || stack)) {
        args = args || [];
        args = [context, args.slice ? args.slice() : args];
        if (firing) {
          stack.push(args);
        } else {
          fire(args);
        }
      }
      return this;
    }, fire:function() {
      self.fireWith(this, arguments);
      return this;
    }, fired:function() {
      return !!fired;
    }};
    return self;
  };
  jQuery.extend({Deferred:function(func) {
    var tuples = [['resolve', 'done', jQuery.Callbacks('once memory'), 'resolved'], ['reject', 'fail', jQuery.Callbacks('once memory'), 'rejected'], ['notify', 'progress', jQuery.Callbacks('memory')]], state = 'pending', promise = {state:function() {
      return state;
    }, always:function() {
      deferred.done(arguments).fail(arguments);
      return this;
    }, then:function() {
      var fns = arguments;
      return jQuery.Deferred(function(newDefer) {
        jQuery.each(tuples, function(i, tuple) {
          var fn = jQuery.isFunction(fns[i]) && fns[i];
          deferred[tuple[1]](function() {
            var returned = fn && fn.apply(this, arguments);
            if (returned && jQuery.isFunction(returned.promise)) {
              returned.promise().done(newDefer.resolve).fail(newDefer.reject).progress(newDefer.notify);
            } else {
              newDefer[tuple[0] + 'With'](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);
            }
          });
        });
        fns = null;
      }).promise();
    }, promise:function(obj) {
      return obj != null ? jQuery.extend(obj, promise) : promise;
    }}, deferred = {};
    promise.pipe = promise.then;
    jQuery.each(tuples, function(i, tuple) {
      var list = tuple[2], stateString = tuple[3];
      promise[tuple[1]] = list.add;
      if (stateString) {
        list.add(function() {
          state = stateString;
        }, tuples[i ^ 1][2].disable, tuples[2][2].lock);
      }
      deferred[tuple[0]] = function() {
        deferred[tuple[0] + 'With'](this === deferred ? promise : this, arguments);
        return this;
      };
      deferred[tuple[0] + 'With'] = list.fireWith;
    });
    promise.promise(deferred);
    if (func) {
      func.call(deferred, deferred);
    }
    return deferred;
  }, when:function(subordinate) {
    var i = 0, resolveValues = slice.call(arguments), length = resolveValues.length, remaining = length !== 1 || subordinate && jQuery.isFunction(subordinate.promise) ? length : 0, deferred = remaining === 1 ? subordinate : jQuery.Deferred(), updateFunc = function(i, contexts, values) {
      return function(value) {
        contexts[i] = this;
        values[i] = arguments.length > 1 ? slice.call(arguments) : value;
        if (values === progressValues) {
          deferred.notifyWith(contexts, values);
        } else {
          if (!--remaining) {
            deferred.resolveWith(contexts, values);
          }
        }
      };
    }, progressValues, progressContexts, resolveContexts;
    if (length > 1) {
      progressValues = new Array(length);
      progressContexts = new Array(length);
      resolveContexts = new Array(length);
      for (; i < length; i++) {
        if (resolveValues[i] && jQuery.isFunction(resolveValues[i].promise)) {
          resolveValues[i].promise().done(updateFunc(i, resolveContexts, resolveValues)).fail(deferred.reject).progress(updateFunc(i, progressContexts, progressValues));
        } else {
          --remaining;
        }
      }
    }
    if (!remaining) {
      deferred.resolveWith(resolveContexts, resolveValues);
    }
    return deferred.promise();
  }});
  var readyList;
  jQuery.fn.ready = function(fn) {
    jQuery.ready.promise().done(fn);
    return this;
  };
  jQuery.extend({isReady:false, readyWait:1, holdReady:function(hold) {
    if (hold) {
      jQuery.readyWait++;
    } else {
      jQuery.ready(true);
    }
  }, ready:function(wait) {
    if (wait === true ? --jQuery.readyWait : jQuery.isReady) {
      return;
    }
    if (!document.body) {
      return setTimeout(jQuery.ready);
    }
    jQuery.isReady = true;
    if (wait !== true && --jQuery.readyWait > 0) {
      return;
    }
    readyList.resolveWith(document, [jQuery]);
    if (jQuery.fn.triggerHandler) {
      jQuery(document).triggerHandler('ready');
      jQuery(document).off('ready');
    }
  }});
  function detach() {
    if (document.addEventListener) {
      document.removeEventListener('DOMContentLoaded', completed, false);
      window.removeEventListener('load', completed, false);
    } else {
      document.detachEvent('onreadystatechange', completed);
      window.detachEvent('onload', completed);
    }
  }
  function completed() {
    if (document.addEventListener || event.type === 'load' || document.readyState === 'complete') {
      detach();
      jQuery.ready();
    }
  }
  jQuery.ready.promise = function(obj) {
    if (!readyList) {
      readyList = jQuery.Deferred();
      if (document.readyState === 'complete') {
        setTimeout(jQuery.ready);
      } else {
        if (document.addEventListener) {
          document.addEventListener('DOMContentLoaded', completed, false);
          window.addEventListener('load', completed, false);
        } else {
          document.attachEvent('onreadystatechange', completed);
          window.attachEvent('onload', completed);
          var top = false;
          try {
            top = window.frameElement == null && document.documentElement;
          } catch (e$33) {
          }
          if (top && top.doScroll) {
            (function doScrollCheck() {
              if (!jQuery.isReady) {
                try {
                  top.doScroll('left');
                } catch (e$34) {
                  return setTimeout(doScrollCheck, 50);
                }
                detach();
                jQuery.ready();
              }
            })();
          }
        }
      }
    }
    return readyList.promise(obj);
  };
  var strundefined = typeof undefined;
  var i;
  for (i in jQuery(support)) {
    break;
  }
  support.ownLast = i !== '0';
  support.inlineBlockNeedsLayout = false;
  jQuery(function() {
    var val, div, body, container;
    body = document.getElementsByTagName('body')[0];
    if (!body || !body.style) {
      return;
    }
    div = document.createElement('div');
    container = document.createElement('div');
    container.style.cssText = 'position:absolute;border:0;width:0;height:0;top:0;left:-9999px';
    body.appendChild(container).appendChild(div);
    if (typeof div.style.zoom !== strundefined) {
      div.style.cssText = 'display:inline;margin:0;border:0;padding:1px;width:1px;zoom:1';
      support.inlineBlockNeedsLayout = val = div.offsetWidth === 3;
      if (val) {
        body.style.zoom = 1;
      }
    }
    body.removeChild(container);
  });
  (function() {
    var div = document.createElement('div');
    if (support.deleteExpando == null) {
      support.deleteExpando = true;
      try {
        delete div.test;
      } catch (e$35) {
        support.deleteExpando = false;
      }
    }
    div = null;
  })();
  jQuery.acceptData = function(elem) {
    var noData = jQuery.noData[(elem.nodeName + ' ').toLowerCase()], nodeType = +elem.nodeType || 1;
    return nodeType !== 1 && nodeType !== 9 ? false : !noData || noData !== true && elem.getAttribute('classid') === noData;
  };
  var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/, rmultiDash = /([A-Z])/g;
  function dataAttr(elem, key, data) {
    if (data === undefined && elem.nodeType === 1) {
      var name = 'data-' + key.replace(rmultiDash, '-$1').toLowerCase();
      data = elem.getAttribute(name);
      if (typeof data === 'string') {
        try {
          data = data === 'true' ? true : data === 'false' ? false : data === 'null' ? null : +data + '' === data ? +data : rbrace.test(data) ? jQuery.parseJSON(data) : data;
        } catch (e$36) {
        }
        jQuery.data(elem, key, data);
      } else {
        data = undefined;
      }
    }
    return data;
  }
  function isEmptyDataObject(obj) {
    var name;
    for (name in obj) {
      if (name === 'data' && jQuery.isEmptyObject(obj[name])) {
        continue;
      }
      if (name !== 'toJSON') {
        return false;
      }
    }
    return true;
  }
  function internalData(elem, name, data, pvt) {
    if (!jQuery.acceptData(elem)) {
      return;
    }
    var ret, thisCache, internalKey = jQuery.expando, isNode = elem.nodeType, cache = isNode ? jQuery.cache : elem, id = isNode ? elem[internalKey] : elem[internalKey] && internalKey;
    if ((!id || !cache[id] || !pvt && !cache[id].data) && data === undefined && typeof name === 'string') {
      return;
    }
    if (!id) {
      if (isNode) {
        id = elem[internalKey] = deletedIds.pop() || jQuery.guid++;
      } else {
        id = internalKey;
      }
    }
    if (!cache[id]) {
      cache[id] = isNode ? {} : {toJSON:jQuery.noop};
    }
    if (typeof name === 'object' || typeof name === 'function') {
      if (pvt) {
        cache[id] = jQuery.extend(cache[id], name);
      } else {
        cache[id].data = jQuery.extend(cache[id].data, name);
      }
    }
    thisCache = cache[id];
    if (!pvt) {
      if (!thisCache.data) {
        thisCache.data = {};
      }
      thisCache = thisCache.data;
    }
    if (data !== undefined) {
      thisCache[jQuery.camelCase(name)] = data;
    }
    if (typeof name === 'string') {
      ret = thisCache[name];
      if (ret == null) {
        ret = thisCache[jQuery.camelCase(name)];
      }
    } else {
      ret = thisCache;
    }
    return ret;
  }
  function internalRemoveData(elem, name, pvt) {
    if (!jQuery.acceptData(elem)) {
      return;
    }
    var thisCache, i, isNode = elem.nodeType, cache = isNode ? jQuery.cache : elem, id = isNode ? elem[jQuery.expando] : jQuery.expando;
    if (!cache[id]) {
      return;
    }
    if (name) {
      thisCache = pvt ? cache[id] : cache[id].data;
      if (thisCache) {
        if (!jQuery.isArray(name)) {
          if (name in thisCache) {
            name = [name];
          } else {
            name = jQuery.camelCase(name);
            if (name in thisCache) {
              name = [name];
            } else {
              name = name.split(' ');
            }
          }
        } else {
          name = name.concat(jQuery.map(name, jQuery.camelCase));
        }
        i = name.length;
        while (i--) {
          delete thisCache[name[i]];
        }
        if (pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache)) {
          return;
        }
      }
    }
    if (!pvt) {
      delete cache[id].data;
      if (!isEmptyDataObject(cache[id])) {
        return;
      }
    }
    if (isNode) {
      jQuery.cleanData([elem], true);
    } else {
      if (support.deleteExpando || cache != cache.window) {
        delete cache[id];
      } else {
        cache[id] = null;
      }
    }
  }
  jQuery.extend({cache:{}, noData:{'applet ':true, 'embed ':true, 'object ':'clsid:D27CDB6E-AE6D-11cf-96B8-444553540000'}, hasData:function(elem) {
    elem = elem.nodeType ? jQuery.cache[elem[jQuery.expando]] : elem[jQuery.expando];
    return !!elem && !isEmptyDataObject(elem);
  }, data:function(elem, name, data) {
    return internalData(elem, name, data);
  }, removeData:function(elem, name) {
    return internalRemoveData(elem, name);
  }, _data:function(elem, name, data) {
    return internalData(elem, name, data, true);
  }, _removeData:function(elem, name) {
    return internalRemoveData(elem, name, true);
  }});
  jQuery.fn.extend({data:function(key, value) {
    var i, name, data, elem = this[0], attrs = elem && elem.attributes;
    if (key === undefined) {
      if (this.length) {
        data = jQuery.data(elem);
        if (elem.nodeType === 1 && !jQuery._data(elem, 'parsedAttrs')) {
          i = attrs.length;
          while (i--) {
            if (attrs[i]) {
              name = attrs[i].name;
              if (name.indexOf('data-') === 0) {
                name = jQuery.camelCase(name.slice(5));
                dataAttr(elem, name, data[name]);
              }
            }
          }
          jQuery._data(elem, 'parsedAttrs', true);
        }
      }
      return data;
    }
    if (typeof key === 'object') {
      return this.each(function() {
        jQuery.data(this, key);
      });
    }
    return arguments.length > 1 ? this.each(function() {
      jQuery.data(this, key, value);
    }) : elem ? dataAttr(elem, key, jQuery.data(elem, key)) : undefined;
  }, removeData:function(key) {
    return this.each(function() {
      jQuery.removeData(this, key);
    });
  }});
  jQuery.extend({queue:function(elem, type, data) {
    var queue;
    if (elem) {
      type = (type || 'fx') + 'queue';
      queue = jQuery._data(elem, type);
      if (data) {
        if (!queue || jQuery.isArray(data)) {
          queue = jQuery._data(elem, type, jQuery.makeArray(data));
        } else {
          queue.push(data);
        }
      }
      return queue || [];
    }
  }, dequeue:function(elem, type) {
    type = type || 'fx';
    var queue = jQuery.queue(elem, type), startLength = queue.length, fn = queue.shift(), hooks = jQuery._queueHooks(elem, type), next = function() {
      jQuery.dequeue(elem, type);
    };
    if (fn === 'inprogress') {
      fn = queue.shift();
      startLength--;
    }
    if (fn) {
      if (type === 'fx') {
        queue.unshift('inprogress');
      }
      delete hooks.stop;
      fn.call(elem, next, hooks);
    }
    if (!startLength && hooks) {
      hooks.empty.fire();
    }
  }, _queueHooks:function(elem, type) {
    var key = type + 'queueHooks';
    return jQuery._data(elem, key) || jQuery._data(elem, key, {empty:jQuery.Callbacks('once memory').add(function() {
      jQuery._removeData(elem, type + 'queue');
      jQuery._removeData(elem, key);
    })});
  }});
  jQuery.fn.extend({queue:function(type, data) {
    var setter = 2;
    if (typeof type !== 'string') {
      data = type;
      type = 'fx';
      setter--;
    }
    if (arguments.length < setter) {
      return jQuery.queue(this[0], type);
    }
    return data === undefined ? this : this.each(function() {
      var queue = jQuery.queue(this, type, data);
      jQuery._queueHooks(this, type);
      if (type === 'fx' && queue[0] !== 'inprogress') {
        jQuery.dequeue(this, type);
      }
    });
  }, dequeue:function(type) {
    return this.each(function() {
      jQuery.dequeue(this, type);
    });
  }, clearQueue:function(type) {
    return this.queue(type || 'fx', []);
  }, promise:function(type, obj) {
    var tmp, count = 1, defer = jQuery.Deferred(), elements = this, i = this.length, resolve = function() {
      if (!--count) {
        defer.resolveWith(elements, [elements]);
      }
    };
    if (typeof type !== 'string') {
      obj = type;
      type = undefined;
    }
    type = type || 'fx';
    while (i--) {
      tmp = jQuery._data(elements[i], type + 'queueHooks');
      if (tmp && tmp.empty) {
        count++;
        tmp.empty.add(resolve);
      }
    }
    resolve();
    return defer.promise(obj);
  }});
  var pnum = /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/.source;
  var cssExpand = ['Top', 'Right', 'Bottom', 'Left'];
  var isHidden = function(elem, el) {
    elem = el || elem;
    return jQuery.css(elem, 'display') === 'none' || !jQuery.contains(elem.ownerDocument, elem);
  };
  var access = jQuery.access = function(elems, fn, key, value, chainable, emptyGet, raw) {
    var i = 0, length = elems.length, bulk = key == null;
    if (jQuery.type(key) === 'object') {
      chainable = true;
      for (i in key) {
        jQuery.access(elems, fn, i, key[i], true, emptyGet, raw);
      }
    } else {
      if (value !== undefined) {
        chainable = true;
        if (!jQuery.isFunction(value)) {
          raw = true;
        }
        if (bulk) {
          if (raw) {
            fn.call(elems, value);
            fn = null;
          } else {
            bulk = fn;
            fn = function(elem, key, value) {
              return bulk.call(jQuery(elem), value);
            };
          }
        }
        if (fn) {
          for (; i < length; i++) {
            fn(elems[i], key, raw ? value : value.call(elems[i], i, fn(elems[i], key)));
          }
        }
      }
    }
    return chainable ? elems : bulk ? fn.call(elems) : length ? fn(elems[0], key) : emptyGet;
  };
  var rcheckableType = /^(?:checkbox|radio)$/i;
  (function() {
    var input = document.createElement('input'), div = document.createElement('div'), fragment = document.createDocumentFragment();
    div.innerHTML = "  \x3clink/\x3e\x3ctable\x3e\x3c/table\x3e\x3ca href\x3d'/a'\x3ea\x3c/a\x3e\x3cinput type\x3d'checkbox'/\x3e";
    support.leadingWhitespace = div.firstChild.nodeType === 3;
    support.tbody = !div.getElementsByTagName('tbody').length;
    support.htmlSerialize = !!div.getElementsByTagName('link').length;
    support.html5Clone = document.createElement('nav').cloneNode(true).outerHTML !== '\x3c:nav\x3e\x3c/:nav\x3e';
    input.type = 'checkbox';
    input.checked = true;
    fragment.appendChild(input);
    support.appendChecked = input.checked;
    div.innerHTML = '\x3ctextarea\x3ex\x3c/textarea\x3e';
    support.noCloneChecked = !!div.cloneNode(true).lastChild.defaultValue;
    fragment.appendChild(div);
    div.innerHTML = "\x3cinput type\x3d'radio' checked\x3d'checked' name\x3d't'/\x3e";
    support.checkClone = div.cloneNode(true).cloneNode(true).lastChild.checked;
    support.noCloneEvent = true;
    if (div.attachEvent) {
      div.attachEvent('onclick', function() {
        support.noCloneEvent = false;
      });
      div.cloneNode(true).click();
    }
    if (support.deleteExpando == null) {
      support.deleteExpando = true;
      try {
        delete div.test;
      } catch (e$37) {
        support.deleteExpando = false;
      }
    }
  })();
  (function() {
    var i, eventName, div = document.createElement('div');
    for (i in{submit:true, change:true, focusin:true}) {
      eventName = 'on' + i;
      if (!(support[i + 'Bubbles'] = eventName in window)) {
        div.setAttribute(eventName, 't');
        support[i + 'Bubbles'] = div.attributes[eventName].expando === false;
      }
    }
    div = null;
  })();
  var rformElems = /^(?:input|select|textarea)$/i, rkeyEvent = /^key/, rmouseEvent = /^(?:mouse|pointer|contextmenu)|click/, rfocusMorph = /^(?:focusinfocus|focusoutblur)$/, rtypenamespace = /^([^.]*)(?:\.(.+)|)$/;
  function returnTrue() {
    return true;
  }
  function returnFalse() {
    return false;
  }
  function safeActiveElement() {
    try {
      return document.activeElement;
    } catch (err) {
    }
  }
  jQuery.event = {global:{}, add:function(elem, types, handler, data, selector) {
    var tmp, events, t, handleObjIn, special, eventHandle, handleObj, handlers, type, namespaces, origType, elemData = jQuery._data(elem);
    if (!elemData) {
      return;
    }
    if (handler.handler) {
      handleObjIn = handler;
      handler = handleObjIn.handler;
      selector = handleObjIn.selector;
    }
    if (!handler.guid) {
      handler.guid = jQuery.guid++;
    }
    if (!(events = elemData.events)) {
      events = elemData.events = {};
    }
    if (!(eventHandle = elemData.handle)) {
      eventHandle = elemData.handle = function(e) {
        return typeof jQuery !== strundefined && (!e || jQuery.event.triggered !== e.type) ? jQuery.event.dispatch.apply(eventHandle.elem, arguments) : undefined;
      };
      eventHandle.elem = elem;
    }
    types = (types || '').match(rnotwhite) || [''];
    t = types.length;
    while (t--) {
      tmp = rtypenamespace.exec(types[t]) || [];
      type = origType = tmp[1];
      namespaces = (tmp[2] || '').split('.').sort();
      if (!type) {
        continue;
      }
      special = jQuery.event.special[type] || {};
      type = (selector ? special.delegateType : special.bindType) || type;
      special = jQuery.event.special[type] || {};
      handleObj = jQuery.extend({type:type, origType:origType, data:data, handler:handler, guid:handler.guid, selector:selector, needsContext:selector && jQuery.expr.match.needsContext.test(selector), namespace:namespaces.join('.')}, handleObjIn);
      if (!(handlers = events[type])) {
        handlers = events[type] = [];
        handlers.delegateCount = 0;
        if (!special.setup || special.setup.call(elem, data, namespaces, eventHandle) === false) {
          if (elem.addEventListener) {
            elem.addEventListener(type, eventHandle, false);
          } else {
            if (elem.attachEvent) {
              elem.attachEvent('on' + type, eventHandle);
            }
          }
        }
      }
      if (special.add) {
        special.add.call(elem, handleObj);
        if (!handleObj.handler.guid) {
          handleObj.handler.guid = handler.guid;
        }
      }
      if (selector) {
        handlers.splice(handlers.delegateCount++, 0, handleObj);
      } else {
        handlers.push(handleObj);
      }
      jQuery.event.global[type] = true;
    }
    elem = null;
  }, remove:function(elem, types, handler, selector, mappedTypes) {
    var j, handleObj, tmp, origCount, t, events, special, handlers, type, namespaces, origType, elemData = jQuery.hasData(elem) && jQuery._data(elem);
    if (!elemData || !(events = elemData.events)) {
      return;
    }
    types = (types || '').match(rnotwhite) || [''];
    t = types.length;
    while (t--) {
      tmp = rtypenamespace.exec(types[t]) || [];
      type = origType = tmp[1];
      namespaces = (tmp[2] || '').split('.').sort();
      if (!type) {
        for (type in events) {
          jQuery.event.remove(elem, type + types[t], handler, selector, true);
        }
        continue;
      }
      special = jQuery.event.special[type] || {};
      type = (selector ? special.delegateType : special.bindType) || type;
      handlers = events[type] || [];
      tmp = tmp[2] && new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)');
      origCount = j = handlers.length;
      while (j--) {
        handleObj = handlers[j];
        if ((mappedTypes || origType === handleObj.origType) && (!handler || handler.guid === handleObj.guid) && (!tmp || tmp.test(handleObj.namespace)) && (!selector || selector === handleObj.selector || selector === '**' && handleObj.selector)) {
          handlers.splice(j, 1);
          if (handleObj.selector) {
            handlers.delegateCount--;
          }
          if (special.remove) {
            special.remove.call(elem, handleObj);
          }
        }
      }
      if (origCount && !handlers.length) {
        if (!special.teardown || special.teardown.call(elem, namespaces, elemData.handle) === false) {
          jQuery.removeEvent(elem, type, elemData.handle);
        }
        delete events[type];
      }
    }
    if (jQuery.isEmptyObject(events)) {
      delete elemData.handle;
      jQuery._removeData(elem, 'events');
    }
  }, trigger:function(event, data, elem, onlyHandlers) {
    var handle, ontype, cur, bubbleType, special, tmp, i, eventPath = [elem || document], type = hasOwn.call(event, 'type') ? event.type : event, namespaces = hasOwn.call(event, 'namespace') ? event.namespace.split('.') : [];
    cur = tmp = elem = elem || document;
    if (elem.nodeType === 3 || elem.nodeType === 8) {
      return;
    }
    if (rfocusMorph.test(type + jQuery.event.triggered)) {
      return;
    }
    if (type.indexOf('.') >= 0) {
      namespaces = type.split('.');
      type = namespaces.shift();
      namespaces.sort();
    }
    ontype = type.indexOf(':') < 0 && 'on' + type;
    event = event[jQuery.expando] ? event : new jQuery.Event(type, typeof event === 'object' && event);
    event.isTrigger = onlyHandlers ? 2 : 3;
    event.namespace = namespaces.join('.');
    event.namespace_re = event.namespace ? new RegExp('(^|\\.)' + namespaces.join('\\.(?:.*\\.|)') + '(\\.|$)') : null;
    event.result = undefined;
    if (!event.target) {
      event.target = elem;
    }
    data = data == null ? [event] : jQuery.makeArray(data, [event]);
    special = jQuery.event.special[type] || {};
    if (!onlyHandlers && special.trigger && special.trigger.apply(elem, data) === false) {
      return;
    }
    if (!onlyHandlers && !special.noBubble && !jQuery.isWindow(elem)) {
      bubbleType = special.delegateType || type;
      if (!rfocusMorph.test(bubbleType + type)) {
        cur = cur.parentNode;
      }
      for (; cur; cur = cur.parentNode) {
        eventPath.push(cur);
        tmp = cur;
      }
      if (tmp === (elem.ownerDocument || document)) {
        eventPath.push(tmp.defaultView || tmp.parentWindow || window);
      }
    }
    i = 0;
    while ((cur = eventPath[i++]) && !event.isPropagationStopped()) {
      event.type = i > 1 ? bubbleType : special.bindType || type;
      handle = (jQuery._data(cur, 'events') || {})[event.type] && jQuery._data(cur, 'handle');
      if (handle) {
        handle.apply(cur, data);
      }
      handle = ontype && cur[ontype];
      if (handle && handle.apply && jQuery.acceptData(cur)) {
        event.result = handle.apply(cur, data);
        if (event.result === false) {
          event.preventDefault();
        }
      }
    }
    event.type = type;
    if (!onlyHandlers && !event.isDefaultPrevented()) {
      if ((!special._default || special._default.apply(eventPath.pop(), data) === false) && jQuery.acceptData(elem)) {
        if (ontype && elem[type] && !jQuery.isWindow(elem)) {
          tmp = elem[ontype];
          if (tmp) {
            elem[ontype] = null;
          }
          jQuery.event.triggered = type;
          try {
            elem[type]();
          } catch (e$38) {
          }
          jQuery.event.triggered = undefined;
          if (tmp) {
            elem[ontype] = tmp;
          }
        }
      }
    }
    return event.result;
  }, dispatch:function(event) {
    event = jQuery.event.fix(event);
    var i, ret, handleObj, matched, j, handlerQueue = [], args = slice.call(arguments), handlers = (jQuery._data(this, 'events') || {})[event.type] || [], special = jQuery.event.special[event.type] || {};
    args[0] = event;
    event.delegateTarget = this;
    if (special.preDispatch && special.preDispatch.call(this, event) === false) {
      return;
    }
    handlerQueue = jQuery.event.handlers.call(this, event, handlers);
    i = 0;
    while ((matched = handlerQueue[i++]) && !event.isPropagationStopped()) {
      event.currentTarget = matched.elem;
      j = 0;
      while ((handleObj = matched.handlers[j++]) && !event.isImmediatePropagationStopped()) {
        if (!event.namespace_re || event.namespace_re.test(handleObj.namespace)) {
          event.handleObj = handleObj;
          event.data = handleObj.data;
          ret = ((jQuery.event.special[handleObj.origType] || {}).handle || handleObj.handler).apply(matched.elem, args);
          if (ret !== undefined) {
            if ((event.result = ret) === false) {
              event.preventDefault();
              event.stopPropagation();
            }
          }
        }
      }
    }
    if (special.postDispatch) {
      special.postDispatch.call(this, event);
    }
    return event.result;
  }, handlers:function(event, handlers) {
    var sel, handleObj, matches, i, handlerQueue = [], delegateCount = handlers.delegateCount, cur = event.target;
    if (delegateCount && cur.nodeType && (!event.button || event.type !== 'click')) {
      for (; cur != this; cur = cur.parentNode || this) {
        if (cur.nodeType === 1 && (cur.disabled !== true || event.type !== 'click')) {
          matches = [];
          for (i = 0; i < delegateCount; i++) {
            handleObj = handlers[i];
            sel = handleObj.selector + ' ';
            if (matches[sel] === undefined) {
              matches[sel] = handleObj.needsContext ? jQuery(sel, this).index(cur) >= 0 : jQuery.find(sel, this, null, [cur]).length;
            }
            if (matches[sel]) {
              matches.push(handleObj);
            }
          }
          if (matches.length) {
            handlerQueue.push({elem:cur, handlers:matches});
          }
        }
      }
    }
    if (delegateCount < handlers.length) {
      handlerQueue.push({elem:this, handlers:handlers.slice(delegateCount)});
    }
    return handlerQueue;
  }, fix:function(event) {
    if (event[jQuery.expando]) {
      return event;
    }
    var i, prop, copy, type = event.type, originalEvent = event, fixHook = this.fixHooks[type];
    if (!fixHook) {
      this.fixHooks[type] = fixHook = rmouseEvent.test(type) ? this.mouseHooks : rkeyEvent.test(type) ? this.keyHooks : {};
    }
    copy = fixHook.props ? this.props.concat(fixHook.props) : this.props;
    event = new jQuery.Event(originalEvent);
    i = copy.length;
    while (i--) {
      prop = copy[i];
      event[prop] = originalEvent[prop];
    }
    if (!event.target) {
      event.target = originalEvent.srcElement || document;
    }
    if (event.target.nodeType === 3) {
      event.target = event.target.parentNode;
    }
    event.metaKey = !!event.metaKey;
    return fixHook.filter ? fixHook.filter(event, originalEvent) : event;
  }, props:'altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which'.split(' '), fixHooks:{}, keyHooks:{props:'char charCode key keyCode'.split(' '), filter:function(event, original) {
    if (event.which == null) {
      event.which = original.charCode != null ? original.charCode : original.keyCode;
    }
    return event;
  }}, mouseHooks:{props:'button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement'.split(' '), filter:function(event, original) {
    var body, eventDoc, doc, button = original.button, fromElement = original.fromElement;
    if (event.pageX == null && original.clientX != null) {
      eventDoc = event.target.ownerDocument || document;
      doc = eventDoc.documentElement;
      body = eventDoc.body;
      event.pageX = original.clientX + (doc && doc.scrollLeft || body && body.scrollLeft || 0) - (doc && doc.clientLeft || body && body.clientLeft || 0);
      event.pageY = original.clientY + (doc && doc.scrollTop || body && body.scrollTop || 0) - (doc && doc.clientTop || body && body.clientTop || 0);
    }
    if (!event.relatedTarget && fromElement) {
      event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;
    }
    if (!event.which && button !== undefined) {
      event.which = button & 1 ? 1 : button & 2 ? 3 : button & 4 ? 2 : 0;
    }
    return event;
  }}, special:{load:{noBubble:true}, focus:{trigger:function() {
    if (this !== safeActiveElement() && this.focus) {
      try {
        this.focus();
        return false;
      } catch (e$39) {
      }
    }
  }, delegateType:'focusin'}, blur:{trigger:function() {
    if (this === safeActiveElement() && this.blur) {
      this.blur();
      return false;
    }
  }, delegateType:'focusout'}, click:{trigger:function() {
    if (jQuery.nodeName(this, 'input') && this.type === 'checkbox' && this.click) {
      this.click();
      return false;
    }
  }, _default:function(event) {
    return jQuery.nodeName(event.target, 'a');
  }}, beforeunload:{postDispatch:function(event) {
    if (event.result !== undefined && event.originalEvent) {
      event.originalEvent.returnValue = event.result;
    }
  }}}, simulate:function(type, elem, event, bubble) {
    var e = jQuery.extend(new jQuery.Event, event, {type:type, isSimulated:true, originalEvent:{}});
    if (bubble) {
      jQuery.event.trigger(e, null, elem);
    } else {
      jQuery.event.dispatch.call(elem, e);
    }
    if (e.isDefaultPrevented()) {
      event.preventDefault();
    }
  }};
  jQuery.removeEvent = document.removeEventListener ? function(elem, type, handle) {
    if (elem.removeEventListener) {
      elem.removeEventListener(type, handle, false);
    }
  } : function(elem, type, handle) {
    var name = 'on' + type;
    if (elem.detachEvent) {
      if (typeof elem[name] === strundefined) {
        elem[name] = null;
      }
      elem.detachEvent(name, handle);
    }
  };
  jQuery.Event = function(src, props) {
    if (!(this instanceof jQuery.Event)) {
      return new jQuery.Event(src, props);
    }
    if (src && src.type) {
      this.originalEvent = src;
      this.type = src.type;
      this.isDefaultPrevented = src.defaultPrevented || src.defaultPrevented === undefined && src.returnValue === false ? returnTrue : returnFalse;
    } else {
      this.type = src;
    }
    if (props) {
      jQuery.extend(this, props);
    }
    this.timeStamp = src && src.timeStamp || jQuery.now();
    this[jQuery.expando] = true;
  };
  jQuery.Event.prototype = {isDefaultPrevented:returnFalse, isPropagationStopped:returnFalse, isImmediatePropagationStopped:returnFalse, preventDefault:function() {
    var e = this.originalEvent;
    this.isDefaultPrevented = returnTrue;
    if (!e) {
      return;
    }
    if (e.preventDefault) {
      e.preventDefault();
    } else {
      e.returnValue = false;
    }
  }, stopPropagation:function() {
    var e = this.originalEvent;
    this.isPropagationStopped = returnTrue;
    if (!e) {
      return;
    }
    if (e.stopPropagation) {
      e.stopPropagation();
    }
    e.cancelBubble = true;
  }, stopImmediatePropagation:function() {
    var e = this.originalEvent;
    this.isImmediatePropagationStopped = returnTrue;
    if (e && e.stopImmediatePropagation) {
      e.stopImmediatePropagation();
    }
    this.stopPropagation();
  }};
  jQuery.each({mouseenter:'mouseover', mouseleave:'mouseout', pointerenter:'pointerover', pointerleave:'pointerout'}, function(orig, fix) {
    jQuery.event.special[orig] = {delegateType:fix, bindType:fix, handle:function(event) {
      var ret, target = this, related = event.relatedTarget, handleObj = event.handleObj;
      if (!related || related !== target && !jQuery.contains(target, related)) {
        event.type = handleObj.origType;
        ret = handleObj.handler.apply(this, arguments);
        event.type = fix;
      }
      return ret;
    }};
  });
  if (!support.submitBubbles) {
    jQuery.event.special.submit = {setup:function() {
      if (jQuery.nodeName(this, 'form')) {
        return false;
      }
      jQuery.event.add(this, 'click._submit keypress._submit', function(e) {
        var elem = e.target, form = jQuery.nodeName(elem, 'input') || jQuery.nodeName(elem, 'button') ? elem.form : undefined;
        if (form && !jQuery._data(form, 'submitBubbles')) {
          jQuery.event.add(form, 'submit._submit', function(event) {
            event._submit_bubble = true;
          });
          jQuery._data(form, 'submitBubbles', true);
        }
      });
    }, postDispatch:function(event) {
      if (event._submit_bubble) {
        delete event._submit_bubble;
        if (this.parentNode && !event.isTrigger) {
          jQuery.event.simulate('submit', this.parentNode, event, true);
        }
      }
    }, teardown:function() {
      if (jQuery.nodeName(this, 'form')) {
        return false;
      }
      jQuery.event.remove(this, '._submit');
    }};
  }
  if (!support.changeBubbles) {
    jQuery.event.special.change = {setup:function() {
      if (rformElems.test(this.nodeName)) {
        if (this.type === 'checkbox' || this.type === 'radio') {
          jQuery.event.add(this, 'propertychange._change', function(event) {
            if (event.originalEvent.propertyName === 'checked') {
              this._just_changed = true;
            }
          });
          jQuery.event.add(this, 'click._change', function(event) {
            if (this._just_changed && !event.isTrigger) {
              this._just_changed = false;
            }
            jQuery.event.simulate('change', this, event, true);
          });
        }
        return false;
      }
      jQuery.event.add(this, 'beforeactivate._change', function(e) {
        var elem = e.target;
        if (rformElems.test(elem.nodeName) && !jQuery._data(elem, 'changeBubbles')) {
          jQuery.event.add(elem, 'change._change', function(event) {
            if (this.parentNode && !event.isSimulated && !event.isTrigger) {
              jQuery.event.simulate('change', this.parentNode, event, true);
            }
          });
          jQuery._data(elem, 'changeBubbles', true);
        }
      });
    }, handle:function(event) {
      var elem = event.target;
      if (this !== elem || event.isSimulated || event.isTrigger || elem.type !== 'radio' && elem.type !== 'checkbox') {
        return event.handleObj.handler.apply(this, arguments);
      }
    }, teardown:function() {
      jQuery.event.remove(this, '._change');
      return !rformElems.test(this.nodeName);
    }};
  }
  if (!support.focusinBubbles) {
    jQuery.each({focus:'focusin', blur:'focusout'}, function(orig, fix) {
      var handler = function(event) {
        jQuery.event.simulate(fix, event.target, jQuery.event.fix(event), true);
      };
      jQuery.event.special[fix] = {setup:function() {
        var doc = this.ownerDocument || this, attaches = jQuery._data(doc, fix);
        if (!attaches) {
          doc.addEventListener(orig, handler, true);
        }
        jQuery._data(doc, fix, (attaches || 0) + 1);
      }, teardown:function() {
        var doc = this.ownerDocument || this, attaches = jQuery._data(doc, fix) - 1;
        if (!attaches) {
          doc.removeEventListener(orig, handler, true);
          jQuery._removeData(doc, fix);
        } else {
          jQuery._data(doc, fix, attaches);
        }
      }};
    });
  }
  jQuery.fn.extend({on:function(types, selector, data, fn, one) {
    var type, origFn;
    if (typeof types === 'object') {
      if (typeof selector !== 'string') {
        data = data || selector;
        selector = undefined;
      }
      for (type in types) {
        this.on(type, selector, data, types[type], one);
      }
      return this;
    }
    if (data == null && fn == null) {
      fn = selector;
      data = selector = undefined;
    } else {
      if (fn == null) {
        if (typeof selector === 'string') {
          fn = data;
          data = undefined;
        } else {
          fn = data;
          data = selector;
          selector = undefined;
        }
      }
    }
    if (fn === false) {
      fn = returnFalse;
    } else {
      if (!fn) {
        return this;
      }
    }
    if (one === 1) {
      origFn = fn;
      fn = function(event) {
        jQuery().off(event);
        return origFn.apply(this, arguments);
      };
      fn.guid = origFn.guid || (origFn.guid = jQuery.guid++);
    }
    return this.each(function() {
      jQuery.event.add(this, types, fn, data, selector);
    });
  }, one:function(types, selector, data, fn) {
    return this.on(types, selector, data, fn, 1);
  }, off:function(types, selector, fn) {
    var handleObj, type;
    if (types && types.preventDefault && types.handleObj) {
      handleObj = types.handleObj;
      jQuery(types.delegateTarget).off(handleObj.namespace ? handleObj.origType + '.' + handleObj.namespace : handleObj.origType, handleObj.selector, handleObj.handler);
      return this;
    }
    if (typeof types === 'object') {
      for (type in types) {
        this.off(type, selector, types[type]);
      }
      return this;
    }
    if (selector === false || typeof selector === 'function') {
      fn = selector;
      selector = undefined;
    }
    if (fn === false) {
      fn = returnFalse;
    }
    return this.each(function() {
      jQuery.event.remove(this, types, fn, selector);
    });
  }, trigger:function(type, data) {
    return this.each(function() {
      jQuery.event.trigger(type, data, this);
    });
  }, triggerHandler:function(type, data) {
    var elem = this[0];
    if (elem) {
      return jQuery.event.trigger(type, data, elem, true);
    }
  }});
  function createSafeFragment(document) {
    var list = nodeNames.split('|'), safeFrag = document.createDocumentFragment();
    if (safeFrag.createElement) {
      while (list.length) {
        safeFrag.createElement(list.pop());
      }
    }
    return safeFrag;
  }
  var nodeNames = 'abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|' + 'header|hgroup|mark|meter|nav|output|progress|section|summary|time|video', rinlinejQuery = / jQuery\d+="(?:null|\d+)"/g, rnoshimcache = new RegExp('\x3c(?:' + nodeNames + ')[\\s/\x3e]', 'i'), rleadingWhitespace = /^\s+/, rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi, rtagName = /<([\w:]+)/, rtbody = /<tbody/i, rhtml = /<|&#?\w+;/, rnoInnerhtml = /<(?:script|style|link)/i, 
  rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i, rscriptType = /^$|\/(?:java|ecma)script/i, rscriptTypeMasked = /^true\/(.*)/, rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g, wrapMap = {option:[1, "\x3cselect multiple\x3d'multiple'\x3e", '\x3c/select\x3e'], legend:[1, '\x3cfieldset\x3e', '\x3c/fieldset\x3e'], area:[1, '\x3cmap\x3e', '\x3c/map\x3e'], param:[1, '\x3cobject\x3e', '\x3c/object\x3e'], thead:[1, '\x3ctable\x3e', '\x3c/table\x3e'], tr:[2, '\x3ctable\x3e\x3ctbody\x3e', '\x3c/tbody\x3e\x3c/table\x3e'], 
  col:[2, '\x3ctable\x3e\x3ctbody\x3e\x3c/tbody\x3e\x3ccolgroup\x3e', '\x3c/colgroup\x3e\x3c/table\x3e'], td:[3, '\x3ctable\x3e\x3ctbody\x3e\x3ctr\x3e', '\x3c/tr\x3e\x3c/tbody\x3e\x3c/table\x3e'], _default:support.htmlSerialize ? [0, '', ''] : [1, 'X\x3cdiv\x3e', '\x3c/div\x3e']}, safeFragment = createSafeFragment(document), fragmentDiv = safeFragment.appendChild(document.createElement('div'));
  wrapMap.optgroup = wrapMap.option;
  wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
  wrapMap.th = wrapMap.td;
  function getAll(context, tag) {
    var elems, elem, i = 0, found = typeof context.getElementsByTagName !== strundefined ? context.getElementsByTagName(tag || '*') : typeof context.querySelectorAll !== strundefined ? context.querySelectorAll(tag || '*') : undefined;
    if (!found) {
      for (found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++) {
        if (!tag || jQuery.nodeName(elem, tag)) {
          found.push(elem);
        } else {
          jQuery.merge(found, getAll(elem, tag));
        }
      }
    }
    return tag === undefined || tag && jQuery.nodeName(context, tag) ? jQuery.merge([context], found) : found;
  }
  function fixDefaultChecked(elem) {
    if (rcheckableType.test(elem.type)) {
      elem.defaultChecked = elem.checked;
    }
  }
  function manipulationTarget(elem, content) {
    return jQuery.nodeName(elem, 'table') && jQuery.nodeName(content.nodeType !== 11 ? content : content.firstChild, 'tr') ? elem.getElementsByTagName('tbody')[0] || elem.appendChild(elem.ownerDocument.createElement('tbody')) : elem;
  }
  function disableScript(elem) {
    elem.type = (jQuery.find.attr(elem, 'type') !== null) + '/' + elem.type;
    return elem;
  }
  function restoreScript(elem) {
    var match = rscriptTypeMasked.exec(elem.type);
    if (match) {
      elem.type = match[1];
    } else {
      elem.removeAttribute('type');
    }
    return elem;
  }
  function setGlobalEval(elems, refElements) {
    var elem, i = 0;
    for (; (elem = elems[i]) != null; i++) {
      jQuery._data(elem, 'globalEval', !refElements || jQuery._data(refElements[i], 'globalEval'));
    }
  }
  function cloneCopyEvent(src, dest) {
    if (dest.nodeType !== 1 || !jQuery.hasData(src)) {
      return;
    }
    var type, i, l, oldData = jQuery._data(src), curData = jQuery._data(dest, oldData), events = oldData.events;
    if (events) {
      delete curData.handle;
      curData.events = {};
      for (type in events) {
        for (i = 0, l = events[type].length; i < l; i++) {
          jQuery.event.add(dest, type, events[type][i]);
        }
      }
    }
    if (curData.data) {
      curData.data = jQuery.extend({}, curData.data);
    }
  }
  function fixCloneNodeIssues(src, dest) {
    var nodeName, e, data;
    if (dest.nodeType !== 1) {
      return;
    }
    nodeName = dest.nodeName.toLowerCase();
    if (!support.noCloneEvent && dest[jQuery.expando]) {
      data = jQuery._data(dest);
      for (e in data.events) {
        jQuery.removeEvent(dest, e, data.handle);
      }
      dest.removeAttribute(jQuery.expando);
    }
    if (nodeName === 'script' && dest.text !== src.text) {
      disableScript(dest).text = src.text;
      restoreScript(dest);
    } else {
      if (nodeName === 'object') {
        if (dest.parentNode) {
          dest.outerHTML = src.outerHTML;
        }
        if (support.html5Clone && (src.innerHTML && !jQuery.trim(dest.innerHTML))) {
          dest.innerHTML = src.innerHTML;
        }
      } else {
        if (nodeName === 'input' && rcheckableType.test(src.type)) {
          dest.defaultChecked = dest.checked = src.checked;
          if (dest.value !== src.value) {
            dest.value = src.value;
          }
        } else {
          if (nodeName === 'option') {
            dest.defaultSelected = dest.selected = src.defaultSelected;
          } else {
            if (nodeName === 'input' || nodeName === 'textarea') {
              dest.defaultValue = src.defaultValue;
            }
          }
        }
      }
    }
  }
  jQuery.extend({clone:function(elem, dataAndEvents, deepDataAndEvents) {
    var destElements, node, clone, i, srcElements, inPage = jQuery.contains(elem.ownerDocument, elem);
    if (support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test('\x3c' + elem.nodeName + '\x3e')) {
      clone = elem.cloneNode(true);
    } else {
      fragmentDiv.innerHTML = elem.outerHTML;
      fragmentDiv.removeChild(clone = fragmentDiv.firstChild);
    }
    if ((!support.noCloneEvent || !support.noCloneChecked) && (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem)) {
      destElements = getAll(clone);
      srcElements = getAll(elem);
      for (i = 0; (node = srcElements[i]) != null; ++i) {
        if (destElements[i]) {
          fixCloneNodeIssues(node, destElements[i]);
        }
      }
    }
    if (dataAndEvents) {
      if (deepDataAndEvents) {
        srcElements = srcElements || getAll(elem);
        destElements = destElements || getAll(clone);
        for (i = 0; (node = srcElements[i]) != null; i++) {
          cloneCopyEvent(node, destElements[i]);
        }
      } else {
        cloneCopyEvent(elem, clone);
      }
    }
    destElements = getAll(clone, 'script');
    if (destElements.length > 0) {
      setGlobalEval(destElements, !inPage && getAll(elem, 'script'));
    }
    destElements = srcElements = node = null;
    return clone;
  }, buildFragment:function(elems, context, scripts, selection) {
    var j, elem, contains, tmp, tag, tbody, wrap, l = elems.length, safe = createSafeFragment(context), nodes = [], i = 0;
    for (; i < l; i++) {
      elem = elems[i];
      if (elem || elem === 0) {
        if (jQuery.type(elem) === 'object') {
          jQuery.merge(nodes, elem.nodeType ? [elem] : elem);
        } else {
          if (!rhtml.test(elem)) {
            nodes.push(context.createTextNode(elem));
          } else {
            tmp = tmp || safe.appendChild(context.createElement('div'));
            tag = (rtagName.exec(elem) || ['', ''])[1].toLowerCase();
            wrap = wrapMap[tag] || wrapMap._default;
            tmp.innerHTML = wrap[1] + elem.replace(rxhtmlTag, '\x3c$1\x3e\x3c/$2\x3e') + wrap[2];
            j = wrap[0];
            while (j--) {
              tmp = tmp.lastChild;
            }
            if (!support.leadingWhitespace && rleadingWhitespace.test(elem)) {
              nodes.push(context.createTextNode(rleadingWhitespace.exec(elem)[0]));
            }
            if (!support.tbody) {
              elem = tag === 'table' && !rtbody.test(elem) ? tmp.firstChild : wrap[1] === '\x3ctable\x3e' && !rtbody.test(elem) ? tmp : 0;
              j = elem && elem.childNodes.length;
              while (j--) {
                if (jQuery.nodeName(tbody = elem.childNodes[j], 'tbody') && !tbody.childNodes.length) {
                  elem.removeChild(tbody);
                }
              }
            }
            jQuery.merge(nodes, tmp.childNodes);
            tmp.textContent = '';
            while (tmp.firstChild) {
              tmp.removeChild(tmp.firstChild);
            }
            tmp = safe.lastChild;
          }
        }
      }
    }
    if (tmp) {
      safe.removeChild(tmp);
    }
    if (!support.appendChecked) {
      jQuery.grep(getAll(nodes, 'input'), fixDefaultChecked);
    }
    i = 0;
    while (elem = nodes[i++]) {
      if (selection && jQuery.inArray(elem, selection) !== -1) {
        continue;
      }
      contains = jQuery.contains(elem.ownerDocument, elem);
      tmp = getAll(safe.appendChild(elem), 'script');
      if (contains) {
        setGlobalEval(tmp);
      }
      if (scripts) {
        j = 0;
        while (elem = tmp[j++]) {
          if (rscriptType.test(elem.type || '')) {
            scripts.push(elem);
          }
        }
      }
    }
    tmp = null;
    return safe;
  }, cleanData:function(elems, acceptData) {
    var elem, type, id, data, i = 0, internalKey = jQuery.expando, cache = jQuery.cache, deleteExpando = support.deleteExpando, special = jQuery.event.special;
    for (; (elem = elems[i]) != null; i++) {
      if (acceptData || jQuery.acceptData(elem)) {
        id = elem[internalKey];
        data = id && cache[id];
        if (data) {
          if (data.events) {
            for (type in data.events) {
              if (special[type]) {
                jQuery.event.remove(elem, type);
              } else {
                jQuery.removeEvent(elem, type, data.handle);
              }
            }
          }
          if (cache[id]) {
            delete cache[id];
            if (deleteExpando) {
              delete elem[internalKey];
            } else {
              if (typeof elem.removeAttribute !== strundefined) {
                elem.removeAttribute(internalKey);
              } else {
                elem[internalKey] = null;
              }
            }
            deletedIds.push(id);
          }
        }
      }
    }
  }});
  jQuery.fn.extend({text:function(value) {
    return access(this, function(value) {
      return value === undefined ? jQuery.text(this) : this.empty().append((this[0] && this[0].ownerDocument || document).createTextNode(value));
    }, null, value, arguments.length);
  }, append:function() {
    return this.domManip(arguments, function(elem) {
      if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
        var target = manipulationTarget(this, elem);
        target.appendChild(elem);
      }
    });
  }, prepend:function() {
    return this.domManip(arguments, function(elem) {
      if (this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9) {
        var target = manipulationTarget(this, elem);
        target.insertBefore(elem, target.firstChild);
      }
    });
  }, before:function() {
    return this.domManip(arguments, function(elem) {
      if (this.parentNode) {
        this.parentNode.insertBefore(elem, this);
      }
    });
  }, after:function() {
    return this.domManip(arguments, function(elem) {
      if (this.parentNode) {
        this.parentNode.insertBefore(elem, this.nextSibling);
      }
    });
  }, remove:function(selector, keepData) {
    var elem, elems = selector ? jQuery.filter(selector, this) : this, i = 0;
    for (; (elem = elems[i]) != null; i++) {
      if (!keepData && elem.nodeType === 1) {
        jQuery.cleanData(getAll(elem));
      }
      if (elem.parentNode) {
        if (keepData && jQuery.contains(elem.ownerDocument, elem)) {
          setGlobalEval(getAll(elem, 'script'));
        }
        elem.parentNode.removeChild(elem);
      }
    }
    return this;
  }, empty:function() {
    var elem, i = 0;
    for (; (elem = this[i]) != null; i++) {
      if (elem.nodeType === 1) {
        jQuery.cleanData(getAll(elem, false));
      }
      while (elem.firstChild) {
        elem.removeChild(elem.firstChild);
      }
      if (elem.options && jQuery.nodeName(elem, 'select')) {
        elem.options.length = 0;
      }
    }
    return this;
  }, clone:function(dataAndEvents, deepDataAndEvents) {
    dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
    deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;
    return this.map(function() {
      return jQuery.clone(this, dataAndEvents, deepDataAndEvents);
    });
  }, html:function(value) {
    return access(this, function(value) {
      var elem = this[0] || {}, i = 0, l = this.length;
      if (value === undefined) {
        return elem.nodeType === 1 ? elem.innerHTML.replace(rinlinejQuery, '') : undefined;
      }
      if (typeof value === 'string' && !rnoInnerhtml.test(value) && (support.htmlSerialize || !rnoshimcache.test(value)) && (support.leadingWhitespace || !rleadingWhitespace.test(value)) && !wrapMap[(rtagName.exec(value) || ['', ''])[1].toLowerCase()]) {
        value = value.replace(rxhtmlTag, '\x3c$1\x3e\x3c/$2\x3e');
        try {
          for (; i < l; i++) {
            elem = this[i] || {};
            if (elem.nodeType === 1) {
              jQuery.cleanData(getAll(elem, false));
              elem.innerHTML = value;
            }
          }
          elem = 0;
        } catch (e$40) {
        }
      }
      if (elem) {
        this.empty().append(value);
      }
    }, null, value, arguments.length);
  }, replaceWith:function() {
    var arg = arguments[0];
    this.domManip(arguments, function(elem) {
      arg = this.parentNode;
      jQuery.cleanData(getAll(this));
      if (arg) {
        arg.replaceChild(elem, this);
      }
    });
    return arg && (arg.length || arg.nodeType) ? this : this.remove();
  }, detach:function(selector) {
    return this.remove(selector, true);
  }, domManip:function(args, callback) {
    args = concat.apply([], args);
    var first, node, hasScripts, scripts, doc, fragment, i = 0, l = this.length, set = this, iNoClone = l - 1, value = args[0], isFunction = jQuery.isFunction(value);
    if (isFunction || l > 1 && typeof value === 'string' && !support.checkClone && rchecked.test(value)) {
      return this.each(function(index) {
        var self = set.eq(index);
        if (isFunction) {
          args[0] = value.call(this, index, self.html());
        }
        self.domManip(args, callback);
      });
    }
    if (l) {
      fragment = jQuery.buildFragment(args, this[0].ownerDocument, false, this);
      first = fragment.firstChild;
      if (fragment.childNodes.length === 1) {
        fragment = first;
      }
      if (first) {
        scripts = jQuery.map(getAll(fragment, 'script'), disableScript);
        hasScripts = scripts.length;
        for (; i < l; i++) {
          node = fragment;
          if (i !== iNoClone) {
            node = jQuery.clone(node, true, true);
            if (hasScripts) {
              jQuery.merge(scripts, getAll(node, 'script'));
            }
          }
          callback.call(this[i], node, i);
        }
        if (hasScripts) {
          doc = scripts[scripts.length - 1].ownerDocument;
          jQuery.map(scripts, restoreScript);
          for (i = 0; i < hasScripts; i++) {
            node = scripts[i];
            if (rscriptType.test(node.type || '') && !jQuery._data(node, 'globalEval') && jQuery.contains(doc, node)) {
              if (node.src) {
                if (jQuery._evalUrl) {
                  jQuery._evalUrl(node.src);
                }
              } else {
                jQuery.globalEval((node.text || node.textContent || node.innerHTML || '').replace(rcleanScript, ''));
              }
            }
          }
        }
        fragment = first = null;
      }
    }
    return this;
  }});
  jQuery.each({appendTo:'append', prependTo:'prepend', insertBefore:'before', insertAfter:'after', replaceAll:'replaceWith'}, function(name, original) {
    jQuery.fn[name] = function(selector) {
      var elems, i = 0, ret = [], insert = jQuery(selector), last = insert.length - 1;
      for (; i <= last; i++) {
        elems = i === last ? this : this.clone(true);
        jQuery(insert[i])[original](elems);
        push.apply(ret, elems.get());
      }
      return this.pushStack(ret);
    };
  });
  var iframe, elemdisplay = {};
  function actualDisplay(name, doc) {
    var style, elem = jQuery(doc.createElement(name)).appendTo(doc.body), display = window.getDefaultComputedStyle && (style = window.getDefaultComputedStyle(elem[0])) ? style.display : jQuery.css(elem[0], 'display');
    elem.detach();
    return display;
  }
  function defaultDisplay(nodeName) {
    var doc = document, display = elemdisplay[nodeName];
    if (!display) {
      display = actualDisplay(nodeName, doc);
      if (display === 'none' || !display) {
        iframe = (iframe || jQuery("\x3ciframe frameborder\x3d'0' width\x3d'0' height\x3d'0'/\x3e")).appendTo(doc.documentElement);
        doc = (iframe[0].contentWindow || iframe[0].contentDocument).document;
        doc.write();
        doc.close();
        display = actualDisplay(nodeName, doc);
        iframe.detach();
      }
      elemdisplay[nodeName] = display;
    }
    return display;
  }
  (function() {
    var shrinkWrapBlocksVal;
    support.shrinkWrapBlocks = function() {
      if (shrinkWrapBlocksVal != null) {
        return shrinkWrapBlocksVal;
      }
      shrinkWrapBlocksVal = false;
      var div, body, container;
      body = document.getElementsByTagName('body')[0];
      if (!body || !body.style) {
        return;
      }
      div = document.createElement('div');
      container = document.createElement('div');
      container.style.cssText = 'position:absolute;border:0;width:0;height:0;top:0;left:-9999px';
      body.appendChild(container).appendChild(div);
      if (typeof div.style.zoom !== strundefined) {
        div.style.cssText = '-webkit-box-sizing:content-box;-moz-box-sizing:content-box;' + 'box-sizing:content-box;display:block;margin:0;border:0;' + 'padding:1px;width:1px;zoom:1';
        div.appendChild(document.createElement('div')).style.width = '5px';
        shrinkWrapBlocksVal = div.offsetWidth !== 3;
      }
      body.removeChild(container);
      return shrinkWrapBlocksVal;
    };
  })();
  var rmargin = /^margin/;
  var rnumnonpx = new RegExp('^(' + pnum + ')(?!px)[a-z%]+$', 'i');
  var getStyles, curCSS, rposition = /^(top|right|bottom|left)$/;
  if (window.getComputedStyle) {
    getStyles = function(elem) {
      return elem.ownerDocument.defaultView.getComputedStyle(elem, null);
    };
    curCSS = function(elem, name, computed) {
      var width, minWidth, maxWidth, ret, style = elem.style;
      computed = computed || getStyles(elem);
      ret = computed ? computed.getPropertyValue(name) || computed[name] : undefined;
      if (computed) {
        if (ret === '' && !jQuery.contains(elem.ownerDocument, elem)) {
          ret = jQuery.style(elem, name);
        }
        if (rnumnonpx.test(ret) && rmargin.test(name)) {
          width = style.width;
          minWidth = style.minWidth;
          maxWidth = style.maxWidth;
          style.minWidth = style.maxWidth = style.width = ret;
          ret = computed.width;
          style.width = width;
          style.minWidth = minWidth;
          style.maxWidth = maxWidth;
        }
      }
      return ret === undefined ? ret : ret + '';
    };
  } else {
    if (document.documentElement.currentStyle) {
      getStyles = function(elem) {
        return elem.currentStyle;
      };
      curCSS = function(elem, name, computed) {
        var left, rs, rsLeft, ret, style = elem.style;
        computed = computed || getStyles(elem);
        ret = computed ? computed[name] : undefined;
        if (ret == null && style && style[name]) {
          ret = style[name];
        }
        if (rnumnonpx.test(ret) && !rposition.test(name)) {
          left = style.left;
          rs = elem.runtimeStyle;
          rsLeft = rs && rs.left;
          if (rsLeft) {
            rs.left = elem.currentStyle.left;
          }
          style.left = name === 'fontSize' ? '1em' : ret;
          ret = style.pixelLeft + 'px';
          style.left = left;
          if (rsLeft) {
            rs.left = rsLeft;
          }
        }
        return ret === undefined ? ret : ret + '' || 'auto';
      };
    }
  }
  function addGetHookIf(conditionFn, hookFn) {
    return {get:function() {
      var condition = conditionFn();
      if (condition == null) {
        return;
      }
      if (condition) {
        delete this.get;
        return;
      }
      return (this.get = hookFn).apply(this, arguments);
    }};
  }
  (function() {
    var div, style, a, pixelPositionVal, boxSizingReliableVal, reliableHiddenOffsetsVal, reliableMarginRightVal;
    div = document.createElement('div');
    div.innerHTML = "  \x3clink/\x3e\x3ctable\x3e\x3c/table\x3e\x3ca href\x3d'/a'\x3ea\x3c/a\x3e\x3cinput type\x3d'checkbox'/\x3e";
    a = div.getElementsByTagName('a')[0];
    style = a && a.style;
    if (!style) {
      return;
    }
    style.cssText = 'float:left;opacity:.5';
    support.opacity = style.opacity === '0.5';
    support.cssFloat = !!style.cssFloat;
    div.style.backgroundClip = 'content-box';
    div.cloneNode(true).style.backgroundClip = '';
    support.clearCloneStyle = div.style.backgroundClip === 'content-box';
    support.boxSizing = style.boxSizing === '' || style.MozBoxSizing === '' || style.WebkitBoxSizing === '';
    jQuery.extend(support, {reliableHiddenOffsets:function() {
      if (reliableHiddenOffsetsVal == null) {
        computeStyleTests();
      }
      return reliableHiddenOffsetsVal;
    }, boxSizingReliable:function() {
      if (boxSizingReliableVal == null) {
        computeStyleTests();
      }
      return boxSizingReliableVal;
    }, pixelPosition:function() {
      if (pixelPositionVal == null) {
        computeStyleTests();
      }
      return pixelPositionVal;
    }, reliableMarginRight:function() {
      if (reliableMarginRightVal == null) {
        computeStyleTests();
      }
      return reliableMarginRightVal;
    }});
    function computeStyleTests() {
      var div, body, container, contents;
      body = document.getElementsByTagName('body')[0];
      if (!body || !body.style) {
        return;
      }
      div = document.createElement('div');
      container = document.createElement('div');
      container.style.cssText = 'position:absolute;border:0;width:0;height:0;top:0;left:-9999px';
      body.appendChild(container).appendChild(div);
      div.style.cssText = '-webkit-box-sizing:border-box;-moz-box-sizing:border-box;' + 'box-sizing:border-box;display:block;margin-top:1%;top:1%;' + 'border:1px;padding:1px;width:4px;position:absolute';
      pixelPositionVal = boxSizingReliableVal = false;
      reliableMarginRightVal = true;
      if (window.getComputedStyle) {
        pixelPositionVal = (window.getComputedStyle(div, null) || {}).top !== '1%';
        boxSizingReliableVal = (window.getComputedStyle(div, null) || {width:'4px'}).width === '4px';
        contents = div.appendChild(document.createElement('div'));
        contents.style.cssText = div.style.cssText = '-webkit-box-sizing:content-box;-moz-box-sizing:content-box;' + 'box-sizing:content-box;display:block;margin:0;border:0;padding:0';
        contents.style.marginRight = contents.style.width = '0';
        div.style.width = '1px';
        reliableMarginRightVal = !parseFloat((window.getComputedStyle(contents, null) || {}).marginRight);
      }
      div.innerHTML = '\x3ctable\x3e\x3ctr\x3e\x3ctd\x3e\x3c/td\x3e\x3ctd\x3et\x3c/td\x3e\x3c/tr\x3e\x3c/table\x3e';
      contents = div.getElementsByTagName('td');
      contents[0].style.cssText = 'margin:0;border:0;padding:0;display:none';
      reliableHiddenOffsetsVal = contents[0].offsetHeight === 0;
      if (reliableHiddenOffsetsVal) {
        contents[0].style.display = '';
        contents[1].style.display = 'none';
        reliableHiddenOffsetsVal = contents[0].offsetHeight === 0;
      }
      body.removeChild(container);
    }
  })();
  jQuery.swap = function(elem, options, callback, args) {
    var ret, name, old = {};
    for (name in options) {
      old[name] = elem.style[name];
      elem.style[name] = options[name];
    }
    ret = callback.apply(elem, args || []);
    for (name in options) {
      elem.style[name] = old[name];
    }
    return ret;
  };
  var ralpha = /alpha\([^)]*\)/i, ropacity = /opacity\s*=\s*([^)]*)/, rdisplayswap = /^(none|table(?!-c[ea]).+)/, rnumsplit = new RegExp('^(' + pnum + ')(.*)$', 'i'), rrelNum = new RegExp('^([+-])\x3d(' + pnum + ')', 'i'), cssShow = {position:'absolute', visibility:'hidden', display:'block'}, cssNormalTransform = {letterSpacing:'0', fontWeight:'400'}, cssPrefixes = ['Webkit', 'O', 'Moz', 'ms'];
  function vendorPropName(style, name) {
    if (name in style) {
      return name;
    }
    var capName = name.charAt(0).toUpperCase() + name.slice(1), origName = name, i = cssPrefixes.length;
    while (i--) {
      name = cssPrefixes[i] + capName;
      if (name in style) {
        return name;
      }
    }
    return origName;
  }
  function showHide(elements, show) {
    var display, elem, hidden, values = [], index = 0, length = elements.length;
    for (; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      values[index] = jQuery._data(elem, 'olddisplay');
      display = elem.style.display;
      if (show) {
        if (!values[index] && display === 'none') {
          elem.style.display = '';
        }
        if (elem.style.display === '' && isHidden(elem)) {
          values[index] = jQuery._data(elem, 'olddisplay', defaultDisplay(elem.nodeName));
        }
      } else {
        hidden = isHidden(elem);
        if (display && display !== 'none' || !hidden) {
          jQuery._data(elem, 'olddisplay', hidden ? display : jQuery.css(elem, 'display'));
        }
      }
    }
    for (index = 0; index < length; index++) {
      elem = elements[index];
      if (!elem.style) {
        continue;
      }
      if (!show || elem.style.display === 'none' || elem.style.display === '') {
        elem.style.display = show ? values[index] || '' : 'none';
      }
    }
    return elements;
  }
  function setPositiveNumber(elem, value, subtract) {
    var matches = rnumsplit.exec(value);
    return matches ? Math.max(0, matches[1] - (subtract || 0)) + (matches[2] || 'px') : value;
  }
  function augmentWidthOrHeight(elem, name, extra, isBorderBox, styles) {
    var i = extra === (isBorderBox ? 'border' : 'content') ? 4 : name === 'width' ? 1 : 0, val = 0;
    for (; i < 4; i += 2) {
      if (extra === 'margin') {
        val += jQuery.css(elem, extra + cssExpand[i], true, styles);
      }
      if (isBorderBox) {
        if (extra === 'content') {
          val -= jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
        }
        if (extra !== 'margin') {
          val -= jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
        }
      } else {
        val += jQuery.css(elem, 'padding' + cssExpand[i], true, styles);
        if (extra !== 'padding') {
          val += jQuery.css(elem, 'border' + cssExpand[i] + 'Width', true, styles);
        }
      }
    }
    return val;
  }
  function getWidthOrHeight(elem, name, extra) {
    var valueIsBorderBox = true, val = name === 'width' ? elem.offsetWidth : elem.offsetHeight, styles = getStyles(elem), isBorderBox = support.boxSizing && jQuery.css(elem, 'boxSizing', false, styles) === 'border-box';
    if (val <= 0 || val == null) {
      val = curCSS(elem, name, styles);
      if (val < 0 || val == null) {
        val = elem.style[name];
      }
      if (rnumnonpx.test(val)) {
        return val;
      }
      valueIsBorderBox = isBorderBox && (support.boxSizingReliable() || val === elem.style[name]);
      val = parseFloat(val) || 0;
    }
    return val + augmentWidthOrHeight(elem, name, extra || (isBorderBox ? 'border' : 'content'), valueIsBorderBox, styles) + 'px';
  }
  jQuery.extend({cssHooks:{opacity:{get:function(elem, computed) {
    if (computed) {
      var ret = curCSS(elem, 'opacity');
      return ret === '' ? '1' : ret;
    }
  }}}, cssNumber:{'columnCount':true, 'fillOpacity':true, 'flexGrow':true, 'flexShrink':true, 'fontWeight':true, 'lineHeight':true, 'opacity':true, 'order':true, 'orphans':true, 'widows':true, 'zIndex':true, 'zoom':true}, cssProps:{'float':support.cssFloat ? 'cssFloat' : 'styleFloat'}, style:function(elem, name, value, extra) {
    if (!elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style) {
      return;
    }
    var ret, type, hooks, origName = jQuery.camelCase(name), style = elem.style;
    name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(style, origName));
    hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
    if (value !== undefined) {
      type = typeof value;
      if (type === 'string' && (ret = rrelNum.exec(value))) {
        value = (ret[1] + 1) * ret[2] + parseFloat(jQuery.css(elem, name));
        type = 'number';
      }
      if (value == null || value !== value) {
        return;
      }
      if (type === 'number' && !jQuery.cssNumber[origName]) {
        value += 'px';
      }
      if (!support.clearCloneStyle && value === '' && name.indexOf('background') === 0) {
        style[name] = 'inherit';
      }
      if (!hooks || !('set' in hooks) || (value = hooks.set(elem, value, extra)) !== undefined) {
        try {
          style[name] = value;
        } catch (e$41) {
        }
      }
    } else {
      if (hooks && 'get' in hooks && (ret = hooks.get(elem, false, extra)) !== undefined) {
        return ret;
      }
      return style[name];
    }
  }, css:function(elem, name, extra, styles) {
    var num, val, hooks, origName = jQuery.camelCase(name);
    name = jQuery.cssProps[origName] || (jQuery.cssProps[origName] = vendorPropName(elem.style, origName));
    hooks = jQuery.cssHooks[name] || jQuery.cssHooks[origName];
    if (hooks && 'get' in hooks) {
      val = hooks.get(elem, true, extra);
    }
    if (val === undefined) {
      val = curCSS(elem, name, styles);
    }
    if (val === 'normal' && name in cssNormalTransform) {
      val = cssNormalTransform[name];
    }
    if (extra === '' || extra) {
      num = parseFloat(val);
      return extra === true || jQuery.isNumeric(num) ? num || 0 : val;
    }
    return val;
  }});
  jQuery.each(['height', 'width'], function(i, name) {
    jQuery.cssHooks[name] = {get:function(elem, computed, extra) {
      if (computed) {
        return rdisplayswap.test(jQuery.css(elem, 'display')) && elem.offsetWidth === 0 ? jQuery.swap(elem, cssShow, function() {
          return getWidthOrHeight(elem, name, extra);
        }) : getWidthOrHeight(elem, name, extra);
      }
    }, set:function(elem, value, extra) {
      var styles = extra && getStyles(elem);
      return setPositiveNumber(elem, value, extra ? augmentWidthOrHeight(elem, name, extra, support.boxSizing && jQuery.css(elem, 'boxSizing', false, styles) === 'border-box', styles) : 0);
    }};
  });
  if (!support.opacity) {
    jQuery.cssHooks.opacity = {get:function(elem, computed) {
      return ropacity.test((computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || '') ? 0.01 * parseFloat(RegExp.$1) + '' : computed ? '1' : '';
    }, set:function(elem, value) {
      var style = elem.style, currentStyle = elem.currentStyle, opacity = jQuery.isNumeric(value) ? 'alpha(opacity\x3d' + value * 100 + ')' : '', filter = currentStyle && currentStyle.filter || style.filter || '';
      style.zoom = 1;
      if ((value >= 1 || value === '') && jQuery.trim(filter.replace(ralpha, '')) === '' && style.removeAttribute) {
        style.removeAttribute('filter');
        if (value === '' || currentStyle && !currentStyle.filter) {
          return;
        }
      }
      style.filter = ralpha.test(filter) ? filter.replace(ralpha, opacity) : filter + ' ' + opacity;
    }};
  }
  jQuery.cssHooks.marginRight = addGetHookIf(support.reliableMarginRight, function(elem, computed) {
    if (computed) {
      return jQuery.swap(elem, {'display':'inline-block'}, curCSS, [elem, 'marginRight']);
    }
  });
  jQuery.each({margin:'', padding:'', border:'Width'}, function(prefix, suffix) {
    jQuery.cssHooks[prefix + suffix] = {expand:function(value) {
      var i = 0, expanded = {}, parts = typeof value === 'string' ? value.split(' ') : [value];
      for (; i < 4; i++) {
        expanded[prefix + cssExpand[i] + suffix] = parts[i] || parts[i - 2] || parts[0];
      }
      return expanded;
    }};
    if (!rmargin.test(prefix)) {
      jQuery.cssHooks[prefix + suffix].set = setPositiveNumber;
    }
  });
  jQuery.fn.extend({css:function(name, value) {
    return access(this, function(elem, name, value) {
      var styles, len, map = {}, i = 0;
      if (jQuery.isArray(name)) {
        styles = getStyles(elem);
        len = name.length;
        for (; i < len; i++) {
          map[name[i]] = jQuery.css(elem, name[i], false, styles);
        }
        return map;
      }
      return value !== undefined ? jQuery.style(elem, name, value) : jQuery.css(elem, name);
    }, name, value, arguments.length > 1);
  }, show:function() {
    return showHide(this, true);
  }, hide:function() {
    return showHide(this);
  }, toggle:function(state) {
    if (typeof state === 'boolean') {
      return state ? this.show() : this.hide();
    }
    return this.each(function() {
      if (isHidden(this)) {
        jQuery(this).show();
      } else {
        jQuery(this).hide();
      }
    });
  }});
  function Tween(elem, options, prop, end, easing) {
    return new Tween.prototype.init(elem, options, prop, end, easing);
  }
  jQuery.Tween = Tween;
  Tween.prototype = {constructor:Tween, init:function(elem, options, prop, end, easing, unit) {
    this.elem = elem;
    this.prop = prop;
    this.easing = easing || 'swing';
    this.options = options;
    this.start = this.now = this.cur();
    this.end = end;
    this.unit = unit || (jQuery.cssNumber[prop] ? '' : 'px');
  }, cur:function() {
    var hooks = Tween.propHooks[this.prop];
    return hooks && hooks.get ? hooks.get(this) : Tween.propHooks._default.get(this);
  }, run:function(percent) {
    var eased, hooks = Tween.propHooks[this.prop];
    if (this.options.duration) {
      this.pos = eased = jQuery.easing[this.easing](percent, this.options.duration * percent, 0, 1, this.options.duration);
    } else {
      this.pos = eased = percent;
    }
    this.now = (this.end - this.start) * eased + this.start;
    if (this.options.step) {
      this.options.step.call(this.elem, this.now, this);
    }
    if (hooks && hooks.set) {
      hooks.set(this);
    } else {
      Tween.propHooks._default.set(this);
    }
    return this;
  }};
  Tween.prototype.init.prototype = Tween.prototype;
  Tween.propHooks = {_default:{get:function(tween) {
    var result;
    if (tween.elem[tween.prop] != null && (!tween.elem.style || tween.elem.style[tween.prop] == null)) {
      return tween.elem[tween.prop];
    }
    result = jQuery.css(tween.elem, tween.prop, '');
    return !result || result === 'auto' ? 0 : result;
  }, set:function(tween) {
    if (jQuery.fx.step[tween.prop]) {
      jQuery.fx.step[tween.prop](tween);
    } else {
      if (tween.elem.style && (tween.elem.style[jQuery.cssProps[tween.prop]] != null || jQuery.cssHooks[tween.prop])) {
        jQuery.style(tween.elem, tween.prop, tween.now + tween.unit);
      } else {
        tween.elem[tween.prop] = tween.now;
      }
    }
  }}};
  Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {set:function(tween) {
    if (tween.elem.nodeType && tween.elem.parentNode) {
      tween.elem[tween.prop] = tween.now;
    }
  }};
  jQuery.easing = {linear:function(p) {
    return p;
  }, swing:function(p) {
    return 0.5 - Math.cos(p * Math.PI) / 2;
  }};
  jQuery.fx = Tween.prototype.init;
  jQuery.fx.step = {};
  var fxNow, timerId, rfxtypes = /^(?:toggle|show|hide)$/, rfxnum = new RegExp('^(?:([+-])\x3d|)(' + pnum + ')([a-z%]*)$', 'i'), rrun = /queueHooks$/, animationPrefilters = [defaultPrefilter], tweeners = {'*':[function(prop, value) {
    var tween = this.createTween(prop, value), target = tween.cur(), parts = rfxnum.exec(value), unit = parts && parts[3] || (jQuery.cssNumber[prop] ? '' : 'px'), start = (jQuery.cssNumber[prop] || unit !== 'px' && +target) && rfxnum.exec(jQuery.css(tween.elem, prop)), scale = 1, maxIterations = 20;
    if (start && start[3] !== unit) {
      unit = unit || start[3];
      parts = parts || [];
      start = +target || 1;
      do {
        scale = scale || '.5';
        start = start / scale;
        jQuery.style(tween.elem, prop, start + unit);
      } while (scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations);
    }
    if (parts) {
      start = tween.start = +start || +target || 0;
      tween.unit = unit;
      tween.end = parts[1] ? start + (parts[1] + 1) * parts[2] : +parts[2];
    }
    return tween;
  }]};
  function createFxNow() {
    setTimeout(function() {
      fxNow = undefined;
    });
    return fxNow = jQuery.now();
  }
  function genFx(type, includeWidth) {
    var which, attrs = {height:type}, i = 0;
    includeWidth = includeWidth ? 1 : 0;
    for (; i < 4; i += 2 - includeWidth) {
      which = cssExpand[i];
      attrs['margin' + which] = attrs['padding' + which] = type;
    }
    if (includeWidth) {
      attrs.opacity = attrs.width = type;
    }
    return attrs;
  }
  function createTween(value, prop, animation) {
    var tween, collection = (tweeners[prop] || []).concat(tweeners['*']), index = 0, length = collection.length;
    for (; index < length; index++) {
      if (tween = collection[index].call(animation, prop, value)) {
        return tween;
      }
    }
  }
  function defaultPrefilter(elem, props, opts) {
    var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay, anim = this, orig = {}, style = elem.style, hidden = elem.nodeType && isHidden(elem), dataShow = jQuery._data(elem, 'fxshow');
    if (!opts.queue) {
      hooks = jQuery._queueHooks(elem, 'fx');
      if (hooks.unqueued == null) {
        hooks.unqueued = 0;
        oldfire = hooks.empty.fire;
        hooks.empty.fire = function() {
          if (!hooks.unqueued) {
            oldfire();
          }
        };
      }
      hooks.unqueued++;
      anim.always(function() {
        anim.always(function() {
          hooks.unqueued--;
          if (!jQuery.queue(elem, 'fx').length) {
            hooks.empty.fire();
          }
        });
      });
    }
    if (elem.nodeType === 1 && ('height' in props || 'width' in props)) {
      opts.overflow = [style.overflow, style.overflowX, style.overflowY];
      display = jQuery.css(elem, 'display');
      checkDisplay = display === 'none' ? jQuery._data(elem, 'olddisplay') || defaultDisplay(elem.nodeName) : display;
      if (checkDisplay === 'inline' && jQuery.css(elem, 'float') === 'none') {
        if (!support.inlineBlockNeedsLayout || defaultDisplay(elem.nodeName) === 'inline') {
          style.display = 'inline-block';
        } else {
          style.zoom = 1;
        }
      }
    }
    if (opts.overflow) {
      style.overflow = 'hidden';
      if (!support.shrinkWrapBlocks()) {
        anim.always(function() {
          style.overflow = opts.overflow[0];
          style.overflowX = opts.overflow[1];
          style.overflowY = opts.overflow[2];
        });
      }
    }
    for (prop in props) {
      value = props[prop];
      if (rfxtypes.exec(value)) {
        delete props[prop];
        toggle = toggle || value === 'toggle';
        if (value === (hidden ? 'hide' : 'show')) {
          if (value === 'show' && dataShow && dataShow[prop] !== undefined) {
            hidden = true;
          } else {
            continue;
          }
        }
        orig[prop] = dataShow && dataShow[prop] || jQuery.style(elem, prop);
      } else {
        display = undefined;
      }
    }
    if (!jQuery.isEmptyObject(orig)) {
      if (dataShow) {
        if ('hidden' in dataShow) {
          hidden = dataShow.hidden;
        }
      } else {
        dataShow = jQuery._data(elem, 'fxshow', {});
      }
      if (toggle) {
        dataShow.hidden = !hidden;
      }
      if (hidden) {
        jQuery(elem).show();
      } else {
        anim.done(function() {
          jQuery(elem).hide();
        });
      }
      anim.done(function() {
        var prop;
        jQuery._removeData(elem, 'fxshow');
        for (prop in orig) {
          jQuery.style(elem, prop, orig[prop]);
        }
      });
      for (prop in orig) {
        tween = createTween(hidden ? dataShow[prop] : 0, prop, anim);
        if (!(prop in dataShow)) {
          dataShow[prop] = tween.start;
          if (hidden) {
            tween.end = tween.start;
            tween.start = prop === 'width' || prop === 'height' ? 1 : 0;
          }
        }
      }
    } else {
      if ((display === 'none' ? defaultDisplay(elem.nodeName) : display) === 'inline') {
        style.display = display;
      }
    }
  }
  function propFilter(props, specialEasing) {
    var index, name, easing, value, hooks;
    for (index in props) {
      name = jQuery.camelCase(index);
      easing = specialEasing[name];
      value = props[index];
      if (jQuery.isArray(value)) {
        easing = value[1];
        value = props[index] = value[0];
      }
      if (index !== name) {
        props[name] = value;
        delete props[index];
      }
      hooks = jQuery.cssHooks[name];
      if (hooks && 'expand' in hooks) {
        value = hooks.expand(value);
        delete props[name];
        for (index in value) {
          if (!(index in props)) {
            props[index] = value[index];
            specialEasing[index] = easing;
          }
        }
      } else {
        specialEasing[name] = easing;
      }
    }
  }
  function Animation(elem, properties, options) {
    var result, stopped, index = 0, length = animationPrefilters.length, deferred = jQuery.Deferred().always(function() {
      delete tick.elem;
    }), tick = function() {
      if (stopped) {
        return false;
      }
      var currentTime = fxNow || createFxNow(), remaining = Math.max(0, animation.startTime + animation.duration - currentTime), temp = remaining / animation.duration || 0, percent = 1 - temp, index = 0, length = animation.tweens.length;
      for (; index < length; index++) {
        animation.tweens[index].run(percent);
      }
      deferred.notifyWith(elem, [animation, percent, remaining]);
      if (percent < 1 && length) {
        return remaining;
      } else {
        deferred.resolveWith(elem, [animation]);
        return false;
      }
    }, animation = deferred.promise({elem:elem, props:jQuery.extend({}, properties), opts:jQuery.extend(true, {specialEasing:{}}, options), originalProperties:properties, originalOptions:options, startTime:fxNow || createFxNow(), duration:options.duration, tweens:[], createTween:function(prop, end) {
      var tween = jQuery.Tween(elem, animation.opts, prop, end, animation.opts.specialEasing[prop] || animation.opts.easing);
      animation.tweens.push(tween);
      return tween;
    }, stop:function(gotoEnd) {
      var index = 0, length = gotoEnd ? animation.tweens.length : 0;
      if (stopped) {
        return this;
      }
      stopped = true;
      for (; index < length; index++) {
        animation.tweens[index].run(1);
      }
      if (gotoEnd) {
        deferred.resolveWith(elem, [animation, gotoEnd]);
      } else {
        deferred.rejectWith(elem, [animation, gotoEnd]);
      }
      return this;
    }}), props = animation.props;
    propFilter(props, animation.opts.specialEasing);
    for (; index < length; index++) {
      result = animationPrefilters[index].call(animation, elem, props, animation.opts);
      if (result) {
        return result;
      }
    }
    jQuery.map(props, createTween, animation);
    if (jQuery.isFunction(animation.opts.start)) {
      animation.opts.start.call(elem, animation);
    }
    jQuery.fx.timer(jQuery.extend(tick, {elem:elem, anim:animation, queue:animation.opts.queue}));
    return animation.progress(animation.opts.progress).done(animation.opts.done, animation.opts.complete).fail(animation.opts.fail).always(animation.opts.always);
  }
  jQuery.Animation = jQuery.extend(Animation, {tweener:function(props, callback) {
    if (jQuery.isFunction(props)) {
      callback = props;
      props = ['*'];
    } else {
      props = props.split(' ');
    }
    var prop, index = 0, length = props.length;
    for (; index < length; index++) {
      prop = props[index];
      tweeners[prop] = tweeners[prop] || [];
      tweeners[prop].unshift(callback);
    }
  }, prefilter:function(callback, prepend) {
    if (prepend) {
      animationPrefilters.unshift(callback);
    } else {
      animationPrefilters.push(callback);
    }
  }});
  jQuery.speed = function(speed, easing, fn) {
    var opt = speed && typeof speed === 'object' ? jQuery.extend({}, speed) : {complete:fn || !fn && easing || jQuery.isFunction(speed) && speed, duration:speed, easing:fn && easing || easing && !jQuery.isFunction(easing) && easing};
    opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === 'number' ? opt.duration : opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[opt.duration] : jQuery.fx.speeds._default;
    if (opt.queue == null || opt.queue === true) {
      opt.queue = 'fx';
    }
    opt.old = opt.complete;
    opt.complete = function() {
      if (jQuery.isFunction(opt.old)) {
        opt.old.call(this);
      }
      if (opt.queue) {
        jQuery.dequeue(this, opt.queue);
      }
    };
    return opt;
  };
  jQuery.fn.extend({fadeTo:function(speed, to, easing, callback) {
    return this.filter(isHidden).css('opacity', 0).show().end().animate({opacity:to}, speed, easing, callback);
  }, animate:function(prop, speed, easing, callback) {
    var empty = jQuery.isEmptyObject(prop), optall = jQuery.speed(speed, easing, callback), doAnimation = function() {
      var anim = Animation(this, jQuery.extend({}, prop), optall);
      if (empty || jQuery._data(this, 'finish')) {
        anim.stop(true);
      }
    };
    doAnimation.finish = doAnimation;
    return empty || optall.queue === false ? this.each(doAnimation) : this.queue(optall.queue, doAnimation);
  }, stop:function(type, clearQueue, gotoEnd) {
    var stopQueue = function(hooks) {
      var stop = hooks.stop;
      delete hooks.stop;
      stop(gotoEnd);
    };
    if (typeof type !== 'string') {
      gotoEnd = clearQueue;
      clearQueue = type;
      type = undefined;
    }
    if (clearQueue && type !== false) {
      this.queue(type || 'fx', []);
    }
    return this.each(function() {
      var dequeue = true, index = type != null && type + 'queueHooks', timers = jQuery.timers, data = jQuery._data(this);
      if (index) {
        if (data[index] && data[index].stop) {
          stopQueue(data[index]);
        }
      } else {
        for (index in data) {
          if (data[index] && data[index].stop && rrun.test(index)) {
            stopQueue(data[index]);
          }
        }
      }
      for (index = timers.length; index--;) {
        if (timers[index].elem === this && (type == null || timers[index].queue === type)) {
          timers[index].anim.stop(gotoEnd);
          dequeue = false;
          timers.splice(index, 1);
        }
      }
      if (dequeue || !gotoEnd) {
        jQuery.dequeue(this, type);
      }
    });
  }, finish:function(type) {
    if (type !== false) {
      type = type || 'fx';
    }
    return this.each(function() {
      var index, data = jQuery._data(this), queue = data[type + 'queue'], hooks = data[type + 'queueHooks'], timers = jQuery.timers, length = queue ? queue.length : 0;
      data.finish = true;
      jQuery.queue(this, type, []);
      if (hooks && hooks.stop) {
        hooks.stop.call(this, true);
      }
      for (index = timers.length; index--;) {
        if (timers[index].elem === this && timers[index].queue === type) {
          timers[index].anim.stop(true);
          timers.splice(index, 1);
        }
      }
      for (index = 0; index < length; index++) {
        if (queue[index] && queue[index].finish) {
          queue[index].finish.call(this);
        }
      }
      delete data.finish;
    });
  }});
  jQuery.each(['toggle', 'show', 'hide'], function(i, name) {
    var cssFn = jQuery.fn[name];
    jQuery.fn[name] = function(speed, easing, callback) {
      return speed == null || typeof speed === 'boolean' ? cssFn.apply(this, arguments) : this.animate(genFx(name, true), speed, easing, callback);
    };
  });
  jQuery.each({slideDown:genFx('show'), slideUp:genFx('hide'), slideToggle:genFx('toggle'), fadeIn:{opacity:'show'}, fadeOut:{opacity:'hide'}, fadeToggle:{opacity:'toggle'}}, function(name, props) {
    jQuery.fn[name] = function(speed, easing, callback) {
      return this.animate(props, speed, easing, callback);
    };
  });
  jQuery.timers = [];
  jQuery.fx.tick = function() {
    var timer, timers = jQuery.timers, i = 0;
    fxNow = jQuery.now();
    for (; i < timers.length; i++) {
      timer = timers[i];
      if (!timer() && timers[i] === timer) {
        timers.splice(i--, 1);
      }
    }
    if (!timers.length) {
      jQuery.fx.stop();
    }
    fxNow = undefined;
  };
  jQuery.fx.timer = function(timer) {
    jQuery.timers.push(timer);
    if (timer()) {
      jQuery.fx.start();
    } else {
      jQuery.timers.pop();
    }
  };
  jQuery.fx.interval = 13;
  jQuery.fx.start = function() {
    if (!timerId) {
      timerId = setInterval(jQuery.fx.tick, jQuery.fx.interval);
    }
  };
  jQuery.fx.stop = function() {
    clearInterval(timerId);
    timerId = null;
  };
  jQuery.fx.speeds = {slow:600, fast:200, _default:400};
  jQuery.fn.delay = function(time, type) {
    time = jQuery.fx ? jQuery.fx.speeds[time] || time : time;
    type = type || 'fx';
    return this.queue(type, function(next, hooks) {
      var timeout = setTimeout(next, time);
      hooks.stop = function() {
        clearTimeout(timeout);
      };
    });
  };
  (function() {
    var input, div, select, a, opt;
    div = document.createElement('div');
    div.setAttribute('className', 't');
    div.innerHTML = "  \x3clink/\x3e\x3ctable\x3e\x3c/table\x3e\x3ca href\x3d'/a'\x3ea\x3c/a\x3e\x3cinput type\x3d'checkbox'/\x3e";
    a = div.getElementsByTagName('a')[0];
    select = document.createElement('select');
    opt = select.appendChild(document.createElement('option'));
    input = div.getElementsByTagName('input')[0];
    a.style.cssText = 'top:1px';
    support.getSetAttribute = div.className !== 't';
    support.style = /top/.test(a.getAttribute('style'));
    support.hrefNormalized = a.getAttribute('href') === '/a';
    support.checkOn = !!input.value;
    support.optSelected = opt.selected;
    support.enctype = !!document.createElement('form').enctype;
    select.disabled = true;
    support.optDisabled = !opt.disabled;
    input = document.createElement('input');
    input.setAttribute('value', '');
    support.input = input.getAttribute('value') === '';
    input.value = 't';
    input.setAttribute('type', 'radio');
    support.radioValue = input.value === 't';
  })();
  var rreturn = /\r/g;
  jQuery.fn.extend({val:function(value) {
    var hooks, ret, isFunction, elem = this[0];
    if (!arguments.length) {
      if (elem) {
        hooks = jQuery.valHooks[elem.type] || jQuery.valHooks[elem.nodeName.toLowerCase()];
        if (hooks && 'get' in hooks && (ret = hooks.get(elem, 'value')) !== undefined) {
          return ret;
        }
        ret = elem.value;
        return typeof ret === 'string' ? ret.replace(rreturn, '') : ret == null ? '' : ret;
      }
      return;
    }
    isFunction = jQuery.isFunction(value);
    return this.each(function(i) {
      var val;
      if (this.nodeType !== 1) {
        return;
      }
      if (isFunction) {
        val = value.call(this, i, jQuery(this).val());
      } else {
        val = value;
      }
      if (val == null) {
        val = '';
      } else {
        if (typeof val === 'number') {
          val += '';
        } else {
          if (jQuery.isArray(val)) {
            val = jQuery.map(val, function(value) {
              return value == null ? '' : value + '';
            });
          }
        }
      }
      hooks = jQuery.valHooks[this.type] || jQuery.valHooks[this.nodeName.toLowerCase()];
      if (!hooks || !('set' in hooks) || hooks.set(this, val, 'value') === undefined) {
        this.value = val;
      }
    });
  }});
  jQuery.extend({valHooks:{option:{get:function(elem) {
    var val = jQuery.find.attr(elem, 'value');
    return val != null ? val : jQuery.trim(jQuery.text(elem));
  }}, select:{get:function(elem) {
    var value, option, options = elem.options, index = elem.selectedIndex, one = elem.type === 'select-one' || index < 0, values = one ? null : [], max = one ? index + 1 : options.length, i = index < 0 ? max : one ? index : 0;
    for (; i < max; i++) {
      option = options[i];
      if ((option.selected || i === index) && (support.optDisabled ? !option.disabled : option.getAttribute('disabled') === null) && (!option.parentNode.disabled || !jQuery.nodeName(option.parentNode, 'optgroup'))) {
        value = jQuery(option).val();
        if (one) {
          return value;
        }
        values.push(value);
      }
    }
    return values;
  }, set:function(elem, value) {
    var optionSet, option, options = elem.options, values = jQuery.makeArray(value), i = options.length;
    while (i--) {
      option = options[i];
      if (jQuery.inArray(jQuery.valHooks.option.get(option), values) >= 0) {
        try {
          option.selected = optionSet = true;
        } catch (_) {
          option.scrollHeight;
        }
      } else {
        option.selected = false;
      }
    }
    if (!optionSet) {
      elem.selectedIndex = -1;
    }
    return options;
  }}}});
  jQuery.each(['radio', 'checkbox'], function() {
    jQuery.valHooks[this] = {set:function(elem, value) {
      if (jQuery.isArray(value)) {
        return elem.checked = jQuery.inArray(jQuery(elem).val(), value) >= 0;
      }
    }};
    if (!support.checkOn) {
      jQuery.valHooks[this].get = function(elem) {
        return elem.getAttribute('value') === null ? 'on' : elem.value;
      };
    }
  });
  var nodeHook, boolHook, attrHandle = jQuery.expr.attrHandle, ruseDefault = /^(?:checked|selected)$/i, getSetAttribute = support.getSetAttribute, getSetInput = support.input;
  jQuery.fn.extend({attr:function(name, value) {
    return access(this, jQuery.attr, name, value, arguments.length > 1);
  }, removeAttr:function(name) {
    return this.each(function() {
      jQuery.removeAttr(this, name);
    });
  }});
  jQuery.extend({attr:function(elem, name, value) {
    var hooks, ret, nType = elem.nodeType;
    if (!elem || nType === 3 || nType === 8 || nType === 2) {
      return;
    }
    if (typeof elem.getAttribute === strundefined) {
      return jQuery.prop(elem, name, value);
    }
    if (nType !== 1 || !jQuery.isXMLDoc(elem)) {
      name = name.toLowerCase();
      hooks = jQuery.attrHooks[name] || (jQuery.expr.match.bool.test(name) ? boolHook : nodeHook);
    }
    if (value !== undefined) {
      if (value === null) {
        jQuery.removeAttr(elem, name);
      } else {
        if (hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined) {
          return ret;
        } else {
          elem.setAttribute(name, value + '');
          return value;
        }
      }
    } else {
      if (hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null) {
        return ret;
      } else {
        ret = jQuery.find.attr(elem, name);
        return ret == null ? undefined : ret;
      }
    }
  }, removeAttr:function(elem, value) {
    var name, propName, i = 0, attrNames = value && value.match(rnotwhite);
    if (attrNames && elem.nodeType === 1) {
      while (name = attrNames[i++]) {
        propName = jQuery.propFix[name] || name;
        if (jQuery.expr.match.bool.test(name)) {
          if (getSetInput && getSetAttribute || !ruseDefault.test(name)) {
            elem[propName] = false;
          } else {
            elem[jQuery.camelCase('default-' + name)] = elem[propName] = false;
          }
        } else {
          jQuery.attr(elem, name, '');
        }
        elem.removeAttribute(getSetAttribute ? name : propName);
      }
    }
  }, attrHooks:{type:{set:function(elem, value) {
    if (!support.radioValue && value === 'radio' && jQuery.nodeName(elem, 'input')) {
      var val = elem.value;
      elem.setAttribute('type', value);
      if (val) {
        elem.value = val;
      }
      return value;
    }
  }}}});
  boolHook = {set:function(elem, value, name) {
    if (value === false) {
      jQuery.removeAttr(elem, name);
    } else {
      if (getSetInput && getSetAttribute || !ruseDefault.test(name)) {
        elem.setAttribute(!getSetAttribute && jQuery.propFix[name] || name, name);
      } else {
        elem[jQuery.camelCase('default-' + name)] = elem[name] = true;
      }
    }
    return name;
  }};
  jQuery.each(jQuery.expr.match.bool.source.match(/\w+/g), function(i, name) {
    var getter = attrHandle[name] || jQuery.find.attr;
    attrHandle[name] = getSetInput && getSetAttribute || !ruseDefault.test(name) ? function(elem, name, isXML) {
      var ret, handle;
      if (!isXML) {
        handle = attrHandle[name];
        attrHandle[name] = ret;
        ret = getter(elem, name, isXML) != null ? name.toLowerCase() : null;
        attrHandle[name] = handle;
      }
      return ret;
    } : function(elem, name, isXML) {
      if (!isXML) {
        return elem[jQuery.camelCase('default-' + name)] ? name.toLowerCase() : null;
      }
    };
  });
  if (!getSetInput || !getSetAttribute) {
    jQuery.attrHooks.value = {set:function(elem, value, name) {
      if (jQuery.nodeName(elem, 'input')) {
        elem.defaultValue = value;
      } else {
        return nodeHook && nodeHook.set(elem, value, name);
      }
    }};
  }
  if (!getSetAttribute) {
    nodeHook = {set:function(elem, value, name) {
      var ret = elem.getAttributeNode(name);
      if (!ret) {
        elem.setAttributeNode(ret = elem.ownerDocument.createAttribute(name));
      }
      ret.value = value += '';
      if (name === 'value' || value === elem.getAttribute(name)) {
        return value;
      }
    }};
    attrHandle.id = attrHandle.name = attrHandle.coords = function(elem, name, isXML) {
      var ret;
      if (!isXML) {
        return (ret = elem.getAttributeNode(name)) && ret.value !== '' ? ret.value : null;
      }
    };
    jQuery.valHooks.button = {get:function(elem, name) {
      var ret = elem.getAttributeNode(name);
      if (ret && ret.specified) {
        return ret.value;
      }
    }, set:nodeHook.set};
    jQuery.attrHooks.contenteditable = {set:function(elem, value, name) {
      nodeHook.set(elem, value === '' ? false : value, name);
    }};
    jQuery.each(['width', 'height'], function(i, name) {
      jQuery.attrHooks[name] = {set:function(elem, value) {
        if (value === '') {
          elem.setAttribute(name, 'auto');
          return value;
        }
      }};
    });
  }
  if (!support.style) {
    jQuery.attrHooks.style = {get:function(elem) {
      return elem.style.cssText || undefined;
    }, set:function(elem, value) {
      return elem.style.cssText = value + '';
    }};
  }
  var rfocusable = /^(?:input|select|textarea|button|object)$/i, rclickable = /^(?:a|area)$/i;
  jQuery.fn.extend({prop:function(name, value) {
    return access(this, jQuery.prop, name, value, arguments.length > 1);
  }, removeProp:function(name) {
    name = jQuery.propFix[name] || name;
    return this.each(function() {
      try {
        this[name] = undefined;
        delete this[name];
      } catch (e$42) {
      }
    });
  }});
  jQuery.extend({propFix:{'for':'htmlFor', 'class':'className'}, prop:function(elem, name, value) {
    var ret, hooks, notxml, nType = elem.nodeType;
    if (!elem || nType === 3 || nType === 8 || nType === 2) {
      return;
    }
    notxml = nType !== 1 || !jQuery.isXMLDoc(elem);
    if (notxml) {
      name = jQuery.propFix[name] || name;
      hooks = jQuery.propHooks[name];
    }
    if (value !== undefined) {
      return hooks && 'set' in hooks && (ret = hooks.set(elem, value, name)) !== undefined ? ret : elem[name] = value;
    } else {
      return hooks && 'get' in hooks && (ret = hooks.get(elem, name)) !== null ? ret : elem[name];
    }
  }, propHooks:{tabIndex:{get:function(elem) {
    var tabindex = jQuery.find.attr(elem, 'tabindex');
    return tabindex ? parseInt(tabindex, 10) : rfocusable.test(elem.nodeName) || rclickable.test(elem.nodeName) && elem.href ? 0 : -1;
  }}}});
  if (!support.hrefNormalized) {
    jQuery.each(['href', 'src'], function(i, name) {
      jQuery.propHooks[name] = {get:function(elem) {
        return elem.getAttribute(name, 4);
      }};
    });
  }
  if (!support.optSelected) {
    jQuery.propHooks.selected = {get:function(elem) {
      var parent = elem.parentNode;
      if (parent) {
        parent.selectedIndex;
        if (parent.parentNode) {
          parent.parentNode.selectedIndex;
        }
      }
      return null;
    }};
  }
  jQuery.each(['tabIndex', 'readOnly', 'maxLength', 'cellSpacing', 'cellPadding', 'rowSpan', 'colSpan', 'useMap', 'frameBorder', 'contentEditable'], function() {
    jQuery.propFix[this.toLowerCase()] = this;
  });
  if (!support.enctype) {
    jQuery.propFix.enctype = 'encoding';
  }
  var rclass = /[\t\r\n\f]/g;
  jQuery.fn.extend({addClass:function(value) {
    var classes, elem, cur, clazz, j, finalValue, i = 0, len = this.length, proceed = typeof value === 'string' && value;
    if (jQuery.isFunction(value)) {
      return this.each(function(j) {
        jQuery(this).addClass(value.call(this, j, this.className));
      });
    }
    if (proceed) {
      classes = (value || '').match(rnotwhite) || [];
      for (; i < len; i++) {
        elem = this[i];
        cur = elem.nodeType === 1 && (elem.className ? (' ' + elem.className + ' ').replace(rclass, ' ') : ' ');
        if (cur) {
          j = 0;
          while (clazz = classes[j++]) {
            if (cur.indexOf(' ' + clazz + ' ') < 0) {
              cur += clazz + ' ';
            }
          }
          finalValue = jQuery.trim(cur);
          if (elem.className !== finalValue) {
            elem.className = finalValue;
          }
        }
      }
    }
    return this;
  }, removeClass:function(value) {
    var classes, elem, cur, clazz, j, finalValue, i = 0, len = this.length, proceed = arguments.length === 0 || typeof value === 'string' && value;
    if (jQuery.isFunction(value)) {
      return this.each(function(j) {
        jQuery(this).removeClass(value.call(this, j, this.className));
      });
    }
    if (proceed) {
      classes = (value || '').match(rnotwhite) || [];
      for (; i < len; i++) {
        elem = this[i];
        cur = elem.nodeType === 1 && (elem.className ? (' ' + elem.className + ' ').replace(rclass, ' ') : '');
        if (cur) {
          j = 0;
          while (clazz = classes[j++]) {
            while (cur.indexOf(' ' + clazz + ' ') >= 0) {
              cur = cur.replace(' ' + clazz + ' ', ' ');
            }
          }
          finalValue = value ? jQuery.trim(cur) : '';
          if (elem.className !== finalValue) {
            elem.className = finalValue;
          }
        }
      }
    }
    return this;
  }, toggleClass:function(value, stateVal) {
    var type = typeof value;
    if (typeof stateVal === 'boolean' && type === 'string') {
      return stateVal ? this.addClass(value) : this.removeClass(value);
    }
    if (jQuery.isFunction(value)) {
      return this.each(function(i) {
        jQuery(this).toggleClass(value.call(this, i, this.className, stateVal), stateVal);
      });
    }
    return this.each(function() {
      if (type === 'string') {
        var className, i = 0, self = jQuery(this), classNames = value.match(rnotwhite) || [];
        while (className = classNames[i++]) {
          if (self.hasClass(className)) {
            self.removeClass(className);
          } else {
            self.addClass(className);
          }
        }
      } else {
        if (type === strundefined || type === 'boolean') {
          if (this.className) {
            jQuery._data(this, '__className__', this.className);
          }
          this.className = this.className || value === false ? '' : jQuery._data(this, '__className__') || '';
        }
      }
    });
  }, hasClass:function(selector) {
    var className = ' ' + selector + ' ', i = 0, l = this.length;
    for (; i < l; i++) {
      if (this[i].nodeType === 1 && (' ' + this[i].className + ' ').replace(rclass, ' ').indexOf(className) >= 0) {
        return true;
      }
    }
    return false;
  }});
  jQuery.each(('blur focus focusin focusout load resize scroll unload click dblclick ' + 'mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave ' + 'change select submit keydown keypress keyup error contextmenu').split(' '), function(i, name) {
    jQuery.fn[name] = function(data, fn) {
      return arguments.length > 0 ? this.on(name, null, data, fn) : this.trigger(name);
    };
  });
  jQuery.fn.extend({hover:function(fnOver, fnOut) {
    return this.mouseenter(fnOver).mouseleave(fnOut || fnOver);
  }, bind:function(types, data, fn) {
    return this.on(types, null, data, fn);
  }, unbind:function(types, fn) {
    return this.off(types, null, fn);
  }, delegate:function(selector, types, data, fn) {
    return this.on(types, selector, data, fn);
  }, undelegate:function(selector, types, fn) {
    return arguments.length === 1 ? this.off(selector, '**') : this.off(types, selector || '**', fn);
  }});
  var nonce = jQuery.now();
  var rquery = /\?/;
  var rvalidtokens = /(,)|(\[|{)|(}|])|"(?:[^"\\\r\n]|\\["\\\/bfnrt]|\\u[\da-fA-F]{4})*"\s*:?|true|false|null|-?(?!0\d)\d+(?:\.\d+|)(?:[eE][+-]?\d+|)/g;
  jQuery.parseJSON = function(data) {
    if (window.JSON && window.JSON.parse) {
      return window.JSON.parse(data + '');
    }
    var requireNonComma, depth = null, str = jQuery.trim(data + '');
    return str && !jQuery.trim(str.replace(rvalidtokens, function(token, comma, open, close) {
      if (requireNonComma && comma) {
        depth = 0;
      }
      if (depth === 0) {
        return token;
      }
      requireNonComma = open || comma;
      depth += !close - !open;
      return '';
    })) ? Function('return ' + str)() : jQuery.error('Invalid JSON: ' + data);
  };
  jQuery.parseXML = function(data) {
    var xml, tmp;
    if (!data || typeof data !== 'string') {
      return null;
    }
    try {
      if (window.DOMParser) {
        tmp = new DOMParser;
        xml = tmp.parseFromString(data, 'text/xml');
      } else {
        xml = new ActiveXObject('Microsoft.XMLDOM');
        xml.async = 'false';
        xml.loadXML(data);
      }
    } catch (e$43) {
      xml = undefined;
    }
    if (!xml || !xml.documentElement || xml.getElementsByTagName('parsererror').length) {
      jQuery.error('Invalid XML: ' + data);
    }
    return xml;
  };
  var ajaxLocParts, ajaxLocation, rhash = /#.*$/, rts = /([?&])_=[^&]*/, rheaders = /^(.*?):[ \t]*([^\r\n]*)\r?$/mg, rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/, rnoContent = /^(?:GET|HEAD)$/, rprotocol = /^\/\//, rurl = /^([\w.+-]+:)(?:\/\/(?:[^\/?#]*@|)([^\/?#:]*)(?::(\d+)|)|)/, prefilters = {}, transports = {}, allTypes = '*/'.concat('*');
  try {
    ajaxLocation = location.href;
  } catch (e$44) {
    ajaxLocation = document.createElement('a');
    ajaxLocation.href = '';
    ajaxLocation = ajaxLocation.href;
  }
  ajaxLocParts = rurl.exec(ajaxLocation.toLowerCase()) || [];
  function addToPrefiltersOrTransports(structure) {
    return function(dataTypeExpression, func) {
      if (typeof dataTypeExpression !== 'string') {
        func = dataTypeExpression;
        dataTypeExpression = '*';
      }
      var dataType, i = 0, dataTypes = dataTypeExpression.toLowerCase().match(rnotwhite) || [];
      if (jQuery.isFunction(func)) {
        while (dataType = dataTypes[i++]) {
          if (dataType.charAt(0) === '+') {
            dataType = dataType.slice(1) || '*';
            (structure[dataType] = structure[dataType] || []).unshift(func);
          } else {
            (structure[dataType] = structure[dataType] || []).push(func);
          }
        }
      }
    };
  }
  function inspectPrefiltersOrTransports(structure, options, originalOptions, jqXHR) {
    var inspected = {}, seekingTransport = structure === transports;
    function inspect(dataType) {
      var selected;
      inspected[dataType] = true;
      jQuery.each(structure[dataType] || [], function(_, prefilterOrFactory) {
        var dataTypeOrTransport = prefilterOrFactory(options, originalOptions, jqXHR);
        if (typeof dataTypeOrTransport === 'string' && !seekingTransport && !inspected[dataTypeOrTransport]) {
          options.dataTypes.unshift(dataTypeOrTransport);
          inspect(dataTypeOrTransport);
          return false;
        } else {
          if (seekingTransport) {
            return !(selected = dataTypeOrTransport);
          }
        }
      });
      return selected;
    }
    return inspect(options.dataTypes[0]) || !inspected['*'] && inspect('*');
  }
  function ajaxExtend(target, src) {
    var deep, key, flatOptions = jQuery.ajaxSettings.flatOptions || {};
    for (key in src) {
      if (src[key] !== undefined) {
        (flatOptions[key] ? target : deep || (deep = {}))[key] = src[key];
      }
    }
    if (deep) {
      jQuery.extend(true, target, deep);
    }
    return target;
  }
  function ajaxHandleResponses(s, jqXHR, responses) {
    var firstDataType, ct, finalDataType, type, contents = s.contents, dataTypes = s.dataTypes;
    while (dataTypes[0] === '*') {
      dataTypes.shift();
      if (ct === undefined) {
        ct = s.mimeType || jqXHR.getResponseHeader('Content-Type');
      }
    }
    if (ct) {
      for (type in contents) {
        if (contents[type] && contents[type].test(ct)) {
          dataTypes.unshift(type);
          break;
        }
      }
    }
    if (dataTypes[0] in responses) {
      finalDataType = dataTypes[0];
    } else {
      for (type in responses) {
        if (!dataTypes[0] || s.converters[type + ' ' + dataTypes[0]]) {
          finalDataType = type;
          break;
        }
        if (!firstDataType) {
          firstDataType = type;
        }
      }
      finalDataType = finalDataType || firstDataType;
    }
    if (finalDataType) {
      if (finalDataType !== dataTypes[0]) {
        dataTypes.unshift(finalDataType);
      }
      return responses[finalDataType];
    }
  }
  function ajaxConvert(s, response, jqXHR, isSuccess) {
    var conv2, current, conv, tmp, prev, converters = {}, dataTypes = s.dataTypes.slice();
    if (dataTypes[1]) {
      for (conv in s.converters) {
        converters[conv.toLowerCase()] = s.converters[conv];
      }
    }
    current = dataTypes.shift();
    while (current) {
      if (s.responseFields[current]) {
        jqXHR[s.responseFields[current]] = response;
      }
      if (!prev && isSuccess && s.dataFilter) {
        response = s.dataFilter(response, s.dataType);
      }
      prev = current;
      current = dataTypes.shift();
      if (current) {
        if (current === '*') {
          current = prev;
        } else {
          if (prev !== '*' && prev !== current) {
            conv = converters[prev + ' ' + current] || converters['* ' + current];
            if (!conv) {
              for (conv2 in converters) {
                tmp = conv2.split(' ');
                if (tmp[1] === current) {
                  conv = converters[prev + ' ' + tmp[0]] || converters['* ' + tmp[0]];
                  if (conv) {
                    if (conv === true) {
                      conv = converters[conv2];
                    } else {
                      if (converters[conv2] !== true) {
                        current = tmp[0];
                        dataTypes.unshift(tmp[1]);
                      }
                    }
                    break;
                  }
                }
              }
            }
            if (conv !== true) {
              if (conv && s['throws']) {
                response = conv(response);
              } else {
                try {
                  response = conv(response);
                } catch (e$45) {
                  return {state:'parsererror', error:conv ? e$45 : 'No conversion from ' + prev + ' to ' + current};
                }
              }
            }
          }
        }
      }
    }
    return {state:'success', data:response};
  }
  jQuery.extend({active:0, lastModified:{}, etag:{}, ajaxSettings:{url:ajaxLocation, type:'GET', isLocal:rlocalProtocol.test(ajaxLocParts[1]), global:true, processData:true, async:true, contentType:'application/x-www-form-urlencoded; charset\x3dUTF-8', accepts:{'*':allTypes, text:'text/plain', html:'text/html', xml:'application/xml, text/xml', json:'application/json, text/javascript'}, contents:{xml:/xml/, html:/html/, json:/json/}, responseFields:{xml:'responseXML', text:'responseText', json:'responseJSON'}, 
  converters:{'* text':String, 'text html':true, 'text json':jQuery.parseJSON, 'text xml':jQuery.parseXML}, flatOptions:{url:true, context:true}}, ajaxSetup:function(target, settings) {
    return settings ? ajaxExtend(ajaxExtend(target, jQuery.ajaxSettings), settings) : ajaxExtend(jQuery.ajaxSettings, target);
  }, ajaxPrefilter:addToPrefiltersOrTransports(prefilters), ajaxTransport:addToPrefiltersOrTransports(transports), ajax:function(url, options) {
    if (typeof url === 'object') {
      options = url;
      url = undefined;
    }
    options = options || {};
    var parts, i, cacheURL, responseHeadersString, timeoutTimer, fireGlobals, transport, responseHeaders, s = jQuery.ajaxSetup({}, options), callbackContext = s.context || s, globalEventContext = s.context && (callbackContext.nodeType || callbackContext.jquery) ? jQuery(callbackContext) : jQuery.event, deferred = jQuery.Deferred(), completeDeferred = jQuery.Callbacks('once memory'), statusCode = s.statusCode || {}, requestHeaders = {}, requestHeadersNames = {}, state = 0, strAbort = 'canceled', jqXHR = 
    {readyState:0, getResponseHeader:function(key) {
      var match;
      if (state === 2) {
        if (!responseHeaders) {
          responseHeaders = {};
          while (match = rheaders.exec(responseHeadersString)) {
            responseHeaders[match[1].toLowerCase()] = match[2];
          }
        }
        match = responseHeaders[key.toLowerCase()];
      }
      return match == null ? null : match;
    }, getAllResponseHeaders:function() {
      return state === 2 ? responseHeadersString : null;
    }, setRequestHeader:function(name, value) {
      var lname = name.toLowerCase();
      if (!state) {
        name = requestHeadersNames[lname] = requestHeadersNames[lname] || name;
        requestHeaders[name] = value;
      }
      return this;
    }, overrideMimeType:function(type) {
      if (!state) {
        s.mimeType = type;
      }
      return this;
    }, statusCode:function(map) {
      var code;
      if (map) {
        if (state < 2) {
          for (code in map) {
            statusCode[code] = [statusCode[code], map[code]];
          }
        } else {
          jqXHR.always(map[jqXHR.status]);
        }
      }
      return this;
    }, abort:function(statusText) {
      var finalText = statusText || strAbort;
      if (transport) {
        transport.abort(finalText);
      }
      done(0, finalText);
      return this;
    }};
    deferred.promise(jqXHR).complete = completeDeferred.add;
    jqXHR.success = jqXHR.done;
    jqXHR.error = jqXHR.fail;
    s.url = ((url || s.url || ajaxLocation) + '').replace(rhash, '').replace(rprotocol, ajaxLocParts[1] + '//');
    s.type = options.method || options.type || s.method || s.type;
    s.dataTypes = jQuery.trim(s.dataType || '*').toLowerCase().match(rnotwhite) || [''];
    if (s.crossDomain == null) {
      parts = rurl.exec(s.url.toLowerCase());
      s.crossDomain = !!(parts && (parts[1] !== ajaxLocParts[1] || parts[2] !== ajaxLocParts[2] || (parts[3] || (parts[1] === 'http:' ? '80' : '443')) !== (ajaxLocParts[3] || (ajaxLocParts[1] === 'http:' ? '80' : '443'))));
    }
    if (s.data && s.processData && typeof s.data !== 'string') {
      s.data = jQuery.param(s.data, s.traditional);
    }
    inspectPrefiltersOrTransports(prefilters, s, options, jqXHR);
    if (state === 2) {
      return jqXHR;
    }
    fireGlobals = s.global;
    if (fireGlobals && jQuery.active++ === 0) {
      jQuery.event.trigger('ajaxStart');
    }
    s.type = s.type.toUpperCase();
    s.hasContent = !rnoContent.test(s.type);
    cacheURL = s.url;
    if (!s.hasContent) {
      if (s.data) {
        cacheURL = s.url += (rquery.test(cacheURL) ? '\x26' : '?') + s.data;
        delete s.data;
      }
      if (s.cache === false) {
        s.url = rts.test(cacheURL) ? cacheURL.replace(rts, '$1_\x3d' + nonce++) : cacheURL + (rquery.test(cacheURL) ? '\x26' : '?') + '_\x3d' + nonce++;
      }
    }
    if (s.ifModified) {
      if (jQuery.lastModified[cacheURL]) {
        jqXHR.setRequestHeader('If-Modified-Since', jQuery.lastModified[cacheURL]);
      }
      if (jQuery.etag[cacheURL]) {
        jqXHR.setRequestHeader('If-None-Match', jQuery.etag[cacheURL]);
      }
    }
    if (s.data && s.hasContent && s.contentType !== false || options.contentType) {
      jqXHR.setRequestHeader('Content-Type', s.contentType);
    }
    jqXHR.setRequestHeader('Accept', s.dataTypes[0] && s.accepts[s.dataTypes[0]] ? s.accepts[s.dataTypes[0]] + (s.dataTypes[0] !== '*' ? ', ' + allTypes + '; q\x3d0.01' : '') : s.accepts['*']);
    for (i in s.headers) {
      jqXHR.setRequestHeader(i, s.headers[i]);
    }
    if (s.beforeSend && (s.beforeSend.call(callbackContext, jqXHR, s) === false || state === 2)) {
      return jqXHR.abort();
    }
    strAbort = 'abort';
    for (i in{success:1, error:1, complete:1}) {
      jqXHR[i](s[i]);
    }
    transport = inspectPrefiltersOrTransports(transports, s, options, jqXHR);
    if (!transport) {
      done(-1, 'No Transport');
    } else {
      jqXHR.readyState = 1;
      if (fireGlobals) {
        globalEventContext.trigger('ajaxSend', [jqXHR, s]);
      }
      if (s.async && s.timeout > 0) {
        timeoutTimer = setTimeout(function() {
          jqXHR.abort('timeout');
        }, s.timeout);
      }
      try {
        state = 1;
        transport.send(requestHeaders, done);
      } catch (e$46) {
        if (state < 2) {
          done(-1, e$46);
        } else {
          throw e$46;
        }
      }
    }
    function done(status, nativeStatusText, responses, headers) {
      var isSuccess, success, error, response, modified, statusText = nativeStatusText;
      if (state === 2) {
        return;
      }
      state = 2;
      if (timeoutTimer) {
        clearTimeout(timeoutTimer);
      }
      transport = undefined;
      responseHeadersString = headers || '';
      jqXHR.readyState = status > 0 ? 4 : 0;
      isSuccess = status >= 200 && status < 300 || status === 304;
      if (responses) {
        response = ajaxHandleResponses(s, jqXHR, responses);
      }
      response = ajaxConvert(s, response, jqXHR, isSuccess);
      if (isSuccess) {
        if (s.ifModified) {
          modified = jqXHR.getResponseHeader('Last-Modified');
          if (modified) {
            jQuery.lastModified[cacheURL] = modified;
          }
          modified = jqXHR.getResponseHeader('etag');
          if (modified) {
            jQuery.etag[cacheURL] = modified;
          }
        }
        if (status === 204 || s.type === 'HEAD') {
          statusText = 'nocontent';
        } else {
          if (status === 304) {
            statusText = 'notmodified';
          } else {
            statusText = response.state;
            success = response.data;
            error = response.error;
            isSuccess = !error;
          }
        }
      } else {
        error = statusText;
        if (status || !statusText) {
          statusText = 'error';
          if (status < 0) {
            status = 0;
          }
        }
      }
      jqXHR.status = status;
      jqXHR.statusText = (nativeStatusText || statusText) + '';
      if (isSuccess) {
        deferred.resolveWith(callbackContext, [success, statusText, jqXHR]);
      } else {
        deferred.rejectWith(callbackContext, [jqXHR, statusText, error]);
      }
      jqXHR.statusCode(statusCode);
      statusCode = undefined;
      if (fireGlobals) {
        globalEventContext.trigger(isSuccess ? 'ajaxSuccess' : 'ajaxError', [jqXHR, s, isSuccess ? success : error]);
      }
      completeDeferred.fireWith(callbackContext, [jqXHR, statusText]);
      if (fireGlobals) {
        globalEventContext.trigger('ajaxComplete', [jqXHR, s]);
        if (!--jQuery.active) {
          jQuery.event.trigger('ajaxStop');
        }
      }
    }
    return jqXHR;
  }, getJSON:function(url, data, callback) {
    return jQuery.get(url, data, callback, 'json');
  }, getScript:function(url, callback) {
    return jQuery.get(url, undefined, callback, 'script');
  }});
  jQuery.each(['get', 'post'], function(i, method) {
    jQuery[method] = function(url, data, callback, type) {
      if (jQuery.isFunction(data)) {
        type = type || callback;
        callback = data;
        data = undefined;
      }
      return jQuery.ajax({url:url, type:method, dataType:type, data:data, success:callback});
    };
  });
  jQuery.each(['ajaxStart', 'ajaxStop', 'ajaxComplete', 'ajaxError', 'ajaxSuccess', 'ajaxSend'], function(i, type) {
    jQuery.fn[type] = function(fn) {
      return this.on(type, fn);
    };
  });
  jQuery._evalUrl = function(url) {
    return jQuery.ajax({url:url, type:'GET', dataType:'script', async:false, global:false, 'throws':true});
  };
  jQuery.fn.extend({wrapAll:function(html) {
    if (jQuery.isFunction(html)) {
      return this.each(function(i) {
        jQuery(this).wrapAll(html.call(this, i));
      });
    }
    if (this[0]) {
      var wrap = jQuery(html, this[0].ownerDocument).eq(0).clone(true);
      if (this[0].parentNode) {
        wrap.insertBefore(this[0]);
      }
      wrap.map(function() {
        var elem = this;
        while (elem.firstChild && elem.firstChild.nodeType === 1) {
          elem = elem.firstChild;
        }
        return elem;
      }).append(this);
    }
    return this;
  }, wrapInner:function(html) {
    if (jQuery.isFunction(html)) {
      return this.each(function(i) {
        jQuery(this).wrapInner(html.call(this, i));
      });
    }
    return this.each(function() {
      var self = jQuery(this), contents = self.contents();
      if (contents.length) {
        contents.wrapAll(html);
      } else {
        self.append(html);
      }
    });
  }, wrap:function(html) {
    var isFunction = jQuery.isFunction(html);
    return this.each(function(i) {
      jQuery(this).wrapAll(isFunction ? html.call(this, i) : html);
    });
  }, unwrap:function() {
    return this.parent().each(function() {
      if (!jQuery.nodeName(this, 'body')) {
        jQuery(this).replaceWith(this.childNodes);
      }
    }).end();
  }});
  jQuery.expr.filters.hidden = function(elem) {
    return elem.offsetWidth <= 0 && elem.offsetHeight <= 0 || !support.reliableHiddenOffsets() && (elem.style && elem.style.display || jQuery.css(elem, 'display')) === 'none';
  };
  jQuery.expr.filters.visible = function(elem) {
    return !jQuery.expr.filters.hidden(elem);
  };
  var r20 = /%20/g, rbracket = /\[\]$/, rCRLF = /\r?\n/g, rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i, rsubmittable = /^(?:input|select|textarea|keygen)/i;
  function buildParams(prefix, obj, traditional, add) {
    var name;
    if (jQuery.isArray(obj)) {
      jQuery.each(obj, function(i, v) {
        if (traditional || rbracket.test(prefix)) {
          add(prefix, v);
        } else {
          buildParams(prefix + '[' + (typeof v === 'object' ? i : '') + ']', v, traditional, add);
        }
      });
    } else {
      if (!traditional && jQuery.type(obj) === 'object') {
        for (name in obj) {
          buildParams(prefix + '[' + name + ']', obj[name], traditional, add);
        }
      } else {
        add(prefix, obj);
      }
    }
  }
  jQuery.param = function(a, traditional) {
    var prefix, s = [], add = function(key, value) {
      value = jQuery.isFunction(value) ? value() : value == null ? '' : value;
      s[s.length] = encodeURIComponent(key) + '\x3d' + encodeURIComponent(value);
    };
    if (traditional === undefined) {
      traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
    }
    if (jQuery.isArray(a) || a.jquery && !jQuery.isPlainObject(a)) {
      jQuery.each(a, function() {
        add(this.name, this.value);
      });
    } else {
      for (prefix in a) {
        buildParams(prefix, a[prefix], traditional, add);
      }
    }
    return s.join('\x26').replace(r20, '+');
  };
  jQuery.fn.extend({serialize:function() {
    return jQuery.param(this.serializeArray());
  }, serializeArray:function() {
    return this.map(function() {
      var elements = jQuery.prop(this, 'elements');
      return elements ? jQuery.makeArray(elements) : this;
    }).filter(function() {
      var type = this.type;
      return this.name && !jQuery(this).is(':disabled') && rsubmittable.test(this.nodeName) && !rsubmitterTypes.test(type) && (this.checked || !rcheckableType.test(type));
    }).map(function(i, elem) {
      var val = jQuery(this).val();
      return val == null ? null : jQuery.isArray(val) ? jQuery.map(val, function(val) {
        return {name:elem.name, value:val.replace(rCRLF, '\r\n')};
      }) : {name:elem.name, value:val.replace(rCRLF, '\r\n')};
    }).get();
  }});
  jQuery.ajaxSettings.xhr = window.ActiveXObject !== undefined ? function() {
    return !this.isLocal && /^(get|post|head|put|delete|options)$/i.test(this.type) && createStandardXHR() || createActiveXHR();
  } : createStandardXHR;
  var xhrId = 0, xhrCallbacks = {}, xhrSupported = jQuery.ajaxSettings.xhr();
  if (window.ActiveXObject) {
    jQuery(window).on('unload', function() {
      for (var key in xhrCallbacks) {
        xhrCallbacks[key](undefined, true);
      }
    });
  }
  support.cors = !!xhrSupported && 'withCredentials' in xhrSupported;
  xhrSupported = support.ajax = !!xhrSupported;
  if (xhrSupported) {
    jQuery.ajaxTransport(function(options) {
      if (!options.crossDomain || support.cors) {
        var callback;
        return {send:function(headers, complete) {
          var i, xhr = options.xhr(), id = ++xhrId;
          xhr.open(options.type, options.url, options.async, options.username, options.password);
          if (options.xhrFields) {
            for (i in options.xhrFields) {
              xhr[i] = options.xhrFields[i];
            }
          }
          if (options.mimeType && xhr.overrideMimeType) {
            xhr.overrideMimeType(options.mimeType);
          }
          if (!options.crossDomain && !headers['X-Requested-With']) {
            headers['X-Requested-With'] = 'XMLHttpRequest';
          }
          for (i in headers) {
            if (headers[i] !== undefined) {
              xhr.setRequestHeader(i, headers[i] + '');
            }
          }
          xhr.send(options.hasContent && options.data || null);
          callback = function(_, isAbort) {
            var status, statusText, responses;
            if (callback && (isAbort || xhr.readyState === 4)) {
              delete xhrCallbacks[id];
              callback = undefined;
              xhr.onreadystatechange = jQuery.noop;
              if (isAbort) {
                if (xhr.readyState !== 4) {
                  xhr.abort();
                }
              } else {
                responses = {};
                status = xhr.status;
                if (typeof xhr.responseText === 'string') {
                  responses.text = xhr.responseText;
                }
                try {
                  statusText = xhr.statusText;
                } catch (e$47) {
                  statusText = '';
                }
                if (!status && options.isLocal && !options.crossDomain) {
                  status = responses.text ? 200 : 404;
                } else {
                  if (status === 1223) {
                    status = 204;
                  }
                }
              }
            }
            if (responses) {
              complete(status, statusText, responses, xhr.getAllResponseHeaders());
            }
          };
          if (!options.async) {
            callback();
          } else {
            if (xhr.readyState === 4) {
              setTimeout(callback);
            } else {
              xhr.onreadystatechange = xhrCallbacks[id] = callback;
            }
          }
        }, abort:function() {
          if (callback) {
            callback(undefined, true);
          }
        }};
      }
    });
  }
  function createStandardXHR() {
    try {
      return new window.XMLHttpRequest;
    } catch (e$48) {
    }
  }
  function createActiveXHR() {
    try {
      return new window.ActiveXObject('Microsoft.XMLHTTP');
    } catch (e$49) {
    }
  }
  jQuery.ajaxSetup({accepts:{script:'text/javascript, application/javascript, application/ecmascript, application/x-ecmascript'}, contents:{script:/(?:java|ecma)script/}, converters:{'text script':function(text) {
    jQuery.globalEval(text);
    return text;
  }}});
  jQuery.ajaxPrefilter('script', function(s) {
    if (s.cache === undefined) {
      s.cache = false;
    }
    if (s.crossDomain) {
      s.type = 'GET';
      s.global = false;
    }
  });
  jQuery.ajaxTransport('script', function(s) {
    if (s.crossDomain) {
      var script, head = document.head || jQuery('head')[0] || document.documentElement;
      return {send:function(_, callback) {
        script = document.createElement('script');
        script.async = true;
        if (s.scriptCharset) {
          script.charset = s.scriptCharset;
        }
        script.src = s.url;
        script.onload = script.onreadystatechange = function(_, isAbort) {
          if (isAbort || !script.readyState || /loaded|complete/.test(script.readyState)) {
            script.onload = script.onreadystatechange = null;
            if (script.parentNode) {
              script.parentNode.removeChild(script);
            }
            script = null;
            if (!isAbort) {
              callback(200, 'success');
            }
          }
        };
        head.insertBefore(script, head.firstChild);
      }, abort:function() {
        if (script) {
          script.onload(undefined, true);
        }
      }};
    }
  });
  var oldCallbacks = [], rjsonp = /(=)\?(?=&|$)|\?\?/;
  jQuery.ajaxSetup({jsonp:'callback', jsonpCallback:function() {
    var callback = oldCallbacks.pop() || jQuery.expando + '_' + nonce++;
    this[callback] = true;
    return callback;
  }});
  jQuery.ajaxPrefilter('json jsonp', function(s, originalSettings, jqXHR) {
    var callbackName, overwritten, responseContainer, jsonProp = s.jsonp !== false && (rjsonp.test(s.url) ? 'url' : typeof s.data === 'string' && !(s.contentType || '').indexOf('application/x-www-form-urlencoded') && rjsonp.test(s.data) && 'data');
    if (jsonProp || s.dataTypes[0] === 'jsonp') {
      callbackName = s.jsonpCallback = jQuery.isFunction(s.jsonpCallback) ? s.jsonpCallback() : s.jsonpCallback;
      if (jsonProp) {
        s[jsonProp] = s[jsonProp].replace(rjsonp, '$1' + callbackName);
      } else {
        if (s.jsonp !== false) {
          s.url += (rquery.test(s.url) ? '\x26' : '?') + s.jsonp + '\x3d' + callbackName;
        }
      }
      s.converters['script json'] = function() {
        if (!responseContainer) {
          jQuery.error(callbackName + ' was not called');
        }
        return responseContainer[0];
      };
      s.dataTypes[0] = 'json';
      overwritten = window[callbackName];
      window[callbackName] = function() {
        responseContainer = arguments;
      };
      jqXHR.always(function() {
        window[callbackName] = overwritten;
        if (s[callbackName]) {
          s.jsonpCallback = originalSettings.jsonpCallback;
          oldCallbacks.push(callbackName);
        }
        if (responseContainer && jQuery.isFunction(overwritten)) {
          overwritten(responseContainer[0]);
        }
        responseContainer = overwritten = undefined;
      });
      return 'script';
    }
  });
  jQuery.parseHTML = function(data, context, keepScripts) {
    if (!data || typeof data !== 'string') {
      return null;
    }
    if (typeof context === 'boolean') {
      keepScripts = context;
      context = false;
    }
    context = context || document;
    var parsed = rsingleTag.exec(data), scripts = !keepScripts && [];
    if (parsed) {
      return [context.createElement(parsed[1])];
    }
    parsed = jQuery.buildFragment([data], context, scripts);
    if (scripts && scripts.length) {
      jQuery(scripts).remove();
    }
    return jQuery.merge([], parsed.childNodes);
  };
  var _load = jQuery.fn.load;
  jQuery.fn.load = function(url, params, callback) {
    if (typeof url !== 'string' && _load) {
      return _load.apply(this, arguments);
    }
    var selector, response, type, self = this, off = url.indexOf(' ');
    if (off >= 0) {
      selector = jQuery.trim(url.slice(off, url.length));
      url = url.slice(0, off);
    }
    if (jQuery.isFunction(params)) {
      callback = params;
      params = undefined;
    } else {
      if (params && typeof params === 'object') {
        type = 'POST';
      }
    }
    if (self.length > 0) {
      jQuery.ajax({url:url, type:type, dataType:'html', data:params}).done(function(responseText) {
        response = arguments;
        self.html(selector ? jQuery('\x3cdiv\x3e').append(jQuery.parseHTML(responseText)).find(selector) : responseText);
      }).complete(callback && function(jqXHR, status) {
        self.each(callback, response || [jqXHR.responseText, status, jqXHR]);
      });
    }
    return this;
  };
  jQuery.expr.filters.animated = function(elem) {
    return jQuery.grep(jQuery.timers, function(fn) {
      return elem === fn.elem;
    }).length;
  };
  var docElem = window.document.documentElement;
  function getWindow(elem) {
    return jQuery.isWindow(elem) ? elem : elem.nodeType === 9 ? elem.defaultView || elem.parentWindow : false;
  }
  jQuery.offset = {setOffset:function(elem, options, i) {
    var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition, position = jQuery.css(elem, 'position'), curElem = jQuery(elem), props = {};
    if (position === 'static') {
      elem.style.position = 'relative';
    }
    curOffset = curElem.offset();
    curCSSTop = jQuery.css(elem, 'top');
    curCSSLeft = jQuery.css(elem, 'left');
    calculatePosition = (position === 'absolute' || position === 'fixed') && jQuery.inArray('auto', [curCSSTop, curCSSLeft]) > -1;
    if (calculatePosition) {
      curPosition = curElem.position();
      curTop = curPosition.top;
      curLeft = curPosition.left;
    } else {
      curTop = parseFloat(curCSSTop) || 0;
      curLeft = parseFloat(curCSSLeft) || 0;
    }
    if (jQuery.isFunction(options)) {
      options = options.call(elem, i, curOffset);
    }
    if (options.top != null) {
      props.top = options.top - curOffset.top + curTop;
    }
    if (options.left != null) {
      props.left = options.left - curOffset.left + curLeft;
    }
    if ('using' in options) {
      options.using.call(elem, props);
    } else {
      curElem.css(props);
    }
  }};
  jQuery.fn.extend({offset:function(options) {
    if (arguments.length) {
      return options === undefined ? this : this.each(function(i) {
        jQuery.offset.setOffset(this, options, i);
      });
    }
    var docElem, win, box = {top:0, left:0}, elem = this[0], doc = elem && elem.ownerDocument;
    if (!doc) {
      return;
    }
    docElem = doc.documentElement;
    if (!jQuery.contains(docElem, elem)) {
      return box;
    }
    if (typeof elem.getBoundingClientRect !== strundefined) {
      box = elem.getBoundingClientRect();
    }
    win = getWindow(doc);
    return {top:box.top + (win.pageYOffset || docElem.scrollTop) - (docElem.clientTop || 0), left:box.left + (win.pageXOffset || docElem.scrollLeft) - (docElem.clientLeft || 0)};
  }, position:function() {
    if (!this[0]) {
      return;
    }
    var offsetParent, offset, parentOffset = {top:0, left:0}, elem = this[0];
    if (jQuery.css(elem, 'position') === 'fixed') {
      offset = elem.getBoundingClientRect();
    } else {
      offsetParent = this.offsetParent();
      offset = this.offset();
      if (!jQuery.nodeName(offsetParent[0], 'html')) {
        parentOffset = offsetParent.offset();
      }
      parentOffset.top += jQuery.css(offsetParent[0], 'borderTopWidth', true);
      parentOffset.left += jQuery.css(offsetParent[0], 'borderLeftWidth', true);
    }
    return {top:offset.top - parentOffset.top - jQuery.css(elem, 'marginTop', true), left:offset.left - parentOffset.left - jQuery.css(elem, 'marginLeft', true)};
  }, offsetParent:function() {
    return this.map(function() {
      var offsetParent = this.offsetParent || docElem;
      while (offsetParent && (!jQuery.nodeName(offsetParent, 'html') && jQuery.css(offsetParent, 'position') === 'static')) {
        offsetParent = offsetParent.offsetParent;
      }
      return offsetParent || docElem;
    });
  }});
  jQuery.each({scrollLeft:'pageXOffset', scrollTop:'pageYOffset'}, function(method, prop) {
    var top = /Y/.test(prop);
    jQuery.fn[method] = function(val) {
      return access(this, function(elem, method, val) {
        var win = getWindow(elem);
        if (val === undefined) {
          return win ? prop in win ? win[prop] : win.document.documentElement[method] : elem[method];
        }
        if (win) {
          win.scrollTo(!top ? val : jQuery(win).scrollLeft(), top ? val : jQuery(win).scrollTop());
        } else {
          elem[method] = val;
        }
      }, method, val, arguments.length, null);
    };
  });
  jQuery.each(['top', 'left'], function(i, prop) {
    jQuery.cssHooks[prop] = addGetHookIf(support.pixelPosition, function(elem, computed) {
      if (computed) {
        computed = curCSS(elem, prop);
        return rnumnonpx.test(computed) ? jQuery(elem).position()[prop] + 'px' : computed;
      }
    });
  });
  jQuery.each({Height:'height', Width:'width'}, function(name, type) {
    jQuery.each({padding:'inner' + name, content:type, '':'outer' + name}, function(defaultExtra, funcName) {
      jQuery.fn[funcName] = function(margin, value) {
        var chainable = arguments.length && (defaultExtra || typeof margin !== 'boolean'), extra = defaultExtra || (margin === true || value === true ? 'margin' : 'border');
        return access(this, function(elem, type, value) {
          var doc;
          if (jQuery.isWindow(elem)) {
            return elem.document.documentElement['client' + name];
          }
          if (elem.nodeType === 9) {
            doc = elem.documentElement;
            return Math.max(elem.body['scroll' + name], doc['scroll' + name], elem.body['offset' + name], doc['offset' + name], doc['client' + name]);
          }
          return value === undefined ? jQuery.css(elem, type, extra) : jQuery.style(elem, type, value, extra);
        }, type, chainable ? margin : undefined, chainable, null);
      };
    });
  });
  jQuery.fn.size = function() {
    return this.length;
  };
  jQuery.fn.andSelf = jQuery.fn.addBack;
  if (typeof define === 'function' && define.amd) {
    define('jquery', [], function() {
      return jQuery;
    });
  }
  var _jQuery = window.jQuery, _$ = window.$;
  jQuery.noConflict = function(deep) {
    if (window.$ === jQuery) {
      window.$ = _$;
    }
    if (deep && window.jQuery === jQuery) {
      window.jQuery = _jQuery;
    }
    return jQuery;
  };
  if (typeof noGlobal === strundefined) {
    window.jQuery = window.$ = jQuery;
  }
  return jQuery;
});
(function e(t, n, r) {
  function s(o, u) {
    if (!n[o]) {
      if (!t[o]) {
        var a = typeof require == 'function' && require;
        if (!u && a) {
          return a(o, !0);
        }
        if (i) {
          return i(o, !0);
        }
        throw new Error("Cannot find module '" + o + "'");
      }
      var f = n[o] = {exports:{}};
      t[o][0].call(f.exports, function(e) {
        var n = t[o][1][e];
        return s(n ? n : e);
      }, f, f.exports, e, t, n, r);
    }
    return n[o].exports;
  }
  var i = typeof require == 'function' && require;
  for (var o = 0; o < r.length; o++) {
    s(r[o]);
  }
  return s;
})({1:[function(require, module, exports) {
  module.exports = {oauthd_url:'https://oauth.io', oauthd_api:'https://oauth.io/api', version:'web-0.2.4', options:{}};
}, {}], 2:[function(require, module, exports) {
  var Url, cache, config, cookies, sha1;
  config = require('../config');
  cookies = require('../tools/cookies');
  cache = require('../tools/cache');
  Url = require('../tools/url');
  sha1 = require('../tools/sha1');
  module.exports = function(window, document, jQuery, navigator) {
    var $, client_states, oauth_result, oauthio, parse_urlfragment, providers_api, providers_cb, providers_desc;
    $ = jQuery;
    Url = Url(document);
    cookies.init(config, document);
    cache.init(cookies, config);
    oauthio = {request:{}};
    providers_desc = {};
    providers_cb = {};
    providers_api = {execProvidersCb:function(provider, e, r) {
      var cbs, i;
      if (providers_cb[provider]) {
        cbs = providers_cb[provider];
        delete providers_cb[provider];
        for (i in cbs) {
          cbs[i](e, r);
        }
      }
    }, getDescription:function(provider, opts, callback) {
      opts = opts || {};
      if (typeof providers_desc[provider] === 'object') {
        return callback(null, providers_desc[provider]);
      }
      if (!providers_desc[provider]) {
        providers_api.fetchDescription(provider);
      }
      if (!opts.wait) {
        return callback(null, {});
      }
      providers_cb[provider] = providers_cb[provider] || [];
      providers_cb[provider].push(callback);
    }};
    config.oauthd_base = Url.getAbsUrl(config.oauthd_url).match(/^.{2,5}:\/\/[^/]+/)[0];
    client_states = [];
    oauth_result = void 0;
    (parse_urlfragment = function() {
      var cookie_state, results;
      results = /[\\#&]oauthio=([^&]*)/.exec(document.location.hash);
      if (results) {
        document.location.hash = document.location.hash.replace(/&?oauthio=[^&]*/, '');
        oauth_result = decodeURIComponent(results[1].replace(/\+/g, ' '));
        cookie_state = cookies.readCookie('oauthio_state');
        if (cookie_state) {
          client_states.push(cookie_state);
          cookies.eraseCookie('oauthio_state');
        }
      }
    })();
    window.location_operations = {reload:function() {
      return document.location.reload();
    }, getHash:function() {
      return document.location.hash;
    }, setHash:function(newHash) {
      return document.location.hash = newHash;
    }, changeHref:function(newLocation) {
      return document.location.href = newLocation;
    }};
    return function(exports) {
      var delayedFunctions, delayfn, e, _preloadcalls;
      delayedFunctions = function($) {
        oauthio.request = require('./oauthio_requests')($, config, client_states, cache, providers_api);
        providers_api.fetchDescription = function(provider) {
          if (providers_desc[provider]) {
            return;
          }
          providers_desc[provider] = true;
          $.ajax({url:config.oauthd_api + '/providers/' + provider, data:{extend:true}, dataType:'json'}).done(function(data) {
            providers_desc[provider] = data.data;
            providers_api.execProvidersCb(provider, null, data.data);
          }).always(function() {
            if (typeof providers_desc[provider] !== 'object') {
              delete providers_desc[provider];
              providers_api.execProvidersCb(provider, new Error('Unable to fetch request description'));
            }
          });
        };
      };
      if (exports.OAuth == null) {
        exports.OAuth = {initialize:function(public_key, options) {
          var i;
          config.key = public_key;
          if (options) {
            for (i in options) {
              config.options[i] = options[i];
            }
          }
        }, setOAuthdURL:function(url) {
          config.oauthd_url = url;
          config.oauthd_base = Url.getAbsUrl(config.oauthd_url).match(/^.{2,5}:\/\/[^/]+/)[0];
        }, getVersion:function() {
          return config.version;
        }, create:function(provider, tokens, request) {
          var i, make_res, make_res_endpoint, res;
          if (!tokens) {
            return cache.tryCache(exports.OAuth, provider, true);
          }
          if (typeof request !== 'object') {
            providers_api.fetchDescription(provider);
          }
          make_res = function(method) {
            return oauthio.request.mkHttp(provider, tokens, request, method);
          };
          make_res_endpoint = function(method, url) {
            return oauthio.request.mkHttpEndpoint(provider, tokens, request, method, url);
          };
          res = {};
          for (i in tokens) {
            res[i] = tokens[i];
          }
          res.get = make_res('GET');
          res.post = make_res('POST');
          res.put = make_res('PUT');
          res.patch = make_res('PATCH');
          res.del = make_res('DELETE');
          res.me = oauthio.request.mkHttpMe(provider, tokens, request, 'GET');
          return res;
        }, popup:function(provider, opts, callback) {
          var defer, frm, getMessage, gotmessage, interval, res, url, wnd, wndTimeout, wnd_options, wnd_settings, _ref;
          gotmessage = false;
          getMessage = function(e) {
            if (e.origin !== config.oauthd_base) {
              return;
            }
            try {
              wnd.close();
            } catch (_error) {
            }
            opts.data = e.data;
            oauthio.request.sendCallback(opts, defer);
            return gotmessage = true;
          };
          wnd = void 0;
          frm = void 0;
          wndTimeout = void 0;
          defer = (_ref = window.jQuery) != null ? _ref.Deferred() : void 0;
          opts = opts || {};
          if (!config.key) {
            if (defer != null) {
              defer.reject(new Error('OAuth object must be initialized'));
            }
            if (callback == null) {
              return defer.promise();
            } else {
              return callback(new Error('OAuth object must be initialized'));
            }
          }
          if (arguments.length === 2 && typeof opts === 'function') {
            callback = opts;
            opts = {};
          }
          if (cache.cacheEnabled(opts.cache)) {
            res = cache.tryCache(exports.OAuth, provider, opts.cache);
            if (res) {
              if (defer != null) {
                defer.resolve(res);
              }
              if (callback) {
                return callback(null, res);
              } else {
                return defer.promise();
              }
            }
          }
          if (!opts.state) {
            opts.state = sha1.create_hash();
            opts.state_type = 'client';
          }
          client_states.push(opts.state);
          url = config.oauthd_url + '/auth/' + provider + '?k\x3d' + config.key;
          url += '\x26d\x3d' + encodeURIComponent(Url.getAbsUrl('/'));
          if (opts) {
            url += '\x26opts\x3d' + encodeURIComponent(JSON.stringify(opts));
          }
          if (opts.wnd_settings) {
            wnd_settings = opts.wnd_settings;
            delete opts.wnd_settings;
          } else {
            wnd_settings = {width:Math.floor(window.outerWidth * 0.8), height:Math.floor(window.outerHeight * 0.5)};
          }
          if (wnd_settings.height == null) {
            wnd_settings.height = wnd_settings.height < 350 ? 350 : void 0;
          }
          if (wnd_settings.width == null) {
            wnd_settings.width = wnd_settings.width < 800 ? 800 : void 0;
          }
          if (wnd_settings.left == null) {
            wnd_settings.left = window.screenX + (window.outerWidth - wnd_settings.width) / 2;
          }
          if (wnd_settings.top == null) {
            wnd_settings.top = window.screenY + (window.outerHeight - wnd_settings.height) / 8;
          }
          wnd_options = 'width\x3d' + wnd_settings.width + ',height\x3d' + wnd_settings.height;
          wnd_options += ',toolbar\x3d0,scrollbars\x3d1,status\x3d1,resizable\x3d1,location\x3d1,menuBar\x3d0';
          wnd_options += ',left\x3d' + wnd_settings.left + ',top\x3d' + wnd_settings.top;
          opts = {provider:provider, cache:opts.cache};
          opts.callback = function(e, r) {
            if (window.removeEventListener) {
              window.removeEventListener('message', getMessage, false);
            } else {
              if (window.detachEvent) {
                window.detachEvent('onmessage', getMessage);
              } else {
                if (document.detachEvent) {
                  document.detachEvent('onmessage', getMessage);
                }
              }
            }
            opts.callback = function() {
            };
            if (wndTimeout) {
              clearTimeout(wndTimeout);
              wndTimeout = undefined;
            }
            if (callback) {
              return callback(e, r);
            } else {
              return undefined;
            }
          };
          if (window.attachEvent) {
            window.attachEvent('onmessage', getMessage);
          } else {
            if (document.attachEvent) {
              document.attachEvent('onmessage', getMessage);
            } else {
              if (window.addEventListener) {
                window.addEventListener('message', getMessage, false);
              }
            }
          }
          if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.onMessageExternal) {
            chrome.runtime.onMessageExternal.addListener(function(request, sender, sendResponse) {
              request.origin = sender.url.match(/^.{2,5}:\/\/[^/]+/)[0];
              if (defer != null) {
                defer.resolve();
              }
              return getMessage(request);
            });
          }
          if (!frm && (navigator.userAgent.indexOf('MSIE') !== -1 || navigator.appVersion.indexOf('Trident/') > 0)) {
            frm = document.createElement('iframe');
            frm.src = config.oauthd_url + '/auth/iframe?d\x3d' + encodeURIComponent(Url.getAbsUrl('/'));
            frm.width = 0;
            frm.height = 0;
            frm.frameBorder = 0;
            frm.style.visibility = 'hidden';
            document.body.appendChild(frm);
          }
          wndTimeout = setTimeout(function() {
            if (defer != null) {
              defer.reject(new Error('Authorization timed out'));
            }
            if (opts.callback && typeof opts.callback === 'function') {
              opts.callback(new Error('Authorization timed out'));
            }
            try {
              wnd.close();
            } catch (_error) {
            }
          }, 1200 * 1000);
          wnd = window.open(url, 'Authorization', wnd_options);
          if (wnd) {
            wnd.focus();
            interval = window.setInterval(function() {
              if (wnd === null || wnd.closed) {
                window.clearInterval(interval);
                if (!gotmessage) {
                  if (defer != null) {
                    defer.reject(new Error('The popup was closed'));
                  }
                  if (opts.callback && typeof opts.callback === 'function') {
                    return opts.callback(new Error('The popup was closed'));
                  }
                }
              }
            }, 500);
          } else {
            if (defer != null) {
              defer.reject(new Error('Could not open a popup'));
            }
            if (opts.callback && typeof opts.callback === 'function') {
              opts.callback(new Error('Could not open a popup'));
            }
          }
          return defer != null ? defer.promise() : void 0;
        }, redirect:function(provider, opts, url) {
          var redirect_uri, res;
          if (arguments.length === 2) {
            url = opts;
            opts = {};
          }
          if (cache.cacheEnabled(opts.cache)) {
            res = cache.tryCache(exports.OAuth, provider, opts.cache);
            if (res) {
              url = Url.getAbsUrl(url) + (url.indexOf('#') === -1 ? '#' : '\x26') + 'oauthio\x3dcache';
              window.location_operations.changeHref(url);
              window.location_operations.reload();
              return;
            }
          }
          if (!opts.state) {
            opts.state = sha1.create_hash();
            opts.state_type = 'client';
          }
          cookies.createCookie('oauthio_state', opts.state);
          redirect_uri = encodeURIComponent(Url.getAbsUrl(url));
          url = config.oauthd_url + '/auth/' + provider + '?k\x3d' + config.key;
          url += '\x26redirect_uri\x3d' + redirect_uri;
          if (opts) {
            url += '\x26opts\x3d' + encodeURIComponent(JSON.stringify(opts));
          }
          window.location_operations.changeHref(url);
        }, callback:function(provider, opts, callback) {
          var defer, res, _ref;
          defer = (_ref = window.jQuery) != null ? _ref.Deferred() : void 0;
          if (arguments.length === 1 && typeof provider === 'function') {
            callback = provider;
            provider = undefined;
            opts = {};
          }
          if (arguments.length === 1 && typeof provider === 'string') {
            opts = {};
          }
          if (arguments.length === 2 && typeof opts === 'function') {
            callback = opts;
            opts = {};
          }
          if (cache.cacheEnabled(opts.cache) || oauth_result === 'cache') {
            res = cache.tryCache(exports.OAuth, provider, opts.cache);
            if (oauth_result === 'cache' && (typeof provider !== 'string' || !provider)) {
              if (defer != null) {
                defer.reject(new Error('You must set a provider when using the cache'));
              }
              if (callback) {
                return callback(new Error('You must set a provider when using the cache'));
              } else {
                return defer != null ? defer.promise() : void 0;
              }
            }
            if (res) {
              if (callback) {
                if (res) {
                  return callback(null, res);
                }
              } else {
                if (defer != null) {
                  defer.resolve(res);
                }
                return defer != null ? defer.promise() : void 0;
              }
            }
          }
          if (!oauth_result) {
            return;
          }
          oauthio.request.sendCallback({data:oauth_result, provider:provider, cache:opts.cache, callback:callback}, defer);
          return defer != null ? defer.promise() : void 0;
        }, clearCache:function(provider) {
          cookies.eraseCookie('oauthio_provider_' + provider);
        }, http_me:function(opts) {
          if (oauthio.request.http_me) {
            oauthio.request.http_me(opts);
          }
        }, http:function(opts) {
          if (oauthio.request.http) {
            oauthio.request.http(opts);
          }
        }};
        if (typeof window.jQuery === 'undefined') {
          _preloadcalls = [];
          delayfn = void 0;
          if (typeof chrome !== 'undefined' && chrome.extension) {
            delayfn = function() {
              return function() {
                throw new Error('Please include jQuery before oauth.js');
              };
            };
          } else {
            e = document.createElement('script');
            e.src = '//code.jquery.com/jquery.min.js';
            e.type = 'text/javascript';
            e.onload = function() {
              var i;
              delayedFunctions(window.jQuery);
              for (i in _preloadcalls) {
                _preloadcalls[i].fn.apply(null, _preloadcalls[i].args);
              }
            };
            document.getElementsByTagName('head')[0].appendChild(e);
            delayfn = function(f) {
              return function() {
                var arg, args_copy;
                args_copy = [];
                for (arg in arguments) {
                  args_copy[arg] = arguments[arg];
                }
                _preloadcalls.push({fn:f, args:args_copy});
              };
            };
          }
          oauthio.request.http = delayfn(function() {
            oauthio.request.http.apply(exports.OAuth, arguments);
          });
          providers_api.fetchDescription = delayfn(function() {
            providers_api.fetchDescription.apply(providers_api, arguments);
          });
          oauthio.request = require('./oauthio_requests')(window.jQuery, config, client_states, cache, providers_api);
        } else {
          delayedFunctions(window.jQuery);
        }
      }
    };
  };
}, {'../config':1, '../tools/cache':5, '../tools/cookies':6, '../tools/sha1':7, '../tools/url':8, './oauthio_requests':3}], 3:[function(require, module, exports) {
  var Url, __indexOf = [].indexOf || function(item) {
    for (var i = 0, l = this.length; i < l; i++) {
      if (i in this && this[i] === item) {
        return i;
      }
    }
    return -1;
  };
  Url = require('../tools/url')();
  module.exports = function($, config, client_states, cache, providers_api) {
    return {http:function(opts) {
      var defer, desc_opts, doRequest, i, options;
      doRequest = function() {
        var i, k, qs, request;
        request = options.oauthio.request || {};
        if (!request.cors) {
          options.url = encodeURIComponent(options.url);
          if (options.url[0] !== '/') {
            options.url = '/' + options.url;
          }
          options.url = config.oauthd_url + '/request/' + options.oauthio.provider + options.url;
          options.headers = options.headers || {};
          options.headers.oauthio = 'k\x3d' + config.key;
          if (options.oauthio.tokens.oauth_token && options.oauthio.tokens.oauth_token_secret) {
            options.headers.oauthio += '\x26oauthv\x3d1';
          }
          for (k in options.oauthio.tokens) {
            options.headers.oauthio += '\x26' + encodeURIComponent(k) + '\x3d' + encodeURIComponent(options.oauthio.tokens[k]);
          }
          delete options.oauthio;
          return $.ajax(options);
        }
        if (options.oauthio.tokens) {
          if (options.oauthio.tokens.access_token) {
            options.oauthio.tokens.token = options.oauthio.tokens.access_token;
          }
          if (!options.url.match(/^[a-z]{2,16}:\/\//)) {
            if (options.url[0] !== '/') {
              options.url = '/' + options.url;
            }
            options.url = request.url + options.url;
          }
          options.url = Url.replaceParam(options.url, options.oauthio.tokens, request.parameters);
          if (request.query) {
            qs = [];
            for (i in request.query) {
              qs.push(encodeURIComponent(i) + '\x3d' + encodeURIComponent(Url.replaceParam(request.query[i], options.oauthio.tokens, request.parameters)));
            }
            if (__indexOf.call(options.url, '?') >= 0) {
              options.url += '\x26' + qs;
            } else {
              options.url += '?' + qs;
            }
          }
          if (request.headers) {
            options.headers = options.headers || {};
            for (i in request.headers) {
              options.headers[i] = Url.replaceParam(request.headers[i], options.oauthio.tokens, request.parameters);
            }
          }
          delete options.oauthio;
          return $.ajax(options);
        }
      };
      options = {};
      i = void 0;
      for (i in opts) {
        options[i] = opts[i];
      }
      if (!options.oauthio.request || options.oauthio.request === true) {
        desc_opts = {wait:!!options.oauthio.request};
        defer = $ != null ? $.Deferred() : void 0;
        providers_api.getDescription(options.oauthio.provider, desc_opts, function(e, desc) {
          if (e) {
            return defer != null ? defer.reject(e) : void 0;
          }
          if (options.oauthio.tokens.oauth_token && options.oauthio.tokens.oauth_token_secret) {
            options.oauthio.request = desc.oauth1 && desc.oauth1.request;
          } else {
            options.oauthio.request = desc.oauth2 && desc.oauth2.request;
          }
          if (defer != null) {
            defer.resolve();
          }
        });
        return defer != null ? defer.then(doRequest) : void 0;
      } else {
        return doRequest();
      }
    }, http_me:function(opts) {
      var defer, desc_opts, doRequest, k, options;
      doRequest = function() {
        var defer, k, promise, request;
        defer = $ != null ? $.Deferred() : void 0;
        request = options.oauthio.request || {};
        options.url = config.oauthd_url + '/auth/' + options.oauthio.provider + '/me';
        options.headers = options.headers || {};
        options.headers.oauthio = 'k\x3d' + config.key;
        if (options.oauthio.tokens.oauth_token && options.oauthio.tokens.oauth_token_secret) {
          options.headers.oauthio += '\x26oauthv\x3d1';
        }
        for (k in options.oauthio.tokens) {
          options.headers.oauthio += '\x26' + encodeURIComponent(k) + '\x3d' + encodeURIComponent(options.oauthio.tokens[k]);
        }
        delete options.oauthio;
        promise = $.ajax(options);
        $.when(promise).done(function(data) {
          if (defer != null) {
            defer.resolve(data.data);
          }
        }).fail(function(data) {
          if (data.responseJSON) {
            if (defer != null) {
              defer.reject(data.responseJSON.data);
            }
          } else {
            if (defer != null) {
              defer.reject(new Error('An error occured while trying to access the resource'));
            }
          }
        });
        return defer != null ? defer.promise() : void 0;
      };
      options = {};
      for (k in opts) {
        options[k] = opts[k];
      }
      if (!options.oauthio.request || options.oauthio.request === true) {
        desc_opts = {wait:!!options.oauthio.request};
        defer = $ != null ? $.Deferred() : void 0;
        providers_api.getDescription(options.oauthio.provider, desc_opts, function(e, desc) {
          if (e) {
            return defer != null ? defer.reject(e) : void 0;
          }
          if (options.oauthio.tokens.oauth_token && options.oauthio.tokens.oauth_token_secret) {
            options.oauthio.request = desc.oauth1 && desc.oauth1.request;
          } else {
            options.oauthio.request = desc.oauth2 && desc.oauth2.request;
          }
          if (defer != null) {
            defer.resolve();
          }
        });
        return defer != null ? defer.then(doRequest) : void 0;
      } else {
        return doRequest();
      }
    }, mkHttp:function(provider, tokens, request, method) {
      var base;
      base = this;
      return function(opts, opts2) {
        var i, options;
        options = {};
        if (typeof opts === 'string') {
          if (typeof opts2 === 'object') {
            for (i in opts2) {
              options[i] = opts2[i];
            }
          }
          options.url = opts;
        } else {
          if (typeof opts === 'object') {
            for (i in opts) {
              options[i] = opts[i];
            }
          }
        }
        options.type = options.type || method;
        options.oauthio = {provider:provider, tokens:tokens, request:request};
        return base.http(options);
      };
    }, mkHttpMe:function(provider, tokens, request, method) {
      var base;
      base = this;
      return function(filter) {
        var options;
        options = {};
        options.type = options.type || method;
        options.oauthio = {provider:provider, tokens:tokens, request:request};
        options.data = options.data || {};
        options.data.filter = filter ? filter.join(',') : undefined;
        return base.http_me(options);
      };
    }, sendCallback:function(opts, defer) {
      var base, data, e, err, i, k, make_res, request, res, tokens, v;
      base = this;
      data = void 0;
      err = void 0;
      try {
        data = JSON.parse(opts.data);
      } catch (_error) {
        e = _error;
        if (defer != null) {
          defer.reject(new Error('Error while parsing result'));
        }
        return opts.callback(new Error('Error while parsing result'));
      }
      if (!data || !data.provider) {
        return;
      }
      if (opts.provider && data.provider.toLowerCase() !== opts.provider.toLowerCase()) {
        err = new Error('Returned provider name does not match asked provider');
        if (defer != null) {
          defer.reject(err);
        }
        if (opts.callback && typeof opts.callback === 'function') {
          return opts.callback(err);
        } else {
          return;
        }
      }
      if (data.status === 'error' || data.status === 'fail') {
        err = new Error(data.message);
        err.body = data.data;
        if (defer != null) {
          defer.reject(err);
        }
        if (opts.callback && typeof opts.callback === 'function') {
          return opts.callback(err);
        } else {
          return;
        }
      }
      if (data.status !== 'success' || !data.data) {
        err = new Error;
        err.body = data.data;
        if (defer != null) {
          defer.reject(err);
        }
        if (opts.callback && typeof opts.callback === 'function') {
          return opts.callback(err);
        } else {
          return;
        }
      }
      data.state = data.state.replace(/\s+/g, '');
      for (k in client_states) {
        v = client_states[k];
        client_states[k] = v.replace(/\s+/g, '');
      }
      if (!data.state || client_states.indexOf(data.state) === -1) {
        if (defer != null) {
          defer.reject(new Error('State is not matching'));
        }
        if (opts.callback && typeof opts.callback === 'function') {
          return opts.callback(new Error('State is not matching'));
        } else {
          return;
        }
      }
      if (!opts.provider) {
        data.data.provider = data.provider;
      }
      res = data.data;
      if (cache.cacheEnabled(opts.cache) && res) {
        cache.storeCache(data.provider, res);
      }
      request = res.request;
      delete res.request;
      tokens = void 0;
      if (res.access_token) {
        tokens = {access_token:res.access_token};
      } else {
        if (res.oauth_token && res.oauth_token_secret) {
          tokens = {oauth_token:res.oauth_token, oauth_token_secret:res.oauth_token_secret};
        }
      }
      if (!request) {
        if (defer != null) {
          defer.resolve(res);
        }
        if (opts.callback && typeof opts.callback === 'function') {
          return opts.callback(null, res);
        } else {
          return;
        }
      }
      if (request.required) {
        for (i in request.required) {
          tokens[request.required[i]] = res[request.required[i]];
        }
      }
      make_res = function(method) {
        return base.mkHttp(data.provider, tokens, request, method);
      };
      res.get = make_res('GET');
      res.post = make_res('POST');
      res.put = make_res('PUT');
      res.patch = make_res('PATCH');
      res.del = make_res('DELETE');
      res.me = base.mkHttpMe(data.provider, tokens, request, 'GET');
      if (defer != null) {
        defer.resolve(res);
      }
      if (opts.callback && typeof opts.callback === 'function') {
        return opts.callback(null, res);
      } else {
      }
    }};
  };
}, {'../tools/url':8}], 4:[function(require, module, exports) {
  var OAuth_creator, jquery;
  if (typeof jQuery !== 'undefined' && jQuery !== null) {
    jquery = jQuery;
  } else {
    jquery = void 0;
  }
  OAuth_creator = require('./lib/oauth')(window, document, jquery, navigator);
  OAuth_creator(window || this);
}, {'./lib/oauth':2}], 5:[function(require, module, exports) {
  module.exports = {init:function(cookies_module, config) {
    this.config = config;
    return this.cookies = cookies_module;
  }, tryCache:function(OAuth, provider, cache) {
    var e, i, res;
    if (this.cacheEnabled(cache)) {
      cache = this.cookies.readCookie('oauthio_provider_' + provider);
      if (!cache) {
        return false;
      }
      cache = decodeURIComponent(cache);
    }
    if (typeof cache === 'string') {
      try {
        cache = JSON.parse(cache);
      } catch (_error) {
        e = _error;
        return false;
      }
    }
    if (typeof cache === 'object') {
      res = {};
      for (i in cache) {
        if (i !== 'request' && typeof cache[i] !== 'function') {
          res[i] = cache[i];
        }
      }
      return OAuth.create(provider, res, cache.request);
    }
    return false;
  }, storeCache:function(provider, cache) {
    this.cookies.createCookie('oauthio_provider_' + provider, encodeURIComponent(JSON.stringify(cache)), cache.expires_in - 10 || 3600);
  }, cacheEnabled:function(cache) {
    if (typeof cache === 'undefined') {
      return this.config.options.cache;
    }
    return cache;
  }};
}, {}], 6:[function(require, module, exports) {
  module.exports = {init:function(config, document) {
    this.config = config;
    return this.document = document;
  }, createCookie:function(name, value, expires) {
    var date;
    this.eraseCookie(name);
    date = new Date;
    date.setTime(date.getTime() + (expires || 1200) * 1000);
    expires = '; expires\x3d' + date.toGMTString();
    this.document.cookie = name + '\x3d' + value + expires + '; path\x3d/';
  }, readCookie:function(name) {
    var c, ca, i, nameEQ;
    nameEQ = name + '\x3d';
    ca = this.document.cookie.split(';');
    i = 0;
    while (i < ca.length) {
      c = ca[i];
      while (c.charAt(0) === ' ') {
        c = c.substring(1, c.length);
      }
      if (c.indexOf(nameEQ) === 0) {
        return c.substring(nameEQ.length, c.length);
      }
      i++;
    }
    return null;
  }, eraseCookie:function(name) {
    var date;
    date = new Date;
    date.setTime(date.getTime() - 86400000);
    this.document.cookie = name + '\x3d; expires\x3d' + date.toGMTString() + '; path\x3d/';
  }};
}, {}], 7:[function(require, module, exports) {
  var b64pad, hexcase;
  hexcase = 0;
  b64pad = '';
  module.exports = {hex_sha1:function(s) {
    return this.rstr2hex(this.rstr_sha1(this.str2rstr_utf8(s)));
  }, b64_sha1:function(s) {
    return this.rstr2b64(this.rstr_sha1(this.str2rstr_utf8(s)));
  }, any_sha1:function(s, e) {
    return this.rstr2any(this.rstr_sha1(this.str2rstr_utf8(s)), e);
  }, hex_hmac_sha1:function(k, d) {
    return this.rstr2hex(this.rstr_hmac_sha1(this.str2rstr_utf8(k), this.str2rstr_utf8(d)));
  }, b64_hmac_sha1:function(k, d) {
    return this.rstr2b64(this.rstr_hmac_sha1(this.str2rstr_utf8(k), this.str2rstr_utf8(d)));
  }, any_hmac_sha1:function(k, d, e) {
    return this.rstr2any(this.rstr_hmac_sha1(this.str2rstr_utf8(k), this.str2rstr_utf8(d)), e);
  }, sha1_vm_test:function() {
    return thishex_sha1('abc').toLowerCase() === 'a9993e364706816aba3e25717850c26c9cd0d89d';
  }, rstr_sha1:function(s) {
    return this.binb2rstr(this.binb_sha1(this.rstr2binb(s), s.length * 8));
  }, rstr_hmac_sha1:function(key, data) {
    var bkey, hash, i, ipad, opad;
    bkey = this.rstr2binb(key);
    if (bkey.length > 16) {
      bkey = this.binb_sha1(bkey, key.length * 8);
    }
    ipad = Array(16);
    opad = Array(16);
    i = 0;
    while (i < 16) {
      ipad[i] = bkey[i] ^ 909522486;
      opad[i] = bkey[i] ^ 1549556828;
      i++;
    }
    hash = this.binb_sha1(ipad.concat(this.rstr2binb(data)), 512 + data.length * 8);
    return this.binb2rstr(this.binb_sha1(opad.concat(hash), 512 + 160));
  }, rstr2hex:function(input) {
    var e, hex_tab, i, output, x;
    try {
      hexcase;
    } catch (_error) {
      e = _error;
      hexcase = 0;
    }
    hex_tab = hexcase ? '0123456789ABCDEF' : '0123456789abcdef';
    output = '';
    x = void 0;
    i = 0;
    while (i < input.length) {
      x = input.charCodeAt(i);
      output += hex_tab.charAt(x >>> 4 & 15) + hex_tab.charAt(x & 15);
      i++;
    }
    return output;
  }, rstr2b64:function(input) {
    var e, i, j, len, output, tab, triplet;
    try {
      b64pad;
    } catch (_error) {
      e = _error;
      b64pad = '';
    }
    tab = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
    output = '';
    len = input.length;
    i = 0;
    while (i < len) {
      triplet = input.charCodeAt(i) << 16 | (i + 1 < len ? input.charCodeAt(i + 1) << 8 : 0) | (i + 2 < len ? input.charCodeAt(i + 2) : 0);
      j = 0;
      while (j < 4) {
        if (i * 8 + j * 6 > input.length * 8) {
          output += b64pad;
        } else {
          output += tab.charAt(triplet >>> 6 * (3 - j) & 63);
        }
        j++;
      }
      i += 3;
    }
    return output;
  }, rstr2any:function(input, encoding) {
    var dividend, divisor, full_length, i, output, q, quotient, remainders, x;
    divisor = encoding.length;
    remainders = Array();
    i = void 0;
    q = void 0;
    x = void 0;
    quotient = void 0;
    dividend = Array(Math.ceil(input.length / 2));
    i = 0;
    while (i < dividend.length) {
      dividend[i] = input.charCodeAt(i * 2) << 8 | input.charCodeAt(i * 2 + 1);
      i++;
    }
    while (dividend.length > 0) {
      quotient = Array();
      x = 0;
      i = 0;
      while (i < dividend.length) {
        x = (x << 16) + dividend[i];
        q = Math.floor(x / divisor);
        x -= q * divisor;
        if (quotient.length > 0 || q > 0) {
          quotient[quotient.length] = q;
        }
        i++;
      }
      remainders[remainders.length] = x;
      dividend = quotient;
    }
    output = '';
    i = remainders.length - 1;
    while (i >= 0) {
      output += encoding.charAt(remainders[i]);
      i--;
    }
    full_length = Math.ceil(input.length * 8 / (Math.log(encoding.length) / Math.log(2)));
    i = output.length;
    while (i < full_length) {
      output = encoding[0] + output;
      i++;
    }
    return output;
  }, str2rstr_utf8:function(input) {
    var i, output, x, y;
    output = '';
    i = -1;
    x = void 0;
    y = void 0;
    while (++i < input.length) {
      x = input.charCodeAt(i);
      y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
      if (55296 <= x && x <= 56319 && 56320 <= y && y <= 57343) {
        x = 65536 + ((x & 1023) << 10) + (y & 1023);
        i++;
      }
      if (x <= 127) {
        output += String.fromCharCode(x);
      } else {
        if (x <= 2047) {
          output += String.fromCharCode(192 | x >>> 6 & 31, 128 | x & 63);
        } else {
          if (x <= 65535) {
            output += String.fromCharCode(224 | x >>> 12 & 15, 128 | x >>> 6 & 63, 128 | x & 63);
          } else {
            if (x <= 2097151) {
              output += String.fromCharCode(240 | x >>> 18 & 7, 128 | x >>> 12 & 63, 128 | x >>> 6 & 63, 128 | x & 63);
            }
          }
        }
      }
    }
    return output;
  }, str2rstr_utf16le:function(input) {
    var i, output;
    output = '';
    i = 0;
    while (i < input.length) {
      output += String.fromCharCode(input.charCodeAt(i) & 255, input.charCodeAt(i) >>> 8 & 255);
      i++;
    }
    return output;
  }, str2rstr_utf16be:function(input) {
    var i, output;
    output = '';
    i = 0;
    while (i < input.length) {
      output += String.fromCharCode(input.charCodeAt(i) >>> 8 & 255, input.charCodeAt(i) & 255);
      i++;
    }
    return output;
  }, rstr2binb:function(input) {
    var i, output;
    output = Array(input.length >> 2);
    i = 0;
    while (i < output.length) {
      output[i] = 0;
      i++;
    }
    i = 0;
    while (i < input.length * 8) {
      output[i >> 5] |= (input.charCodeAt(i / 8) & 255) << 24 - i % 32;
      i += 8;
    }
    return output;
  }, binb2rstr:function(input) {
    var i, output;
    output = '';
    i = 0;
    while (i < input.length * 32) {
      output += String.fromCharCode(input[i >> 5] >>> 24 - i % 32 & 255);
      i += 8;
    }
    return output;
  }, binb_sha1:function(x, len) {
    var a, b, c, d, e, i, j, olda, oldb, oldc, oldd, olde, t, w;
    x[len >> 5] |= 128 << 24 - len % 32;
    x[(len + 64 >> 9 << 4) + 15] = len;
    w = Array(80);
    a = 1732584193;
    b = -271733879;
    c = -1732584194;
    d = 271733878;
    e = -1009589776;
    i = 0;
    while (i < x.length) {
      olda = a;
      oldb = b;
      oldc = c;
      oldd = d;
      olde = e;
      j = 0;
      while (j < 80) {
        if (j < 16) {
          w[j] = x[i + j];
        } else {
          w[j] = this.bit_rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
        }
        t = this.safe_add(this.safe_add(this.bit_rol(a, 5), this.sha1_ft(j, b, c, d)), this.safe_add(this.safe_add(e, w[j]), this.sha1_kt(j)));
        e = d;
        d = c;
        c = this.bit_rol(b, 30);
        b = a;
        a = t;
        j++;
      }
      a = this.safe_add(a, olda);
      b = this.safe_add(b, oldb);
      c = this.safe_add(c, oldc);
      d = this.safe_add(d, oldd);
      e = this.safe_add(e, olde);
      i += 16;
    }
    return Array(a, b, c, d, e);
  }, sha1_ft:function(t, b, c, d) {
    if (t < 20) {
      return b & c | ~b & d;
    }
    if (t < 40) {
      return b ^ c ^ d;
    }
    if (t < 60) {
      return b & c | b & d | c & d;
    }
    return b ^ c ^ d;
  }, sha1_kt:function(t) {
    if (t < 20) {
      return 1518500249;
    } else {
      if (t < 40) {
        return 1859775393;
      } else {
        if (t < 60) {
          return -1894007588;
        } else {
          return -899497514;
        }
      }
    }
  }, safe_add:function(x, y) {
    var lsw, msw;
    lsw = (x & 65535) + (y & 65535);
    msw = (x >> 16) + (y >> 16) + (lsw >> 16);
    return msw << 16 | lsw & 65535;
  }, bit_rol:function(num, cnt) {
    return num << cnt | num >>> 32 - cnt;
  }, create_hash:function() {
    var hash;
    hash = this.b64_sha1((new Date).getTime() + ':' + Math.floor(Math.random() * 9999999));
    return hash.replace(/\+/g, '-').replace(/\//g, '_').replace(/\=+$/, '');
  }};
}, {}], 8:[function(require, module, exports) {
  module.exports = function(document) {
    return {getAbsUrl:function(url) {
      var base_url;
      if (url.match(/^.{2,5}:\/\//)) {
        return url;
      }
      if (url[0] === '/') {
        return document.location.protocol + '//' + document.location.host + url;
      }
      base_url = document.location.protocol + '//' + document.location.host + document.location.pathname;
      if (base_url[base_url.length - 1] !== '/' && url[0] !== '#') {
        return base_url + '/' + url;
      }
      return base_url + url;
    }, replaceParam:function(param, rep, rep2) {
      param = param.replace(/\{\{(.*?)\}\}/g, function(m, v) {
        return rep[v] || '';
      });
      if (rep2) {
        param = param.replace(/\{(.*?)\}/g, function(m, v) {
          return rep2[v] || '';
        });
      }
      return param;
    }};
  };
}, {}]}, {}, [4]);
Ext.application({name:'MobileJudge', extend:MobileJudge.Application, launch:function() {
  Ext.fly('appLoadingIndicator').destroy();
  this.callParent();
}});
